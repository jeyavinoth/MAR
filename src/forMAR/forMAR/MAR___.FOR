C +************************************************************************+
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |               M        M       AAAAAAA        RRRRRRR                  |
C |               MM      MM      A       A      R       R                 |
C |               M M    M M      A       A      R       R                 |
C |               M  M  M  M      A       A      R       R                 |
C |               M   MM   M      A AAAAA A      R RRRRR R                 |
C |               M        M      A       A      R R                       |
C |     (MODELE tridimensionnel ATMOSPHERIQUE a l'echelle REGIONALE)       |
C |               M        M      A       A      R   R                     |
C |               M        M      A       A      R    R                    |
C |               M        M      A       A      R     R                   |
C |               M        M      A       A      R      R                  |
C |                                                                        |
C |                 \__ _                    ____ /                        |
C |               \_/     @@@@              /    \                         |
C |               / \    @@@@@@            /    / \                        |
C |              /   \  @@@@@@            |    /   |                       |
C |                    ... ***             \  /   /    LGGE/CNRS           |
C |                   .... **               \/___/                         |
C |                  .... **                / IAG/UCL                      |
C |                                                                        |
C |   Laboratoire de Glaciologie et de Géophysique de l'Environnement      |
C |      Institut d'Astronomie   et de Geophysique Georges Lemaître        |
C |   Laboratoire d'etudes des Transferts en Hydrologie et Environnement   |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C |                                                                        |
C +************************************************************************+
C |                                                                        |
C | Version MARv3.5.3  4 May 2007 (HG) + 29 Apr 2015 (XF)                  |
C | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                  | 
C
C Tunning
C =======
C 
C 1. To have more precipitation, humidty and LWD:
C     - FacFIk=10.00 instead of FacFIk=05.00 in MAR_FI.inc
C     - cnos (#ur,#up, ...) in hydmic.f impact the ratio inland/margin precip
C     - the number of CPUs used could impact the amount of precip 
C
C 2. TURtke_difv(dtLLoc,0.5) instead of TURtke_difv(dtLLoc,0.0) increases
C the temperature over Tundra and decreases over the ice sheet in summer but MAR
C is less stable. In winter, TURtke_difv(dtLLoc,0.5) is colder.               
C
C 3. qsmlt =     psmlt * dt in Hydmic (option #GL) increases the ratio RF/SF
C
C 4. To have more SWD/LWD (in PHYrad_CEP.f)
C  (1.-min(1.,exp((tairDY(i,j,lkl)-258.15)*0.1))) instead of 273.15
C  * (                 qsHY(i,j        ,lkl)*XX where xx <<
C
C 5. see sub time_steps for the time step of the different schemes.  
C
C Tunning for Belgium
C ===================

c 1. Set FacFIk=20.0 in MAR_FI.inc

c 2. Uncomment "c #EU" in PHYrad_CEP_mp.f

c 3. Uncomment "!#EU"
c    in radCEP.d/Source.d/su____.d/sucst.F90

c 4. Uncomment "c #EU" in SISVAT_DAT and remove the corresponding other data

C
C WARNING
C =======
c 1. Due to the use of simple precision, the amount of precipitation is depend of
c the architecture use and the nbr of CPUs use. This uncertainty could represent 2-3% of precip locally.
c
c 2. Be carfull about itexpe. Itexpe is interger*8 by default. This asks to have also itexpe
c as integer*8 in NESTOR (for the MARdyn.dat used when itexpe=0). 
c
C +************************************************************************+
C |                                                                        |
C |     MAR CONTRIBUTORS:                                                  |
C |                                                                        |
C | --- Hubert Gallee     : Development of the Dry Model Version...........|
C |                         Explicit Hydrological Cycle Revision...........|
C |                         Energy  Snow     Model.........................|
C |                         Blowing Snow     Model.........................|
C |                         Polynya          Model.........................|
C |                         Generic Chemical Model.........................|
C |     Adress : LGGE/CNRS, 54, rue Molière, BP96, ........................|
C |              F-38402 Saint-Martin d'Hères CEDEX, ......................|
C |     e-mail : gallee@lgge.obs.ujf-grenoble.fr ..........................|
C |                                                                        |
C | --- Olivier Brasseur  : Mass Flux convective Scheme: Development ......|
C |                         2 1/2 Turbulence Parameterization..............|
C |                         NESTing Organization for Regional models ......|
C |     Adress : Cellule interregionale de l'Environnement ................|
C |              10-11, avenue des Arts, B-1210 Bruxelles .................|
C |     e-mail : Brasseur@irceline.fr .....................................|
C |                                                                        |
C | --- Laurent Delobbe   : Explicit Hydrological Cycle Revision...........|
C |                         StratoCumulus Experiment.......................|
C |     Adress : Royal Meteorological Institute of Belgium, ...............|
C |              Observations Department, Av. Circulaire 3  1180 Brussels .|
C |     e-mail : Laurent.Delobbe@oma.be ...................................|
C |                                                                        |
C | --- Koen De Ridder    : Treatment of Processes Relative to Vegetation..|
C |     Adress : Vlaams Instelling voor Technische Onderzoek, .............|
C |                   Boeretang 200, B-2400 Mol, Belgie ...................|
C |     e-mail : DRidderK@vito.be .........................................|
C |                                                                        |
C | --- Xavier Fettweis   : Energy  Snow/Ice Model.........................|
C |     Adress : Institut d'Astronomie et de Geophysique G.Lemaitre........|
C |                   2, chemin du Cyclotron, B-1348 LLN, Belgique.........|
C |     e-mail : fettweis@astr.ucl.ac.be...................................|
C |                                                                        |
C | --- Filip Lefebre     : Energy  Snow/Ice Model.........................|
C |     Adress : Vlaams Instelling voor Technische Onderzoek, .............|
C |                   Boeretang 200, B-2400 Mol, Belgie ...................|
C |     e-mail : filip.lefebre@vito.be ....................................|
C |                                                                        |
C | --- Philippe Marbaix  : Map projection and nesting interpolation.......|
C |                         NW Europe Climate, Post-processing.............|
C |     Adress : Laboratoire des Sciences du Climat et de l'Environnement..|
C |     e-mail : philippe.marbaix@lsce.saclay.cea.fr.......................|
C |                                                                        |
C | --- Christophe Messager:  West African Climate / HCM Coupling..........|
C |     Adress : IRD/LTHE, BP53, F-38041 Grenoble CEDEX 9, ................|
C |     e-mail : messager@hmg.inpg.fr .....................................|
C |     URL    : http://www.lthe.hmg.inpg.fr/GRID .........................|
C |                                                                        |
C | --- Wilfran Moufouma-Oka: West African Climate / Interannual Variab....|
C |     Adress : IRD/LTHE, BP53, F-38041 Grenoble CEDEX 9, ................|
C |     e-mail : moufouma@hmg.inpg.fr .....................................|
C |                                                                        |
C | --- Romain  Ramel:        West African Climate / MCC and Convection....|
C |     Adress : IRD/LTHE, BP53, F-38041 Grenoble CEDEX 9, ................|
C |     e-mail :    ramel@hmg.inpg.fr .....................................|
C |                                                                        |
C | --- Christian Tricot  : Solar/IR Radiative Routines Implementation ....|
C |     Adress : Royal Meteorological Institute of Belgium, ...............|
C |              Climatology  Department, Av. Circulaire 3  1180 Brussels .|
C |     e-mail : clim@atmos.oma.be ........................................|
C |                                                                        |
C | --- Emilie Vanvyve    : European Hydrology and Climate.................|
C |     Adress : Institut d'Astronomie et de Geophysique G.Lemaitre........|
C |                   2, chemin du Cyclotron, B-1348 LLN, Belgique.........|
C |     e-mail : vanvyve@astr.ucl.ac.be....................................|
C |                                                                        |
C +************************************************************************+
C |                                                                        |
C | REFERENCES :                                                           |
C | ^^^^^^^^^^^^                                                           |
C | + Gallee H. and Schayes G.,                                      1992. |
C |   Dynamical Aspects of Katabatic Winds Evolution in the                |
C |   Antarctic Coastal Zone.                                              |
C |   Boundary Layer Meteorology                      59,  141--161        |
C |                                                                        |
C | + Thunis, P., Grossi, P., Graziani, G., Gallee, H., Moyaux, B.,        |
C |   and Schayes G.,                                                1992. |
C |   Preliminary simulations of the flow field over the Attic Peninsula   |
C |   Environmental Software                           8,   43--54         |
C |                                                                        |
C | + Gallee H. and Schayes G.,                                      1994. |
C |   Development of a Three-Dimensional Meso--gamma                       |
C |   Primitive Equations Model,                                           |
C |   Katabatic Winds Simulation in the area of Terra Nova Bay, Antarctica |
C |   Monthly Weather Review                         122,  671--685        |
C |                                                                        |
C | + Gallee, H.,                                                    1995. |
C |   Simulation of the mesocyclonic activity in the Ross Sea,  Antarctica |
C |   Monthly Weather Review                         123, 2051--2069       |
C |                                                                        |
C | + Gallee, H., Fontaine de Ghelin, O., and van den Broecke, M.,   1995. |
C |   Simulation of Atmospheric Circulations during GIMEX 91 Experiment    |
C |   using a Meso-gamma Primitive Equations Model                         |
C |   Journal of Climate                               8, 2843--2869       |
C |                                                                        |
C | + Gallee, H.,                                                    1996. |
C |   Possible Influence of Mesocyclonic Activity on Snow Precipitation    |
C |   in the Antarctic Coastal Zone                                        |
C |   Zeitschrift fur Gletscherkunde und Glazialgeologie 31, 17--24        |
C |                                                                        |
C | + Gallee, H.,                                                    1996. |
C |   Mesoscale atmospheric circulations                                   |
C |   over the southwestern Ross Sea sector, Antarctica,                   |
C |   Journal of Applied Meteorology                  35, 1142--1152       |
C |                                                                        |
C | + Gallee, H., P. Pettre, and G. Schayes,                         1996. |
C |   Sudden Cessation of Katabatic Wind in Adelie Land, Antarctica        |
C |   Journal of Applied Meteorology                  35, 1129--1141       |
C |                                                                        |
C | + van den Broecke, M. and Gallee, H.,                            1996. |
C |   Observation and Simulation of barrier winds                          |
C |   at the western margin of the Greenland ice sheet,                    |
C |   Quart. J. R. M. Soc.                           122, 1365--1383       |
C |                                                                        |
C | + Gallee, H.,                                                    1997. |
C |   Air-Sea Interactions over Terra Nova Bay during Winter:              |
C |   Simulation with a coupled Atmosphere-Polynya Model                   |
C |   Journal of Geophysical Research              102, 13813--13824       |
C |                                                                        |
C | + Gallee, H., and P. Duynkerke,                                  1997. |
C |   Air-Snow Interactions and the Surface Energy and Mass Balance        |
C |   over the Melting Zone of West Greenland during GIMEX                 |
C |   Journal of Geophysical Research              102, 13835--13849       |
C |                                                                        |
C | + Gallee, H., and P. Pettre,                                     1998. |
C |   Dynamical Constraints on Katabatic Wind Cessation in Adelie Land,    |
C |   Antarctica                                                           |
C |   Journal of Atmospheric Sciences               55,  1755--1770        |
C |                                                                        |
C | + Gallee, H.,                                                    1998. |
C |   A simulation of blowing snow over the Antarctic ice sheet            |
C |   Annals of Glaciology                          26,   203--206         |
C |                                                                        |
C | + Brasseur, O., C. Tricot, H. Gallee, K. De Ridder                     |
C |   and G. Schayes,                                                1998. |
C |   Impact of turbulent closure, dynamics and grid resolution            |
C |   on diurnal temperature evolution for clear sky situations            |
C |   over Belgium using a three-dimensional mesoscale model               |
C |   Boundary Layer Meteorology                    87,   163--193         |
C |                                                                        |
C | + Delobbe, L.,  and H. Gallee,                                   1998. |
C |   Simulation of marine Stratocumulus:                                  |
C |   Effect of Precipitation Parameterization and                         |
C |   Sensitivity to Droplet Number Concentration                          |
C |   Boundary Layer Meteorology                    89,    75--107         |
C |                                                                        |
C | + De Ridder,K., and H. Gallee,                                   1998. |
C |   Land Surface-induced regional climate change in Southern Israel      |
C |   Journal of Applied Meteorology                37,  1470--1485        |
C |                                                                        |
C | + Delobbe, L.,  and H. Gallee,                                   2000. |
C |   A sensitivity study of the subtropical ocean surface energy balance  |
C |   to the parameterization of precipitation from stratocumulus clouds.  |
C |   Boundary Layer Meteorology                    94,   399--422         |
C |                                                                        |
C | + Gallee H., G. Guyomarc'h, and E. Brun                          2001. |
C |   Impact of the snow drift                                             |
C |   on the Antarctic ice sheet surface mass balance:                     |
C |   possible sensitivity study to snow surface properties                |
C |   Boundary Layer Meteorology                    99,     1--19          |
C |                                                                        |
C | + Brasseur, O.                                                   2001. |
C |   Development and application of a physical approach                   |
C |   to estimate wind gusts.                                              |
C |   Monthly Weather Review                       129,     5--25          |
C |                                                                        |
C | + Gallee H., G. Wendler and O. Brasseur                          2001. |
C |   A simulation of an extreme katabatic wind event.                     |
C |   Meteorology and Atmospheric Physics           (submitted)            |
C |                                                                        |
C | + Brasseur O., Gallee H., JD. Creutin, T. Lebel, and P. Marbaix  2002. |
C |   High resolution simulations of precipitation over the Alps           |
C |   with the perspective of coupling to hydrological models.             |
C |   Advances in Global Change Research, 10 (M. Beniston, Ed.), 75--100   |
C |                                                                        |
C | + Brasseur O., Gallee H., Boyen H., and Tricot C.,               2002. |
C |   Reply to comments on : Development and application                   |
C |   of a physical approach to estimate wind gusts                        |
C |   Monthly Weather Review                       130,  1936--1942        | 
C |                                                                        |
C | + Lefebre, F., H. Gallee, J.-P. van Ypersele and P. Huybrechts,  2002. |
C |   Modelling of large-scale melt parameters with a regional climate     |
C |   model in South Greenland during the 1991 melt season                 |
C |   Annals of Glaciology                          35,   391--397         |
C |                                                                        |
C | + Lefebre, F., H. Gallee, J.-P. van Ypersele and W. Greuell,     2003. |
C |   Modelling of  snow and ice melt at ETH-Camp (West Greenland):        |
C |   a study of surface albedo                                            |
C |   Journal of Geophysical Research       108(D8),  10.1029/2001JD001160 |
C |                                                                        |
C | + Naithani, J., H.Gallee and G. Schayes,                         2002. |
C |   Marine air intrusion into the Adelie land sector of east Antarctica  |
C |   A study using Regional Climate Model (MAR)                           |
C |   Journal of Geophysical Research       107(D11), 10.1029/2000JD000274 |
C |                                                                        |
C | + Marbaix, P., H. Gallee, O. Brasseur, and J.-P. van Ypersele,   2003. |
C |   Lateral Boundary Conditions in regional climate models:              |
C |   a detailed study of the relaxation procedure                         |
C |   Monthly Weather Review                       131,   461--479         |
C |                                                                        |
C | + Messager, C., H. Gallée and O. Brasseur,                       2004. |
C |   Precipitation sensitivity to regional SST                            |
C |   in a regional climate simulation                                     |
C |   during the West African Monsoon for two dry years                    |
C |   Climate Dynamics           22:249-266, doi 10.1007/s00382-003-0381-x |
C |                                                                        |
C | + Gallée H., W. Moufouma-Okia, P. Bechtold, O. Brasseur, I. Dupays     |
C |   P. Marbaix, C. Messager R. Ramel and T. Lebel                  2004. |
C |   A high resolution simulation of a West African rainy season          |
C |   using a regional climate model                                       |
C |   Journal of Geophysical Research 109 D05108, doi 10.1029/2003JD004020 |
C |                                                                        |
C | + Fettweis, X., H. Gallée, F. Lefebre, and J. van Ypersele       2005. |
C |   Greenland Surface Mass Balance simulated by a Regional Climate Model |
C |   and Comparison with satellite derived data in 1990-1991.             |
C |   Climate Dynamics                       doi 10.1007/s00382-005-0010-y |
C |                                                                        |
C | + Gallée H., V. Peyaud and I. Goodwin                            2005. |
C |   Temporal and spatial variability of the Antarctic Ice Sheet          |
C |   Surface Mass Balance assessed from a comparison between              |
C |   snow stakes measurements and regional climate modeling.              |
C |   Annals of Glaciology                          41,    17--22.         |
C |                                                                        |
C | + Lefebre, F., X. Fettweis, H. Gallée, J. van Ypersele, P. Marbaix,    |
C |   W. Greuell, and P. Calanca                                     2005. |
C |   Evaluation of a high-resolution regional climate simulation          |
C |   over Greenland.                                                      |
C |   Climate Dynamics                       doi 10.1007/s00382-005-0005-8 |
C |                                                                        |
C | + Fettweis, X., H. Gallée, F. Lefebre, and J. van Ypersele       2006. |
C |   The 1988-2003 Greenland ice sheet melt extent using                  |
C |   passive microwave satellite data and a regional climate model        |
C |   Climate Dynamics                       doi 10.1007/s00382-006-0150-8 |
C |                                                                        |
C | + Messager, C., H. Gallée, O. Brasseur, B. Cappelaere, C. Peugeot,     |
C |   L. Séguis, M. Vauclin, R. Ramel, G. Grasseau, Laurent Léger and      |
C |   D. Girou.                                                      2006. |
C |   Influence of observed and RCM-simulated precipitation on the water   |
C |   discharge over the Sirba basin, Burkina Faso/Niger                   |
C |   Climate Dynamics                       doi 10.1007/s00382-006-0131-y |
C |                                                                        |
C | + Ramel, R., H. Gallee and C. Messager                           2006. |
C |   On the northward shift of the West African Monsoon                   |
C |   Climate Dynamics                       doi 10.1007/s00382-005-0093-5 |
C |                                                                        |
C | + M.R. Swain and H. Gallée                                       2006. |
C |   Antarctic Boundary Layer Seeing                                      |
C |   Astronomical Society of the Pacific          118,  1190--1197.       |
C |                                                                        |
C | + Fettweis, X., J. van Ypersele, H. Gallée, F. Lefebre, and            |
C |   W. Lefebvre                                                    2007  |
C |   The 1979-2005 Greenland ice sheet melt extent                        |
C |   from passive microwave data using an improved version                |
C |   of the melt retrieval XPGR algorithm                                 |
C |   Geophys. Res. Lett.,       34, L05502, doi:10.1029/2006GL028787.     |
C |                                                                        |
C | + Gallee H.                                                      2006. |
C |   Validation of a Regional Climate Model over East Antarctica          |
C |   Climate Dynamics                              (in preparation)       |
C |                                                                        |
C +************************************************************************+
C |                                                                        |
C | SUMMARY : THE MODEL USES THE FULL COMPRESSIBLE PRIMITIVES EQUATIONS    |
C | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    |
C |                                                                        |
C | Vertical Coordinate : Normalized Pressure Sigma                        |
C | Horizontal Grid     : Arakawa A-grid                                   |
C |                       (Purser and Leslie, MWR 116, 2069--2080, 1988)   |
C | Modes : 1-Dimensional (mx=1,my=1,mz) OR                                |
C | ^^^^^^^ 2-Dimensional (mx  ,my=1,mz) OR                                |
C |         3-Dimensional (mx  ,my  ,mz)                                   |
C |             Condition  mx > my       must be fulfilled in this case    |
C |                       (cfr."MARdim.inc")                               |
C |                                                                        |
C +************************************************************************+
C |                                                                        |
C | THE FILE MAR___.FOR contains the BASIC SOURCE CODE                     |
C | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                     |
C |                                                                        |
C | It may be used as is in 1-D, 2-D or 3-D Mode                           |
C | It may be modified in order to allow other possibilities.              |
C |    Modifications are performed by replacing labels `c #XY' by blanks.  |
C |   (see Preprocessor MAR_pp.for)                                        |
C |                                                                        |
C | #    MAIN       OPTIONS:                                               |
C | #^^^^^^^^^^^^^^^^^^^^^^^                                               |
C |                                                                        |
C | #     ADDITIONAL OPTIONS: Dynamics                                     |
C | #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                     |
C |                                                                        |
C | #     ADDITIONAL OPTIONS: Sea, Polynya and Snow Models                 |
C | #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                 |
C |                                                                        |
C | #     ADDITIONAL OPTIONS:                                              |
C | #^^^^^^^^^^^^^^^^^^^^^^^^                                              |
C |                                                                        |
C | #     ADDITIONAL OPTIONS: BOUNDARY CONDITIONS                          |
C | #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                          |
C |                                                                        |
C | #     ADDITIONAL OPTIONS: CONVECTIVE ADJUSTMENT                        |
C | #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                        |
C |                                                                        |
C | #     ADDITIONAL OPTIONS: VERTICAL  TURBULENCE                         |
C | #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                         |
C |                                                                        |
C | #     ADDITIONAL OPTIONS: SURFACE LAYER                                |
C | #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                |
C |                                                                        |
C | #     ADDITIONAL OPTIONS: HORIZONTAL DIFFUSION                         |
C | #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                         |
C |  !. `Standard' Horizontal Diffusion is performed on Sigma Surfaces     |
C |  !.  Smagorinski Relation (see Tag et al. 1979, JAM 18, 1429--1441)    |
C |  !.  CAUTION: Horizontal Diffusion is switched on with turhor = .true. |
C |  2.      _PE, _HH,     : Diffus.on Sigma Surfaces (%Grad.) +Vert.Corr. |
C |  3.      _PE, _HH, #CR : Diffus.on Sigma Surfaces (%Grad.) +all  Corr. |
C |  4. #DF, #PE,          : Diffus.on Sigma Surfaces (%Strain)+Vert.Corr. |
C |  5. #DF, #PE, #DC, #CR : Diffus.on Sigma Surfaces (%Strain)+all  Corr. |
C |                          (#DC -> u,v; #CR -> other Variables)          |
C |  CAUTION: IF #QE, THEN #qe MUST BE SWITCHED ON before 2, 3, 4 OR 5     |
C |  ^^^^^^^  IF #HY, THEN #se MUST BE SWITCHED ON before 2, 3, 4 OR 5     |
C |                                                                        |
C +************************************************************************+


      program MAR
C +   ^^^^^^^^^^^

c #AO USE mod_prism_proto !
c #AO USE mar_module      !TANGO modules
c #AO USE flincom         !

      IMPLICIT NONE

C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MARSND.inc'

      include 'MAR_DY.inc'
      include 'MARqqm.inc'
c #NH include 'MAR_NH.inc'
c #OL include 'MAR_OL.inc'

      include 'MAR_LB.inc'
      include 'MAR_UB.inc'
c #Di include 'MAR_DI.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'
c #BR include 'MAR_BR.inc'
c #CA include 'MAR_CA.inc'
      include 'MAR_FI.inc'

c #HY include 'MAR_HY.inc'
c #TC include 'MAR_TC.inc'
      include 'MAR_RA.inc'

      include 'MAR_SL.inc'
c #AO include 'MAR_AO.inc'

      include 'MAR_WK.inc'

c #IB include 'MAR_SV.inc'
      include 'MARlSV.inc'
c #IB include 'MARsSN.inc'
c #IB include 'MAR_IB.inc'
      include 'MAR_IO.inc'

c #EE include 'radCEP.inc'

C +--Local  Variables
C +  ================

      include 'MARvec.inc'
      integer  norder_0
      integer  newlbc_0
      real     rhcrit_0
      real     tstart_0

      character*3 DYNadv

c #MR logical     RadMAR
c #LL logical     RadLMD

c #OL logical     TURver

      real    dt_inv,dtLLoc,dtDifH,dt_Out,deltaF,cfladv,csnd
      real    hham  ,hhac  ,fham  ,thac  ,argham,hhhnnn,tdt   ,afdt
      real    pav   ,ppp   ,wwwabs,wwwmax,ectnew,pente ,dthdz ,adum ,adu
      real    pnhLav,pnh_av
      
      integer n     ,mlg   ,mlh   ,mlm   ,mld   ,iargum,i__min,i__max
      integer kk    ,kdim  ,ksig  ,iv    ,iw
      integer nt_Loc,jt_Loc,it_Loc,ntLLoc,itLLoc,itPhys
      integer iham  ,nham  ,ihamr ,nhamr ,jham  ,ibd
      integer jmmd  ,jm10  ,jh10  ,jh1   ,jd10  ,jd1
      integer iteChi
      integer iprint,log_nc
      integer iout  ,idum  ,jdum  ,id6   ,i_wmax,j_wmax,k_wmax
      integer ntracr,lotrac
      
c #VN logical           ntFlog                              ! Auxil.Variables
c #VN integer           nt_BAK,nt_sig                       !(variable nt_Mix)
c #VN real              VLoc  ,VLocmx,rtFact,CFLinv,TLocmn  !
c #VN integer           iLocmx,jLocmx,kLocmx                !

      REAL              DistST
C +...                  DistST:   Normalized Earth's Sun Distance

      character* 8      ttime


C +--Lateral Boundary Conditions
C +  ---------------------------

c #RB real      dumy3U(mx,my,mz)
c #RB real      dumy3V(mx,my,mz)


C +--Vertically Integrated Normalized Mass Flux
C +  ------------------------------------------

      real      fu(mx,my),fv(mx,my)


C +--Hamming Filter
C +  --------------

c #HF real      uuuham(mx,my,mz),vvvham(mx,my,mz)
c #HF real      pktham(mx,my,mz),qvaham(mx,my,mz),pnnham(mx,my)
C +...Hamming Filter variables for use in the Initialisation
C +   (Lynch and Huang 1992, MWR 120, 1019--1034)


C +--Atmospheric Water: Mass Conservation
C +  ------------------------------------

      real      dumy3Q(mx,my,mz)

c #WB real         dt_Bal


C +--Tracers:           Mass Conservation
C +  ------------------------------------

c #MV character*15 latrac(4)
c #MV real         totrac(4)
c #MV real         tracmx(4)
c #MV integer      itrcmx(4)
c #MV integer      jtrcmx(4)
c #MV integer      ktrcmx(4)


C +--Machine Precision
C +  -----------------

       REAL   reamin,reamax


C +--IO
C +  --

      real      zza(5)
      real      tta(5)


C +--DATA
C +  ====

c #MV data  (latrac(n),n=1,4)
c #MV.      /'Before Hor. ADV','Before Ver. ADV',
c #MV.       'Before Subgrids','After  Subgrids'/


C +--Flags
C +  =====

      openmp    = .false.
c #MP openmp    = .true.
 
c #SA sALONE    = .true.
c #GE geoNST    = .true.
c #MR RadMAR    = .true.
c #LL RadLMD    = .true.
c #OL TURver    = .FALSE.

c #KA ini_KA_TE = .false.

      VSISVAT   = .true.
c #FR VSISVAT   = .FALSE.
c #SV VSISVAT   = .FALSE.
      iniIRs    = .false.
      iniOUT    = .false.

C +--Blowing Snow
C +  ~~~~~~~~~~~~
       BloMod=.FALSE.
c #AE  BloMod=.true.

C +--Advection
C +  ~~~~~~~~~
       DYNadv='LFB'
c #UW  DYNadv='UPW'

       no_vec=.false.
c #NV  no_vec=.true.
c #VN  ntFlog=.FALSE.

       openLB=.FALSE.
c #OB  openLB=.true.

       sommlb=.FALSE.
c #RB  sommlb=.true.

       SBLitr=.true.
c #BR  SBLitr=.true. 
C +... SBLitr=.true. ==> SBL is iterated

       tur_25=.FALSE.
c #BR  tur_25=.true.


C +--CONSTANTS
C +  =========

      ntracr = 0
c #TC ntracr = ntrac


C +--Grid Constants
C +  --------------

      rxy= 1.e-6/(mx*my)
      m  = mx
      m1 = m -1
      m2 = m -2
      m3 = m -3
      m4 = m -4
      mn3= mn-3
      mn4= mn-4
c #OL mlg= mz- 5
c #OL mlh= mz-19
c #OL mlm= max(1,mlh)
c #OL mld= mlm - mlh
c #OL mlg= mlg + mld
c #OL mlh= mlm

      ttime='        '

      write(6,6)
 6    format(
     .     /,"                                               "
     .      ,"                   "
     .    ,/," **********************************************"
     .      ,"****************** "
     .    ,/," *                                             "
     .      ,"                 * "
     .    ,/," *  MM      MM   AAAA   RRRRRR      OOOO   NN  "
     .      ,"    NN HH    HH  * "
     .    ,/," *  MMMM  MMMM AA    AA RR    RR  OO    OO NNNN"
     .      ,"    NN HH    HH  * "
     .    ,/," *  MM  MM  MM AAAAAAAA RRRRRR    OO    OO NN  "
     .      ,"NN  NN HHHHHHHH  * "
     .    ,/," *  MM      MM AA    AA RR  RR    OO    OO NN  "
     .      ,"  NNNN HH    HH  * "
     .    ,/," *  MM      MM AA    AA RR    RR    OOOO   NN  "
     .      ,"    NN HH    HH  * "
     .    ,/," *                                             "
     .      ,"                 * "
     .    ,/," *   Modèle Atmosphérique Régional A Option Non"
     .      ,"-Hydrostatique   * "
     .    ,/," *                                             "
     .      ,"                 * "
     .    ,/," **********************************************"
     .      ,"****************** "
     .    ,/,"                                               "
     .      ,"                   "
     .    ,/,"                     ---   4 May       2007 ---"
     .      ,"                   "
     .    ,/,"                                               "
     .      ,"                   ")


C +--Machine Precision
C +  =================

C +        ******
      call relrea
C +        ******


C +--Min and Max Arguments of Function exp(x)
C +  ----------------------------------------

      argmin = log( rrmin)
      iargum =     argmin
      i__min =     iargum + 7
      argmax = log( rrmax)
      iargum =     argmax
      i__max =     iargum - 8

      write(6,600) argmin,i__min,argmax,i__max
 600  format(/,' Function  exp(x)    :   Arguments:',
     .       /,' Minimum Value       : ',e12.4, 5x,'==> (',i3,')',
     .       /,' Maximum Value       : ',e12.4, 5x,'==> (',i3,')')

      argmin =     i__min
      argmax =     i__max


C +--PHYSICAL DATA
C +  =============

C +        ******
      call PHYmar
C +        ******


C +--CONTROL PARAMETERS
C +  ==================

      open(unit=3, status='old',file='MARctr.dat')
      rewind 3
      read(3,31)reaVAR,reaLBC,safVAR
 31   format(l12)
      if (.NOT. reaVAR)geoNST=.FALSE.
      read(3,31)hamfil
C +...          hamfil: Initialisation based on Temporal Filtering  (Hamming)   
      read(3,31)conmas
C +...          conmas: Initialis. Constrained (Mass            Conservation)
      read(3,31)potvor
C +...          potvor: Initialis. Constrained (Potent. Vortic. Conservation)
      read(3,31)brocam
      read(3,31)center
C +...          center=.T. => Pressure       Spatial Scheme  centered
      read(3,32)nordps
 32   format(i12)
C +...          nordps= 4  :  Pressure       Spatial Scheme Precision
      read(3,31)staggr
C +...          staggr=.T. =>                Vertical  Grid staggered
      read(3,31)turhor
      read(3,31)chimod
C +...          chimod=.F.: Atmospheric Chemical Model  turned OFF
C +             chimod=.T.: Atmospheric Chemical Model  turned ON
      read(3,31)convec
C +...          convec=.T.: Mass Flux convective Scheme turned ON
      read(3,31)micphy
C +...          micphy=.F.: only the dry model is run
C +             micphy=.T.: the explicit hydrological cycle is included
      read(3,31)fracld
C +...          fracld=.T.: Fraction.Cloudiness Scheme  turned ON
      read(3,33)rhcrit_0
c #HY           rhcrHY= rhcrit_0
C +...          rhcrHY: relative humidity critical saturation value 

c #HY IF       (rhcrHY.gt.1.0d+0)                                 THEN
c #HY   write(6,300)      rhcrHY
 300    format(/,' ***********************************',
     .            '********************************',
     .         /,' * Critical Humidity =',f6.2,
     .           ' [%] / new units: [-] => divide by 100 *',
     .         /,' ***********************************',
     .            '********************************',/,1x)
c #HY           rhcrHY =  rhcrHY * 1.0d-2
c #HY END IF

      read(3,33)tstart_0
c #HY           tim_HY= tstart_0
C +...          tim_HY: hydrological cycle starting time (prefarably uses 0.) 
 33   format(f12.4)
      read(3,34)cz0_GE 
 34   format(d12.4)
      read(3,31)physic
C +...          physic: Physics   are   included           
      read(3,31)vegmod
C +...          vegmod =.true. : Interactive SVAT             turned ON
      if (.not. physic) vegmod =.FALSE.
      read(3,31)snomod
C +...          snomod =.true. : Interactive Snow    Model    turned ON
      if (.not. physic) snomod =.FALSE.
      read(3,31)polmod
C +...          polmod =.true. : Interactive Polynya Dynamics turned ON
      read(3,33)hic0    
C +...          hic0   : assumed initial sea-ice Thickness      
      read(3,33)fxlead
C +...          fxlead : assumed initial minimal Leads Fraction
      read(3,31)qsolSL
C +...          qsolSL: Deardorff model for soil humidity
      read(3,33)dt
                dt_inv = 1.0 / dt
      read(3,32)nboucl
      read(3,32)nprint
      read(3,32)ntFast                                       !
      IF   (mod(ntFast,2).EQ.0) THEN                         !
        write(6,301)     ntFast                              !
 301    format(/,' ***********************************',     !
     .            '********************************',        !
     .         /,' * Value of   ntFast =',i6  ,              !
     .           ' is even (precluded) =====> 1 is added *', !
     .         /,' ***********************************',     !
     .            '********************************',/,1x)   !
                ntFast = ntFast + 1                          ! Fixed    ntFast
      END IF                                                 !
c #VN           nt_Mix =          1                          ! variable nt_Mix
      
      read(3,33)dtDiff
      read(3,33)dtPhys
C +...          dtPhys: Surface   Physics Time Step
      read(3,33)dtRadi
C +...          dtRadi: Radiation         Time Step
      read(3,34)rxbase
C +...          rxbase : Nudging        Coefficient           
      read(3,34)rxfact
C +...          rxfact : Lateral Sponge Coefficient           
      close(unit=3)


C +--New Control Parameters
C +  ----------------------

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt Robert = 0.01                                      ! STD. Value = 0.01
                                                         ! MAX. Value = 0.20
C +--Non-Hydrostatic Dynamics
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
c #NH csnd   = 330.
C +...csnd   : Prescribed Sound Speed (m/s)

c #NH c2NH   = csnd * csnd

C +--Chemical Model
C +  ~~~~~~~~~~~~~~
      lotrac = 0
c #TC lotrac = 1
C +
c #TC          jtAdvH = 1
c #TC          dtAdvH = dt
c #TC          jt_ODE = 1
c #TC if (.not.chimod) then
c #TC          dt_ODE = dt
c #TC          jt_ODE = 1
c #TC          nt_ODE = 1
c #TC          ikTC(1)= 1
c #TC end if


C +--Print Characteristic
C +  --------------------

      if (nprint.lt.0) then
       nprint =        - nprint
       log_nc = 1
      else
       log_nc = 0
      end if
       ipr_nc = 1                                                       
       npr_nc = 1      + nprint                                         
C +... ipr_nc  (npr_nc): Netcdf Output File: Current No (Total Nb) of Prints 


       nterun = nboucl * nprint


C +-- Initialize coupling  (cpl)
C +   ==========================

c #AO WRITE(6,*) 'Initialize coupling in MAR'           !cpl

C +        ******
c #AO CALL inicma                                       !cpl
C +        ******

c #AO WRITE(6,*) 'Coupling initialization done in MAR'  !cpl


C +--OUTPUT Files
C +  ============

      open(unit= 4,status='new',file='MARphy.out')
      rewind     4

      open(unit=21,status='new',file='MAR.log')
      rewind    21


C +--Katabatic Jump Diagnostics
C +  --------------------------

      IF (mx.gt.1.and.my.le.1)                                    THEN
        open(unit=22,status='unknown',file='MAR.uuu')
        rewind    22
        open(unit=23,status='unknown',file='MAR.ttt')
        rewind    23
        open(unit=24,status='unknown',file='MAR.ppp')
        rewind    24
      END IF

c #WE open(unit=25,status='unknown',file='MAR.TKE__VER')
c #WE rewind    25

c #SE open(unit=29,status='unknown',file='MAR.SNOW_VER')
c #SE rewind    29


C +--Dynamical Balance (Output in dynbil)
C +  ------------------------------------

c #DY open(unit=61,status='unknown',file='MAR.DY1')
c #DY rewind    61
c #DY open(unit=62,status='unknown',file='MAR.DY2')
c #DY rewind    62
c #DY open(unit=63,status='unknown',file='MAR.DY3')
c #DY rewind    63
c #DY open(unit=64,status='unknown',file='MAR.DY4')
c #DY rewind    64
c #DY open(unit=65,status='unknown',file='MAR.DY5')
c #DY rewind    65
c #DY open(unit=66,status='unknown',file='MAR.DY6')
c #DY rewind    66


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ INITIALISATION +++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

C +        ******
      call INIgen
C +        ******


C +        **********
c #DB call Debugg_MAR('INIgen    ')
C +...     Debugg_MAR: cfr. DEBUGG.d Directory
C +        **********


C +--PBL Initialization Parameter
C +  ============================

      IF (itexpe.le.0)                                              THEN
          log_1D =  0
      ELSE
          log_1D =  1
      END IF


C +--HAMMING Filter Parameters
C +  =========================

       iham  = 0
       nham  = 0

c #HF IF (hamfil)                                                   THEN

c #HF  hham  = 3.  *3600.
C +... hham  : Time Span for Diabatic Initialisation
C +            (cfr. Huang and Lynch 1993 MWR 121, p. 590)
c #HF  hhac  = hham
C +... hhac  : Filter Cutoff Time Period
C +            (cfr. Lynch and Huang 1992 MWR 120, p.1021)
c #HF  nham  = hham*demi/dt
c #HF  iham  =-nham
c #HF  fham  = pi / (nham+1) 
c #HF  thac  =(pi / (nham  ))*(hham/hhac)
C +... thac  : Filter Cutoff Frequency    
C +            (cfr. Lynch and Huang 1992 MWR 120, p.1021)

c #HF END IF

       ihamr = iham
       nhamr = nham


C +--Domain Averaged Pressure Thickness
C +  ==================================

        pav  = 0.
      DO j=1,my
      DO i=1,mx
        pav  = pav + pstDYn(i,j)
      END DO
      END DO
        pav  = pav / (mx*my)


C +--Dynamical Balance
C +  =================

c #DY  ibd= 0
c #DY  tdt= 0.
c #DY afdt= 1.
c #DY fnam='                '

C +        ******
c #DY call dynbil(tdt,afdt,jmez,ibd)
C +        ******


C +--OUTPUT
C +  ======

C +   ---------------------
      if (IO_loc.ge.2) then 
C +   ---------------------

       DO i=1,5
         tta(i) = tsrfSL(igrdIO(i),jgrdIO(i),1)-TfSnow
       END DO
         write(21,607)(igrdIO(i),jgrdIO(i),       i=1,5),
     .             (sh(igrdIO(i),jgrdIO(i)),tta(i),i=1,5)
  607    format(//,5(5x,' (',i4,',',i4,')',5x,'!! '),
     .           /,5(' altitude ! temperat. ','!! '),
     .           /,5(10('-'),'!',11('-'),'!!-'),
     .           /,5(f8.1,'  ! ',f8.2,'  !! '))
       DO kk=1,mz
          k=mz+1-kk
         DO i=1,5
          zza(i) = gplvDY(igrdIO(i),jgrdIO(i),k)*grvinv
          tta(i) = pktaDY(igrdIO(i),jgrdIO(i),k)*pcap
         END DO
          write(21,609)(zza(i),tta(i),i=1,5)
  609     format(5(f8.1,'  ! ',f8.2,'  !! '))
       END DO
          write(21,611)
  611     format(1x)

C +   ------
      end if
C +   ------

      IF (mmx.gt.1.and.mmy.le.1)                                    THEN
        write(22,221)itexpe,(xxkm(i),i=imez-10,imez+30)
        write(23,221)itexpe,(xxkm(i),i=imez-10,imez+30)
        write(24,221)itexpe,(xxkm(i),i=imez-10,imez+30)
      END IF

c #DY   write(61,221)itexpe,(xxkm(i),i=imez-10,imez+30)
c #DY   write(62,221)itexpe,(xxkm(i),i=imez-10,imez+30)
c #DY   write(63,221)itexpe,(xxkm(i),i=imez-10,imez+30)
c #DY   write(64,221)itexpe,(xxkm(i),i=imez-10,imez+30)
c #DY   write(65,221)itexpe,(xxkm(i),i=imez-10,imez+30)
c #DY   write(66,221)itexpe,(xxkm(i),i=imez-10,imez+30)


C +--NetCDF Files
C +  ------------

      nbhour =          0
 1    CONTINUE
      nbhour = nbhour + 1
      IF (mod(3600*nbhour,idt).ne.0)                           GO TO 1

c #ID IF (log_nc.eq.1)                                            THEN

c #ID                dt_Loc =   dt

C +           ******
c #ID    call OUT_nc
C +           ******

c #ID END IF


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of the EXTERNAL TIME INCREMENTATION (nprint over dt * nboucl) ++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      iprint = 0
 3    CONTINUE


C +--Output Files Label
C +  ==================

        fnam( 1: 3) = 'si_'
        jmmd        = 1 + mod(minuGE,10)
        jm10        = 1 +     minuGE/10
        jh10        = 1 +     jhaMAR/10
        jh1         = 1 + mod(jhaMAR,10)
        jd10        = 1 +     jdaMAR/10
      IF (jd10.gt.10)                                             THEN
        fnam( 3: 3) =   '+'
        jd10        =     mod(jd10  ,10)
      END IF
        jd1         = 1 + mod(jdaMAR,10)
        fnam( 4: 4) = labnum(jd10)
        fnam( 5: 5) = labnum(jd1)
        fnam( 6: 6) = labnum(jh10)
        fnam( 7: 7) = labnum(jh1)
        fnam( 8: 8) = labnum(jm10)
        fnam( 9: 9) = labnum(jmmd)
        fnam(10:10) = '.'
        fnam(11:13) = explIO
        fnam(14:16) = '   '


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of the INTERNAL TIME INCREMENTATION (nboucl over dt) +++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      iboucl = 1
 2    CONTINUE


C +--cpl : GET FIELDS FROM OASIS
C +  ===========================

C +        ***********
c #AO call OASIS_2_MAR
C +        ***********


C +--Modification of the Surface  Forcing
C +  ====================================

C +         ******
c #SB  call SBCnew
c #XF  call FILatmo
C +         ******

      IF ( iterun <=  1 .or. mod(iterun,12*3600/int(dt))==0)
     .call time_steps 


C +--Branch to  Stand Alone Surface Model
C +  ====================================

c #SA IF (sALONE)  GO TO 4
C +...             go to Stand Alone Surface Model


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of DIABATIC INITIALISATION +++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


 150  CONTINUE


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of FAST PROPAGATING WAVES DYNAMICS     (HYDROSTATIC PART) ++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      IF ( mmx .gt. 1 .and. log_1D.eq.1 )                         THEN
C +...``Dynamics'' is active only after the 1-D Initialisation Phase


C +--Update of Horizontal Wind Speed and Mass
C +  ========================================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          ubefDY(i,j,k)  = uairDY(i,j,k)
          vbefDY(i,j,k)  = vairDY(i,j,k)
        END DO
        END DO
        END DO

        DO j=1,my
        DO i=1,mx
           pstDY( i,j)   = pstDYn(i,j)
          opstDY( i,j)   = pstDYn(i,j)
        END DO
        END DO


C +--Update of nt_Mix parameter (CFL criterion on Max Wind Speed)
C +  ============================================================

c #VN   IF (.NOT.ntFlog)                                            THEN
c #VN       ntFlog    =.TRUE.
c #VN       CFLinv    = dt/dx          ! Inverse           CFL Number
c #VN       rtFact    = 500.0 * CFLinv ! Sound Speed upper Bound (500m/s) 
                                       ! Normalized by the CFL Number

C +--Local     Wind Speed
C +  --------------------

c #VN       VLocmx    = 0.
c #VN       TLocmn    = 273.15
c #VN       iLocmx    = 0
c #VN       jLocmx    = 0
c #VN       kLocmx    = 0
c #VN     DO j=1,my
c #VN     DO i=1,mx
c #VN     DO k=1,mz
c #VN       WKxyz1(i,j,k) =             (abs(uairDY(i,j,k))
c #VN.                     + min(1,my-1)*abs(vairDY(i,j,k)))
c #vN     ENDDO
c #vN     ENDDO
c #vN     ENDDO

c #vN     DO j=1,my
c #vN     DO i=1,mx
c #vN     DO k=1,mz
c #VN       VLocmx    =      max(VLocmx     ,WKxyz1(i,j,k))
c #vN     ENDDO
c #vN     ENDDO
c #vN     ENDDO

c #vN     DO j=1,my
c #vN     DO i=1,mx
c #VN       TLocmn   =       min(TLocmn     ,tairDY(i,j,mz-1))              
c #VN     ENDDO
c #VN     ENDDO

c #vN     DO j=1,my
c #vN     DO i=1,mx
c #vN     DO k=1,mz
c #VN       IF (WKxyz1(i,j,k).GT.VLocmx-epsi)                       THEN
c #VN         iLocmx      =      i
c #VN         jLocmx      =      j
c #VN         kLocmx      =      k
c #VN       ENDIF
c #VN     ENDDO
c #VN     ENDDO
c #VN     ENDDO

c #VN     TLocmn    = TLocmn - 273.15  
c #VN     nt_sig    =          1  +  CFLzDY  /  ntFast
c #VN     nt_BAK    =                           nt_Mix
c #VN     nt_Mix    = max(nt_sig,           int(rtFact + CFLinv*VLocmx))
cc #VN     if(TLocmn<-60.) nt_Mix=min(nt_Mix*2,
cc #VN.                           nt_Mix+(-50-int(TLocmn))/10)

c #VN     IF (nt_Mix .ne. nt_BAK)                                   THEN

c #VN       dtFast      = dt     / ((ntFast+1) *nt_Mix) ! see INIgen
c #VN       FIfstu      = FIslou / ((ntFast+1) *nt_Mix) ! see GRDmar
c #VN       FIfstp      = FIslop / ((ntFast+1) *nt_Mix) ! see GRDmar
c #VN       DO k = 1,mz
c #VN         FIk_fu(k) = FIfstu /              nt_Mix  ! see GRDmar
c #VN         FIk_fp(k) = FIfstp /              nt_Mix  ! see GRDmar
c #VN       END DO

c #VN       write(6,1001)                                         
c #VN.                    TLocmn,VLocmx,iLocmx,jLocmx ,kLocmx            
c #VN.                   ,nt_BAK,nt_Mix,itexpe                    
c #VN.                   ,jdarGE,labmGE(mmarGE),iyrrGE            
c #VN.                   ,jhurGE,       minuGE ,jsecGE            
 1001       format('WARNING: TT min =',f8.2,
     .        ' S(|V|)max =',f8.1,' (',3i4,')',
     .        ' ==> update nt_Mix(=',i4,');:=', i4,' at iteration',i8,
     .        '     Time is ',i2,'-',a3,'-',i4,
     .                    '/',i2,'.',i2,'.',i2,' UT')

c #VN     ENDIF 
c #VN   END IF


C +--Begin the Time Loop
C +  ===================

c #VN   DO it_Mix = 1,nt_Mix
        DO itFast = 1,ntFast+1


C +--Integration of the Hydrostatic Relation
C +  =======================================

          IF (.not.brocam)                                          THEN

           if(openmp) then
C +            ******
            call DYNgpo_mp
C +            ******
           else
C +            ******
            call DYNgpo
C +            ******
           endif

C +...      WARNING : Place of this routine DYNgpo in the organigram depends 
C +         if Brown-Campana (1978, MWR, p.1125) time scheme is used or not!
C +         Here is the place when the Brown-Campana time scheme is NOT used. 

C +              **********
c #db       call Debugg_MAR('DYNgpo .F.')
C +              **********

          END IF


C +--Mass Continuity
C +  ===============

          norder_0=nordps

          if(openmp) then
C +            ******
          call DYNdps_mp(norder_0)
C +            ******
          else
C +            ******
          call DYNdps(norder_0)
C +            ******
          endif


C +            **********
c #db     call Debugg_MAR('DYNdps .F.')
C +            **********


C +--Nudging
C +  -------


c #ob     DO j=1,my
c #ob     DO i=1,mx
c #ob       dumy3D(i,j,1)=pstDYn(i,j)
c #ob     END DO
c #ob     END DO

c #ob                            kdim = 1

C +            **********
c #ob     call LBC000_run(dumy3D,kdim)
C +            **********

c #ob     DO j=1,my
c #ob     DO i=1,mx
c #ob       pstDYn(i,j)  =dumy3D(i,j,1)
c #ob     END DO
c #ob     END DO


C +--Filtering
C +  ---------

          IF (FIfstp.gt.0.)                                         THEN

              DO j=1,my
              DO i=1,mx
                dumy3D(i,j,1) = pstDYn(i,j)   - pstDY1(i,j)
              END DO
              END DO
                dumeps(    1) = FIfstp
                kdim          = 1

            IF(mmy.le.1)                                            THEN

c #OB         IF (openLB)                                           THEN

C +                  **********
c #OB           call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                  **********

c #OB         ELSE

C +                  *********
                call DYNfil_1D (dumy3D,dumeps,kdim)
C +                  *********

c #OB         END IF

            ELSE
c #OB         IF (openLB)                                           THEN

C +                  **********
c #OB           call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                  **********

c #OB         ELSE

c #NV           IF (no_vec)                                         THEN

C +                    *********
c #NV             call DYNfil_3D (dumy3D,dumeps,kdim)
C +                    *********

c #NV           ELSE

C +                    *********
                  call DYNfilv3D (dumy3D,dumeps,kdim)
C +                    *********

c #NV           END IF

c #OB         END IF

            END IF

              DO j=1,my
              DO i=1,mx
                pstDYn(i,j)   = dumy3D(i,j,1) + pstDY1(i,j)
              END DO
              END DO

C +              **********
c #db       call Debugg_MAR('DYNfil Dp*')
C +              **********

          END IF


C +--Integration of the Hydrostatic Relation
C +  =======================================

          IF (brocam)                                               THEN


           if(openmp) then
C +            ******
            call DYNgpo_mp
C +            ******
           else
C +            ******
            call DYNgpo
C +            ******
           endif

C +...      WARNING : The place of routine DYNgpo in the organigram depends 
C +         if Brown-Campana (1978, MWR, p.1125) time scheme is used or not!
C +         Here is the place when Brown-Campana time scheme is used. 

C +              **********
c #db       call Debugg_MAR('DYNfil Dp*')
C +              **********

          END IF


C +--Contribution of Horizontal Pressure Gradient Force 
C +  ==================================================

                      norder_0=nordps

        if(openmp) then
C +          **********
        call DYNdgz_mp(norder_0)
C +          **********
        else
C +          **********
        call DYNdgz(norder_0)
C +          **********
        endif

C +            **********
c #db     call Debugg_MAR('DYNdgz    ')
C +            **********


C +--Contribution of the Divergence Damper (Hydrostatic PART)
C +  ========================================================

C +            ******
c #DD     call DYNdmp
C +            ******

C +            **********
c #db     call Debugg_MAR('DYNdmp    ')
C +            **********


C +--Filtering of the Horizontal Wind Speed Components
C +  =================================================

          IF     (itFast.le.ntFast)                                 THEN
            IF   (FIk_fu(1).gt.0.0)                                 THEN
              IF (mmy.le.1)                                         THEN

                DO k=1,mz
                DO i=1,mx
                  dumy3D(i,1,k) = uairDY(i,1,k)
                END DO
                  dumeps(    k) = FIk_fu(    k)
                END DO
                  kdim          =            mz

c #OB           IF (openLB)                                         THEN

C +                    **********
c #OB             call DYNfil_1D0(dumy3D,dumeps,mz)
C +                    **********

c #OB           ELSE

C +                    *********
                  call DYNfil_1D (dumy3D,dumeps,mz)
C +                    *********

c #OB           END IF

C +...            The PGF does not contribute  to v in the 2-D version
C +                       making the filtering of v unnecessary. 

                DO k=1,mz
                DO i=1,mx
                  uairDY(i,1,k) = dumy3D(i,1,k)
                END DO
                END DO

              ELSE

                DO k=1,mz
                  dumeps(k)     = FIk_fu(    k)
                END DO
                  kdim          =            mz

                DO k=1,mz
                DO j=1,my
                DO i=1,mx
                  dumy3D(i,j,k) = uairDY(i,j,k)
                END DO
                END DO
                END DO

c #OB           IF (openLB)                                         THEN

C +                    **********
c #OB             call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                    **********

c #OB           ELSE

c #NV             IF (no_vec)                                       THEN
c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif
c #NV             ELSE

C +                      *********
                    call DYNfilv3D (dumy3D,dumeps,kdim)
C +                      *********

c #NV             END IF

c #OB           END IF

                DO k=1,mz
                DO j=1,my
                DO i=1,mx
                  uairDY(i,j,k) = dumy3D(i,j,k) 
                  dumy3D(i,j,k) = vairDY(i,j,k)
                END DO
                END DO
                END DO

c #OB           IF (openLB)                                         THEN

C +                    **********
c #OB             call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                    **********

c #OB           ELSE

c #NV             IF (no_vec)                                       THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV             ELSE

C +                      *********
                    call DYNfilv3D (dumy3D,dumeps,kdim)
C +                      *********

c #NV             END IF

c #OB           END IF

                DO k=1,mz
                DO j=1,my
                DO i=1,mx
                  vairDY(i,j,k) = dumy3D(i,j,k)
                END DO
                END DO
                END DO

              END IF

            END IF

C +              **********
c #db       call Debugg_MAR('DYNfil u,v')
C +              **********


C +--Filtering of the Vertical H Wind Speed Component
C +  ================================================

          ELSE
            IF     (itFast.eq.ntFast+1)                             THEN
              IF   (FIk_fp(1).gt.0.0  )                             THEN
                IF (mmy.le.1)                                       THEN

                  DO k=1,mz
                  DO i=1,mx
                     dumy3D(i,1,k)= psigDY(i,1,k)
                  END DO
                     dumeps(    k)= FIk_fp(    k)
                  END DO
                     kdim         =           mz

c #OB             IF (openLB)                                       THEN

C +                      **********
c #OB               call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                      **********

c #OB             ELSE

C +                      *********
                    call DYNfil_1D (dumy3D,dumeps,kdim)
C +                      *********

c #OB             END IF

C +...              The PGF does not contribute to v in the 2-D version
C +                         making the filtering of v unnecessary. 

                  DO k=1,mz
                  DO i=1,mx
                    psigDY(i,1,k) = dumy3D(i,1,k)
                  END DO
                  END DO

                ELSE

                  DO k=1,mz
                    dumeps(k)     = FIk_fp(    k)
                  END DO
                    kdim          =            mz

                  DO k=1,mz
                  DO j=1,my
                  DO i=1,mx
                    dumy3D(i,j,k) = psigDY(i,j,k)
                  END DO
                  END DO
                  END DO

c #OB             IF (openLB)                                       THEN

C +                      **********
c #OB               call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                      **********

c #OB             ELSE

c #NV               IF (no_vec)                                     THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV               ELSE

C +                        *********
                      call DYNfilv3D (dumy3D,dumeps,kdim)
C +                        *********

c #NV               END IF

c #OB             END IF

                  DO k=1,mz
                  DO j=1,my
                  DO i=1,mx
                    psigDY(i,j,k) = dumy3D(i,j,k)
                  END DO
                  END DO
                  END DO
                END IF
              END IF
            END IF
          END IF

        END DO
c #VN   END DO


C +--Dynamical Balance (Pressure Gradient Force)
C +  ===========================================

c #DY    ibd= 1
c #DY    tdt= 0.
c #DY   afdt= 1.

C +          ******
c #DY   call dynbil(tdt,afdt,jmez,ibd)
C +          ******

C +          **********
c #DB   call Debugg_MAR('After Fast')
C +          **********


C +--Update of nt_Mix parameter (CFL criterion on Max Wind Speed)
C +  ============================================================


C +--Local     Wind Speed
C +  --------------------

c #VN       VLocmx    = 0.
c #VN       TLocmn    = 273.15
c #VN       iLocmx    = 0
c #VN       jLocmx    = 0
c #VN       kLocmx    = 0
c #VN     DO j=1,my
c #VN     DO i=1,mx
c #VN     DO k=1,mz
c #VN       WKxyz1(i,j,k) =              (abs(uairDY(i,j,k))
c #VN.                      + min(1,my-1)*abs(vairDY(i,j,k)))
c #vN     ENDDO
c #vN     ENDDO
c #vN     ENDDO

c #vN     DO j=1,my
c #vN     DO i=1,mx
c #vN     DO k=1,mz
c #VN       VLocmx    =      max(VLocmx     ,WKxyz1(i,j,k))
c #vN     ENDDO
c #vN     ENDDO
c #vN     ENDDO

c #vN     DO j=1,my
c #vN     DO i=1,mx
c #VN       TLocmn   =       min(TLocmn     ,tairDY(i,j,mz-1))              
c #VN     ENDDO
c #VN     ENDDO

c #vN     DO j=1,my
c #vN     DO i=1,mx
c #vN     DO k=1,mz
c #VN       IF (WKxyz1(i,j,k).GT.VLocmx-epsi)                       THEN
c #VN         iLocmx      =      i
c #VN         jLocmx      =      j
c #VN         kLocmx      =      k
c #VN       ENDIF
c #VN     END DO
c #VN     END DO
c #VN     END DO

c #VN     TLocmn    = TLocmn - 273.15  
c #VN     nt_sig    =          1  +  CFLzDY  /  ntFast
c #VN     nt_BAK    =                           nt_Mix
c #VN     nt_Mix    = max(nt_sig,           int(rtFact + CFLinv*VLocmx))
cc #VN     if(TLocmn<-60.) nt_Mix=min(nt_Mix*2,
cc #VN.                           nt_Mix+(-50-int(TLocmn))/10)

c #VN     IF (nt_Mix .ne. nt_BAK)                                   THEN

c #VN       dtFast      = dt     / ((ntFast+1) *nt_Mix) ! see INIgen
c #VN       FIfstu      = FIslou / ((ntFast+1) *nt_Mix) ! see GRDmar
c #VN       FIfstp      = FIslop / ((ntFast+1) *nt_Mix) ! see GRDmar
c #VN       DO k = 1,mz
c #VN         FIk_fu(k) = FIfstu /              nt_Mix  ! see GRDmar
c #VN         FIk_fp(k) = FIfstp /              nt_Mix  ! see GRDmar
c #VN       END DO

c #VN       write(6,1001)                                         
c #VN.                    TLocmn,VLocmx,iLocmx,jLocmx ,kLocmx            
c #VN.                   ,nt_BAK,nt_Mix,itexpe                    
c #VN.                   ,jdarGE,labmGE(mmarGE),iyrrGE            
c #VN.                   ,jhurGE,       minuGE ,jsecGE            

c #VN     ENDIF 


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END   of FAST PROPAGATING WAVES DYNAMICS     (HYDROSTATIC PART) ++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of FAST PROPAGATING WAVES DYNAMICS (NON-HYDROSTATIC PART) ++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Non-Hydrostatic Dynamics 
C +  ========================

C +              ******
c #NH       call DYN_NH
C +              ******

C +              **********
c #db       call Debugg_MAR('DYN_NH    ')
C +              **********


C +--Radiating Boundary Conditions
C +  -----------------------------


C +--Statistics
C +  ~~~~~~~~~~
C +              **********
c #db       call Debugg_MAR('LBCnud_000')
C +              **********


C +--Filtering
C +  ---------

C +              ********* 
c #NH       call DYNfil_NH
C +              ********* 


C +--Water Budget
C +  ------------

c #WB                         dt_Bal = dt
C +              ******
c #WB       call H2O_WB(0,-1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******

C +              ******
c #WB       call H2O_WB(0, 1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******

C +              **********
c #db       call Debugg_MAR('DYNfil_NH ')
C +              **********


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END   of FAST PROPAGATING WAVES DYNAMICS (NON-HYDROSTATIC PART) ++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of SLOW PROPAGATING WAVES DYNAMICS +++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Advection
C +  =========

C +--Tracer Mass Verification (Advection)
C +  ------------------------------------

c #MV     IF    (jtAdvH.eq.1)                                       THEN
c #MV            totrac(1) = 0.
c #MV            tracmx(1) = 0.
c #MV       DO k=1,mz
c #MV       DO j=1,my
c #MV       DO i=1,mx
c #MV            totrac(1) = totrac(1)+qxTC(i,j,k,1)*opstDY(i,j)
c #MV.                                              *dsigm1(k)
c #MV         IF(tracmx(1)        .lt. qxTC(i,j,k,1))               THEN
c #MV            tracmx(1) =           qxTC(i,j,k,1)
c #MV            itrcmx(1) =                  i
c #MV            jtrcmx(1) =                  j
c #MV            ktrcmx(1) =                  k
c #MV         END IF
c #MV       END DO
c #MV       END DO
c #MV       END DO
c #MV     END IF


C +--Leapfrog Backward Scheme
C +  ------------------------

        IF    (DYNadv.EQ.'LFB')                                     THEN

c #WB                         dt_Bal = dt
C +              ******
c #WB       call H2O_WB(1,-1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******

                            norder_0 = nordps
C +              **********
            call DYNadv_LFB(norder_0)
C +              **********

C +              **********
c #DB       call Debugg_MAR('DYNadv_LFB')
C +              **********

c #WB                         dt_Bal = dt
C +              ******
c #WB       call H2O_WB(1, 1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******

        END IF


C +--Forward           Scheme
C +  ------------------------

        IF    (DYNadv.EQ.'UPW')                                     THEN

C +--Vertical Advection: (Thermo)Dynamics
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +              **********
            call DYNadv_ver
C +              **********

C +              **********
c #DB       call Debugg_MAR('DYNadv_ver')
C +              **********

C +--Vertical Advection: Water    Species
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

c #HY     IF (.not.micphy)                                        THEN

C +              ***********
            call DYNadv_verq
C +              ***********

C +              **********
c #DB       call Debugg_MAR('DYNadv_vrq')
C +              **********

c #HY     ELSE

C +              **********
c #HY       call HYDadv_ver
C +              **********

C +              **********
c #DB       call Debugg_MAR('HYDadv_ver')
C +              **********
C +
c #HY     END IF

C +--Vertical Advection: Tracers
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +              **********
c #TC       call TRCadv_ver
C +              **********

C +              **********
c #DB       call Debugg_MAR('TRCadv_ver')
C +              **********

C +--Horizontal Advection: Momentum
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            FirstC = .FALSE.
            qqmass = .FALSE.

C +              **********
            call DYNadv_hor(uairDY,opstDY,pstDYn,uairDY,vairDY)
C +              **********

C +              **********
            call DYNadv_hor(vairDY,opstDY,pstDYn,uairDY,vairDY)
C +              **********

C +--Horizontal Advection: (Thermo)dynamics
C +  ~~~~~~~~~~~~~~~~~~~~~ Water    Species
C +                        ~~~~~~~~~~~~~~~~
            FirstC = .true.
            qqmass = .true.

            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              dumy3D(i,j,k) = pktaDY(i,j,k)
            END DO
            END DO
            END DO

C +              **********
            call DYNadv_hor(dumy3D,opstDY,pstDYn,uairDY,vairDY)
C +              **********

            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              pktaDY(i,j,k) = dumy3D(i,j,k)
            END DO
            END DO
            END DO

            FirstC = .FALSE.

C +              **********
            call DYNadv_hor(  qvDY,opstDY,pstDYn,uairDY,vairDY)
C +              **********

c #HY       IF (micphy)                                           THEN

C +                **********
c #HY         call DYNadv_hor(ccniHY,opstDY,pstDYn,uairDY,vairDY)
C +                **********


C +                **********
c #HY         call DYNadv_hor(  qiHY,opstDY,pstDYn,uairDY,vairDY)
C +                **********


C +                **********
c #HY         call DYNadv_hor(  qsHY,opstDY,pstDYn,uairDY,vairDY)
C +                **********


C +                **********
c #HY         call DYNadv_hor(  qwHY,opstDY,pstDYn,uairDY,vairDY)
C +                **********


C +                **********
c #HY         call DYNadv_hor(  qrHY,opstDY,pstDYn,uairDY,vairDY)
C +                **********

c #HY       END IF

C +--Statistics
C +  ~~~~~~~~~~
C +              **********
c #DB       call Debugg_MAR('DYNadv_hor')
C +              **********

C +--Horizontal Advection: Saltating Snow
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +              **********
c #BS       call DYNadv_sal
C +              **********

C +--Horizontal Advection: Tracers
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

c #TC     IF    (mod(itexpe,jtAdvH).eq.0)                         THEN

c #TC       qqmass =.true.

C +              **********
c #TC       call TRCadv_hor
C +              **********

C +              **********
c #DB       call Debugg_MAR('TRCadv_hor')
C +              **********

C +--New Time Step
C +  ~~~~~~~~~~~~~
c #TC         cfladv =     epsi
c #TC       DO k=1,mz
c #TC       DO j=1,my
c #TC       DO i=1,mx
c #TC         cfladv = max(cfladv,abs(uairDY(i,j,k)))
c #TC         cfladv = max(cfladv,abs(vairDY(i,j,k)))
c #TC       END DO
c #TC       END DO
c #TC       END DO

c #TC         dtAdvH = demi   *dx/cfladv
c #TC         dtAdvH = min(dtAdvH,dt_ODE)
c #TC         dtAdvH = max(dtAdvH,dt    )

c #TC         jtAdvH =  dtAdvH / dt
C +...        jtAdvH :  Number of  Dynamical Steps for 1 Advection     Step

c #TC         dtAdvH =  dt * jtAdvH
C +...        dtAdvH :  Calibrated Advection       Time Step

c #TC         ntAdvH =   1

c #TC     END IF

        END IF


C +--Tracer Mass Verification (Advection)
C +  ------------------------------------

c #MV     IF    (jtAdvH.eq.1)                                     THEN
c #MV        totrac(2) = 0.
c #MV        tracmx(2) = 0.
c #MV       DO k=1,mz
c #MV       DO j=1,my
c #MV       DO i=1,mx
c #MV            totrac(2) = totrac(2)+qxTC(i,j,k,1)*pstDYn(i,j)
c #MV.                                              *dsigm1(k)
c #MV         IF(tracmx(2)        .lt. qxTC(i,j,k,1))             THEN
c #MV            tracmx(2) =           qxTC(i,j,k,1)
c #MV            itrcmx(2) =                  i
c #MV            jtrcmx(2) =                  j
c #MV            ktrcmx(2) =                  k
c #MV         END IF
c #MV       END DO
c #MV       END DO
c #MV       END DO
c #MV     END IF


C +--Dynamical Balance (Advection)
C +  -----------------------------

c #DY      ibd= 3
c #DY      tdt= 1.
c #DY     afdt= 1.

C +            ******
c #DY     call dynbil(tdt,afdt,jmez,ibd)
C +            ******


C +--Rayleigh Friction (Ref. ARPS 4.0 User's Guide, para 6.4.3 p.152)
C +  =================

c #RF DO k=1,mzabso
c #RF   DO j=1,my
c #RF   DO i=1,mx
c #RF     pktaDY(i,j,k)=(pktaDY(i,j,k) + Ray_UB(k)*dt    *pktaUB(i,j,k))
c #RF.                 /(1.0           + Ray_UB(k)*dt                  )
c #RF   END DO
c #RF   END DO
c #RF END DO


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END   of SLOW PROPAGATING WAVES DYNAMICS +++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      ELSE

           if(openmp) then
C +            ******
            call DYNgpo_mp
C +            ******
           else
C +            ******
            call DYNgpo
C +            ******
           endif


C +--Mid-Level Geopotential
C +  ----------------------

           k=1
        DO j=1,my
        DO i=1,mx
          gpmiDY(i,j,k) = 0.5 *(3.5*gplvDY(i,j,  1)-0.5d0*gplvDY(i,j,2))
        END DO
        END DO

        DO k=kp1(1),mz
        DO j=1,my
        DO i=1,mx
          gpmiDY(i,j,k) = 0.5 *(    gplvDY(i,j,k-1)+      gplvDY(i,j,k))
        END DO
        END DO
        END DO

           k=       mzz
        DO j=1,my
        DO i=1,mx
          gpmiDY(i,j,k) =(0.5 *     z__SBL         +          sh(i,j)  )
     .                  *           gravit
        END DO
        END DO

C +          **********
c #DB   call Debugg_MAR('DYNgpo    ')
C +          **********

      END IF


C +--Specific Mass
C +  =============

C +          ******
        call DYNrho
C +          ******

C +          **********
c #db   call Debugg_MAR('DYNrho    ')
C +          **********


C +--Saturation Specific Humidity
C +  ============================

C +          ******
        call qsat3D
C +          ******


C +--Vertical Velocity in Cartesian Coordinates
C +  ==========================================


C +                                 ******
c #CA IF (convec.and.mmx.gt.1) call DYNwww
C +                                 ******


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of MAR "SUBGRID ZONE" (INCLUDING CORIOLIS FORCE) +++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Tracer Mass Verification
C +  ========================

c #MV IF    (jtAdvH.eq.1)                                         THEN
c #MV        totrac(3) = 0.
c #MV        tracmx(3) = 0.
c #MV   DO k=1,mz
c #MV   DO j=1,my
c #MV   DO i=1,mx
c #MV        totrac(3) = totrac(3) +qxTC(i,j,k,1) *pstDYn(i,j)*dsigm1(k)
c #MV     IF(tracmx(3)         .lt. qxTC(i,j,k,1))                THEN
c #MV        tracmx(3) =            qxTC(i,j,k,1)
c #MV        itrcmx(3) =                 i
c #MV        jtrcmx(3) =                 j
c #MV        ktrcmx(3) =                 k
c #MV     END IF
c #MV   END DO
c #MV   END DO
c #MV   END DO
c #MV END IF


C +--Local Temporal Parameters
C +  =========================

      IF (log_1D.eq.0     .and.
     .    tequil.gt.0.)                                           THEN

C +--Boundary Layer Initialisation over time tequil
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       tequil = tequil*3600.
C +... Conversion [h]->[s]
       dt_Loc = dtquil
       nt_Loc = tequil/dtquil
       jt_Loc = 1
      ELSE

C +--Boundary Layer is iterated    over time dt
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       dt_Loc = dtDiff
       nt_Loc = ntDiff
       jt_Loc = jtDiff
c #OM  dt_Loc = dt
c #OM  nt_Loc = 1
c #OM  jt_Loc = 1
      END IF


C +--Begin of Subgrid Loop
C +  =====================

      IF (mod(itexpe,jt_Loc).eq.0)                                THEN

        DO it_Loc= 1,nt_Loc 


C +--Coriolis Force Contribution (Implicit Scheme)
C +  ---------------------------------------------

          DO i=1,mx
          DO j=1,my
          DO k=1,mz
            uairDY(i,j,k) = uairDY(i,j,k) 
     .       + fcorDY(i,j)*(vairDY(i,j,k)-vgeoDY(i,j,k)) *dt_Loc
            vairDY(i,j,k) = vairDY(i,j,k) 
     .       - fcorDY(i,j)*(uairDY(i,j,k)-ugeoDY(i,j,k)) *dt_Loc
          END DO
          END DO
          END DO

C +--Dynamical Balance (Coriolis Force)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #DY      ibd= 4
c #DY      tdt= 1.
c #DY     afdt= 0.

C +            ******
c #DY     call dynbil(tdt,afdt,jmez,ibd)
C +            ******


C +--Horizontal Subgrid Processes
C +  ----------------------------

          IF (turhor      .and. 
     .        log_1D.eq.1 .and.
     .        mmx   .gt.1)                                        THEN 

c #WB                         dt_Bal = dt_Loc
C +              ******
c #WB       call H2O_WB(2,-1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******

C +--Horizontal Diffusion Coefficient
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +              *********
            call TURhor_kh 
C +              *********

C +              **********
c #db       call Debugg_MAR('TURhor_kh ')
C +              **********

C +--Contribution of Horizontal Diffusion
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +              **********
            call TURhor_dyn(dtDifH) 
C +              **********

C +              **********
c #DB       call Debugg_MAR('TURhor_dyn')
C +              **********

c #WB                         dt_Bal = dt_Loc
C +              ******
c #WB       call H2O_WB(2, 1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******

          END IF 


C +--Water Vapor and Precipitation Loading
C +  -------------------------------------

C +            ******
          call DYNloa
C +            ******

C +            **********
c #db     call Debugg_MAR('DYNloa    ')
C +            **********


C +--Vertical   Subgrid Processes
C +  ----------------------------

          IF  (dtDiff.gt.0.)                                      THEN 

C +--Turbulent Kinetic Energy
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
            IF (jt_Loc.gt.1)                                      THEN
                dtLLoc =  min(dt_Loc,dtAdvH)
                dtLLoc =  min(dtLLoc,dtDifH)
C +...          CAUTION:             dtDifH computed in TURhor_dyn

                dtLLoc =  max(dtLLoc,dt    )
                ntLLoc =      dt_Loc/dtLLoc
                ntLLoc =  max(ntLLoc,iun   )
                dtLLoc =      dt_Loc/ntLLoc
            ELSE
                dtLLoc =      dt_Loc
                ntLLoc =           1
            END IF

            DO  itLLoc =           1,ntLLoc

c #BR       IF (tur_25)                                           THEN

C +               *********
c #BR        call TURpbl_25(dtLLoc)
C +               *********

C +               **********
c #DB        call Debugg_MAR('TURpbl_25 ')
C +               **********

c #BR       ELSE

C +                         ****************
              IF (mmx.gt.1) call TURtke_advh(dtLLoc)
              IF (mmx.gt.1) call TURtke_advv(dtLLoc)
              IF (mmx.gt.1) call TURtke_difh(dtLLoc)
                            call TURtke_difv(dtLLoc,0.)
                            call TURtke_gen (dtLLoc)
C +                         ***************

C +               **********
c #DB        call Debugg_MAR('TURtke Cie')
C +               **********

c #BR       END IF

            END DO

C +--Surface Layer
C +  ~~~~~~~~~~~~~
c #FR       IF (VSISVAT)                                          THEN

              DO k=1,mz
              DO j=1,my
              DO i=1,mx
                ssvSL(i,j,k) = sqrt(max(uairDY(i,j,k)*uairDY(i,j,k)
     .                                 +vairDY(i,j,k)*vairDY(i,j,k)
     .                                 ,epsi))
              END DO
              END DO
              END DO

c #FR       ELSE

C +                ******
c #FR         call TURsbl
C +                ******

C +                **********
c #db         call Debugg_MAR('TURsbl    ')
C +                **********

c #FR       END IF

C +--Mass Flux convective Scheme
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #WB                           dt_Bal = dt_Loc
C +                ******
c #WB         call H2O_WB(3,-1.,dt_Bal,.FALSE.,.FALSE.)
C +                ******

              itConv = itexpe*nt_Loc/jt_Loc+it_Loc

            IF (convec)                                             THEN

C +                ******
              call CVAorg
C +                ******

C +                **********
c #DB         call Debugg_MAR('CVAorg    ')
C +                **********

            END IF

c #WB                           dt_Bal = dt_Loc
C +                ******
c #WB         call H2O_WB(3, 1.,dt_Bal,.FALSE.,.FALSE.)
C +                ******

C +--Contribution of Turbulent Vertical Diffusion
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #OL       IF (TURver)                                             THEN
c #WB                           dt_Bal = dt_Loc
C +                ******
c #WB         call H2O_WB(4,-1.,dt_Bal,.FALSE.,.FALSE.)
C +                ******

C +                ******
              call TURabl
c #SY         call SSpray
C +                ******

C +                **********
c #DB         call Debugg_MAR('TURabl    ')
C +                **********

c #WB                           dt_Bal = dt_Loc
C +                ******
c #WB         call H2O_WB(4, 1.,dt_Bal,.FALSE.,.FALSE.)
C +                ******

C +--Contribution of Turbulent Vertical Diffusion (Non Hydrostatic Variables)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +                ******
c #NH         call TURvNH
C +                ******

C +                **********
c #db         call Debugg_MAR('TURvNH    ')
C +                **********

c #OL       END IF

          END IF 


C +--Dynamical Balance (Subgrids)
C +  ----------------------------

c #DY      ibd= 2
c #DY      tdt= 0.
c #DY     afdt= 1.

C +            ******
c #DY     call dynbil(tdt,afdt,jmez,ibd)
C +            ******

        END DO 

      END IF


C +--Tracers Turbulent Transfert 
C +  ===========================

c #TC IF             (dt_ODE .ne.dtDiff)                          THEN

c #TC   IF(mod(itexpe,jt_ODE).eq.0)                               THEN
c #TC          dt_Loc=dt_ODE
c #TC          nt_Loc=nt_ODE
c #TC     DO   it_Loc=1,nt_Loc

C +              *********
c #TC       call TURabl_TC
C +              *********

c #TC     END DO
c #TC   END IF

C +              **********
c #db       call Debugg_MAR('TURabl_TC ')
C +              **********

c #TC END IF


C +--Tracer Mass Verification
C +  ========================

c #MV IF  (mod(itexpe,jt_ODE).eq.0)                               THEN
c #MV      totrac(4) = 0.
c #MV      tracmx(4) = 0.
c #MV   DO k=1,mz
c #MV   DO j=1,my
c #MV   DO i=1,mx
c #MV      totrac(4) = totrac(4) + qxTC(i,j,k,1) *pstDYn(i,j) *dsigm1(k)
c #MV   IF(tracmx(4)          .lt. qxTC(i,j,k,1))                 THEN
c #MV      tracmx(4) =             qxTC(i,j,k,1)
c #MV      itrcmx(4) =                  i
c #MV      jtrcmx(4) =                  j
c #MV      ktrcmx(4) =                  k
c #MV   END IF
c #MV   END DO
c #MV   END DO
c #MV   END DO
c #MV END IF


C +--OUTPUT
C +  ------

c #MV  write(6,133)iterun,(latrac(n),totrac(n),tracmx(n),
c #MV.                     itrcmx(n),jtrcmx(n),ktrcmx(n),n=1,4)
 133   format(i8,3x,a15,2d15.6,3i6,4(/,11x,a15,2d15.6,3i6))


C +--Initialized Temperature Vertical Profiles
C +  =========================================

C +   ----------------------------------
      IF (IO_loc.ge.2 .and. log_1D.eq.0)                          THEN
C +   ----------------------------------

        DO i=1,5
            tta(i) = tsrfSL(igrdIO(i),jgrdIO(i),1)-TfSnow
        END DO
            write(21,607) (igrdIO(i),jgrdIO(i),       i=1,5),
     .                 (sh(igrdIO(i),jgrdIO(i)),tta(i),i=1,5)
        DO kk=1,mz
           k=mzz-kk
          DO i=1,5
            zza(i) =       gplvDY(igrdIO(i),jgrdIO(i),k)*grvinv
            tta(i) =       pktaDY(igrdIO(i),jgrdIO(i),k)*pcap
          END DO
            write(21,609)(zza(i),tta(i),i=1,5)
        END DO
            write(21,611)

C +   ------
      END IF
C +   ------

      log_1D  = 1
C +...log_1D  = 1 <==> PBL initialisation is performed


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END   of MAR "SUBGRID ZONE" (INCLUDING CORIOLIS FORCE) +++++++++++++++
C +++ EXPLICIT HYDROLOGICAL CYCLE  +++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Cloud Microphysical Processes
C +  =============================

c #HY IF (micphy)                                              THEN 

c #WB                     dt_Bal = dt
C +          ******
c #WB   call H2O_WB(5,-1.,dt_Bal,.FALSE.,.FALSE.)
C +          ******

C +          ******
c #HY   call HYDgen
C +          ******

C +          **********
c #DB   call Debugg_MAR('HYDgen    ')
C +          **********

c #WB                     dt_Bal = dt
C +          ******
c #WB   call H2O_WB(5, 1.,dt_Bal,.FALSE.,.FALSE.)
C +          ******

c #HY ELSE


C +--Elimination of Water Vapor in Excess
C +  ====================================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          qvDY(i,j,k)=max(zero         ,qvDY(i,j,k))
          qvDY(i,j,k)=min(qvswDY(i,j,k),qvDY(i,j,k))
        END DO
        END DO
        END DO

c #HY END IF 


C +--Dust  Microphysical Processes
C +  =============================

C +                    ****
c #BD IF (BloMod) call DUST
C +                    ****


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ CHEMICAL PROCESSES +++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


c #CH IF (chimod)                                                 THEN

C +                                        **********
c #CH   IF (    itexpe        .eq.0)  call CHImie_INI
C +                                        **********

C +            **********
c #db     call Debugg_MAR('CHImie_INI')
C +            **********

c #CH                                                 iteChi = itexpe
C +
C +                                        **********
c #CH   IF (mod(iteChi,jt_ODE).eq.0)  call CHImie_ODE(iteChi)
C +                                        **********
c #CH END IF 


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ BEGIN of LATERAL BOUNDARY CONDITIONS and FILTERING +++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Modification of the External Forcing
C +  ====================================

      IF  (mmx           .gt.1     )                              THEN

C +--LBC are provided by a Large Scale (3-D) Model
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF (reaLBC)                                               THEN

C +            ******
          call INIlbc(ihamr,nhamr,newlbc_0)
c #RF     call INIubc(ihamr,nhamr,newlbc_0)
C +            ******

C +            **********
c #db     call Debugg_MAR('INIlbc    ')
C +            **********

C +                               **********
c #DA     IF (newlbc_0.eq.1) call LBCnud_par
C +                               **********

C +            **********
c #db     call Debugg_MAR('LBCnud_par')
C +            **********

C +--LBC are provided by one Sounding (Horizontal Homogeneity is assumed)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE

C +            ******
          call INIsnd
C +            ******

C +            **********
c #db     call Debugg_MAR('INIsnd    ')
C +            **********

C +            **********
c #DA     call LBCnud_par
C +            **********

C +            **********
c #db     call Debugg_MAR('LBCnud_par')
C +            **********

        END IF


C +--Lateral Boundary Conditions  for Mass Continuity p*
C +  ("Nudging" Type / Davies, QJRMS, 1976, pp.405--418)
C +    ("Open" Lateral Boundary Condition is possible)
C +  ===================================================


          ksig = 1

          iv   = 5

c #RB   IF (sommlb)                                               THEN

c #RB     IF (mmx.gt.1)                                           THEN
c #RB       DO j=1,my
c #RB           fu( 1,j) = 0.
c #RB           fu(mx,j) = 0.
c #RB         DO k=1,mz
c #RB           fu( 1,j) = fu( 1,j) + dsigm1(k)*uairDY( 1,j,k)
c #RB           fu(mx,j) = fu(mx,j) + dsigm1(k)*uairDY(mx,j,k)
c #RB         END DO
c #RB       END DO
c #RB     END IF

c #RB     IF (mmy.gt.1)                                           THEN
c #RB       DO i=1,mx
c #RB           fv(i, 1) = 0.
c #RB           fv(i,my) = 0.
c #RB         DO k=1,mz
c #RB           fv(i, 1) = fv(i, 1) + dsigm1(k)*vairDY(i, 1,k)
c #RB           fv(i,my) = fv(i,my) + dsigm1(k)*vairDY(i,my,k)
c #RB         END DO
c #RB       END DO
c #RB     END IF

C +            **********
c #RB     call LBCrad_atm(pstDYn,fu,fv,iv,ksig)
C +            **********

C +            **********
c #DB     call Debugg_MAR('LBCrad p* ')
C +            **********

c #RB   ELSE

          DO j=1,my
          DO i=1,mx
            dumy3D(i,j,1)=pstDYn(i,j)
          END DO
          END DO
C +
C +            **********
          call LBCnud_atm(dumy3D,iv,ksig)
C +            **********
C +
          DO j=1,my
          DO i=1,mx
            pstDYn(i,j) = dumy3D(i,j,1)
          END DO
          END DO

C +            **********
c #db     call Debugg_MAR('LBCnud p* ')
C +            **********

c #RB   END IF


C +--START of:
C +--Lateral Boundary Conditions  for Wind, Temperature, Specific Humidity
C +  ("Nudging" Type / Davies, QJRMS, 1976, pp.405--418)
C +  =====================================================================


c #WB                         dt_Bal = dt
C +              ******
c #WB       call H2O_WB(6,-1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******


C +--Radiative Lateral Boundary Conditions: Auxiliary Variables
C +  ==========================================================

            kdim=mz

c #RB   DO   k=1,mz
c #RB     DO j=1,my
c #RB     DO i=1,mx
c #RB       dumy3U(i,j,k) = uairDY(i,j,k)
c #RB       dumy3V(i,j,k) = vairDY(i,j,k)
c #RB     END DO
c #RB     END DO
c #RB   END DO


C +--Lateral Boundary Conditions and Horizontal Filter
C +  =================================================

C +--Wind x-Direction
C +  ----------------

             iv = 1

C +--Dummy Variable
C +  ~~~~~~~~~~~~~~
        DO   k=1,mz 
          DO j=1,my
          DO i=1,mx
            dumy3D(i,j,k) = uairDY(i,j,k)
          END DO
          END DO
        END DO

C +--Radiating LBC
C +  ~~~~~~~~~~~~~
c #RB   IF (sommlb)                                               THEN
C +
C +              **********
c #RB       call LBCrad_atm(dumy3D,dumy3U,dumy3V,iv,kdim)
C +              **********

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
c #RB   ELSE

C +              **********
            call LBCnud_atm(dumy3D,iv,kdim)
C +              **********

C +              **********
c #ob       call LBC000_run(dumy3D,   kdim)
C +              **********

c #RB   END IF

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
        IF   (FIk_fu(1).gt.0.0)                                   THEN 
            DO  k=1,mz 
              dumeps(    k) = FIk_fu(    k)
            END DO
              kdim          =            mz

          IF (mmy.le.1)                                           THEN 
c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

C +                *********
              call DYNfil_1D (dumy3D,dumeps,kdim)
C +                *********

c #OB       END IF

          ELSE 
c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

c #NV         IF (no_vec)                                         THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV         ELSE

C +                  *********
                call DYNfilv3D (dumy3D,dumeps,kdim)
C +                  *********

c #NV         END IF

c #OB       END IF
          END IF 
        END IF 

C +--Update
C +  ~~~~~~
        DO   k=1,mz 
          DO j=1,my
          DO i=1,mx
            uairDY(i,j,k)  =  dumy3D(i,j,k)
          END DO
          END DO
        END DO


C +--Wind y-Direction
C +  ----------------

             iv = 2

        DO   k=1,mz 
          DO j=1,my
          DO i=1,mx
            dumy3D(i,j,k) = vairDY(i,j,k)
          END DO
          END DO
        END DO

C +--Radiating LBC
C +  ~~~~~~~~~~~~~
c #RB   IF (sommlb)                                               THEN

C +              **********
c #RB       call LBCrad_atm(dumy3D,dumy3U,dumy3V,iv,kdim)
C +              **********

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
c #RB   ELSE

C +              **********
            call LBCnud_atm(dumy3D,iv,kdim)
C +              **********

C +              **********
c #ob       call LBC000_run(dumy3D,   kdim)
C +              **********

c #RB   END IF

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
        IF   (FIk_fu(1).gt.0.0)                                   THEN 
          IF (mmy.le.1)                                           THEN 
            DO k=1,mz 
              dumeps(    k) = FIk_su(    k)
            END DO
              kdim          =            mz

c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

C +                *********
              call DYNfil_1D (dumy3D,dumeps,kdim)
C +                *********

c #OB       END IF

          ELSE 
            DO k=1,mz 
              dumeps(    k) = FIk_fu(    k)
            END DO
              kdim          =            mz

c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

c #NV         IF (no_vec)                                         THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV         ELSE

C +                  *********
                call DYNfilv3D (dumy3D,dumeps,kdim)
C +                  *********

c #NV         END IF

c #OB       END IF
          END IF 
        END IF 

        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
            vairDY(i,j,k)  =  dumy3D(i,j,k)
          END DO
          END DO
        END DO


C +--Specific Humidity
C +  -----------------

             iv = 3

        DO   k=1,mz 
          DO j=1,my
          DO i=1,mx
            dumy3D(i,j,k) =   qvDY(i,j,k)
          END DO
          END DO
        END DO

C +--Water Mass
C +  ~~~~~~~~~~
C +              ******
            call DYNqqm(dumy3D,'BAK','FIL_Qv')
C +              ******

C +--Radiating LBC
C +  ~~~~~~~~~~~~~
c #RB   IF (sommlb)                                               THEN

C +              **********
c #RB       call LBCrad_atm(dumy3D,dumy3U,dumy3V,iv,kdim)
C +              **********

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
c #RB   ELSE

C +              **********
            call LBCnud_atm(dumy3D,iv,kdim)
C +              **********

C +              **********
c #ob       call LBC000_run(dumy3D,   kdim)
C +              **********

c #RB   END IF

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
        IF   (FIk_st(1).gt.0.0)                                   THEN 
            DO k=1,mz 
              dumeps(    k) = FIslot
c #KQ         dumeps(    k) = FIk_st(    k)
            END DO
              kdim          =            mz

          IF (mmy.le.1)                                           THEN 
c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

C +                *********
              call DYNfil_1D (dumy3D,dumeps,kdim)
C +                *********

c #OB       END IF

          ELSE 
c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

c #NV         IF (no_vec)                                         THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV         ELSE

C +                  *********
                call DYNfilv3D (dumy3D,dumeps,kdim)
C +                  *********

c #NV         END IF

c #OB       END IF
          END IF 
        END IF 

        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
            dumy3Q(i,j,k)=max(dumy3D(i,j,k),epsq)
          END DO
          END DO
        END DO

C +--Restore the Water Vapor total Mass
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +              ******
            call DYNqqm(dumy3Q,'SET','FIL_Qv')
C +              ******

        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
              qvDY(i,j,k) =   dumy3Q(i,j,k)
          END DO
          END DO
        END DO


C +--Potential Temperature
C +  ---------------------

             iv = 4

        DO   k=1,mz 
          DO j=1,my
          DO i=1,mx
            dumy3D(i,j,k) = pktaDY(i,j,k)
          END DO
          END DO
        END DO

C +--Radiating LBC
C +  ~~~~~~~~~~~~~
c #RB   IF (sommlb)                                               THEN

C +              **********
c #RB       call LBCrad_atm(dumy3D,dumy3U,dumy3V,iv,kdim)
C +              **********

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
c #RB   ELSE

C +              **********
            call LBCnud_atm(dumy3D,iv,kdim)
C +              **********

C +              **********
c #ob       call LBC000_run(dumy3D,   kdim)
C +              **********

c #RB   END IF
C +
C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
        IF   (FIk_st(1).gt.0.0)                                   THEN 
            DO k=1,mz 
              dumeps(    k) = FIk_st(    k)
            END DO
              kdim          =            mz

          IF (mmy.le.1)                                           THEN 
c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

C +                *********
              call DYNfil_1D (dumy3D,dumeps,kdim)
C +                *********

c #OB       END IF

          ELSE 
c #OB       IF (openLB)                                           THEN

C +                **********
c #OB         call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                **********

c #OB       ELSE

c #NV         IF (no_vec)                                         THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV         ELSE

C +                  *********
                call DYNfilv3D (dumy3D,dumeps,kdim)
C +                  *********

c #NV         END IF

c #OB       END IF
          END IF 
        END IF 

        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
            pktaDY(i,j,k)  =  dumy3D(i,j,k)
          END DO
          END DO
        END DO


C +--TKE (Filtering only)
C +  --------------------

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
c #FE   IF   (FIk_st(1).gt.0.0)                                   THEN 
c #FE       DO k=1,mz
c #FE       DO j=1,my
c #FE       DO i=1,mx
c #FE         dumy3D(i,j,k) = ect_TE(i,j,k)
c #FE       END DO
c #FE       END DO
c #FE       END DO

c #FE       DO k=1,mz 
c #FE         dumeps(    k) = FIk_st(    k)
c #FE       END DO
c #FE         kdim          =            mz

c #FE     IF (mmy.le.1)                                           THEN 
c #FO       IF (openLB)                                           THEN

C +                **********
c #FO         call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                **********

c #FO       ELSE

C +                *********
c #FE         call DYNfil_1D(dumy3D,dumeps,kdim)
C +                *********

c #FO       END IF

c #FE     ELSE 
c #FO       IF (openLB)                                           THEN

C +                **********
c #FO         call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                **********

c #FO       ELSE

c #fe         IF (no_vec)                                         THEN

c #fe               if(openmp) then
C +                      **********
c #fe               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #fe               else
C +                      **********
c #fe               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #fe               endif

c #fe         ELSE

C +                  *********
c #FE           call DYNfilv3D (dumy3D,dumeps,kdim)
C +                  *********

c #fe         END IF

c #FO       END IF
c #FE     END IF 
c #FE   END IF 

c #FE   DO   k=1,mz
c #FE     DO j=1,my
c #FE     DO i=1,mx
c #FE       ectnew        = max(epsi  ,dumy3D(i,j,k))
c #FE       tranTE(i,j,k) =    (ectnew-ect_TE(i,j,k)) * dt_inv 
c #FE.    + tranTE(i,j,k)
c #FE       ect_TE(i,j,k) =     ectnew
c #FE     END DO
c #FE     END DO
c #FE   END DO


C +--Statistics
C +  ----------

C +          **********
c #DB   call Debugg_MAR('LBC u,v,..')
C +          **********


C +--Lateral Boundary Conditions and Horizontal Filter (Microphysics)
C +  ================================================================

        IF (iterun.eq.0)                                          THEN
              FIsloQ = FIslot
        END IF

        IF   (micphy)                                             THEN


C +--Filter Parameter, H2O Variables
C +  -------------------------------

c #HY         DO k = 1,mz
c #HY           dumeps(k)     = FIsloQ
c #HY         END DO
c #HY           kdim          = mz


C +--Cloud Ice Crystals Number
C +  -------------------------

c #HY          iv   = 3
c #HY          kdim = mz
C +
c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3D(i,j,k) = ccniHY(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Water Mass
C +  ~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3D,'BAK','FIL_CN')
C +                ******

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
C +                **********
c #HY         call LBCnud_000(dumy3D,iv,kdim)
C +                **********

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
c #HY     IF     (FIsloQ   .gt.0.0)                               THEN 
c #HY       IF   (mmy.le.1)                                       THEN 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

C +                  *********
c #HY           call DYNfil_1D (dumy3D,dumeps,kdim)
C +                  *********

c #HO         END IF

c #HY       ELSE 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

c #hy           IF (no_vec)                                       THEN

c #hy               if(openmp) then
C +                      **********
c #hy               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #hy               else
C +                      **********
c #hy               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #hy               endif

c #hy           ELSE

C +                    *********
c #HY             call DYNfilv3D (dumy3D,dumeps,kdim)
C +                    *********

c #hy           END IF

c #HO         END IF
c #HY       END IF 
c #HY     END IF 

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3Q(i,j,k) = max(dumy3D(i,j,k),zero)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Restore the Hydrometeor total Mass
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3Q,'SET','FIL_CN')
C +                ******

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         ccniHY(i,j,k)=      dumy3Q(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO


C +--Cloud Ice Crystals Concentration
C +  --------------------------------

c #HY          iv   = 3
c #HY          kdim = mz

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3D(i,j,k) =   qiHY(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Water Mass
C +  ~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3D,'BAK','FIL_Qi')
C +                ******

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
C +                **********
c #HY         call LBCnud_000(dumy3D,iv,kdim)
C +                **********

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
c #HY     IF     (FIsloQ   .gt.0.0)                               THEN 
c #HY       IF   (mmy.le.1)                                       THEN 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

C +                  *********
c #HY           call DYNfil_1D (dumy3D,dumeps,kdim)
C +                  *********

c #HO         END IF

c #HY       ELSE 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

c #hy           IF (no_vec)                                       THEN

c #hy               if(openmp) then
C +                      **********
c #hy               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #hy               else
C +                      **********
c #hy               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #hy               endif

c #hy           ELSE

C +                    *********
c #HY             call DYNfilv3D (dumy3D,dumeps,kdim)
C +                    *********

c #hy           END IF

c #HO         END IF
c #HY       END IF 
c #HY     END IF 

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3Q(i,j,k)=max(dumy3D(i,j,k),zero)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Restore the Hydrometeor total Mass
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3Q,'SET','FIL_Qi')
C +                ******

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY           qiHY(i,j,k)=    dumy3Q(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO


C +--Snow     Flakes
C +  ---------------

c #HY          iv   = 3
c #HY          kdim = mz

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3D(i,j,k) =   qsHY(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Water Mass
C +  ~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3D,'BAK','FIL_Qs')
C +                ******

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
C +                **********
c #HY         call LBCnud_000(dumy3D,iv,kdim)
C +                **********

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
c #HY     IF     (FIsloQ   .gt.0.0)                               THEN 
c #HY       IF   (mmy.le.1)                                       THEN 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

C +                  *********
c #HY           call DYNfil_1D (dumy3D,dumeps,kdim)
C +                  *********

c #HO         END IF

c #HY       ELSE 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

c #hy           IF (no_vec)                                       THEN

c #hy               if(openmp) then
C +                      **********
c #hy               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #hy               else
C +                      **********
c #hy               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #hy               endif
C +
c #hy           ELSE

C +                   **********
c #HY             call DYNfilv3D (dumy3D,dumeps,kdim)
C +                    *********

c #hy           END IF

c #HO         END IF
c #HY       END IF 
c #HY     END IF 

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3Q(i,j,k)=max(dumy3D(i,j,k),zero)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Restore the Hydrometeor total Mass
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3Q,'SET','FIL_Qs')
C +                ******

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY           qsHY(i,j,k)=    dumy3Q(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO


C +--Cloud    Droplets
C +  -----------------

c #HY          iv   = 3
c #HY          kdim = mz

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3D(i,j,k) =   qwHY(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Water Mass
C +  ~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3D,'BAK','FIL_Qw')
C +                ******

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
C +                **********
c #HY         call LBCnud_000(dumy3D,iv,kdim)
C +                **********

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
c #HY     IF     (FIsloQ   .gt.0.0)                               THEN 
c #HY       IF   (mmy.le.1)                                       THEN 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

C +                  *********
c #HY           call DYNfil_1D (dumy3D,dumeps,kdim)
C +                  *********

c #HO         END IF

c #HY       ELSE 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

c #hy           IF (no_vec)                                       THEN

c #hy               if(openmp) then
C +                      **********
c #hy               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #hy               else
C +                      **********
c #hy               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #hy               endif

c #hy           ELSE

C +                    *********
c #HY             call DYNfilv3D (dumy3D,dumeps,kdim)
C +                    *********

c #hy           END IF

c #HO         END IF
c #HY       END IF 
c #HY     END IF 

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3Q(i,j,k)=max(dumy3D(i,j,k),zero)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Restore the Hydrometeor total Mass
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3Q,'SET','FIL_Qw')
C +                ******

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY           qwHY(i,j,k) =   dumy3Q(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO


C +--Rain     Drops
C +  --------------

c #HY          iv   = 3
c #HY          kdim = mz

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3D(i,j,k) =     qrHY(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Water Mass
C +  ~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3D,'BAK','FIL_Qr')
C +                ******

C +--Nudging   LBC
C +  ~~~~~~~~~~~~~
C +                  **********
c #HY           call LBCnud_000(dumy3D,iv    ,kdim)
C +                  **********

C +--Horizontal Filter
C +  ~~~~~~~~~~~~~~~~~
c #HY     IF     (FIsloQ   .gt.0.0)                               THEN 
c #HY       IF   (mmy.le.1)                                       THEN 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_1D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

C +                  *********
c #HY           call DYNfil_1D (dumy3D,dumeps,kdim)
C +                  *********

c #HO         END IF

c #HY       ELSE 
c #HO         IF (openLB)                                         THEN

C +                  **********
c #HO           call DYNfil_3D0(dumy3D,dumeps,kdim)
C +                  **********

c #HO         ELSE

c #hy           IF (no_vec)                                       THEN

c #hy               if(openmp) then
C +                      **********
c #hy               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #hy               else
C +                      **********
c #hy               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #hy               endif

c #hy           ELSE

C +                    *********
c #HY             call DYNfilv3D (dumy3D,dumeps,kdim)
C +                    *********

c #hy           END IF

c #HO         END IF
c #HY       END IF 
c #HY     END IF 

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY         dumy3Q(i,j,k)=max(dumy3D(i,j,k),zero)
c #HY       END DO
c #HY       END DO
c #HY     END DO

C +--Restore the Hydrometeor total Mass
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +                ******
c #HY         call DYNqqm(dumy3Q,'SET','FIL_Qr')
C +                ******

c #HY     DO   k=1,mz
c #HY       DO j=1,my
c #HY       DO i=1,mx
c #HY           qrHY(i,j,k)=    dumy3Q(i,j,k)
c #HY       END DO
c #HY       END DO
c #HY     END DO


C +--Statistics
C +  ----------

c #WB                         dt_Bal = dt
C +              ******
c #WB       call H2O_WB(6, 1.,dt_Bal,.FALSE.,.FALSE.)
C +              ******

        END IF 

C +          **********
c #DB   call Debugg_MAR('DYNfil qHY')
C +          **********


C +--Filtering  of Tracer        Variables
C +  =====================================

        IF    (ntracr.gt.0)                                       THEN
c #TC   DO n=1,ntrac


C +--Mass
C +  ----

c #TC     DO   k=1,mz 
c #TC         sumv(      k) =   0.0
c #TC         dumeps(    k) =   FIsloQ
c #TC       DO j=1,my
c #TC       DO i=1,mx
c #TC         sumv(      k) =   qxTC(i,j,k,n)*pstDYn(i,j) + sumv(k)
c #TC         dumy3D(i,j,k) =   qxTC(i,j,k,n)
c #TC       END DO
c #TC       END DO
c #TC     END DO


C +--Filtering (2D)
C +  --------------

c #TC     IF   (mmy.le.1)                                         THEN 
c #TO       IF (openLB)                                           THEN

C +           ***************
c #TO         call DYNfil_1D0(dumy3D,dumeps,kdim)
C +           ***************

c #TO       ELSE

C +           **************
c #TC         call DYNfil_1D (dumy3D,dumeps,kdim)
C +           **************

c #TO       END IF


C +--Filtering (3D)
C +  --------------

c #TC     ELSE 
c #TO       IF (openLB)                                           THEN

C +           ***************
c #TO         call DYNfil_3D0(dumy3D,dumeps,kdim)
C +           ***************

c #TO       ELSE

c #tc           IF (no_vec)                                       THEN

c #tc               if(openmp) then
C +                      **********
c #tc               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #tc               else
C +                      **********
c #tc               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #tc               endif

c #tc           ELSE

C +               **************
c #TC             call DYNfilv3D (dumy3D,dumeps,kdim)
C +               **************

c #tc           END IF

c #TO       END IF
c #TC     END IF 


C +--Restore Mass
C +  ------------

c #TC     DO   k=1,mz 
c #TC         sumvn   =   0.0
c #TC       DO j=1,my
c #TC       DO i=1,mx
c #TC                     qxTC(i,j,k,n) = max(zero,dumy3D(i,j,k))
c #TC         sumvn   =   qxTC(i,j,k,n) * pstDYn(i,j)  +  sumvn
c #TC       END DO
c #TC       END DO

c #TC       IF (sumvn.gt.0.0)                                     THEN
c #TC           sumvn = sumv(k) / sumvn
c #TC         DO j=1,my
c #TC         DO i=1,mx
c #TC                     qxTC(i,j,k,n) = qxTC(i,j,k,n) * sumvn
c #TC         END DO
c #TC         END DO
c #TC       ELSE
c #TC         DO j=1,my
c #TC         DO i=1,mx
c #TC                     qxTC(i,j,k,n) = 0.0
c #TC         END DO
c #TC         END DO
c #TC       END IF

c #TC     END DO

c #TC   END DO
        END IF 

C +          **********
c #db   call Debugg_MAR('DYNfil qx ')
C +          **********

      END IF 


C +--Horizontal Dynamical Balance (Filtering)           
C +  ========================================

c #DY  ibd= 6
c #DY afdt= 1.0

C +        ******
c #DY call dynbil(tdt,afdt,jmez,ibd)
C +        ******


C +--HAMMING Filter performs the Diabatic Initialisation
C +  = Lynch and Huang 1992, Huang and Lynch 1993, MWR =
C +   =================================================

c #HF IF (hamfil)                                                 THEN

c #HF   IF (itexpe.eq.0.and.iham.eq.-nham)                        THEN
c #HF       jham    =  -iham

c #HF     DO j=1,my
c #HF     DO i=1,mx
c #HF       pnnham(i,j)   = pstDYn (i,j)
c #HF     END DO
c #HF     END DO

c #HF     DO k=1,mz
c #HF     DO j=1,my
c #HF     DO i=1,mx
c #HF       uuuham(i,j,k) = uairDY(i,j,k)
c #HF       vvvham(i,j,k) = vairDY(i,j,k)
c #HF       pktham(i,j,k) = pktaDY(i,j,k)
c #HF       qvaham(i,j,k) =   qvDY(i,j,k)
c #HF     END DO
c #HF     END DO
c #HF     END DO
c #HF   END IF

c #HF   IF (itexpe.eq.0.and.iham.le. nham.and.iham.ne.0)          THEN
c #HF       argham  =      jham*fham
c #HF       hhhnnn  = (sin(jham*thac)/(jham*pi))*sin(argham)/argham

c #HF     DO j=1,my
c #HF     DO i=1,mx
c #HF       pnnham(i,j)   = pstDYn (i,j)  *hhhnnn + pnnham(i,j)
c #HF     END DO
c #HF     END DO

c #HF     DO k=1,mz
c #HF     DO j=1,my
c #HF     DO i=1,mx
c #HF       uuuham(i,j,k) = uairDY(i,j,k)*hhhnnn + uuuham(i,j,k)
c #HF       vvvham(i,j,k) = vairDY(i,j,k)*hhhnnn + vvvham(i,j,k)
c #HF       pktham(i,j,k) = pktaDY(i,j,k)*hhhnnn + pktham(i,j,k)
c #HF       qvaham(i,j,k) =   qvDY(i,j,k)*hhhnnn + qvaham(i,j,k)
c #HF     END DO
c #HF     END DO
c #HF     END DO
c #HF   END IF

c #HF   IF (itexpe.eq.0.and.iham.eq.nham)                         THEN

c #HF     write(21,1560)
 1560     format(/,'   --- Initialisation / END Hamming Filter ---',/)
c #HF     DO j=1,my
c #HF     DO i=1,mx
c #HF       pstDY  (i,j)  = pnnham(i,j)
c #HF       pstDYn (i,j)  = pnnham(i,j)
c #HF       pstDY1 (i,j)  = pnnham(i,j)
c #HF     END DO
c #HF     END DO

c #HF     DO k=1,mz
c #HF     DO j=1,my
c #HF     DO i=1,mx
c #HF       uairDY(i,j,k) =                     uuuham(i,j,k)
c #HF       vairDY(i,j,k) =                     vvvham(i,j,k)
c #HF       pktaDY(i,j,k) =                     pktham(i,j,k)
c #HF         qvDY(i,j,k) =                     qvaham(i,j,k)
c #HF     END DO
c #HF     END DO
c #HF     END DO

c #HF       ihamr  =      0
c #HF       nhamr  =      0
c #HF       itexpe =   nham

c #HF   END IF

c #HF   IF (iham.gt.nham)                                    GO TO 151
c #HF     iham   = 1+iham
c #HF     ihamr  =   iham
c #HF                                                        GO TO 150
 151    CONTINUE

c #HF END IF


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END   of DIABATIC INITIALISATION +++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Global Correction for p* 
C +  ========================

C +        **********
c #PS call DYNdps_cor(pav)
C +        **********

C +        **********
c #db call Debugg_MAR('DYNdps_cor')
C +        **********


C +--Top Boundary Conditions (fixed)
C +  ===============================

c #Di DO j=1,my
c #Di DO i=1,mx
c #Di     qvDY(i,j,1) = qvtoDI(i,j)
c #Di   pktaDY(i,j,1) = pkttDI(i,j)
c #Di   uairDY(i,j,1) = uairDI(i,j)
c #Di   vairDY(i,j,1) = vairDI(i,j)
c #Di END DO
c #Di END DO


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ PHYSICS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      GO TO 41


C +--BEGIN Feed Stand Alone Surface Model
C +  ====================================

 4    CONTINUE


C +--Surface Layer
C +  -------------

c #FR   IF (VSISVAT)                                              THEN

              DO j=1,my
              DO i=1,mx
                ssvSL(i,j,mz) = sqrt(max(uairDY(i,j,mz)*uairDY(i,j,mz)
     .                                  +vairDY(i,j,mz)*vairDY(i,j,mz)
     .                                  ,epsi))
              END DO
              END DO

c #FR   ELSE
c #FR                 dt_Loc = dt

C +            ******
c #FR     call TURsbl
C +            ******

c #FR   END IF


C +--END   Feed Stand Alone Surface Model
C +  ====================================

 41   CONTINUE


C +--Radiative Processes and 1D Surface Physics
C +  ==========================================

      IF     (physic)                                               THEN 

        IF   (mod(itexpe,jtRadi).eq.0)                              THEN 

c #MR     IF (RadMAR)                                               THEN

C +                **********
c #MR         call PHYrad_MAR
C +                **********

c #MR     ELSE
c #LL       IF (RadLMD)                                             THEN

C +                **********
c #LL         call PHYrad_LMD
C +                **********

c #LL       ELSE

C +                **********
c #EE         call PHYrad_top(DistST)
C +                **********

c #EE         if (openmp.and.klonr.eq.1) then
c #EE          if(iterun<=2.or.itexpe<100) then
C +                  **********
c #EE           call PHYrad_CEP(DistST)
c #EE           call PHYrad_CEP_mp(DistST)
C +                  **********
c #EE          else
C +                  *************
c #EE           call PHYrad_CEP_mp(DistST)
C +                  *************
c #EE          endif
c #EE         else
C +                 **********
c #EE          call PHYrad_CEP(DistST)
C +                 **********
c #EE         endif
c #LL       END IF

c #MR     END IF

        END IF

        IF   (mod(itexpe,  jtPhys).eq.0)                            THEN 

          IF (VSISVAT)                                              THEN

            if(openmp) then
C +              *************
            call PHY_SISVAT_MP(ihamr ,nhamr )
C +              *************
            else
            DO      itPhys=1,ntPhys
C +              **********
            call PHY_SISVAT(ihamr ,nhamr )
C +              **********
            ENDDO
            endif

          ELSE

           DO      itPhys=1,ntPhys
C +              **********
            call PHY_KDsvat(ihamr ,nhamr )
C +              **********
           ENDDO
          END IF

        END IF


C +          **********
c #DB   call Debugg_MAR('PHYgen    ')
C +          **********

      END IF


C +--Polynya Model
C +  =============

c #PO IF (polmod)                                                   THEN

C +          **********
c #PO   call SRFmod_pol
C +          **********

C +          **********
c #db   call Debugg_MAR('SRFmod_pol')
C +          **********

c #PO END IF


C +--Update of Surface Temperature
C +  =============================

      DO n=1,mw
      DO j=1,my
      DO i=1,mx
        tsrfSL(i,j,n)   =   tsrfSL(i,j,n) +  dtgSL(i,j,n)
      END DO
      END DO
      END DO


      if (reaLBC)                                                   THEN

C +          **********
        call LBCnud_srf
C +          **********

C +          **********
c #db   call Debugg_MAR('LBCnud_srf')
C +          **********

      END IF

      DO j=1,my
      DO i=1,mx
        TairSL(i,j)     = 0.
c #vL END DO
c #vL END DO
      DO iw=1,mw
c #vL DO j=1,my
c #vL DO i=1,mx
        TairSL(i,j)     = TairSL(i,j) + SLsrfl(i,j,iw) * tsrfSL(i,j,iw) 
c #vL END DO
c #vL END DO
      END DO
c #vL DO j=1,my
c #vL DO i=1,mx
        pktaDY(i,j,mzz) = TairSL(i,j) / exp(cap*log(pstDY(i,j)+ptopDY))
      END DO
      END DO


C +--Min./Max. 2-m Air Temperature
C +  =============================

C +        ******
c #T2 call TUR_2m
C +        ******

C +        **********
c #db call Debugg_MAR('TUR_2m    ')
C +        **********


C +--Contribution from Diabatic Heating
C +  ==================================

c #K1  pente = 0.005
c #K1  dthdz = (tSND(20,1)-tSND(15,1))/(zSND(20,1)-zSND(15,1)) + 9.77d-3
C +... 1D Katabatic Flow  Simulation (Forcing : dTheta/dt = -w dTheta/dz)
       DO k=1,mz
       DO j=1,my
       DO i=1,mx
c #GR    IF (i.ge.imez-2.and.
c #GR.       i.le.imez+2     )    
c #GR.     pktRAd(i,j,k) = pktRAd(i,j,k) -31.d-6*dt
C +...     2D Gravity Current Simulation (Forcing : -10C/jour)
           pktaDY(i,j,k)=pktaDY(i,j,k) + pktRAd(i,j,k)
c #K1.      + dt *pente *uairDY(i,j,k) *dthdz
c #K1.           /exp(cap*log(sigma(k) *  pstDY(i,j)+ptopDY))
       END DO
       END DO
       END DO


C +--cpl : GIVE FIELDS TO OASIS
C +  ==========================

C +        ***********
c #AO call MAR_2_OASIS
C +        ***********


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ TIME BASE ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      itexpe  =   itexpe + 1
      iterun  =   iterun + 1

C +        ******
      call TIMgeo
      call TIMcur
C +        ******


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ OUTPUT +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Model Domain Water Budget
C +  =========================

C +        ******
c #WB call H2O_WB(9, 0.,dt_Bal,.FALSE.,.FALSE.)
C +        ******


C +--Linear Mountain Wave Experiment: RMSE
C +  =====================================

C +        ******
c #OL call OUTlmw
C +        ******


C +--Ice-Sheet Surface Mass Balance
C +  ==============================

C +                               ******
c #IB if(iterun.eq.1.or.mod(iterun,4).eq.0) call OUTice
C +                               ******


C +--Particular Output for Wind Vector
C +  =================================

                                                            iout=0
c #W6                                                       iout=1
      IF (mmy.gt.1.and.mod(jmmMAR, 2).eq.0.and.jssMAR.eq.0) iout=1
      IF (mmy.eq.1.and.mod(jmmMAR,10).eq.0.and.jssMAR.eq.0) iout=1
c #SA                                                       iout=0

      IF (iout.eq.1)                                                THEN

              idum  = 1
              jdum  = 1
              adum  = 0.0
        DO i=ip11,mx1
        DO j=1,my
          IF (adum.LT.abs(uairDY(ip1(i),j,mz)-uairDY(im1(i),j,mz))) THEN
              idum  = i
              jdum  = j
              adum  = abs(uairDY(ip1(i),j,mz)-uairDY(im1(i),j,mz))
          END IF
        END DO
        END DO

C +--Non-Hydrostatic Pressure Perturbation
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          pnhLav = 0.
          pnh_av = 0.
c #NH   DO k=   1,mz
c #NH   DO j=jp11,my1
c #NH     pnhLav = pnhLav+pairNH(ip11,   j,k)*pstDYn(ip11,   j)*sigma(k)
c #NH.                   +pairNH( mx1,   j,k)*pstDYn( mx1,   j)*sigma(k)
c #NH   ENDDO
c #NH   IF (mmy.GT.1)                                             THEN
c #NH   DO i=ip11,mx1
c #NH     pnhLav = pnhLav+pairNH(   i,jp11,k)*pstDYn(   i,jp11)*sigma(k)
c #NH.                   +pairNH(   i, my1,k)*pstDYn(   i, my1)*sigma(k)
c #NH   ENDDO
c #NH   END IF
c #NH   DO j=jp11,my1
c #NH   DO i=ip11,mx1
c #NH     pnh_av = pnh_av+pairNH(   i,   j,k)*pstDYn(   i,   j)*sigma(k)
c #NH   END DO
c #NH   END DO
c #NH   END DO
c #NH   IF (mmy.EQ.1)                                             THEN
c #NH     pnhLav = pnhLav /(       2           *mz)
c #NH     pnh_av = pnh_av /(   (mx-2)          *mz)
c #NH   ELSE
c #NH     pnhLav = pnhLav /((2*(mx-2)+2*(my-2))*mz)
c #NH     pnh_av = pnh_av /(   (mx-2)  *(my-2) *mz)
c #NH   END IF

         id6 =            6
         idum=max(idum,   7)
         idum=min(idum,mx-6)
C +...   2-D and 3-D Simulations

c #GR    idum=         mx-6
C +
c #BS   IF (mmy.eq.1)
c #BS.   idum=         imez

        IF (mmx.eq.1)                                             THEN
         id6 =            0
         idum=            1
C +...   1-D         Simulations

        END IF

        DO i=idum-id6,idum+id6
            vecx1(i)= 10.0 *(pstDYn(i,jdum) + ptopDY)
c #NH       vecx3(i)= 10.0 * pstDYn(i,jdum) * pairNH(i,jdum,mz)
c #W6       vecx4(i)=        tairDY(i,jdum,mz) 
c #W6.                     - TfSnow
c #BS       vecx4(i)=  0.0
c #BS    DO k=1,mz
c #BS       vecx4(i)= vecx4(i)+ssvSL(i,jdum,k)*qsHY(i,jdum,k)
c #BS.                        *pstDY(i,jdum)*dsigm1(       k)
c #BS.                        *1.0e3        *grvinv
c #BS    END DO
        END DO
        IF (mmx.gt.1 .and. mmy.eq.1)                              THEN
          DO i=imez-10, imez+30
            vecx2(i)= 10.0 *(pstDYn(i,1)-pstDYn(imez-10,1)
     .                      -pstDY1(i,1)+pstDY1(imez-10,1))
          END DO
        END IF
        IF   (mmx.eq.1)                                           THEN
          write(21,21)itexpe,jdarGE,    labmGE(mmarGE),iyrrGE,
     .                       jhlrGE(iSND,jSND),minuGE ,jsecGE,
     .                (uairDY(1,1,k),k=mz-9,mz),
     .                (vairDY(1,1,k),k=mz-9,mz)
 21       format(i5,i3,'-',a3,'-',i4,'/',i2,'.',i2,'.',i2,' ||',10f6.2,
     .         /,24x,                                   'LT ||',10f6.2)
        ELSE
          IF (mmy.gt.1)                                           THEN
c #W6       write( 6,22)itexpe,jdarGE,labmGE(mmarGE),iyrrGE,
c #W6.                         jhurGE,       minuGE ,jsecGE,
c #W6.                  (uairDY(i,jdum,mz),i=idum-6,idum-1),
c #W6.        idum,jdum,(uairDY(i,jdum,mz),i=idum,idum+5),
c #W6.        ttime,                  itizGE(idum,jdum),
c #W6.                  (vecx1(i),i=idum-6,idum-1),
c #W6.       xxkm(idum),(vecx1(i),       i=idum,idum+5)
c #W6.                 ,(vecx4(i),i=idum-6,idum-1),
c #W6.                  (vecx4(i),       i=idum,idum+5)
            write(21,22)itexpe,jdarGE,labmGE(mmarGE),iyrrGE,
     .                         jhurGE,       minuGE ,jsecGE,
     .                  (uairDY(i,jdum,mz),i=idum-6,idum-1),
     .        idum,jdum,(uairDY(i,jdum,mz),i=idum,idum+5),
     .        ttime,                  itizGE(idum,jdum),
     .                  (vecx1(i),i=idum-6,idum-1),
     .       xxkm(idum),(vecx1(i),       i=idum,idum+5)
c #W6.                 ,(vecx4(i),i=idum-6,idum-1),
c #W6.                  (vecx4(i),       i=idum,idum+5)
 22         format(i7,i3,'-',a3,'-',i4,'/',i2,'.',i2,'.',i2,' ||',6f7.1,
     .                             ' | (',i3,',',i3,')',f5.1,' |',5f7.1,
     .                                /,3x,a8,9x,'UT (',i3,') ||',6f7.1,
     .                             ' |',f6.0,'km',      f7.1,' |',5f7.1 
c #W6.                            ,   /,3x,8x,9x,'    ',3x,'  ||',6f7.2,
c #W6.                             ' |', 6x ,'  ',      f7.2,' |',5f7.2
     .                                                                 )
          ELSE
c #W6       write( 6,23)itexpe,jdarGE,labmGE(mmarGE),iyrrGE,
c #W6.                         jhurGE,       minuGE ,jsecGE,
c #W6.                  (uairDY(i,jdum,mz),i=idum-6,idum-1),
c #W6.        idum,jdum,(uairDY(i,jdum,mz),i=idum,idum+5),
c #W6.        ttime,                  itizGE(idum,jdum),
c #W6.                  (vecx1(i),i=idum-6,idum-1),
c #W6.       xxkm(idum),(vecx1(i),       i=idum,idum+5)
c #W6.                 ,(vecx4(i),i=idum-6,idum-1),
c #W6.                  (vecx4(i),       i=idum,idum+5)
            write(21,23)itexpe,jdarGE,labmGE(mmarGE),iyrrGE,
     .                         jhurGE,       minuGE ,jsecGE,
     .                  (uairDY(i,jdum,mz),i=idum-6,idum-1),
     .        idum,jdum,(uairDY(i,jdum,mz),i=idum,idum+5),
     .        ttime,                  itizGE(idum,jdum),
     .                  (vecx1(i),i=idum-6,idum-1),
     .       xxkm(idum),(vecx1(i),       i=idum,idum+5)
c #W6.                 ,(vecx4(i),i=idum-6,idum-1),
c #W6.                  (vecx4(i),       i=idum,idum+5)
 23         format(i7,i3,'-',a3,'-',i4,'/',i2,'.',i2,'.',i2,' ||',6f7.1,
     .                             ' | (',i4,',',i2,')',f5.1,' |',5f7.1,
     .                                /,3x,a8,9x,'UT (',i3,') ||',6f7.1,
     .                             ' |',f6.0,'km',      f7.1,' |',5f7.1 
c #W6.                            ,   /,3x,8x,9x,'    ',3x,'  ||',6f7.2,
c #W6.                             ' |', 6x ,'  ',      f7.2,' |',5f7.2
     .                                                                 )
          END IF
c #w6       write( 6,24)(vecx3(i),i=idum-6,idum-1),
c #w6.                  (vecx3(i),       i=idum,idum+5)
c #NH       write(21,24)(vecx3(i),i=idum-6,idum-1),
c #NH.                  (vecx3(i),       i=idum,idum+5)
 24         format(                     3x,8x,9x,'    ',3x,'  ||',6f7.1,
     .                             ' |', 6x ,'  ',      f7.1,' |',5f7.1)
c #w6       write( 6,25) 1000.*pnh_av,1000.*pnhLav
c #w6       write(21,25) 1000.*pnh_av,1000.*pnhLav
 25         format(             '   p_HN Averages (Domain/LB) ||',42x  ,
     .                             ' | [Pa]   ',        f7.1,' |', f7.1)
        END IF
C +
        IF (mmx.gt.1 .and. mmy.eq.1)                              THEN
          ppp = 10*pstDY(imez-10,1)
          write(22,221)itexpe,(uairDY(i,1,mz),       i=imez-10,imez+30)
          write(23,221)itexpe,(tairDY(i,1,mz)-TfSnow,i=imez-10,imez+30)
 221      format(i10,20f5.1,/,10x,21f5.1)
          write(24,223)itexpe,(vecx2(i), i=imez-10,imez+30)
 223      format(i10,20f5.2,/,10x,21f5.2)
        END IF
C +
c #OL     write(21,2004)
c #OL.     ((1.d3*(uairDY(imez,1,k)-ugeoDY(imez,1,k))),k=mlh,mlg),
c #OL.                      (0.1019*gplvDY(imez,1,k)  ,k=mlh,mlg)
 2004     format(21x,                          ' || ',15f7.2,
     .         /,21x,                          ' || ',15f7.0)
      END IF
C +
C +
C +--Horizontal Dynamical Balance (Summary)             
C +  ======================================
C +
c #DY  ibd= 7
c #DY  tdt= 0.0
c #DY afdt= 0.0
C +
C +   ***********
c #DY call dynbil(tdt,afdt,jmez,ibd)
C +   ***********
C +
C +  
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END   of the INTERNAL TIME INCREMENTATION (nboucl over dt) +++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
          iboucl =  iboucl + 1 
      IF (iboucl.le.nboucl)                                   GO TO  2 
C +
C +
C +--Vertical Wind Speed wairDY (z Coordinate system)
C +  ================================================
C +
c #SA IF (sALONE)                                             GO TO 40
C +
C +                                   ***********
        IF (.not.convec.and.mmx.gt.1) call DYNwww
C +                                   ***********
C +
C +
c #WA     wwwabs=00.d+0
c #WA   DO k=1,mz
c #WA   DO j=1,my
c #WA   DO i=1,mx
c #WA     IF      (abs(wairDY(i,j,k)).gt.wwwabs)                  THEN
c #WA       wwwabs=abs(wairDY(i,j,k))
c #WA       wwwmax=    wairDY(i,j,k)
c #WA       i_wmax=i
c #WA       j_wmax=j
c #WA       k_wmax=k
c #WA     END IF
c #WA   END DO
c #WA   END DO
c #WA   END DO
c #WA       write(6,6010) i_wmax,j_wmax,sh(i_wmax,j_wmax),
c #WA.                        0.109*gplvDY(i_wmax,j_wmax,k_wmax),
c #WA.                              wairDY(i_wmax,j_wmax,k_wmax),
c #WA.                             (psigDY(i_wmax,j_wmax,k),k=1,mz)
 6010       format(6x,' z_Surf(',i3,',',i3,') =',f7.0,
     .             6x,'  w_Max(',f8.0,'m) =',f6.0,'cm/s',
     .           /,6x,' psigDY:',10f9.6,/,(14x,10f9.6))
C +
 40   CONTINUE


C +--OUTPUT for Graphs
C +  =================

           iprint =      iprint + 1 
           ipr_nc =      ipr_nc + 1

c #ID IF (log_nc.eq.1)                                            THEN
C +
C +...              dt_Loc is assumed

C +     ***********
c #ID   call OUT_nc
C +     ***********

c #ID ELSE

C +     ***********
        call OUTgks
C +     ***********

c #ID END IF


C +--Save of Model Variables 
C +  =======================

      IF (safVAR.and.jdh_LB.ne.-1)                                THEN
C +
C +     ***********
        call OUTsav
C +     ***********
C +
      ELSE IF       (jdh_LB.eq.-1)                                THEN
        write(6,6600)
 6600   format(/,'############################################',
     .         /,'# NO LATERAL BOUNDARY CONDITIONS AVAILABLE #',
     .         /,'############################################',/,1x)
        stop
      END  IF


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END   of the EXTERNAL TIME INCREMENTATION (nprint over dt * nboucl) ++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      IF (iprint.ge.nprint)                                   GO TO 30 
      GO TO 3 
 30   CONTINUE 


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ CLOSE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      close(unit=4)

      close(unit=21)

      IF (mx.gt.1.and.my.le.1)                                    THEN
        close(unit=22)
        close(unit=23)
        close(unit=24)
      END IF

c #WE close(unit=25)

c #SE close(unit=29)

c #DY close(unit=61)
c #DY close(unit=62)
c #DY close(unit=63)
c #DY close(unit=64)
c #DY close(unit=65)
c #DY close(unit=66)


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ END OF RUN +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +   ***********
c #SB call SBCnew
C +   ***********


C +--PSMILe termination (cpl)
C +  ========================

C +   **************************
c #AO CALL prism_terminate_proto (info)
C +   **************************

c #AO IF (info .NE. PRISM_Ok) THEN
c #AO     WRITE (6,*) 'An error occured in '
c #AO     WRITE (6,*) 'prism_terminate = '
c #AO     WRITE (6,*) info
c #AO END IF


C +--MAR    termination
C +  ==================

      open (unit=1,status='unknown',file='MAR.OK')
           write(1,1000) itexpe,jdarGE,labmGE(mmarGE),iyrrGE,
     .                          jhurGE,       minuGE ,jsecGE
 1000      format('MAR execution stopped normaly at iteration',i8,
     .          /,'Time          is',i13,'-',a3,'-',i4,
     .                            '/',i2,'.',i2,'.',i2,' UT')
      close(unit=1)

      stop
      end


      block data PHYdat

C +------------------------------------------------------------------------+
C | MAR PHYSIC                                             28-11-2006  MAR |
C |   Block Data PHYdat is used to define physical constants used in   MAR |
C +------------------------------------------------------------------------+
C |                                                                        |
C | # REMARK: "c  #  " means that data are redefined in SubRoutine PHYmar  |
C |   ^^^^^^                                                               |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MAR_GE.inc'
      include 'MARSND.inc'
c #AO include 'MAR_AO.inc'


C +--Numeric   Constants
C +  ===================

      data  izr /   0             /
      data  iun /   1             /
      data zero /   0.0           /
      data demi /   0.5           /
      data unun /   1.0           /
      data epsi /   0.000001000000/
      data eps9 /   0.000000001000/
      data eps12/   0.000000000001/
      data thous/1000.0           /


C +--Earth     Constants
C +  ===================

      data earthr/6371.229e+3/
C +...     earthr: Earth Radius            

      data earthv/ 729.217e-7/
C +...     earthv: Earth Angular Velocity

      data gravit/   9.81e0/ 
C +...     gravit: Gravity Acceleration


C +--Dynamical Constants
C +  ===================

      data akmol /   1.35e-5/
C +...     akmol : Air Viscosity 

      data vonkar/   0.40e0/
C +...     vonkar: von Karman constant

      data A_Turb /5.8/
C +...     A_Turb: Stability Coefficient in the SBL Universal Stable Function
C +                for Momt (Cheng et al., 2005, 2004JD004923, p.3, eq.9: 5.8)

      data AhTurb /5.4/
C +...     AhTurb: Stability Coefficient in the SBL Universal Stable Function
C +                for Heat (Cheng et al., 2005, 2004JD004923, p.3, eq.9: 5.4)

      data AsTurb /4.0/
C +...     AsTurb: Stability Coefficient in the SBL Universal Stable Function
C +                for BLOW*(Bintanja,     2000, BLM 95,       p.390      4.0)

      data r_Turb /3.0/
C +...     r_Turb: Turbulent Diffusivities Ratio K*/Km
C +                         (Bintanja,     2000, BLM 95, p. 384           3.0)


C +--Thermodynamical Constants (Atmosphere)
C +  ======================================

      data Ra    / 287.05967 /
      data RDryAi/ 287.05967 /
C +...     RDryAi: Perfect Gas Law  Constant / dry Air     (J/kg/K)

      data cp    /1004.708845/
C +...     cp    : Air Specific Heat                       (J/kg/K)

c #   data cap   /   0.28586e0/
C +...     cap   = R / Cp

      data pcap  /   3.73010e0/
C +...     pcap  = 100 ** (R / Cp)

      data RVapor/ 461.e0/
C +...     RVapor: Perfect Gas Law  Constant / Water Vapor (J/kg/K)

      data epsq  /   3.00e-6/
C +...     epsq  : Minimum Water Vapor Content 

      data Lv_H2O/   2.5008e+6/
C +...     Lv_H2O: Latent Heat of Vaporisation for Water   (J/kg)

      data Ls_H2O/   2.8345e+6/
C +...     Ls_H2O: Latent Heat of Sublimation  for Ice     (J/kg)

      data stefan/   5.67e-8/
C +...     stefan: Stefan-Bolstzman Constant (W/m2/K4)

      data qv_MIN/   3.00e-6/
C +...     qv_MIN: Specific Humididy Minimum (Christian Tricot, pers.com.)

C +--cpl : constants usefull for coupled configuration (see MAR_AO.inc)
C +  ==================================================================

C +...
c #AO data epsAO/     0.97/
C +...     epsAO: emissivity (same in NEMO)

c #AO data cpv/    1846.1/
C +...     cpv: water vapor specific heat (J/kg/K)

c #AO data cpvir/     0.83746/
C +...     cpvir: [cpv/cp - 1] (usefull value for qsat) (-)

c #AO data R_Rv/      0.622/
C +...     R_Rv: [gas cste dry air=287.0] / [gas cste moist air=461.5]


C +--Temperature Increment as a Function of Phase Change Increment
C +  =============================================================

c #   data   r_LvCp                          / 2490.04 /
C +...      [Lv=2500000J/kg]/[Cp=1004J/kg/K] = 2490.04

c #   data   r_LcCp                          /  332.27 /
C +...      [Lc= 333600J/kg]/[Cp=1004J/kg/K] =  332.27

c #   data   r_LsCp                          / 2822.31 /
C +...      [Ls=2833600J/kg]/[Cp=1004J/kg/K] = 2822.31


C +--Thermodynamical Constants (Sea)
C +  ===============================
C +
      data tfrwat/ 271.20e0/
C +...     tfrwat: Sea-Water freezing Temperature  (K)
C +                (definition: cfr. data in .main.)

      data siclf / 302.00e6/
C +...     siclf : Sea-Ice Heat of Fusion       (J/m3)

      data cdsice/   2.04e0/
C +...     cdsice: Conductivity of  Sea Ice    (W/m/K)

      data hic0  /   1.00e0/
C +...     hic0  : Sea-Ice Initial Thickness       (m)
C +                (Ross Sea Typical Value)

      data ro_Wat/1000.00e0/
C +...     ro_Wat: Density of Water            (kg/m3)

      data C__Wat/4186.00e0/
C +...     C__Wat: Heat Capacity of Water     (J/kg/K)

      data fracoh/   0.75e0/
C +...     fracoh=   1.00 - 0.25
C +***Hibler (1984):   25% of cooling => Oceanic Heat Flux (ANTARCTIC Ocean)


C +--Thermodynamical Constants (Ice)
C +  ===============================

      data ro_Ice /   920.e0/
C +...     ro_Ice: Density of Pure Ice          (kg/m3)

      data cdice  /   2.10e0/
C +...     cdice:  Conductivity of pure Ice     (W/m/K)


C +--Thermodynamical Constants (Snow)
C +  ================================

      data  csnow/2105.00e+0/
C +...      csnow:  Heat Capacity of Snow                        [J/kg/K]
C +***             (see Loth et al. 1993, JGR 98 D6, 2.2.2 2e para p.10453)

      data TfSnow/ 273.15e+0/
C +...     TfSnow: Snow      melting  Temperature  (K)

      data r0sno /   3.00e+1/
C +...     r0sno : Falling Snow minimal Density(kg/m3)
C +                (CEN/CROCUS Value)

!     data blsno /   3.30e+2/
C +...     blsno : Blown   Snow         Density(kg/m3) / until  2-Dec-2009
      data blsno /   2.55e+2/
C +...     blsno : Blown   Snow         Density(kg/m3) / calibration

      data Lf_H2O/   3.337e+5/
C +...     Lf_H2O: Latent  Heat of Fusion/ Snow (J/kg)


C +--Standard Atmosphere (Winter / Middle Latitudes)
C +  ===============================================

      data iSND / 1 /
      data jSND / 1 /

      data zSND / -143.,    0., 1001., 1993., 2992., 3993., 4994.,
     .            5983., 6978., 7988., 8984., 9970.,10968.,11975.,
     .           12966.,13949.,14945.,15932.,16950.,17900.,18914.,
     .           19884.,20894.,21933.,22985.,23799.,24990.,29928.,
     .           35068.,38589.,46673.,49408.,49583.,49761.,49948.,
     .           50132.,50324.,50521.,50723.,50930.,51143.       ,
     .            -143.,    0., 1001., 1993., 2992., 3993., 4994.,
     .            5983., 6978., 7988., 8984., 9970.,10968.,11975.,
     .           12966.,13949.,14945.,15932.,16950.,17900.,18914.,
     .           19884.,20894.,21933.,22985.,23799.,24990.,29928.,
     .           35068.,38589.,46673.,49408.,49583.,49761.,49948.,
     .           50132.,50324.,50521.,50723.,50930.,51143.       /

      data tSND / 277.0, 272.2, 268.7, 265.2, 261.7, 255.7, 249.7,
     .            243.7, 237.7, 231.7, 225.7, 219.7, 219.2, 218.7,
     .            218.2, 217.7, 217.2, 216.7, 216.2, 215.7, 215.2,
     .            215.2, 215.2, 215.2, 215.2, 215.2, 215.2, 217.4,
     .            227.8, 243.2, 258.5, 265.7, 265.7, 265.7, 265.7,
     .            265.7, 265.7, 265.7, 265.7, 265.7, 265.7       ,
     .            277.0, 272.2, 268.7, 265.2, 261.7, 255.7, 249.7,
     .            243.7, 237.7, 231.7, 225.7, 219.7, 219.2, 218.7,
     .            218.2, 217.7, 217.2, 216.7, 216.2, 215.7, 215.2,
     .            215.2, 215.2, 215.2, 215.2, 215.2, 215.2, 217.4,
     .            227.8, 243.2, 258.5, 265.7, 265.7, 265.7, 265.7,
     .            265.7, 265.7, 265.7, 265.7, 265.7, 265.7       /

      data qSND /.27e-2,.27e-2,.21e-2,.17e-2,.13e-2,.80e-3,.51e-3,
     .           .32e-3,.14e-3,.67e-4,.35e-4,.18e-4,.20e-4,.20e-4,
     .           .70e-5,.45e-5,.40e-5,.39e-5,.40e-5,.42e-5,.48e-5,
     .           .51e-5,.68e-5,.81e-5,.10e-4,.13e-4,.17e-4,.20e-4,
     .           .14e-4,.10e-4,.14e-4,.69e-5,.70e-5,.72e-5,.74e-5,
     .           .75e-5,.77e-5,.79e-5,.81e-5,.83e-5,.86e-5       ,
     .           .27e-2,.27e-2,.21e-2,.17e-2,.13e-2,.80e-3,.51e-3,
     .           .32e-3,.14e-3,.67e-4,.35e-4,.18e-4,.20e-4,.20e-4,
     .           .70e-5,.45e-5,.40e-5,.39e-5,.40e-5,.42e-5,.48e-5,
     .           .51e-5,.68e-5,.81e-5,.10e-4,.13e-4,.17e-4,.20e-4,
     .           .14e-4,.10e-4,.14e-4,.69e-5,.70e-5,.72e-5,.74e-5,
     .           .75e-5,.77e-5,.79e-5,.81e-5,.83e-5,.86e-5       /

      data pSND / 1036., 1018.,  897.,  790.,  694.,  608.,  531.,
     .             463.,  402.,  347.,  299.,  257.,  220.,  188.,
     .             161.,  138.,  118.,  101.,   86.,   74.,   63.,
     .              54.,   46.,   39.,   33.,   29.,   24.,   11.,
     .               5.,    3.,    1.,   0.7, 0.685, 0.669, 0.654,
     .            0.637, 0.622, 0.606, 0.591, 0.576, 0.560       ,
     .            1036., 1018.,  897.,  790.,  694.,  608.,  531.,
     .             463.,  402.,  347.,  299.,  257.,  220.,  188.,
     .             161.,  138.,  118.,  101.,   86.,   74.,   63.,
     .              54.,   46.,   39.,   33.,   29.,   24.,   11.,
     .               5.,    3.,    1.,   0.7, 0.685, 0.669, 0.654,
     .            0.637, 0.622, 0.606, 0.591, 0.576, 0.560       /


C +--Time Constants
C +  ==============

      data  njmoGE
     .     /0,31,28,31,30, 31, 30, 31, 31, 30, 31, 30, 31/
      data  njmbGE
     .     /0, 0, 1, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0/
      data  njyrGE
     .     /0, 0,31,59,90,120,151,181,212,243,273,304,334/
      data  njybGE
     .     /0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1/
C +...      njmoGE: Nb of Days in each Month of the Year
C +         njmbGE: Leap  Year Correction    to njmoGE    
C +         njyrGE: Nb of Days since   Begin of the Year, 
C +                            before  Current Month
C +         njybGE: Leap  Year Correction    to njyrGE    

      data  labmGE
     .     /'---','Jan','Feb','Mar','Apr','May','Jun',
     .            'Jul','Aug','Sep','Oct','Nov','Dec'/


C +--Characters
C +  ==========

      data labnum/'0','1','2','3','4','5','6','7','8','9'/

      end 


      subroutine PHYmar

C +------------------------------------------------------------------------+
C | MAR PHYmar                                             16-11-2002  MAR |
C |   Subroutine PHYmar is used to define physical constants used in   MAR |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'
      include 'MARdim.inc'
      include 'MAR_GE.inc'

      CHARACTER*5     :: RCP_CMIP5
      common/c_RCP_CMIP5/RCP_CMIP5

C +--LMDZ Time Constants
C +  ===================

      logical  YR_360,YR_365 ! y_360
      integer  n
      integer  njyr30(0:12), njmo30(0:12)
      integer  njyb30(0:12), njmb30(0:12)

      character*10 CALENDAR

      data  njmo30
     .     /0,30,30,30,30, 30, 30, 30, 30, 30, 30, 30, 30/
      data  njmb30
     .     /0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0/
      data  njyr30
     .     /0, 0,30,60,90,120,150,180,210,240,270,300,330/
      data  njyb30
     .     /0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0/
C +...      njmoGE: Nb of Days in each Month of the Year
C +         njmbGE: Leap  Year Correction    to njmoGE
C +         njyrGE: Nb of Days since   Begin of the Year,
C +                            before  Current Month
C +         njybGE: Leap  Year Correction    to njyrGE

        YR_360  = .false.
        YR_365  = .false.
      RCP_CMIP5 = "RCP60" ! RCP26,RCP45,RCP60,RCP85 

      open(unit=10,file="MARscenario.ctr",status="old",err=1000)
      read(10,*,end=1001) RCP_CMIP5
      read(10,*,end=1001) CALENDAR

      if(TRIM(CALENDAR)=="YR_360") YR_360=.true.
      if(TRIM(CALENDAR)=="YR_365") YR_365=.true.

      goto 1001

1000  continue
      print *,"PHYmar ERROR: MARscenario.ctr no found!!!"

1001  continue 
      print *,"PHYmar WARNING: RCP="//RCP_CMIP5 

      close(10) 

      IF (YR_360)                                                   THEN
        print *,"PHYmar WARNING: YR_360=.true."
        DO  n = 0,12
            njmoGE(n) = njmo30(n)
            njmbGE(n) = njmb30(n)
            njyrGE(n) = njyr30(n)
            njybGE(n) = njyb30(n)
        ENDDO
      END IF

      IF (YR_365)                                                   THEN
        print *,"PHYmar WARNING: YR_365=.true."
        DO  n = 0,12
            njmbGE(n) = 0
            njybGE(n) = 0
        ENDDO
      END IF

C +--CONSTANTS
C +  =========

C +--Time          Constants
C +  -----------------------

      nhyrGE =(njyrGE(12) + njmoGE(12)) * 24
C +...nhyrGE : Number of Hours in one Year


C +--Geometric     Constants
C +  -----------------------

      third= 1./3.
      pi   = acos(-unun)
C +...pi    /   3.141592653589793238462643/

      hourad  = pi / 12.0
      degrad  = pi /180.0
C +...degrad:   Conversion Factor: Radian --> Degrees


C +--Thermodynamic Constants
C +  -----------------------

        CvDryA = Cp             - RDryAi
        cap    = RDryAi         / Cp
        racv   = RDryAi         / CvDryA

        r_LvCp = Lv_H2O         / Cp
        r_LcCp =(Ls_H2O-Lv_H2O) / Cp
        r_LsCp = Ls_H2O         / Cp


C +--Earth         Constants
C +  -----------------------

        gravi2 = gravit * gravit
        grvinv = 1.0    / gravit

      return
      end


      subroutine TIMcur

C +------------------------------------------------------------------------+
C | MAR TIME                                               18-09-2001  MAR |
C |   SubRoutine TIMcur computes MAR               Time                    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT (via common block)                                            |
C |    ^^^^^  itexpe: Experiment Iteration Counter                         |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  jdaMAR: Nb of Days    Since Run Beginning (i.e. itexpe = 0)  |
C |           jhaMAR: Nb of Hours                                          |
C |           jmmMAR: Nb of Minutes                                        |
C |           jssMAR: Nb of Seconds                                        |
C |           jhaRUN: Nb of Hours   Since Run Beginning                    |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'


C +--MAR Time 
C +  ========

      jssMAR  =    itexpe*idt
      jmmMAR  =    jssMAR/60
      jhaRUN  =    jmmMAR/60
      jdaMAR  =    jhaRUN/24

      jhaMAR  =    jhaRUN -   jdaMAR *24
      jmmMAR  =    jmmMAR -  (jdaMAR *24 + jhaMAR) *60
      jssMAR  =    jssMAR - ((jdaMAR *24 + jhaMAR) *60 + jmmMAR) *60

      return
      end


      subroutine TIMgeo

C +------------------------------------------------------------------------+
C | MAR TIME                                                1-11-2001  MAR |
C |   SubRoutine TIMgeo computes Current Universal and Local Times         |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT (via common block)                                            |
C |    ^^^^^  itexpe: Experiment Iteration Counter                         |
C |           itizGE(mx,my): Time Zone                                     |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  iyrrGE       : year                                          |
C |           mmarGE       : Month                                         |
C |           jdarGE       : Day                                           |
C |           jhurGE       : Universal Time                      (Hour UT) |
C |           jhlrGE(mx,my): Local     Time                      (Hour LT) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'


C +--Local  Variables
C +  ================
cXF
      integer   njmo,leap
      integer*8 jdarGE8,jhurGE8,minuGE8,jsecGE8
CXF

C +--Universal Time
C +  ==============

          iyrrGE = iyr0GE
          mmarGE = mma0GE
          jdarGE8= jda0GE
          jhurGE8= jhu0GE
          minuGE8=          0
          jsecGE8= itexpe*idt
 240  CONTINUE
      if (jsecGE8.lt.  60)                                    GO TO 241
          jsecGE8= jsecGE8- 60
          minuGE8= minuGE8+ 1
      go to 240
 241  CONTINUE
      if (minuGE8.lt.  60)                                    GO TO 242
          minuGE8= minuGE8- 60
          jhurGE8= jhurGE8+ 1
      go to 241
 242  CONTINUE
      if (jhurGE8.lt.  24)                                    GO TO 243
          jhurGE8= jhurGE8- 24
          jdarGE8= jdarGE8+ 1
      go to 242
 243  CONTINUE
cXF
                                                        leap=1
          if(mod(iyrrGE,100)==0.and.mod(iyrrGE,400)/=0) leap=0
cXF

          njmo   =          njmoGE(mmarGE)
     .                     +njmbGE(mmarGE)*max(0,1-mod(iyrrGE,4))
     .                     *leap

      if (jdarGE8.le.       njmo)                             GO TO 244
          jdarGE8= jdarGE8- njmo
          mmarGE = mmarGE + 1
      if (mmarGE .le.  12)                                    GO TO 243
          mmarGE = mmarGE - 12
          iyrrGE = iyrrGE + 1
      go to 243
 244  CONTINUE


C +--Local     Time
C +  ==============

      DO j=1,my
      DO i=1,mx
                               jhlrGE(i,j) = jhurGE8 + itizGE(i,j)
        IF (jhlrGE(i,j).ge.24) jhlrGE(i,j) = jhlrGE(i,j) - 24
        IF (jhlrGE(i,j).lt. 0) jhlrGE(i,j) = jhlrGE(i,j) + 24
      END DO
      END DO

      jdarGE = jdarGE8
      jhurGE = jhurGE8
      minuGE = minuGE8
      jsecGE = jsecGE8

      return
      end


      subroutine TIMcor

C +------------------------------------------------------------------------+
C | MAR TIME                                               30-11-2000  MAR |
C |   SubRoutine TIMcor computes Corrected Local Times                     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT (via common block)                                            |
C |    ^^^^^  jhurGE     : Universal Time                        (Hour UT) |
C |           itizGE(i,j): Time Zone      of Grid Point (i,j)              |
C |           jhlrGE(i,j): Local     Time at Grid Point (i,j)    (Hour LT) |
C |           mmarGE     : Month                                           |
C |           jdarGE     : Day                                             |
C |                                                                        |
C |   OUTPUT: mmplus     : Month    (corrected)                            |
C |   ^^^^^^^ jdplus     : Day      (corrected)                            |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'


C +--Corrected Time Base
C +  ===================

                                              jdplus = jdarGE
       if (jhurGE+itizGE(i,j).lt.jhlrGE(i,j)) jdplus = jdarGE-1
       if (jhurGE+itizGE(i,j).gt.jhlrGE(i,j)) jdplus = jdarGE+1
       if (jdplus.eq.0)                       then 
                                              mmplus = mmarGE-1  +12
                                              mmplus = mod(mmplus,12)
                                              jdplus = njmoGE(mmplus)
       else
        if(jdplus.gt.njmoGE(mmarGE))          then
                                              mmplus = mmarGE+1
                                              jdplus =        1
        else
                                              mmplus = mmarGE
        end if
       end if

       return
       end


      subroutine GRDsig(zmin,aavu,bbvu,ccvu,vertic)

C +------------------------------------------------------------------------+
C | MAR GRID                                               15-02-2008  MAR |
C |   SubRoutine GRDsig is used to initialize the vertical grid            |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   zmin           : Height above Surface / 1st Sigma Level (m) |
C |   ^^^^^    aavu,bbvu,ccvu : Vertical Discretization Parameters         |
C |            vertic         : Logical Variable caracteris.vertic.discris.|
C |                                                                        |
C |   DATA:    sigpar(10)     : Parish Model Vertical Discretisation       |
C |   ^^^^^                                                                |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^   Variable  which is  initialized is:                         |
C |               sigma(mz): Independant Variable (Normalized Pressure)    |
C |                                                                        |
C |   ASSUMPTION: sigma is calculated from initial level height amsl       |
C |   ^^^^^^^^^^^                     assumig that T(msl) = SST            |
C |                                                dT/dz  = -0.0065 K/m    |
C |                                                p_s    = 100     hPa    |
C |                                                                        |
C | # OPTIONS: #SA  Regular      Vertical Discretisation                   |
C | # ^^^^^^^^ #PA  Parish Model Vertical Discretisation                   |
C | #          #ll  LMDZ   Model Vertical Discretisation (L. Li)           |
C | #          #HE  NORLAM       Vertical Discretisation (G. Heineman)     |
C | #          #L1  Alternate    Vertical Discretisation (when very fine)  |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MARSND.inc'

      include 'MAR_DY.inc'

      include 'MAR_TU.inc'

      include 'MAR_SL.inc'

      include 'MAR_IO.inc'

      include 'MAR_WK.inc'

      logical  vertic


C +--Local  Variables
C +  ================

      integer   lsf   ,lvg,kk    ,km  ,kn ,k1

      real      ga0   ,gaz,zmin  ,dzz ,rz ,rzb,zzo,sh_min
      real      ps_sig,vu ,aavu  ,bbvu,ccvu,ps_max,pstar0 
c #HE real      sighei(29)
c #lm real      siglmd(11)
c #PA real      sigpar(10),sigp11,sigp12(11:12),sigp13(10:13)


C +--DATA
C +  ====

      data      ps_sig/100.0e0/ 
C +...data      ps_sig/101.3e0/ 

c #HE data      sighei 
c #HE.       /0.10015,0.19077,0.27276,0.34695,0.41409,0.47483,0.52979,
c #HE.0.57952,0.62452,0.66524,0.70208,0.73542,0.76558,0.79288,0.81757,
c #HE.0.83992,0.86014,0.87844,0.89499,0.90997,0.92352,0.93579,0.94688,
c #HE.0.95692,0.96601,0.97423,0.98167,0.98840,0.99111/
C +***          sighei: DNMI model Vertical Discretisat.  (Heinemann 1996)

c #lm data      siglmd/0.014767,0.071835,0.150135,0.270661,0.410669,
c #lm.                 0.565832,0.708390,0.829996,0.913837,0.966484,
c #lm.                 0.990723/
C +***          siglmd: Vertical Discretisation of LMDZ   Model
C +                     (Laurent LI, personal communication,  5 dec. 2000)

c #PA data      sigpar/0.100,0.350,0.600,0.800,0.900,
c #PA.                 0.930,0.950,0.970,0.985,0.996/
C +***          sigpar: Vertical Discretisation of Parish Model
C +                     (Bromwich, Du and Parish 1994 MWR 122 No 7 p.1418)

c #PA data      sigp11                              /0.998/
c #PA data     (sigp12(k),k=11,12)                  /0.998,0.999/
c #PA data     (sigp13(k),k=10,13)            /0.990,0.996,0.998,0.999/
C +***          sigp1x: Vertical Discretisation of Parish Model (modified)

      data lsf / 1/

      data ga0 / 0.0065e0/
C +...     ga0 : Standard Atmospheric Lapse Rate

      lvg = 0
C +...lvg : set to 1 if |Vg(sounding)| .ne. 0 anywhere


C +--Entry Checking Point
C +  ====================

      if (IO_loc.ge.2) write(21,999)
 999  format(//,'   --- Initialisation / GRDsig ---')


C +--Temperature Vertical Profile 
C +  ============================

      gaz = ga0

      if (IO_loc.ge.2) write(21,1)gaz,sst_SL,ps_sig,gravit,RDryAi
 1    format(/,'  dT/dz  =',f8.5,' K/m',
     .       /,'  SST    =',f8.2,' K',
     .       /,'  ps_sig =',f8.2,' kPa',
     .       /,'  gravit =',f8.2,' m/s2',
     .       /,'  RDryAi =',f8.2,' J/kg/K')


C +--Sigma Levels
C +  ============

C +- 1) Coarse Resolution of the Surface Layer
C +  -----------------------------------------

      IF (.not.vertic)                                            THEN

C +       aa = 0.5
C +       bb = 1.5
C +       cc =-1.0
C +...    Reference : E. Richard, these, 1991, p.29

          vu =       0.0
        DO k=1,mz
          vu = vu  + 1.0/dble(mzz)
          sigma(k) = aavu*vu + bbvu*vu*vu + ccvu*vu*vu*vu

C +- Vertical Discretisation of NORLAM
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #HE     sigma(k) = sighei(k)
        END DO

C +- Vertical Discretisation of LMDZ   Model
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #lm   DO k=1,11
c #lm        sigma(k)  = siglmd(k)
c #lm   END DO

C +- Vertical Discretisation of Parish Model
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #PA   DO k=1,10
c #PA        sigma(k)  = sigpar(k)
c #PA   END DO

c #PA       mmz  = mz
c #PA   if (mmz.gt.10) then
c #PA    if(mmz.eq.11)
c #PA.       sigma(11) = sigp11
c #PA    if(mmz.eq.12) then
c #PA       do k = 11,12
c #PA        sigma( k) = sigp12(k)
c #PA       end do
c #PA    end if
c #PA    if(mmz.eq.13) then
c #PA       do k = 10,13
c #PA        sigma( k) = sigp13(k)
c #PA       end do
c #PA    end if
c #PA   end if

        DO k=1,mz
          IF (abs(gaz).gt.1.d-5)                                  THEN
            zsigma(k) =-(   sst_SL /gaz) *    ((1.e0+(sigma(k)-1.e0)
     .                                        *(1.e2/ps_sig))
     .                                   **(RDryAi*gaz/gravit)-1.e0) 
          ELSE
            if (IO_loc.ge.2.and.k.eq.1) write(21,116)
 116        format(/,'  t(z)   = CONSTANT')
            zsigma(k) =-(RDryAi*sst_SL/gravit)*log((unun+(sigma(k)-unun)
     .                                        *(1.d2/ps_sig)))
          END IF
        END DO


C +- 2) Fine   Resolution of the Surface Layer
C +  -----------------------------------------

      ELSE

        gaz    =max(gaz,epsi)

               km =          2
               km =      min(km,mz)
               kn =          1
c #L1          kn =          2
        zsigma( 1)=     zmin
        zsigma(km)=2.0 *zmin

        DO k=min(3,mz),mz
            rz     =zmin*aavu **(k-1)
            rzb    =ccvu*bbvu **(k-1)
          IF (TUkhmx.gt.0.0)                                      THEN
            zsigma(k)=rzb   *rz /(rz + rzb  )
          ELSE
            zsigma(k)=       rz
          END IF

            zsigma(k)= max(zsigma(k),zsigma(k-1)+zsigma(kn))
        END DO

            sh_min   =   8807.0
C +...      sh_min_0     Everest

        DO j=1,my
        DO i=1,mx
            sh_min   = min(sh_min,sh(i,j))
        END DO
        END DO
            ps_max   =     ps_sig*(1.0-gaz* sh_min           /sst_SL)
     .                                         **(gravit/(gaz*RDryAi))
            pstar0   =     ps_max-ptopDY
        DO k=1,mz
            kk=mz+1-k
            sigma(kk)=    (ps_sig/pstar0)
     .                          *((1.0-gaz*(sh_min+zsigma(k))/sst_SL)
     .                                         **(gravit/(gaz*RDryAi))
     .                           - 1.0                              )
     .                           + 1.0      + (ps_sig-ps_max)/pstar0
C +...      sigma(kk): the fine resolution  of the surface layer 
C +                    is computed using a geometric progression

        END DO
      END IF


C +--Output
C +  ======

      do k=1,mz
        kk=  mzz-k
        WKxza(1,k) = zsigma(kk)
      end do

      do k=1,mz
        zsigma (k) = WKxza(1,k)
        WKxza(1,k) = 0.0
      end do

      IF (IO_loc.ge.2)                                            THEN
       write(21,130)( sigma(k),k=1,mz)
 130   format(/,'  Sigma    Levels :',/,(1x,15f8.4))
       write(21,131)(zsigma(k),k=1,mz)
 131   format(/,'  Altitude Levels :',/,(1x,15f8.1))
      END IF

      return
      end


      subroutine GRDmar

C +------------------------------------------------------------------------+
C | MAR GRID                                               20-02-2004  MAR |
C |   SubRoutine GRDmar is used to initialize the grid parameters          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT (via common block)                                            |
C |    ^^^^^    sigma(mz) : Independant Variable on      Levels            |
C |             FIslot    : Implicit Filter Parameter                      |
C |                                 (Slow Dynamics / Temperature)          |
C |             FIslou    : ...     (Slow Dynamics / Wind Speed)           |
C |             FIslop    : ...     (Slow Dynamics / Pressure)             |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^     xxkm(mx) : Distance along the x-axis                 (km) |
C |              yykm(my) : Distance along the y-axis                 (km) |
C |                                                                        |
C |            sigmid(mzz): Independant Variable between Levels (i.e.k-1/2)|
C |            dsigm1(mz ):      Difference  d(sigma)|k                    |
C |            qsigm1(mz ): 1 / [Difference  d(sigma)|k    ]               |
C |            dsigm2(mz ):      Difference 2d(sigma)|k                    |
C |            qsigm2(mz ): 1 / [Difference 2d(sigma)|k    ]               |
C |            dsig_1(mzz):      Difference  d(sigma)|k+1/2                |
C |            qsig_1(mzz): 1 / [Difference  d(sigma)|k+1/2]               |
C |            dsig_2(mzz):      Difference 2d(sigma)|k+1/2                |
C |                                                                        |
C |            Ray_UB(mzabso) : Top Absorbing Layer  Contribution to       |
C |                             Rayleigh             Friction        (-/s) |
C |                                                                        |
C |            TUspon(mzabso) : Top Absorbing Layer  Contribution to       |
C |                             Horizontal Diffusion Coefficient    (m2/s) |
C |                                                                        |
C |            FIspon(mzabso) : Top Absorbing Layer  Contribution          |
C |                             to Implicit Filter Parameter               |
C |                    FIk_st(mz): Implicit Filter Parameter               |
C |                                   (Slow Dynamics / Temperature)        |
C |                    FIk_su(mz): ...(Slow Dynamics / Wind Speed)         |
C |            FIfstu, FIk_fu(mz): ...(Fast Dynamics / Wind Speed)         |
C |            FIfstu, FIk_fp(mz): ...(Fast Dynamics / Pressure,Velocity)  |
C |                                                                        |
C |            n6mxLB, n7mxLB : Effective Length of Lateral Sponge (x-Axe) |
C |            n6myLB, n7myLB : Effective Length of Lateral Sponge (y-Axe) |
C |                                                                        |
C |            im1(mx),2,..: max(i-1, 1), max(i-2, 1), etc...              |
C |            ip1(mx),2,..: min(i+1,mx), min(i+2,mx), etc...              |
C |                                                                        |
C |            jm1(my),2,..: max(j-1, 1), max(j-2, 1), etc...              |
C |            jp1(my),2,..: min(j+1,my), min(j+2,my), etc...              |
C |                                                                        |
C |            km1(mz),2,..: max(k-1, 1), max(k-2, 1), etc...              |
C |            kp1(mz),2,..: min(k+1,mz), min(k+2,mz), etc...              |
C |                                                                        |
C |            CUspxh(mx)  : Cubic Spline Auxiliary Variable (x Direction) |
C |            CUspxb(mx)  : idem                                          |
C |            CUspyh(mx)  : Cubic Spline Auxiliary Variable (y Direction) |
C |            CUspyb(mx)  : idem                                          |
C |            CUspzh(mx)  : Cubic Spline Auxiliary Variable (z Direction) |
C |            CUspzb(mx)  : idem                                          |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_CU.inc'
      include 'MAR_LB.inc'
      include 'MAR_UB.inc'

c #NH include 'MAR_NH.inc'

      include 'MAR_TU.inc'
      include 'MAR_FI.inc'

      include 'MAR_IO.inc'


C +--Local  Variables
C +  ================
C +
      integer  im10,ip10,im20,ip20
      integer  jm10,jp10,jm20,jp20
      integer  km10,kp10,km20,mzabs
      real                    FIabs
C +
C +
C +--DATA
C +  ====
C +
      logical DFspon
      data    DFspon /.true./
c #KS         DFspon =.false.
C +
C +--Entry Checking Point
C +  ====================
C +
      if (IO_loc.ge.2) write(21,999)
 999  format(//,'   --- Initialisation / GRDmar ---')
C +
C +
C +--Auxiliary Horizontal Independant Variables
C +  ==========================================
C +
      mmx  = mx
      mmx1 = mx1
      mmx1 = max( 1,mmx1)
      mmx2 = mx-2
      mmx2 = max( 1,mmx2)
      mmx3 = mx-3
      mmx3 = max( 1,mmx3)
      mmx4 = mx-4
      mmx4 = max( 1,mmx4)
      mmx5 = mx-5
      mmx5 = max( 1,mmx5)
      mmx6 = mx-6
      mmx6 = max( 1,mmx6)
      m0x2 =    2
      m0x2 = min(mx,m0x2)
      m0x3 =    3
      m0x3 = min(mx,m0x3)
      m0x4 =    4
      m0x4 = min(mx,m0x4)
      m0x5 =    5
      m0x5 = min(mx,m0x5)
      m0x6 =    6
      m0x6 = min(mx,m0x6)
C +
      mmy  = my
      mmy1 = my1
      mmy1 = max( 1,mmy1)
      mmy2 = my-2
      mmy2 = max( 1,mmy2)
      mmy3 = my-3
      mmy3 = max( 1,mmy3)
      mmy4 = my-4
      mmy4 = max( 1,mmy4)
      mmy5 = my-5
      mmy5 = max( 1,mmy5)
      mmy6 = my-6
      mmy6 = max( 1,mmy6)
      m0y2 =    2
      m0y2 = min(my,m0y2)
      m0y3 =    3
      m0y3 = min(my,m0y3)
      m0y4 =    4
      m0y4 = min(my,m0y4)
      m0y5 =    5
      m0y5 = min(my,m0y5)
      m0y6 =    6
      m0y6 = min(my,m0y6)
C +
      mmz  = mz
      mmz1 = mz1
      mmz1 = max(1,mmz1)
      mmz2 = mz-2
      mmz2 = max(1,mmz2)
C +
      dx2=dx*2.0
      dy2=dy*2.0
C +
      IF (mmx.gt.1)                                               THEN
C +
        dtx=dt/dx
        dty=dt/dy
C +
        dxinv =1.0/dx
        dyinv =1.0/dy
        dxinv2=1.0/dx2
        dyinv2=1.0/dy2
C +
       DO i=1,mx
         xxkm(i) = 0.001 * (i-imez) *dx
       END DO
C +
       DO j=1,my
         yykm(j) = 0.001 * (j-jmez) *dy
       END DO
C +
      END IF
C +
C +
C +--4th Order Centered Difference Parameter
C +  ---------------------------------------
C +
       fac43 = 4.0/3.0
C +
C +
C +--Effective Length of the Lateral Sponge
C +  --------------------------------------
C +
      IF   (mmx.eq.1)                                             THEN
          n40xLB = 1
          n50xLB = 1
          n5mxLB = 1
          n6mxLB = 0
          n7mxLB = 1
          n40yLB = 1
          n50yLB = 1
          n5myLB = 1
          n6myLB = 0
          n7myLB = 1
C +
      ELSE
          n40xLB = mx-n6+2
          n50xLB = mx-n6+1
          n5mxLB = n6-1
          n6mxLB = n6
          n7mxLB = n7
C +
        IF (mmy.eq.1)                                             THEN
          n40yLB = 1
          n50yLB = 1
          n5myLB = 1
          n6myLB = 0
          n7myLB = 1
        ELSE
          n40yLB = my-n6+2
          n50yLB = my-n6+1
          n5myLB = n6-1
          n6myLB = n6
          n7myLB = n7
        END IF
C +
      END IF
C +
C +
C +--Boundaries Masks
C +  ----------------
C +
      DO i=1,mx
         im10   =     i-1
         ip10   =     i+1
         im1(i) = max(im10, 1)
         ip1(i) = min(ip10,mx)
         im20   =     i-2
         ip20   =     i+2
         im2(i) = max(im20, 1)
         ip2(i) = min(ip20,mx)
      END DO
C +
      DO j=1,my
         jm10   =     j-1
         jp10   =     j+1
         jm1(j) = max(jm10, 1)
         jp1(j) = min(jp10,my)
         jm20   =     j-2
         jp20   =     j+2
         jm2(j) = max(jm20, 1)
         jp2(j) = min(jp20,my)
      END DO
C +
C +
C +--Auxiliary Vertical   Independant Variables
C +  ==========================================
C +
C +
C +--Boundaries Masks
C +  ----------------
C +
      DO k=1,mz
         km10   =     k-1
         kp10   =     k+1
         km1(k) = max(km10, 1)
         kp1(k) = min(kp10,mz)
         km20   =     k-2
         km2(k) = max(km20, 1)
      END DO
C +
C +
C +--Discretisation
C +  --------------
C +
        dsig_1(0)      = sigma(1)
        dsig_1(1)      = sigma(kp1(1))   - sigma(1)
        dsig_2(1)      = sigma(kp1(1)) 
        sigmid(1)      = 0.0
        sigmid(mzz)    = 1.0
C +
      DO       k=kp1(1),mmz1
        dsig_1(k)      =  sigma(kp1(k)) -  sigma(k)
        dsig_2(k)      =  sigma(kp1(k)) -  sigma(km1(k))
        sigmid(k)      =( sigma(k)      +  sigma(km1(k))) /2.0
        dsigm1(km1(k)) = sigmid(k)      - sigmid(km1(k))
        dsigm2(km1(k)) = sigmid(k)      - sigmid(km2(k))
      END DO
C +
C +--The lowest layer of the model is assumed to be a constant flux layer
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        dsig_1(mz)      =         1.0       -  sigma(mz)
        dsig_2(mz)      =         sigma(mz) -  sigma(km1(mz))
        sigmid(mz)      = 0.50 *( sigma(mz) +  sigma(km1(mz)))
        dsigm1(km1(mz)) =        sigmid(mz) - sigmid(km1(mz))
        dsigm2(km1(mz)) =        sigmid(mz) - sigmid(km2(mz))
C +
        dsig_1(mzz)     =        dsig_1(mz)
        dsig_2(mzz)     = 2.00 * dsig_1(mzz)
        dsigm1(mz)      = 1.00 - sigmid(mz)
        dsigm2(mz)      = 1.00 - sigmid(km1(mz))
C +
      DO k=0,mzz
        qsig_1(k)       = 1.00 / dsig_1(k)
      END DO
C +
      DO k=1,mz
        qsigm1(k)       = 1.00 / dsigm1(k)
        qsigm2(k)       = 1.00 / dsigm2(k)
      END DO
C +
C +
C +--Filter Parameter    Initialisation (rapidly propagating Waves Dynamics)
C +  =======================================================================
C +
            FIfstu    = FIslou /(ntFast+1)
            FIfstp    = FIslop /(ntFast+1)
C +
      DO k = 1,mz     
            FIk_st(k) = FIslot
            FIk_su(k) = FIslou
            FIk_fu(k) = FIfstu
            FIk_fp(k) = FIfstp
      END DO
C +
C +
C +--Top Absorbing Layer Initialisation
C +  ==================================
C +
            FIabs     = TUkhmx *  4.0 *dtfast /(dx*dx)
C +
      IF   (mz.gt.1)                                              THEN
            mzabs=       mzabso+1
            mzabs=min(mz,mzabs)
        IF (DFspon)                                               THEN
          DO k = 1,mzabso
            FIspon(k) = FIabs  * (sigma(mzabs)-sigma(k))
     .                         / (sigma(mzabs)-sigma(1))
            FIk_st(k) = FIk_st(k) + FIspon(k) *dt/dtfast
            FIk_su(k) = FIk_su(k) + FIspon(k) *dt/dtfast
            FIk_fu(k) = FIk_fu(k) + FIspon(k)
            FIk_fp(k) = FIk_fp(k) + FIspon(k)
            TUspon(k) = zero
          END DO
        ELSE
          DO k = 1,mzabso
            FIspon(k) = zero
            TUspon(k) = TUkhmx * (sigma(mzabs)-sigma(k))
     .                         / (sigma(mzabs)-sigma(1))
          END DO
        END IF
      END IF


C +--Rayleigh Friction (Ref. ARPS 4.0 User's Guide, para 6.4.3 p.152)
C +  =================

c #RF DO k=1,mzabso
c #RF   Ray_UB(k) = 0.5*(1.-cos(pi*(sigma(mzabso)-sigma(k))
c #RF.                            /(sigma(mzabso)-sigma(1))))/( 1.5*dt)
c #rf   Ray_UB(k) =                (sigma(mzabso)-sigma(k))
c #rf.                           / (sigma(mzabso)-sigma(1))  /(10.0*dt)
c #RF END DO


C +--Cubic Spline Initialisation
C +  ===========================
C +
C +  1) x - Direction
C +  ----------------
           CUspxh( 1) = 0.0
           CUspxh(mx) = 0.0
           CUspxb( 1) = 0.0
           CUspxb(mx) = 0.0
         DO i=ip11,mx1
           CUspxh( i) =       CUspxb(im1(i)) + 4.0
           CUspxb( i) =-1.0 / CUspxh(i)
         END DO
C +
C +  2) y - Direction
C +  ----------------
           CUspyh( 1) = 0.0
           CUspyh(my) = 0.0
           CUspyb( 1) = 0.0
           CUspyb(my) = 0.0
      IF (mmy.gt.1)                                               THEN
         DO j=jp11,my1
           CUspyh( j) =       CUspyb(jm1(j)) + 4.0
           CUspyb( j) =-1.0 / CUspyh(j)
         END DO
      END IF
C +
C +  3) Sigma - Direction (to be used in routine DYNadv_cubv)
C +  --------------------------------------------------------
c #ZU      CUspzh( 1)=dsig_1(1  ) /(dsig_1( 1)+ sigma(1))
c #ZU      CUspzh(mz)=dsig_1( mz) /(dsig_1(mz)+dsig_1(mmz1))
c #ZU      CUspzb( 1)= sigma(1)   /(dsig_1( 1)+ sigma(1))
c #ZU      CUspzb(mz)=dsig_1(mmz1)/(dsig_1(mz)+dsig_1(mmz1))
c #ZU    DO k=kp1(1),mmz1
c #ZU      CUspzh( k)=dsig_1(k  ) /(dsig_1(k)+dsig_1(k-1))
c #ZU      CUspzb( k)=dsig_1(k-1) /(dsig_1(k)+dsig_1(k-1))
c #ZU    END DO
C +
      return
      end


      subroutine GRDgeo

C +------------------------------------------------------------------------+
C | MAR GRID                                           Tue 17-11-2009  MAR |
C |   SubRoutine GRDgeo computes the Latitudes, Longitudes and             |
C |                              the Time Zone of each Grid Point          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT: abs(maptyp)=0: Polar   Stereogr. Project. (SOUTH HEMISPHERE) |
C |    ^^^^^              1: Oblique Stereogr. Project. (ALL    LATITUDES  |
C |                                                                        |
C |    INPUT (via common block)                                            |
C |    ^^^^^  imez,jmez    : Indices of the MAR Domain Center              |
C |           GEddxx       : (2-D): x-Axis      Direction                  |
C |                          (3-D): South-North Direction along            |
C |                                 90E, 180E, 270E or 360E Meridians      |
C |           GElat0       : Latitude  of (0,0) in  MAR              (deg) |
C |           GElon0       : Longitude of (0,0) in  MAR              (deg) |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  GElatr(mx,my): Latitude  of the (x,y) MAR coordinate   (rad) |
C |           GElonh(mx,my): Longitude of the (x,y) MAR coordinate     (h) |
C |           itizGE(mx,my): Time Zone                                     |
C |           fcorDY(mx,my): Coriolis Parameter (may be variable)          |
C |                                                                        |
C |   MODIF.  3 Nov 2009   : Map Scaling Factor SFm_DY computed only       |
C |   ^^^^^                  for a domain which is North/South Pole        |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'


C +--Local  Variables
C +  ================

      integer         i1_gg ,i2_gg ,id10  ,jd10
      real            GElon ,GElat ,RadLat,clat_s
      real     argrot,cosrot,sinrot 
      real            xxmar0,yymar0
      real     ddista,xdista,ydista


C +--GEOGRAPHIC Coordinates
C +  ======================

      IF (.NOT.geoNST)                                            THEN

C +--1-D and 2-D Cases
C +  -----------------

        IF (mmy.eq.1)                                             THEN 

            argrot = (GEddxx-90.0)*degrad
            cosrot =  cos(argrot)
            sinrot =  sin(argrot)

          DO j=1,my
          DO i=1,mx
            xxmar0 = cosrot*(i-imez)*dx + sinrot*(j-jmez)*dx
            yymar0 = cosrot*(j-jmez)*dx - sinrot*(i-imez)*dx

C +         ***********
            call GRDstr(xxmar0,yymar0,GElon0,GElat0,GElon,GElat,GEtrue)
C +         ***********

            GElatr(i,j) =  GElat
            GElonh(i,j) =  GElon  

          END DO
          END DO


C +--3-D         Cases
C +  -----------------

        ELSE 

C +- ANTARCTICA (Polar   Stereographic Projection is assumed)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AP     if (maptyp.eq.0)                                        THEN
c #AP        do j=1,my
c #AP        do i=1,mx
c #AP          xxmar0  = (i-imez)*dx/1000.
c #AP          yymar0  = (j-jmez)*dy/1000.
c #AP
C +                 ***********
c #AP          call StereoSouth(xxmar0,yymar0,GEddxx,GElon,GElat)
C +                 ***********
c #AP
c #AP          GElonh(i,j) =  GElon / 15.
C +   ...      Conversion: degrees->hour
c #AP          GElatr(i,j) =  GElat * degrad
C +   ...      Conversion: rad ->degrees
C +
c #AP        enddo
c #AP        enddo
c #AP     end if

c #PP     IF (maptyp.eq.0)                                       THEN
c #PP         ddista = earthr * 2.0 * tan((45.0+GElat0*0.50)*degrad)
c #PP         xdista = ddista       * cos((90.0-GElon0)     *degrad)
c #PP         ydista = ddista       * sin((90.0-GElon0)     *degrad)
c #PP       DO j=1,my
c #PP       DO i=1,mx
c #PP         IF (abs(GEddxx- 90.0).lt.epsi)                      THEN
c #PP                xxmar0 = (i-imez)*dx
c #PP                yymar0 = (j-jmez)*dy
c #PP         END IF
c #PP         IF (abs(GEddxx      ).lt.epsi)                      THEN
c #PP                xxmar0 = (j-jmez)*dy
c #PP                yymar0 =-(i-imez)*dx
c #PP         END IF
c #PP         IF (abs(GEddxx-270.0).lt.epsi)                      THEN
c #PP                xxmar0 =-(i-imez)*dx
c #PP                yymar0 =-(j-jmez)*dy
c #PP         END IF
c #PP         IF (abs(GEddxx-180.0).lt.epsi)                      THEN
c #PP                xxmar0 =-(j-jmez)*dy
c #PP                yymar0 = (i-imez)*dx
c #PP         END IF
c #PP 
c #PP                xxmar0 = xxmar0 + xdista
c #PP                yymar0 = yymar0 + ydista
c #PP 
c #PP              ddista      =     sqrt(xxmar0*xxmar0+yymar0*yymar0)
c #PP              GElatr(i,j) =-0.5*pi 
c #PP.                           +2.*atan(ddista*0.5   /earthr)
c #PP         IF(abs(xxmar0).gt.zero)                             THEN
c #PP                GElonh(i,j) =     atan(yymar0       /xxmar0)
c #PP           IF  (xxmar0.lt.zero)
c #PP.               GElonh(i,j) =                GElonh(i,j) + pi
c #PP 
c #PP                GElonh(i,j) =   0.50 * pi - GElonh(i,j)
c #PP            IF (GElonh(i,j).gt.        pi)
c #PP.               GElonh(i,j) =  -2.00 * pi + GElonh(i,j)
c #PP            IF (GElonh(i,j).lt.       -pi)
c #PP.               GElonh(i,j) =   2.00 * pi + GElonh(i,j)
c #PP 
c #PP         ELSE
c #PP           IF   (yymar0.gt.zero)                             THEN
c #PP                GElonh(i,j) =   0.00
c #PP           ELSE
c #PP                GElonh(i,j) =           pi 
c #PP           END IF
c #PP         END IF
C +   ...     transformation stereographic coordinates (center = South Pole)
C +   ...                 -> spherical     coordinates
c #PP  
c #PP                GElonh(i,j) =                GElonh(i,j)   / hourad
C +   ...     Conversion:   radian       -> Hour
c #PP 
c #PP       END DO
c #PP       END DO
c #PP  
c #PP     END IF

C +- OTHERS     (Oblique Stereographic Projection is assumed)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF (abs(maptyp).eq.1)                                   THEN 

            DO j=1,my
            DO i=1,mx

             argrot = (GEddxx-90.0)*degrad
             cosrot = cos(argrot)
             sinrot = sin(argrot)
             xxmar0 = cosrot*(i-imez)*dx+sinrot*(j-jmez)*dy
             yymar0 = cosrot*(j-jmez)*dy-sinrot*(i-imez)*dx

C +          ***********
             call GRDstr(xxmar0,yymar0,GElon0,GElat0,GElon,GElat,GEtrue)
C +          ***********

             GElatr(i,j) =  GElat
             GElonh(i,j) =  GElon  

            END DO
            END DO

          END IF 

        END IF 

      END IF 


C +--Sine, Cosine of Latitude
C +  ========================

        DO j=1,my
        DO i=1,mx
              clatGE(i,j)  =   cos(GElatr(i,j))
              slatGE(i,j)  =   sin(GElatr(i,j))
        END DO
        END DO


C +--Scaling Map Factor
C +  ==================

        IF (abs(GElat0).GE.90.-epsi)                                THEN
              clat_s    =   1.+sin((90.-    GEtrue)*degrad)
          DO j=1,my
          DO i=1,mx
              SFm_DY(i,j) = clat_s/( 1.+abs(slatGE(i,j)))
          END DO
          END DO
        ELSE
          DO j=1,my
          DO i=1,mx
              SFm_DY(i,j)  =   1.0
          END DO
          END DO
        END IF


C +--Numerical Equator
C +  ~~~~~~~~~~~~~~~~~
        DO j=1,my
        DO i=1,mx
          IF(abs(GElatr(i,j)).lt.        epsi)                    THEN
                 RadLat       =          epsi
                 slatGE(i,j)  =   sin(RadLat )
                 clatGE(i,j)  =   cos(RadLat )
          END IF

C +--Numerical North Pole
C +  ~~~~~~~~~~~~~~~~~~~~
          IF(    GElatr(i,j) .gt.demi*pi-epsi)                    THEN
                 RadLat       =  demi*pi-epsi
                 slatGE(i,j)  =   sin(RadLat )
                 clatGE(i,j)  =   cos(RadLat )
          END IF

C +--Numerical South Pole
C +  ~~~~~~~~~~~~~~~~~~~~
          IF(    GElatr(i,j) .lt.epsi-demi*pi)                    THEN
                 RadLat       =  epsi-demi*pi
                 slatGE(i,j)  =   sin(RadLat )
                 clatGE(i,j)  =   cos(RadLat )
          END IF

       END DO
       END DO


C +--Coriolis Parameter
C +  ==================

      DO j=1,my
      DO i=1,mx
        fcorDY(i,j) = 2.0*earthv*sin(GElatr(i   ,j   ))
c #CC   fcorDY(i,j) = 2.0*earthv*sin(GElatr(imez,jmez))
C +...  fcorDY      : Coriolis Parameter

      END DO
      END DO


C +--Time Zone
C +  =========

      DO j=1,my
      DO i=1,mx
            itizGE(i,j)    =    GElonh(i,j)
        if (itizGE(i,j).gt. 12) itizGE(i,j) = itizGE(i,j)-24
        if (itizGE(i,j).lt.-12) itizGE(i,j) = itizGE(i,j)+24
      END DO
      END DO


C +--OUTPUT
C +  ======

          i1_gg = imez  - 50
          i2_gg = imez  + 50
          i1_gg = max(i1_gg, 1)
          i2_gg = min(i2_gg,mx)
          id10  = 1 + min(mx-1,10)
          jd10  = 1 + min(my-1,10)

          write(4,990)(i,i=i1_gg,i2_gg,id10)
 990      format(/,' LATITUDES / LONGITUDES / TOPOGRAPHY:  x ->  y ^ ',
     .           /,' ===================================',/,9x,13i9)
          DO j=my,1,-jd10
            write(4,991)j,(GElatr(i,j)/degrad,i=i1_gg,i2_gg,id10)
 991        format(  i9,11f9.3)
            write(4,992)  (GElonh(i,j)*1.5d+1,i=i1_gg,i2_gg,id10)
 992        format(  9x,11f9.3)
            write(4,993)  (sh    (i,j)*1.0d-3,i=i1_gg,i2_gg,id10)
 993        format(  9x,11f9.3)
            write(4,994)  (itizGE(i,j),       i=i1_gg,i2_gg,id10)
 994        format(  9x,11i9  )
            write(4,995)  (fcorDY(i,j)       ,i=i1_gg,i2_gg,id10)
 995        format(  9x,11f9.6)
          END DO

      return
      end


      subroutine GRDstr(xxmar,yymar,GE0lon,GE0lat,GElonM,GElatM,GEtruL)

C +------------------------------------------------------------------------+
C | MAR GRID                                               19-11-2004  MAR |
C |   SubRoutine GRDstr computes the Latitudes, Longitudes                 |
C |                              of a MAR Domain Grid Point                |
C |                     assuming Inverse Stereographic Oblique Projection  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  xxmar ,yymar : MAR        Coordinates                        |
C |   ^^^^^^  GE0lon,GE0lat: Geographic Coordinates of MAR Domain Center   |
C |                          (3-D): South-North Direction along            |
C |                                 90E, 180E, 270E or 360E Meridians      |
C |                                                                        |
C |   OUTPUT: GElatM       : Latitude  of the MAR grid point      (radian) |
C |   ^^^^^^^ GElonM       : Longitude of the MAR grid point        (hour) |
C |                                                                        |
C |   REFERENCE: F. Pearson, Map projection methods, CRC Press, 1990.      |
C |   ^^^^^^^^^^                                                           |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'


C +--local  Parameters
C +  =================

      real    pidemi,CphiP ,SphiP ,Sphi  
      real    dGElon,GElonM,GElatM 
      real    GEtruL,GE0lon,GE0lat
      real    denomi,OBLlon,OBLlat
      real    ddista,xxmar ,yymar 
      real    costru

      pidemi= pi / 2.0

      CphiP = cos(degrad*GE0lat)
      SphiP = sin(degrad*GE0lat)

      costru= cos(degrad*GEtruL)


C +--Coordinates relative to a Pole set to the Domain Center
C +  =======================================================


C +--Relative Longitude -OBLlon (0 <= OBLlon < 2pi)
C +  ----------------------------------------------

      if      (xxmar.gt.0.)                      then
         OBLlon = pidemi - atan(yymar/xxmar) 
      else if (xxmar.eq.0. .and. yymar.lt.0.)    then
         OBLlon = pi
      else if (xxmar.lt.0.)                      then
         OBLlon = 3.00 *pidemi - atan(yymar/xxmar) 
      else if (xxmar.eq.0. .and. yymar.ge.0.)    then
         OBLlon = 0.0
      end if


C +--Relative  Latitude  OBLlat
C +  --------------------------

      ddista = sqrt ( xxmar*xxmar + yymar*yymar )
      OBLlat = 0.50*pi - 2.0*atan(ddista/(earthr*(1.+costru))) 


C +--Coordinates Change (OBLlon,OBLlat) -> (GElonM,GElatM) 
C +                   / (rotation, Pearson p.57)
C +  =====================================================


C +--Latitude (radians)
C +  ------------------

      Sphi  = SphiP * sin(OBLlat) + CphiP * cos(OBLlat) * cos(OBLlon)
      GElatM= asin(Sphi)


C +--Longitude  (hours)  
C +  ------------------

C +--dGElon = GElonM - GE0lon  (-pi < dGElon <= pi)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      denomi =  CphiP * tan (OBLlat) - SphiP * cos(OBLlon) 

      if (OBLlon.gt.epsi          .and. OBLlon.lt.(pi-epsi))     then

C +--1) OBLlon in trigonometric quadrant 1 or 4 ("right"):
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        dGElon = atan(sin(OBLlon)/denomi) 
        if (dGElon.lt.0.0) then
            dGElon = dGElon + pi
C +...      Go to Quadrant 1 by adding       180 degrees
        end if

C +--2) OBLlon is in trigonometric quadrant 2or3 ("left "):
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      else if (OBLlon.gt.(pi+epsi).and. OBLlon.lt.(2.0*pi-epsi)) then

        dGElon = atan(sin(OBLlon)/denomi)
        if (dGElon.gt.0.0) then
            dGElon = dGElon - pi
C +...      Go to Quadrant 2 by substracting 180 degrees
        end if

      else if (OBLlon.le.epsi .or. OBLlon.ge.(2.0*pi-epsi))      then

C +--3) OBLlon = 0 -> dGElon = 0 or pi :
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ((pidemi-OBLlat) .gt. (pidemi-degrad*GE0lat) ) then
C +...    North pole crossed ==> add 180 degrees to Longitude
          dGElon = pi
        else
          dGElon = 0.0 
        end if 

      else if (OBLlon.ge.(pi-epsi) .and. OBLlon.le.(pi+epsi))    then 

C +--4) OBLlon = pi -> dGElon = 0 or pi :
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ((pidemi-OBLlat) .gt. (pidemi+degrad*GE0lat) ) then
C +...    South pole crossed ==> add 180 degrees to Longitude
          dGElon = pi
        else
          dGElon = 0.0
        end if
      end if

C +--Longitude (hours)
C +  ~~~~~~~~~
      GElonM= (dGElon + GE0lon * degrad) / hourad

      return 
      end


C     + ---------------------------------------------------------- +
c #AP    Subroutine StereoSouth (E,N,GEddxx,lon,lat)
C     | Compute the lon, lat from Oblique Stereographic Projection |
C     | Written by Cecile Agosta                          17-05-10 |
C     | EPSG Polar Stereographic transformation Variant B          |
C     | (http://www.epsg.org/guides/docs/G7-2.pdf)                 |
C     | Equivalent to EPSG 3031 (WGS-84 ellipsoid)                 |
C     + ---------------------------------------------------------- +
C     |                                                            |
C     | INPUT :  E      : Stereo coordinate on the East  (X, km)   |
C     | ^^^^^^^  N      : Stereo coordinate on the North (Y, km)   |
C     |          GEddxx : Longitude of X axis (90=East, clockwise) |
C     |         [lat true = 71 S]                                  |
C     |                                                            |
C     | OUTPUT : lon    : longitude (deg)                          |
C     | ^^^^^^^  lat    : latitude  (deg)                          |
C     |                                                            |
C     + ---------------------------------------------------------- +
c #AP IMPLICIT NONE
c #AP
c #AP INCLUDE 'MARdim.inc'
c #AP
C      + General Variables
C      + -----------------
c #AP Real,INTENT(in ) :: E,N,GEddxx
c #AP Real,INTENT(out) :: lon,lat
c #AP 
C      + Local Variables
C      + ---------------
c #AP Real ddista
c #AP 
C      + Constants
C      + ---------
c #AP Real  aa,ex,pi,degrad,latF,FE,FN,tF,mF,k0,t,rho,khi,lon0
c #AP Real  trulat
c #AP
C      + aa : (km) = demi grand axe
c #AP    aa     = 6378.1370
C      + ex : excentricity WGS-84
c #AP  ex     = 0.081819190842621
C      + trulat : Latitude of standard parallel, 71 S for ESPG 3031
c #AP    trulat = -71.
c #AP pi     = 4. * atan(1.)
c #AP degrad = pi / 180.
c #AP
c #AP latF = trulat*degrad
c #AP lon0 = (GEddxx-90.)*degrad
c #AP
c #AP FE = 0. !False Easting
c #AP FN = 0. !False Northing
c #AP
C      + Polar Stereographic Projection
C      + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AP
c #AP tF = tan (pi/4 + latF/2) /
c #AP.    ( (1 + ex*sin(latF)) / (1 - ex*sin(latF)) )**(ex/2)
c #AP mF = cos(latF) / (1 - ex**2 * sin(latF)**2)**0.5
c #AP k0 = mF   *( (1+ex)**(1+ex) * (1-ex)**(1-ex) )**0.5 / (2*tF)
c #AP
c #AP rho = ( (E-FE)**2 + (N-FN)**2 )**0.5
c #AP t   = rho * ( (1+ex)**(1+ex) * (1-ex)**(1-ex) )**0.5 / (2*aa*k0)
c #AP khi = 2*atan(t) - pi/2
c #AP
c #AP lat = khi
c #AP.      + (  ex**2/2   +  5*ex**4/24  +     ex**6/12 + 13*ex**8/360)
c #AP.        *sin(2*khi)
c #AP.      + (7*ex**4/48  + 29*ex**6/240 + 811*ex**8/11520            )
c #AP.        *sin(4*khi)
c #AP.      + (7*ex**6/120 + 81*ex**8/1120                             )
c #AP.        *sin(6*khi)
c #AP.      + (            4279*ex**8/161280                           )
c #AP.        *sin(8*khi)
c #AP
c #AP if      (E-FE .eq. 0. .and. N-FN .ge. 0) then
c #AP   lon = lon0
c #AP else if (E-FE .eq. 0. .and. N-FN .le. 0) then
c #AP   lon = lon0 + pi
c #AP else
c #AP   lon = lon0 + atan2(E-FE,N-FN)
c #AP endif
c #AP      
c #AP lat = lat / degrad
c #AP lon = lon / degrad
c #AP
c #AP Return
c #AP END Subroutine StereoSouth
c #AP
c #AP
C     + ---------------------------------------------------------- +
c #AP Subroutine StereoSouth_inverse (lon,lat,lonE,E,N)
C     | Compute Oblique Stereographic Projection from lon,lat      |
C     | Written by Cecile Agosta                          17-05-10 |
C     | EPSG Polar Stereographic transformation Variant B          |
C     | (http://www.epsg.org/guides/docs/G7-2.pdf)                 |
C     | Equivalent to EPSG 3031 (WGS-84 ellipsoid)                 |
C     + ---------------------------------------------------------- +
C     |                                                            |
C     | INPUT : lon     : Longitude (deg)                          |
C     | ^^^^^^^ lat     : Latitude  (deg)                          |
C     |        lon0    : Longitude of X axis (90=East, clockwise)  |
C     |       [lat true = 71 S]                                    |
C     |                                                            |
C     | OUTPUT : E      : Stereo coordinate on the East  (X, km)   |
C     | ^^^^^^^^ N      : Stereo coordinate on the North (Y, km)   |
C     |                                                            |
C     + ---------------------------------------------------------- +
c #AP IMPLICIT NONE
c #AP
c #AP INCLUDE 'MARdim.inc'
c #AP
C      + General Variables
C      + -----------------
c #AP Real,INTENT(in ) :: lon,lat,lonE
c #AP Real,INTENT(out) :: E,N
c #AP
C      + Local Variables
C      + ---------------
c #AP Real  costru,ddista
c #AP
C      + Constants
C      + ---------
c #AP Real  aa,ex,pi,degrad,latF,FE,FN,tF,mF,k0,t,rho,lonrad,latrad
c #AP Real  lon0,trulat
c #AP
C      + aa : (km) = demi grand axe
c #AP    aa     = 6378.1370
C      + ex : excentricity WGS-84
c #AP    ex     = 0.081819190842621
C      + trulat : Latitude of standard parallel, 71 S for ESPG 3031
c #AP    trulat = -71.
c #AP pi     = 4. * atan(1.)
c #AP degrad = pi / 180.
c #AP
c #AP latF   = trulat*degrad
c #AP lon0   = (lonE-90)*degrad
c #AP lonrad = lon *degrad
c #AP latrad = lat *degrad
c #AP
C     + False Easting
c #AP FE = 0.
C     + False Northing
c #AP FN = 0. 
c #AP
C      + Polar Stereographic Projection
C      + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AP
c #AP tF  = tan (pi/4 + latF  /2) /
c #AP.      ( (1 + ex*sin(latF  )) / (1 - ex*sin(latF  )) )**(ex/2)
c #AP mF  = cos(latF) / (1 - ex**2 * sin(latF)**2)**0.5
c #AP k0  = mF*( (1+ex)**(1+ex) * (1-ex)**(1-ex) )**0.5 / (2*tF)
c #AP
c #AP t   = tan (pi/4 + latrad/2) /
c #AP.      ( (1 + ex*sin(latrad)) / (1 - ex*sin(latrad)) )**(ex/2)
c #AP rho = 2*aa*k0*t / ( (1+ex)**(1+ex) * (1-ex)**(1-ex) )**0.5
c #AP
c #AP E = FE + rho*sin (lonrad - lon0)
c #AP N = FN + rho*cos (lonrad - lon0)
c #AP
c #AP RETURN
c #AP END Subroutine StereoSouth_inverse


      subroutine INIgen

C +------------------------------------------------------------------------+
C | MAR INPUT                                               1-12-2006  MAR |
C |   SubRoutine INIgen set up MAR Initialization Procedure                |
C |                                                                        |
C +------------------------------------------------------------------------+


c #AO USE mod_prism_proto !
c #AO USE mar_module      !TANGO modules
c #AO USE flincom         !

      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MARSND.inc'

      include 'MAR_DY.inc'
c #NH include 'MAR_NH.inc'

      include 'MAR_LB.inc'
      include 'MAR_UB.inc'
c #Di include 'MAR_DI.inc'
      include 'MARsIB.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'
      include 'MAR_FI.inc'

      include 'MAR_RA.inc'

c #HY include 'MAR_HY.inc'
c #CA include 'MAR_CA.inc'
c #PB include 'MAR_PB.inc'
c #TC include 'MAR_TC.inc'

      include 'MAR_SL.inc'
c #AO include 'MAR_AO.inc'
c #PO include 'MAR_PO.inc'
c #SN include 'MAR_SV.inc'
c #AO include 'MAR_TV.inc'
c #sn include 'MAR_SN.inc'
c #BS include 'MAR_BS.inc'

c #OL include 'MAR_OL.inc'

      include 'MAR_IO.inc'
      include 'MARsSN.inc'      !*CL*


C +--Local Variables and DATA
C +  ========================

c #HP external zext
c #HP integer  zext

      logical  zoro
      logical  verti0
      integer  itever,itexpe2
c #NH integer  iyrONH,mmaONH,jdaONH,jhuONH
c #CA integer  iyrCVA,mmaCVA,jdaCVA,jhuCVA
c #HY integer  iyrHYD,mmaHYD,jdaHYD,jhuHYD
c #TC integer  iyrTCA,mmaTCA,jdaTCA,jhuTCA
      integer  iyrTUR,mmaTUR,jdaTUR,jhuTUR
      integer  iyrSOL,mmaSOL,jdaSOL,jhuSOL
c #PO integer  iyrPOL,mmaPOL,jdaPOL,jhuPOL
c #sn integer  iyrSNO,mmaSNO,jdaSNO,jhuSNO
      integer  imezdy,jmezdy,mzabs1,itizon
      integer  lo_CAU,ipri  ,iv_ini,n, isl

C +--Modified Time Step
C +  ~~~~~~~~~~~~~~~~~~
c #XF integer  YYtmp ,MMtmp ,DDtmp

      real     dtdom ,zmin_0,aavu_0,bbvu_0,ccvu_0,ps_sig
c #HF real     hham  ,nham  ,hhac  ,thac
      real     aladyn,alodyn,gradTz,rhcrit,tstart
      real     sh2(mx,my), sh3(mx,my,mw-1)

      character* 3 swich(0:1)
      data    swich/'OFF','ON '/
      data   ps_sig/100./


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ INITIALISATION of the DOMAIN CHARACTERISTICS +++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      open (unit=1,status='old',file='MARdom.dat')
      rewind     1
       read     (1,141)  explIO
 141   format   (a3)
       read     (1,145)  GElat0,GElon0,GEddxx
       read     (1,1425) mma0GE,jda0GE,jhu0GE,itizon,iyr0GE
 1425  format   (4i4,i4)
       read     (1,1426) imez  ,jmez  ,maptyp,GEtrue
 1426  format   (3i4,28x,e13.6)
       read     (1,1427) igrdIO
 1427  format   (5i4)
       read     (1,1427) jgrdIO
       read     (1,1427) IO_gen
                         IO_loc=IO_gen
       read     (1,1427) mxw1IO,mxw2IO,ixw_IO
       read     (1,1427) myw1IO,myw2IO,iyw_IO
       read     (1,1427) mzw1IO,mzw2IO,izw_IO
       read     (1,1427) kkatIO,kmidIO
C +...                   +-> For output on NetCDF Files: 
C +                          Assumed Levels of Bound.Layer / Mid Troposph.
       read     (1,145)  dx,dy,dtdom
 145   format   (4d13.6)
       read     (1,1450) verti0
 1450  format   (l3)
       read     (1,145)  ptopDY    
C +...                   ptopDY: model top pressure 
       read     (1,145)  zmin_0,aavu_0,bbvu_0,ccvu_0
       z__SBL          = zmin_0
       read     (1,145)  FIslot,FIslou,FIslop,FIkhmn
       read     (1,145)  TUkhff,TUkhmx
                                TUkhmx=TUkhmx*dtdom /dt
       read     (1,145)  tequil,dtquil
       read     (1,145)  zs_SL,zn_SL,zl_SL,cs2SL
       read     (1,145)  sst_SL  
       read     (1,145)  dtagSL
       read     (1,145)  w20SL,wg0SL,wk0SL,wx0SL

       read     (1,1430)
 1430  format   (1x)
       read     (1,143)  isolSL
 143   format   ((10i13))
       read     (1,1430)
       read     (1,1432) sh2
       if(itexpe<=1) then
        do i=1,mx; do j=1,my
         sh(i,j)=sh2(i,j)
        enddo    ; enddo
       endif
 1432  format   ((10d13.6))
       read     (1,1430)
       read     (1,1432) SL_z0
       read     (1,1430)
       read     (1,1432) SL_r0
       read     (1,1430)
       read     (1,1432) ch0SL
       read     (1,1430)
       read     (1,1432) rsurSL
       read     (1,1430)

C +--Underlaying Surface Albedo (to which Surface alb0SL is set,
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~  unless NOT 1st Run, itexpe.ne.0)
       read     (1,1432) albsSL
       do j=1,my
       do i=1,mx
           alb0SL(i,j) = albsSL(i,j)
       end do
       end do

       read     (1,1430)
       read     (1,1432) eps0SL
       read     (1,1430)
       read     (1,1432) d1_SL 

c #po  read     (1,1430)
c #po  read     (1,1432) uocnPO
c #po  read     (1,1430)
c #po  read     (1,1432) vocnPO
c #po  read     (1,1430)
c #po  read     (1,1432) aPOlyn

       IF (geoNST)                                                THEN
         read   (1,1430)
         read   (1,1432) ((GElonh(i,j),i=1,mx),j=1,my)
         read   (1,1430)
         read   (1,1432) ((GElatr(i,j),i=1,mx),j=1,my)
         read   (1,1430)
         read   (1,1432)    sigma

         DO j=1,my
         DO i=1,mx
           GElatr(i,j) = GElatr(i,j) * degrad  !  degrees --> radians
           GElonh(i,j) = GElonh(i,j) / 15.0    !  degrees --> hours
         END DO
         END DO

         DO k=1,mz
            zsigma(k) =-(sst_SL / 0.0065) *   ((1.e0+(sigma(k)     -1.)
     .                                        *(1.e2/ps_sig))
     .                                    ** (RDryAi*0.0065/gravit)-1.)
         END DO

         IF (IO_gen.ge.2)                                           THEN
           write(21,130)( sigma(k),k=1,mz)
 130       format(/,'  Sigma    Levels :',/,(1x,15f8.4))
           write(21,131)(zsigma(k),k=1,mz)
 131       format(/,'  Altitude Levels :',/,(1x,15f8.1))
         END IF
       END IF

C +--Orography Roughness
C +  ~~~~~~~~~~~~~~~~~~~
c #OR    DO k=1,mw
c #OR    DO j=1,my
c #OR    DO i=1,mx
c #OR       SLzoro(i,j,k) = SL_z0(i,j,k)
c #OR    END DO
c #OR    END DO
c #OR    END DO
c #OR       zoro = .TRUE.
c #RN       zoro = .FALSE.
c #OR    IF(zoro) 
c #OR.      STOP '@#! Uses Andreas parameterization of z0_h with z0_oro'
      close(unit=1)


C + ***   *CL* Read subgrid topography   ***
      IF (mw .eq. 5) then

      open (unit=555,status='old',file='MARdom2.dat')

      print*, '***************************'
      print*, '*   Read of MARdom2.dat   *'
      print*, '***************************'

       read     (555,'(f12.6)') sh3
       if(itexpe<=1) then
        do i=1,mx; do j=1,my
        do k=1,nsx-1
         sh_int(i,j,k)=sh3(i,j,k)
        enddo
         sh_int(i,j,nsx) = sh(i,j)
        enddo   ; enddo
       endif
      close(unit=555)

      ENDIF


C +--SVAT IO
C +  -------

c #TV   IF (vegmod.and.        .not.reaVAR)                       THEN

C +       ***********
c #TV     call SVAsav('read')
C +       ***********

c #TV   END IF


C +--Time Discretisation
C +  ===================

C +--Slow Dynamics
C +  -------------

      idt    = dt
      jdt    =(dt-idt)*100.


C +--Fast Dynamics
C +  -------------

      dtfast = dt     /(ntFast+1)


C +--Subgrids
C +  --------

      if (dtDiff.lt.dt)     then
       if(dtDiff.gt.0.)     then
          ntDiff =  dt / dtDiff
C +...    ntDiff :  Number of  Subgrid Scale Steps for 1 Dynamical Step

          dtDiff =  dt / ntDiff
C +...    dtDiff :  Calibrated Subgrid Scale Time Step

          jtDiff =   1
       else
          ntDiff =   1
          jtDiff =   nboucl * nprint + 1
       end if
      else
          jtDiff =       dtDiff / dt
          jtDiff =  max (jtDiff,1)
C +...    jtDiff :  Number of  Dynamical Steps for 1 Subgrid Scale Step

          dtDiff =  dt * jtDiff
C +...    dtDiff :  Calibrated Subgrid   Scale Time Step

          ntDiff =   1
      end if
      if (dtDiff.gt.0.)     then
cXF
          ntDiff =  1
          dtDiff =  dt
          jtPhys =  1
cXF
      end if


C +--Surface   Physics
C +  -----------------

      if (dtPhys.lt.dt) then
          ntPhys =  dt / dtPhys
C +...    ntPhys :  Number of  Surface Phys. Steps for 1 Dynamical Step

          dtPhys =  dt / ntPhys
C +...    dtPhys :  Calibrated Surface Phys. Time Step

          jtPhys =   1
      else
          jtPhys =       dtPhys / dt
          jtPhys =  max (jtPhys,1)
C +...    jtPhys :  Number of  Dynamical Steps for 1 Surface Phys. Step

          dtPhys =  dt * jtPhys
C +...    dtPhys :  Calibrated Surface Physics Time Step

          ntPhys =   1
      end if

cXF
          ntPhys =  1
          dtPhys =  dt
          jtPhys =  1
cXF


C +--Radiation Physics
C +  -----------------

      if (dtRadi.lt.dt) then
          write(6,*) ' NO Split Time Differ.  on dtRadi ',
     .               ' !!#¹@|#@&##!!     EMERGENCY EXIT '
          STOP
          ntRadi =  dt / dtRadi
C +...    ntRadi :  Number of  Surface Phys. Steps for 1 Dynamical Step

          dtRadi =  dt / ntRadi
C +...    dtRadi :  Calibrated Surface Phys. Time Step

          jtRadi2 =  1
      else
          jtRadi2 =       dtRadi / dt
C +...    jtRadi :  Number of  Dynamical Steps for 1 Surface Phys. Step

          dtRadi  =  dt * jtRadi2
C +...    dtRadi :  Calibrated Surface Physics Time Step

          ntRadi =   1
      end if


C +--Other Constants
C +  ---------------

      t2SLtn = 1.0/dtPhys-0.50/cs2SL
      t2SLtd = 1.0/dtPhys+0.50/cs2SL
      fracSL =      dt /0.6e3
      fracSL = min(unun,fracSL)
C +...fracSL : Fractional Time (Blowing Snow Srf Flux Computation)
C +            Factor   1.8d3 is the Turbulence Time Scale (1/2 h)
C +            Factor   0.6d3 is used.


C +--Coriolis Parameter
C +  ==================

      fcorDY(imez,jmez) = 2.0*earthv*sin(GElat0*degrad)
C +...fcorDY            : Coriolis Parameter (Indicative Value)


C +--OUTPUT
C +  ======

C +   ---------------------
      if (IO_loc.ge.1) then
C +   ---------------------

       write(21,600) explIO,GElat0,GElon0,
     .               jda0GE,mma0GE,jhu0GE,itizon,
     .                      minuGE,jsecGE,fcorDY(imez,jmez),cz0_GE
  600  format(/,' SIMULATION ',a3,/,' ++++++++++++++',//,
     . ' Lat.',f5.1,3x,'Long.',f6.1,4x,'Date :',i3,'-',i2,
     . ' / ',i2,' h.UT +(',i3,')LT',i3,' min.',i3,' sec.',
     .  //,' f(Coriolis) = ',e12.5,
     .   /,' cos(Z) min  : ',e12.5)

       write(21,601)
 601   format(//,' CODE STATUS',/,' +++++++++++',/,
c #DP./,'#DP DOUBLE PRECISION -- DOUBLE PRECISION -- DOUBLE PRECISION ',
c #//./,'#// Parallelisation Set Up is activated   (software MPI used)',
c #HF./,'#HF Initialisation of Huang and Lynch 1993   (HAMMING Filter)',

c #NH./,'#NH DYNAMICS: Non-Hydrost. Code  (adapted from Laprise, 1992)',
c #nh./,'#nh DYNAMICS: Non-Hydrost. Code  (Slope            Contribut)',
c #DH./,'#DH DYNAMICS: Non-Hydrost. Code  (Diabatic Heating Contribut)',
c #ON./,'#ON DYNAMICS: Non-Hydrost. Corr. (Weisman &al.1997 MWR p.541)',
c #DD./,'#DD DYNAMICS: Mass Divergence Damper (Skamarock &Klemp, 1992)',
c #VN./,'#VN DYNAMICS: Variable Number of Leap-Frog Loops (Fast Waves)',
c #IL./,'#IL DYNAMICS: PGF: SBL Fraction with  Air = Surface Temperat.',
c #GE./,'#GE DYNAMICS: Geographic Coordinates may be red in MARdom.dat',
c #CC./,'#CC DYNAMICS: Constant Coriolis Parameter = fcorDY(imez,jmez)',
c #2Z./,'#2Z DYNAMICS: Zonally Averaged Model (latitude = x-direction)',
c #HE./,'#HE DYNAMICS: NORLAM       Vertical Discretisation(29 Levels)',
c #lm./,'#lm DYNAMICS: LMDZ   Model Vertical Discretisation(11 Levels)',
c #PA./,'#PA DYNAMICS: Parish Model Vertical Discretisation(10 Levels)',
c #PV./,'#PV DYNAMICS: Large Scale Flow conserves Pot. Vort. (2D ONLY)',
c #pv./,'#pv DYNAMICS: Large Scale Flow conserves Pot. Temp. (2D ONLY)',
c #UW./,'#UW DYNAMICS: Advect.  3rd Accurate in Space Upstream Scheme ',
c #UP./,'#UP DYNAMICS: Vertical 1st Accurate in Space Upstream Scheme ',
c #ZU./,'#ZU DYNAMICS: Vertical Advection: Cubic Spline (4th accurate)',
c #ZO./,'#ZO DYNAMICS: Vertical Advection: Cubic Spline (+Open  SrfBC)',
c #UR./,'#UR DYNAMICS: Vertical Advection/ Upper Radiating Bound.Cond.',
c #EP./,'#EP DYNAMICS: Lateral Sponge included in    Horizontal Filter',
c #RB./,'#RB DYNAMICS: Lateral BC: Carpenter(1982) Sommerfeld Modified',
c #DA./,'#DA DYNAMICS: Lateral BC: Davies (1976) BC on Wind // Lat.B. ',
c #da./,'#da DYNAMICS: Lateral BC: Davies (1976) BC: K, nu  computed. ',
c #FB./,'#FB DYNAMICS: Lateral BC: Fixed in Horizontal Cubic Spline   ',
c #OB./,'#OB DYNAMICS: Lateral BC: Zero Gradient                      ',
c #OG./,'#OG DYNAMICS: Lateral BC: (Left) NO Nudging if relaxg=.false.',
c #ob./,'#ob DYNAMICS: Lateral BC: Zero Gradient (Subroutine LBC000)  ',
c #RF./,'#RF DYNAMICS: Top BC: Rayleight Friction in the Top Sponge   ',
c #Di./,'#Di DYNAMICS: Top BC: Dirichlet  (fixed)                     ',
c #V+./,'#V+ DYNAMICS: Top BC: Von Neuman (prescrib.non zero-gradient)',
c #PS./,'#PS DYNAMICS: Domain Averaged Pressure Thickness   maintained',
c #DY./,'#DY DYNAMICS: OUTPUT: Components  lowest Level Forces Balance',

c _PE./,'_PE DIFFUSION:(%Grad.)   Slope      USE+ _HH or     (_HH #CR)',
c #PE./,'#PE DIFFUSION:(%Deform.) Slope      USE+ #DF or (#DF #DC #CR)',
c _HH./,'_HH DIFFUSION:(%Grad.)   Vert.Cor.  USE+ _PE                 ',
c #DF./,'#DF DIFFUSION:(%Deform.) Vert.Cor.  USE+ #PE or (#PE #DC #CR)',
c #DC./,'#DC DIFFUSION:(%Deform.)            USE+        (#DF #PE #CR)',
c #CR./,'#CR DIFFUSION: Cross Corr.    USE+ (_PE _HH) or (#DF #PE #DC)',

c #FE./,'#FE FILTERING: Digital Filtering of TKE                      ',
c #fe./,'#fe FILTERING: Digital Filtering of TKE  is   not vectorized ',
c #FO./,'#FO FILTERING: Digital Filtering of TKE (zero gradient at LB)',
c #KS./,'#KS FILTERING: Upper Sponge is solved by horizontal filtering',

c #BR./,'#BR TURBULENCE: 2.5 Level  2nd Order  (Brasseur         1997)',
c #CA./,'#CA CONVECTIVE  Adjustment (general                 Set Up)  ',
c #cA./,'#cA CONVECTIVE  Adjustment (no Double Counting      Set Up)  ',
c #ca./,'#ca CONVECTIVE  Adjustment (no Vector               Set Up)NV',
c #FC./,'#FC CONVECTIVE  Adjustment (Fritsch & Chappell 1980 Set Up)  ',
c #fc./,'#fc CONVECTIVE  Adjustment (Fritsch & Chappell 1980 Set Up)NV',
c #kf./,'#kf CONVECTIVE  Adjustment (Kain    & Fritsch  1990 Improvm.)',
c #IT./,'#IT CONVECTIVE  Adjustment (over 5km Adiabatics Starting Pts)',
c #AN./,'#AN CONVECTIVE  Adjustment (Subgrid Mountain Breeze included)',
c #WD./,'#WD CONVECTIVE  Adjustment (Water Detrainment       included)',
c #CG./,'#CG CONVECTIVE  Adjustment (Cloud Glaciation        included)',
c #ND./,'#ND CONVECTIVE  Adjustment (No Precip if LevFSink<LiftCond.L)',
c #vT./,'#vT CONVECTIVE  Adjustment (Virtual Temperature  is computed)',
c #PB./,'#PB CONVECTIVE  Adjustment (Peter Bechtold     2000 Set Up)  ',
c #pb./,'#pb CONVECTIVE  Adjustment (Peter Bechtold     2000 Set Up)NV',
c #KE./,'#KE CONVECTIVE  Adjustment (Emanuel & Zivkovic 1999 Set Up)  ',

c #LE./,'#LE TURBULENCE: K  : Louis                      (1979) BLM 17',
c #Kl./,'#Kl TURBULENCE: K-l: Therry & Lacarrere         (1983) BLM 25',
c #PD./,'#PD TURBULENCE: K-e: Original Duynkerke         (1988) JAS 45', 
c #TA./,'#TA TURBULENCE: K-e: Dissipation + Advect.Horiz.TKE Transport', 
c #TD./,'#TD TURBULENCE: K-e: Dissipation + Diffus.Horiz.TKE Transport', 
c #AV./,'#AV TURBULENCE: K-e: Buoyancy includes      Aerosol Loading  ', 
c #HR./,'#HR TURBULENCE: K-e: Huang & Raman              (1991) BLM 55',
c #KI./,'#KI TURBULENCE: K-e: Kitada                     (1987) BLM 41',
c #BH./,'#BH TURBULENCE: K-e: Kitada (modified)           USE with #KI',
c #KC./,'#KC TURBULENCE: T.K.E.(mz1) := T.K.E.(mz)                    ',
c #KA./,'#KA TURBULENCE: T.K.E. & e(T.K.E.) Filter along the vertical ',
c #AM./,'#AM TURBULENCE: u*   Time Mean (BOX Moving Average)          ',
c #AT./,'#AT TURBULENCE: u*T* Time Mean (BOX Moving Average)          ',
c #AS./,'#AS TURBULENCE: u*s* Time Mean (BOX Moving Average)          ',
c #VX./,'#VX TURBULENCE: u*q* limited to SBL Saturat. Specif. Humidity',
c #De./,'#De TURBULENCE: Top BC: Dirichlet (fixed) (ect_TE and eps_TE)',
c #WE./,'#WE TURBULENCE: T.K.E. OUTPUT on File MAR.TKE                ',
c #AE./,'#AE TURBULENCE: Aerosols Erosion / Turbulent Diffusion Coeff.',
c #SY./,'#SY TURBULENCE: Sea Spray Parameterization (Andreas, 199x) ON',

c #DU./,'#DU SBL: Univ.Funct.:    Duynkerke(1991)                     ',
c #BU./,'#BU SBL: Univ.Funct.:    Businger (1973)  USE with _NO OR #NO',
c _NO./,'_NO SBL: Univ.Funct.: NO Noilhan  (1987)  USE with #BU OR #DR',
c #NO./,'#NO SBL: Univ.Funct.:    Noilhan  (1987)  USE with #BU       ',
c #DR./,'#DR SBL: Univ.Funct.:    Dyer     (1974)  USE with _NO       ',
c #LP./,'#LP SBL: Blowing Snow Fric. Veloc. Thr. (Li and Pomeroy 1997)',
c #DS./,'#DS SBL: Blowing Snow SBL   Flux   (analytical Form of dq/dz)',
c #ZS./,'#ZS SBL: Mom.: Roughn.Length= F(u*) Chamberlain (1983),  Sea ',
c #ZN./,'#ZN SBL: Mom.: Roughn.Length= F(u*) Shao  & Lin (1999), Snow ',
c #ZA./,'#ZA SBL: Mom.: Roughn.Length= F(u*) Andreas &al.(2004), Snow ',
c #RN./,'#RN SBL: Heat: Roughn.Length= F(u*,z0)  Andreas (1987)       ',
c #ZM./,'#ZM SBL: M/H   Roughn.Length: Box Moving Average (in Time)   ',
c #OR./,'#OR SBL: Orography Roughness included from SL_z0 in MARdom   ',
c #SB./,'#SB Surface Boundary: modified externally (from Campain Data)',
c #TI./,'#TI Turbul. Heat Surface Flux: Implicit numerical Scheme     ',
c #QE./,'#QE Turbul. H2O  Surface Flux: Explicit numerical Scheme     ',
c #FI./,'#FI Turbul. Mom. Surface Flux: Implicit numerical Scheme     ',
c #BI./,'#BI Blowing Snow Surface Flux: Implicit numerical Scheme     ',

c #OL./,'#OL TEST:      Linear Mountain Wave: Specific IO    (2D ONLY)',
c #OM./,'#OM TEST: (Non)Linear Mountain Wave: Specific INPUT (2D ONLY)',
c #OS./,'#OS TEST:      Linear Mountain Wave: Specific IO    (2D ONLY)',
c #GR./,'#GR TEST: LBC: 10C/d  Atmos.Cooling at Model Center (2D ONLY)',
c #K1./,'#K1 TEST: LBC: Katab. Atmos.Warming                 (1D ONLY)',
c #EK./,'#EK TEST: EKMAN Spiral: Constant Vertical Turbul. Coefficient',
c #CL./,'#CL TEST: Convective Mixed Layer Test         (HS = 100 W/m2)',
c #NL./,'#NL TEST: Nearly   Neutral Layer Test         (HS =   0 W/m2)',

c #TC./,'#TC TraCer   Advection-Diffusion Equation        is turned ON',
c #tc./,'#tc TraCer   Filtering is  not vectorized                    ',
c #TO./,'#TO TraCer   Open Lateral Boundary Conditions on digit.Filter',
c #TS./,'#TS TraCer   Tracer Deposition diagnostic        is turned ON',
c #BD./,'#BD TraCer   Aeolian Erosion  Submodel           is turned ON',
c #DV./,'#DV TraCer   Aeolian Erosion  Submodel: Air Loading by Dust  ',
c #CH./,'#CH Chemical Atmospheric         Model       may be turned ON',
c #MV./,'#MV TraCer   Total Mass          Verification    is turned ON',

c #HY./,'#HY Explicit Cloud MICROPHYSICS              may be turned ON',
c #hy./,'#hy Explicit Cloud MICROPHYSICS: NO Vectorisation Optmization',
c #HM./,'#HM Explicit Cloud MICROPHYSICS: Hallett-Mossop Ice Multipl. ',
c #hm./,'#hm Explicit Cloud MICROPHYSICS: Hallett-Mossop Ice Mult.  NV',
c #LI./,'#LI Explicit Cloud MICROPHYSICS: Lin et al. (1983) Autoconv. ',
c #BS./,'#BS Explicit Cloud MICROPHYSICS: Blow. *(Snow)         Model ',
c #HV./,'#HV Explicit Cloud MICROPHYSICS: Air Loading by Hydrometeors ',
c #BV./,'#BV Explicit Cloud MICROPHYSICS: SBL Loading by all Water Sp.',
c #bv./,'#bv Explicit Cloud MICROPHYSICS: SBL Loading not vectorized  ',
c #SS./,'#SS Explicit Cloud MICROPHYSICS: Blow. *(Snow)  Linear Model ',
c #S0./,'#S0 Explicit Cloud MICROPHYSICS: Blow. *(Byrd)  Linear Model ',
c #EM./,'#EM Explicit Cloud MICROPHYSICS: de Montmollin Parameterizat.',
c #BW./,'#BW Explicit Cloud MICROPHYSICS: Blowing Snow Statistics     ',
c #b2./,'#b2 Explicit Cloud MICROPHYSICS: Blowing Snow Statistics (II)',
c #EV./,'#EV Explicit Cloud MICROPHYSICS: Snow Erosion Statistics     ',
c #HW./,'#HW Explicit Cloud MICROPHYSICS: OUTPUT of qr,qs, qw,qi on NC',
c #EW./,'#EW Explicit Cloud MICROPHYSICS: OUTPUT (Ener./Mass) (Unit 6)',
c #WH./,'#WH Explicit Cloud MICROPHYSICS: OUTPUT              (Unit 6)',
c #WQ./,'#WQ Explicit Cloud MICROPHYSICS: OUTPUT (Full Verif) (Unit 6)',
c #WB./,'#WB Explicit Cloud MICROPHYSICS: Water Conservation Controled',
c #WW./,'#WW Explicit Cloud MICROPHYSICS: Water Conservation Summary  ',
c #ww./,'#WW Explicit Cloud MICROPHYSICS: Water Conservation Summary +',
c #WF./,'#WF Explicit Cloud MICROPHYSICS: Water Conservation is Forced',
c #HO./,'#HO Explicit Cloud MICROPHYSICS: Zero-Gradient Lat.Bound.Cond',

c #MR./,'#MR PHYSICS: MARrad: Solar/Infrared     (Laurent LI set up)  ',
c #AZ./,'#AZ PHYSICS: Solar : Direct Radiation:   Surface Slope Impact',
c #MM./,'#MM PHYSICS: Solar : Direct Radiation:   Mountains Mask    ON',
c #TR./,'#TR PHYSICS: Solarn: Clear Sky, without Underlying Reflection',
c #EE./,'#EE PHYSICS: radCEP: ECMWF   routine    (cfr. JJ Morcrette)  ',
c #LL./,'#LL PHYSICS: radLMD: radlwsw routine    (Laurent LI set up)  ',
c #ll./,'#ll PHYSICS: radLMD: radlwsw routine    (Laurent LI set up)NV',
c #AR./,'#AR PHYSICS: radLMD: radlwsw routine Interactive Terr.Aerosol',
c #WL./,'#WL PHYSICS: radLMD: radlwsw routine IO (Laurent LI set up)  ',

c #SA./,'#SA PHYSICS: MAR Code behaves  as a Stand Alone Surface Model',

c #FR./,'#FR Surface Model: Force Restore (Deardorff) at least   is ON',
c #WG./,'#WG Soil Humidity: Force Restore (Deardorff) may be turned ON',

c #AO./,'#AO COUPLING with  NEMO  Ocean-Sea-Ice Model using OASIS     ',

c #PO./,'#PO POLYNYA Model                            may be turned ON',
c #FD./,'#FD POLYNYA Model: Sea-Ice Velocity is Free Drift            ', 
c #HA./,'#HA POLYNYA Model: POLYNYA Surface Energy Balance:  2000 W/m2',
c #HI./,'#HI POLYNYA Model: Hibler (1979) Parameteriz. of Ice Strength',
c #CN./,'#CN POLYNYA Model: Prescription of a Local Avective Time Step',
c #ST./,'#ST EVOLUTIVE SST (Sea Surface Temperature/Swab Ocean)       ',
c #RE./,'#RE PRESCRIB. SST (Sea Surface Temperature/Reynolds DATA Set)',

c #SN./,'#SN SNOW Model                               may be turned ON',
c #AB./,'#AB SNOW Model: Interactive Albedo f(Grain) (Brun et al.1991)',
c #AG./,'#AG SNOW Model: Snow Aging Col de Porte     (Brun et al.1991)',
c #CZ./,'#CZ SNOW Model: Zenithal Angle Correction  (Segal et al.1991)',
c #DG./,'#DG SNOW Model: Snow Settling when Melting | Minimum Density ',
c #Se./,'#Se SNOW Model: Energy Conserv. Verific.: Summary, Output    ',
c #SE./,'#SE SNOW Model: Energy Conserv. Verific.: Summary, Output+   ',
c #SF./,'#SF SNOW Model: Energy Conserv. Verific.: Forcing, Conduction',
c #SW./,'#SW SNOW Model: Water  Conserv. Verific.: Melting, Freezing  ',
c #HS./,'#HS SNOW Model: Hardened SNOW Pack Initialization            ',
c #MA./,'#MA SNOW Model: Increased polar B* Mobility (Mann et al.2000)',
c #NP./,'#NP SNOW Model: Fallen Snow Density = f(V)  (Kotlyakov, 1961)',
c #SD./,'#SD SNOW Model: Antarct.,Fallen Snow Density (NP must be OFF)',
c #RU./,'#RU SNOW Model: Slush:  Internal Run OFF of Water Excess     ',
c #GK./,'#GK SNOW Model: Interactive Albedo (Greuell &Konzelmann 1994)',
c #SL./,'#SL SNOW Model: Interactive Albedo (Zuo     &Oerlemans  1995)',
c #SM./,'#SM SNOW Model: Melting/Freezing Diagnostics                 ',
c #SZ./,'#SZ SNOW Model: Z0 Dependance on varying Sastrugi Height     ',
c #TZ./,'#TZ SNOW Model: Z0 (Momentum) (typical value in polar models)',
c #CP./,'#CP SNOW Model: For Validation on Col de Porte Data          ',
c #GL./,'#GL SNOW Model: ETH-Camp & Greenland 3D simulations          ',

c #AP./,'#AP PROJECTION: Antarct., Oblique Stereo. Proj., EPSG 3031   ',
c #PP./,'#PP PROJECTION: Polar Stereographic Projection               ',

c #TV./,'#TV Soil /Vegetation Variables                  are used     ',
c #GP./,'#GP Soil /Vegetation Model: LAI, GLF Variations NOT prescrib.',
c #LN./,'#LN Soil /Vegetation Model: LAI(x,y,t) prescribed(MARglf.DAT)',
c #SV./,'#SV Soil /Vegetation Model (Koen De Ridder)  may be turned ON',
c #SH./,'#SH Soil /Vegetation Model: Hapex-Sahel   Vegetation     DATA',
c #V1./,'#V1 Soil /Vegetation Model: (KD) Vegetat. IGBP Classification',
c #V2./,'#V2 Soil /Vegetation Model: (KD) Vegetat. MAR  Classification',

c #GA./,'#GA SISVAT: Soil Humidity Geometric Average at Layer Interfac',
c #GF./,'#GF SISVAT: Gravitational Saturation Front          turned ON',
c #GH./,'#GH SISVAT: Gravitational Saturation Front - Horton turned ON',
c #OP./,'#OP SISVAT: Interactive Sea Surface Temperature     turned ON',
c #op./,'#op SISVAT: SST Nudging -->   prescribed values     turned ON',
c #IP./,'#IP SISVAT: Sea-Ice Fraction prescribed from SMMR and SSM/I  ',
c #SI./,'#SI SISVAT: Sea-Ice Fraction calculated from prescribed SST  ',
c #IA./,'#IA SISVAT: Sea-Ice Bottom   accretion  and  ocean cooling   ',
c #MT./,'#MT SISVAT: Monin-Obukhov Theory is linearized (Garrat schem)',
c #SR./,'#SR SISVAT: traces & OUTPUT a variable among called routines ',
c #WV./,'#WV SISVAT: performs OUTPUT on an ASCII File (1 file each pt)',
c #sa./,'#sa SISVAT: must be pre-processed, except for stand-alone run',

c #CS./,'#CS  INPUT: Constant Sounding during 1st Hours     (2-D ONLY)',

c #IB./,'#IB OUTPUT: Ice-Sheet Surface Mass Balance  (on MARphy File )',
c #ID./,'#ID OUTPUT: Main Dependant Variables        (on NetCDF File )',
c #UL./,'#UL OUTPUT: Time Dimension is UNLIMITED     (on NetCDF File )',
c #T2./,'#T2 OUTPUT: 2-m  Air Temperature            (on NetCDF File )',
c #W6./,'#W6 OUTPUT, Additional: Simulation Statistics      on MAR.log',
c #w6./,'#w6 OUTPUT, Additional: Simulation Statistics (NH) on MAR.log',
c #WA./,'#WA OUTPUT, Additional:                            DYNadv_ver',
c #WR./,'#WR OUTPUT, Additional: INIsnd, infra, SRFmod_sno, SRFmod_pol',

c #vL./,'#vL PORTABILITY: Vectorization enhanced                      ',
c #vN./,'#vN PORTABILITY: Vectorization enhanced: Leap Frog Counter   ',
c #vK./,'#vK PORTABILITY: Vectorization enhanced: TKE                 ',
c #vH./,'#vH PORTABILITY: Vectorization enhanced: Hydrological Cycle  ',
c #vB./,'#vB PORTABILITY: Vectorization enhanced: Blowing  Snow *     ',
c #vD./,'#vD PORTABILITY: Vectorization enhanced: Blowing  Dust .     ',
c #vR./,'#vR PORTABILITY: Vectorization enhanced: Sastrugi Height     ',
c #vS./,'#vS PORTABILITY: Vectorization enhanced: Snow     Model      ',
c #vV./,'#vV PORTABILITY: Vectorization enhanced: SVAT                ',
c #vZ./,'#vZ PORTABILITY: Vectorization enhanced: Av.Roughness Length ',
c #HP./,'#HP PORTABILITY: Enables use of own    library on Linux Syst.',
c #NV./,'#NV PORTABILITY: Vectorization  is     turned  OFF           ',
     .   1x                                                            )

       write(21,602)
     .   reaVAR,swich(-zext(reaVAR)),reaLBC,swich(-zext(reaLBC)),
     .   safVAR,swich(-zext(safVAR)),hamfil,swich(-zext(hamfil)) 
 602   format(//,' OPTIONS',/,' +++++++',/,
     &     /,'  reaVAR=',l2,4x,' => Input: Prev.Dyn.Sim.(MAR/GCM) ',a3,
     &     /,'  reaLBC=',l2,4x,' => LBC:   Prev.Dyn.Sim.(MAR/GCM) ',a3,
     &     /,'  safVAR=',l2,4x,' => Saving    on Files MARxxx.DAT ',a3,
     &     /,'  hamfil=',l2,4x,' => Diabatic Initialisation       ',a3)
c #HF       if (hamfil) write(21,603) hham,nham,hhac,thac
  603  format(
     &       '  Hamming Filter Characteristics:',
     &     /,'   Time       =',f11.4,  '=> N(Hamming)= ',i12,
     &     /,'   Cutoff     =',f11.4,  '=> Frequency = ',f12.4,/,1x)
C +
       rhcrit = 0.0
       tstart = 0.0
c #HY  rhcrit = rhcrHY
c #HY  tstart = tim_HY
       write(21,604)
     .   conmas,swich(-zext(conmas)),potvor,swich(-zext(potvor)),
     .   brocam,swich(-zext(brocam)),turhor,swich(-zext(turhor)),
     .   convec,swich(-zext(convec)),
     .   micphy,swich(-zext(micphy)),1.d+2*rhcrit,tstart,
     .   fracld,swich(-zext(fracld)),
     .   chimod,swich(-zext(chimod)),
     .   physic,swich(-zext(physic)),
     .   snomod,swich(-zext(snomod)),polmod,swich(-zext(polmod)),fxlead,
     .   vegmod,swich(-zext(vegmod)),qsolSL,swich(-zext(qsolSL)),
     .   rxbase,rxfact
 604   format(
     &       '  conmas=',l2,4x,' => Mass  Conservation Constraint ',a3,
     &     /,'  potvor=',l2,4x,' => PV    Conservation Constraint ',a3,
     &     /,'  brocam=',l2,4x,' => Brown and Campana Time Scheme ',a3,
     &     /,'  turhor=',l2,4x,' => Horizontal Diffusion          ',a3,
     &     /,'  convec=',l2,4x,' => Mass Flux convective Scheme   ',a3,
     &     /,'  micphy=',l2,4x,' => Cloud Microphysics            ',a3,
     &     /,'  rhcrHY=',f6.0, ' %  Critical Relative Humidity Value  ',
     &     /,'  tim_HY=',f6.0, '    Cloud Microphysics Starting Time  ',
     &     /,'  fracld=',l2,4x,' => Fractional Cloudiness Scheme  ',a3,
     &     /,'  chimod=',l2,4x,' => Chemical Atmospheric  Model   ',a3,
     &     /,'  physic=',l2,4x,' => Atmosphere / Surface  Physics ',a3,
     &     /,'  snomod=',l2,4x,' => Interactive Snow      Model   ',a3,
     &     /,'  polmod=',l2,4x,' => Interactive Polynya   Model   ',a3,
     &     /,'  fxlead=',f5.2,'     Initial Minimal Lead   Fraction    ',
     &     /,'  vegmod=',l2,4x,' => Interactive SVAT      Model   ',a3,
     &     /,'  qsolSL=',l2,4x,' => Soil Humidity         Model   ',a3,
     &     /,'  rxbase=',f6.3, '    Nudging Coeff.(Anthes et al. 1989)',
     &     /,'  rxfact=',f6.1, '    Lateral Sponge Coefficient   (A89)')
C +
       write(21,605) dx,mx,dy,my,
     .               dt    ,dtfast,ntFast,
     .               center,nordps,staggr,
     .               dtRadi,jtRadi,ntRadi,
     .               dtPhys,jtPhys,ntPhys,
     .               dtDiff,jtDiff,ntDiff,
     .               FIslot,FIkhmn,TUkhff,TUkhmx,FIslou,FIslop
  605  format(//,' MAR DISCRETISATION',/,' ++++++++++++++++++',
     & //,'  dx         =',f8.1,' m   /  Nb Points : ',i12,
     &  /,'  dy         =',f8.1,' m   /  Nb Points : ',i12,
     &  /,'  dt         =',f8.1,' sec',
     &  /,'  dt Lamb    =',f8.1,' sec',
     &  /,'  nt Lamb    =',i6,
     &  /,'  p* Discret.=',l6,5x,  '  /  p* Precis.= ',i12,
     &  /,'  Vert.Stagg.=',l6,
     & //,'  dt Sol./IR =',f8.1,' sec => jt Sol./IR= ',i12,
     &  /,'                              nt Sol./IR= ',i12,
     & //,'  dt Surface =',f8.1,' sec => jt Surface= ',i12,
     &  /,'                              nt Surface= ',i12,
     &  /,                             ' CAUTION: := dt',
     & //,'  dt Turbul. =',f8.1,' sec => jt Turbul.= ',i12,
     &  /,'                           /  nt Turbul.= ',i12,
     &  /,                             ' CAUTION: := dt',
     & //,'  delta T    =',f11.4,  '  => Kh(delta) = ',e12.4,
     &  /,'              ', 11x ,  '  -- fac. (Kh) = ',f12.4,
     &  /,'  Absorbing Layer          -> Kh max    = ',e12.4,
     &  /,'  delta u    =',f11.4,
     &  /,'  delta p    =',f11.4)
C +
C +
C +   ------
      end if
C +   ------
C +
C +
C +--WARNINGS
C +  ========
C +
C +--Time Step
C +  ---------
C +
      if (abs(dt-dtdom).gt.epsi) write(6,2) dt,dtdom
 2    format(/,' ***********************************',
     .          '********************************',
     .       /,' * CAUTION: dt(MARctr.dat)=',f8.2,'s',
     .          ' .ne. dt(MARdom.dat)=',f8.2,'s *',
     .       /,' ***********************************',
     .          '********************************',/,1x)
C +
C +
C +--Topography 
C +  ----------
C +
                                                 lo_CAU =  0
      IF (n7mxLB.gt.1)                                            THEN
        DO j=1,my
        DO i=1,n7mxLB-1
          if (abs(sh(i,j)-sh(ip1(i),j)).gt.epsi) lo_CAU =  1
        END DO
        END DO
      END IF
C +
      IF (n6mxLB.gt.0)                                            THEN
        DO j=1,my
        DO i=mx-n6mxLB+1,mx
          if (abs(sh(i,j)-sh(im1(i),j)).gt.epsi) lo_CAU =  1
        END DO
        END DO
      END IF
C +
      IF (n7myLB.gt.1)                                            THEN
        DO j=1,n7myLB-1
        DO i=1,mx
          if (abs(sh(i,j)-sh(i,jp1(j))).gt.epsi) lo_CAU =  1
        END DO
        END DO
      END IF
C +
      IF (n6myLB.gt.0)                                            THEN
        DO i=1,mx
        DO j=my-n6myLB+1,my
          if (abs(sh(i,j)-sh(i,jm1(j))).gt.epsi) lo_CAU =  1
        END DO
        END DO
      END IF
C +
       if (lo_CAU.eq.1) 
     . write(6,1)
 1     format(' ***********************************',
     .         '*******************************',
     .      /,' * CAUTION: Lateral Sponge too large',
     .        ' OR Lateral Plateau too small *',
     .      /,' ***********************************',
     .         '*******************************',/,1x)


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ INITIALISATION INCLUDING A SAVED STATE OF THE VARIABLES ++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +   +++++++++++                                                 ++++
      IF (reaVAR)                                                 THEN 
C +   +++++++++++                                                 ++++


C +--Timing  
C +  ======

          iterun = 0


C +--Dynamics
C +  ========

          open (unit=11,status='old',form='unformatted',
     .                               file='MARdyn.DAT')
          rewind     11
c         read      (11) itexpe2,jdh_LB ; itexpe=itexpe2  ! if itexpe is integer*4 in NESTOR
          read      (11) itexpe ,jdh_LB                   ! if itexpe is integer*8 in NESTOR
          read      (11) iyrDYN,mmaDYN,jdaDYN,jhuDYN
C +...    Time    Parameters

C +--Modified Time Step (BEGIN)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~
c #XF     open  (unit=51,status='old',file='MARtime.ctr',err=51)
c #XF     read  (51,*,err=51) YYtmp,MMtmp,DDtmp,dt_old,dt_new
 51       continue
c #XF     close (51)

c #XF     if( YYtmp .eq. iyrDYN .and. MMtmp .eq. mmaDYN .and.
c #XF.        DDtmp .eq. jdaDYN .and.
c #XF.        dt_old.gt. 0      .and. dt_new.gt. 0) then
c #XF      write(6,*) ' '
c #XF      write(6,*) 'WARNING-WARNING-WARING-WARING-WARNING'
c #XF      write(6,*) 'itexpe modified by MARtime.ctr'
c #XF      write(6,*) 'dt_old =',dt_old
c #XF      write(6,*) 'dt_new =',dt_new
c #XF      write(6,*) 'WARNING-WARNING-WARING-WARING-WARNING'
c #XF      write(6,*) ' '
c #XF      itexpe = (itexpe*dt_old)/dt_new
c #XF     endif
C +--Modified Time Step   (END)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~

          read      (11) imezdy,jmezdy
          read      (11) aladyn,alodyn
C +...    Spatial Parameters

          read      (11) sigma,ptopDY,dx,dy
C +...    Discretisation

          read      (11) uairDY
          read      (11) vairDY
          read      (11) pktaDY
          read      (11) pstDY
          read      (11) qvDY
C +...    Dynamics

          read      (11) sh

c         MAR-GRISLI coupling
c #GL     call ice_sheet_model_coupling

          read      (11) pstDY1

          read      (11) iyr_LB,mma_LB,jda_LB,jhu_LB,jdh_LB
          read      (11) vaxgLB,vaxdLB,vayiLB,vaysLB
C +...    Lateral Boundary Conditions

          read      (11) sst_LB

          read      (11) uairUB,vairUB,pktaUB
C +...    Upper   Sponge   Reference State

          IF (jdh_LB.le.0)                                        THEN
            write(6,6000)jdh_LB
 6000       format(/,'############################################',
     .             /,'# CAUTION: previous jdh_LB =',i6,' set:= 1 #',
     .             /,'############################################',/)

                         jdh_LB = 1
          END IF

          IF (itexpe.GT.0)                                        THEN
              read  (11) pstDYn
              read  (11) RAd_ir
              read  (11) IRsoil
              read  (11)  virDY
              read  (11) tim1LB,v1xgLB,v1xdLB,v1yiLB,v1ysLB
              read  (11) tim2LB,v2xgLB,v2xdLB,v2yiLB,v2ysLB
              read  (11) sst1LB,sst2LB
              read  (11) ua1_UB,ua2_UB
              read  (11) va1_UB,va2_UB
              read  (11) pkt1UB,pkt2UB
            IF (  my.EQ.1)                                        THEN
              read  (11) ugeoDY
              read  (11) vgeoDY
c #PV       stop '    ?!&~@|@[#@#  PV not conserved! EMERGENCY STOP'
            END IF
          END IF

          close(unit=11)


C +--sigma-levels Height
C +  -------------------

          DO k=1,mz
             zsigma(k) =-(sst_SL / 0.0065) *   ((1.e0+(sigma(k)     -1.)
     .                                         *(1.e2/ps_sig))
     .                                     ** (RDryAi*0.0065/gravit)-1.)
          END DO

          IF (IO_gen.ge.2)                                          THEN
            write(21,130)( sigma(k),k=1,mz)
            write(21,131)(zsigma(k),k=1,mz)
          END IF


C +--Auxiliary Grid Parameters
C +  -------------------------

C +       ***********
          call GRDmar
C +       ***********


C +--Geographical Coordinates 
C +  ------------------------

C +       ***********
          call GRDgeo
C +       ***********


C +--Local Time of the Model Center
C +  ------------------------------

C +       ***********
          call TIMcur
          call TIMgeo
C +       ***********


C +--LBC Coefficients
C +  ----------------

          IF (itexpe.EQ.0)                                        THEN
          tim1LB=ou2sGE(iyr_LB,mma_LB,jda_LB,jhu_LB,0,0)    
          tim2LB=   tim1LB                                             

          DO   iv_ini=1,5
            DO i=1,n7mxLB
            DO k=1,mz
            DO j=1,my
              v1xgLB(i,j,k,iv_ini) = vaxgLB(i,j,k,iv_ini)
              v2xgLB(i,j,k,iv_ini) = vaxgLB(i,j,k,iv_ini)
            END DO
            END DO
            END DO

            DO i=mx-n6mxLB,mx
            DO k=1,mz
            DO j=1,my
              v1xdLB(i,j,k,iv_ini) = vaxdLB(i,j,k,iv_ini)
              v2xdLB(i,j,k,iv_ini) = vaxdLB(i,j,k,iv_ini)
            END DO
            END DO
            END DO

            DO j=1,n7myLB
            DO k=1,mz
            DO i=1,mx
              v1yiLB(i,j,k,iv_ini) = vayiLB(i,j,k,iv_ini)
              v2yiLB(i,j,k,iv_ini) = vayiLB(i,j,k,iv_ini)
            END DO
            END DO
            END DO

            DO j=my-n6myLB,my
            DO k=1,mz
            DO i=1,mx
              v1ysLB(i,j,k,iv_ini) = vaysLB(i,j,k,iv_ini)
              v2ysLB(i,j,k,iv_ini) = vaysLB(i,j,k,iv_ini)
            END DO
            END DO
            END DO
          END DO
          END IF

C +       ***************
          call LBCnud_ini
C +       ***************

C +       ***************
c #DA     call LBCnud_par     
C +       ***************


C +--Soil Model
C +  ==========

          open (unit=11,status='old',form='unformatted',
     .                               file='MARsol.DAT')
          rewind     11
          read      (11) itever
          read      (11) iyrSOL,mmaSOL,jdaSOL,jhuSOL
          if (itever.ne.itexpe.or.
     .        iyrSOL.ne.iyrDYN.or.
     .        mmaSOL.ne.mmaDYN.or.
     .        jdaSOL.ne.jdaDYN.or.
     .        jhuSOL.ne.jhuDYN)    
     .     write(6,817)
 817       format(' ++WARNING++ MARsol improperly specified ')

          read      (11) nSLsrf
          read      (11) SLsrfl
          read      (11) TairSL
          read      (11) tsrfSL
          read      (11) alb0SL,eps0SL
          read      (11) SaltSL
          read      (11) ro_SL0
          read      (11) ro_SL
          read      (11) d1_SL
          read      (11) t2_SL
          read      (11) w2_SL,wg_SL
          read      (11) roseSL
          read      (11) qvapSL  
          read      (11) hsnoSL  
          read      (11) hmelSL  

          read      (11) SLuusl,SL_z0
          read      (11) SLutsl,SL_r0

          IF (itexpe.GT.0)                                        THEN
            read    (11) pktaSL
            read    (11) sicsIB
            read    (11) sic1sI,sic2sI
            read    (11) albeSL
            read    (11) SLuus ,SLuts
            read    (11) SLuqs ,SLuqsl
            read    (11) duusSL
            read    (11) dutsSL
            read    (11) cdmSL ,cdhSL
c #AW       read    (11) V_0aSL
c #AH       read    (11) dT0aSL
c #AM       read    (11) u_0aSL
c #AT       read    (11) uT0aSL
c #AS       read    (11) us0aSL
c #VX       read    (11) WV__SL
            read    (11) SLlmo ,SLlmol
c #BV       read    (11)  virSL
          END IF




          close(unit=11)


c #IP     IF (itexpe.eq.0)                                          THEN
c #IP       open (unit=11,status='old',form='unformatted',
c #IP.            file='MARsic.DAT')
c #IP       rewind     11
c #IP       read      (11) iyr_sI,mma_sI,jda_sI,jhu_sI,jdh_sI
c #IP       read      (11) sicsIB
c #IP       close(unit=11)
c #IP     END IF


C +--Update of Soil Parameters
C +  -------------------------

                Tfr_LB = tfrwat
c #RE           Tfr_LB = tfrwat +0.15 +epsi

          DO j=1,my
          DO i=1,mx

          IF   (isolSL(i,j).le.2)                                 THEN

C +---1. Open Water
C +   ~~~~~~~~~~~~~
            IF (sst_LB(i,j).ge. Tfr_LB)                           THEN
                isolSL(i,j)   = 1
                 d1_SL(i,j)   = 2.09e+8
                albeSL(i,j)   = 0.10
                eps0SL(i,j)   = 0.97
                 SL_z0(i,j,1) =          zs_SL
                 SL_r0(i,j,1) = 0.1     *zs_SL
                 ch0SL(i,j)   = 0.00132
                rsurSL(i,j)   = 0.0

C +---2. Sea Ice
C +   ~~~~~~~~~~
            ELSE
                isolSL(i,j)   = 2
                 d1_SL(i,j)   = 1.05e+5
                albeSL(i,j)   = 0.70
                eps0SL(i,j)   = 0.97
                 SL_z0(i,j,1) =          zn_SL
                 SL_r0(i,j,1) = 0.1     *zn_SL
                 ch0SL(i,j)   = 0.0021
C +...          (Kondo and Yamazaki, 1990, JAM 29, p.376)
                rsurSL(i,j)   = 0.0
            END IF
          END IF

          END DO
          END DO


C +--SVAT Model
C +  ==========

c #TV   IF (vegmod)                                               THEN

C +       ***********
c #TV     call SVAsav('read')
C +       ***********

c #TV   END IF


C +--Ocean Model
C +  ===========

C +--cpl Get fields from oasis initialisation files
C +  ----------------------------------------------

c #AO il_time_secs = 0                         !temps depuis le debut du run 
                                               ! (au pas de temps precedant)

C +--read fields from NEMO at 1st time step of this run
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AO write(6,*) '     CALL fromcpl, itexpe =', itexpe

C +        *******
c #AO CALL fromcpl(il_time_secs, srftAO(:,:,1), sicsAO,
c #AO.                    albAO(:,:,2), srftAO(:,:,2), hicAO,
c #AO.                                  hsnoAO, UoceAO, VoceAO )
C +        *******

c #AO tocken_AO=1       !not to call fromcpl further at the first time step


C +--Open Water Albedo
C +  -----------------

c #AO IF (itexpe.eq.0)  THEN

c #AO  DO i=1,mx
c #AO  DO j=1,my
c #AO    albAO(i,j,1)=0.066 !open water albedo prescribed at first time step 
c #AO                       ! clear sky value in flx_core.h90 (NEMO)
c #AO  ENDDO
c #AO  ENDDO

c #AO ELSE

c #AO  DO i=1,mx
c #AO  DO j=1,my
c #AO    IF (sicsIB(i,j).eq.0)  THEN
c #AO            albAO(i,j,1)= albeSL(i,j)  !where no sea ice, albedo begin with previous run
c #AO    ELSE                               !value (taking into account solar zenith angle and
c #AO            albAO(i,j,1)= 0.066        !cloud cover); elsewhere, albedo over ocean is 0.066
c #AO    ENDIF                              !and albedo over ice is NEMO's albedo (could be improuved
c #AO  ENDDO                                !by sending solar zenith angle and cloud cover to NEMO
c #AO  ENDDO                                !so that it computes himself ocean albedo)  

c #AO ENDIF

c #AO  do j=1,my
c #AO  do i=1,mx
c #AO    if (isolSL(i,j).le.2) then
c #AO        albsSL(i,j) =     albAO(i,j,1) * (1. - sicsAO(i,j))
c #AO.                     +   albAO(i,j,2) *       sicsAO(i,j)
c #AO        albeSL(i,j) =  albsSL(i,j)
c #AO    endif       
c #AO  end do
c #AO  end do

c #AO  do j=1,my
c #AO  do i=1,mx


C +--NEMO SST
C +  --------

c #AO        sst_LB(i,j) =    srftAO(i,j,1)
c #AO  end do
c #AO  end do


c #AO     DO i=1,mx
c #AO     DO j=1,my
c #AO       IF (isolSL(i,j).le.2)  THEN
c #AO           maskSL(i,j) = 1  !ocean/sea-ice
c #AO       ELSE
c #AO           maskSL(i,j) = 0  !land
c #AO       END IF

c #AO       DO n=1,2
c #AO        tsrfSL(i,j,n) = tsrfSL(i,j,n)*(1-maskSL(i,j))
c #AO.                     + srftAO(i,j,n)*   maskSL(i,j)  
c #AO        DO isl =   -nsol,0
c #AO        TsolTV(i,j,n,1-isl) =                         !
c #AO.      (tsrfSL(i,j,n)                *(1-maskSL(i,j)) ! Soil Temperature
c #AO.     +(srftAO(i,j,n)*(2-n)                           ! Prescribed   SST
c #AO.      + 271.2       *(n-1))         *   maskSL(i,j)) ! Beneath Ice   ST
c #AO        ENDDO

c #AO        SLsrfl(i,j,n) = SLsrfl(i,j,n)*(1-maskSL(i,j)) 
c #AO.              +maskSL(i,j)*(  (n-1)*    sicsAO(i,j)       
c #AO.                             +(2-n)*(1.-sicsAO(i,j))) 
c #AO       ENDDO
c #AO        sicsIB(i,j)   =                  sicsAO(i,j)
c #AO     ENDDO
c #AO     ENDDO


C +    ================                                           ====
       IF (itexpe.gt.0)                                           THEN 
C +    ================                                           ====
C +
C +
C +--Non-Hydrostatic Dynamics
C +  ========================
C +
c #NH        open (unit=11,status='unknown',form='unformatted',
c #NH.             file='MARonh.DAT')
c #NH        rewind     11
c #NH        read      (11) itever
c #NH        read      (11) iyrONH,mmaONH,jdaONH,jhuONH
c #NH      IF (itever.ne.itexpe.or.
c #NH.         iyrONH.ne.iyrDYN.or.
c #NH.         mmaONH.ne.mmaDYN.or.
c #NH.         jdaONH.ne.jdaDYN.or.
c #NH.         jhuONH.ne.jhuDYN)    
c #NH.       write(6,810)
 810         format(' ++WARNING++ MARonh improperly specified ')
C +...       Time    Parameters
C +
c #NH        read      (11) ua0_NH
c #NH        read      (11) va0_NH
c #NH        read      (11) wa0_NH
c #NH        read      (11) wairNH
c #NH        read      (11) pairNH
C +...       Dynamics
C +
c #NH        close(unit=11)
C +
C +
C +--Mass Flux convective Scheme
C +  ===========================
C +
c #CA    IF (convec)                                              THEN
c #CA      open (unit=11,status='old',form='unformatted',
c #CA.                                file='MARcva.DAT')
c #CA      rewind     11
c #CA      read      (11) itever
c #CA      read      (11) iyrCVA,mmaCVA,jdaCVA,jhuCVA
c #CA      IF (itever.ne.itexpe.or.
c #CA.         iyrCVA.ne.iyrDYN.or.
c #CA.         mmaCVA.ne.mmaDYN.or.
c #CA.         jdaCVA.ne.jdaDYN.or.
c #CA.         jhuCVA.ne.jhuDYN)    
c #CA.       write(6,811)
 811         format(' ++WARNING++ MARcva improperly specified ')
C +...       Time    Parameters
C +
c #CA        read      (11) adj_CA
c #CA        read      (11) int_CA
c #CA        read      (11) dpktCA
c #CA        read      (11) dqv_CA
c #CA        read      (11) dqw_CA
c #CA        read      (11) dqi_CA
c #CA        read      (11) drr_CA
c #CA        read      (11) dss_CA
c #CA        read      (11) dsn_CA
c #CA        read      (11) rainCA
c #CA        read      (11) snowCA
c #CA        read      (11) tau_CA
C +
c #PB        read      (11) Kstep1
c #PB        read      (11) K_CbT1
c #PB        read      (11) K_CbB1
c #PB        read      (11) P_CH_0
c #PB        read      (11) PdCH_1
c #PB        read      (11) PdTa_1
c #PB        read      (11) PdQa_1
c #PB        read      (11) PdQw_1
c #PB        read      (11) PdQi_1
c #PB        read      (11) Pdrr_1
c #PB        read      (11) Pdss_1
c #PB        read      (11) PuMF_1
c #PB        read      (11) PdMF_1
c #PB        read      (11) Pfrr_1
c #PB        read      (11) Pfss_1
c #PB        read      (11) Pcape1
C +
c #CA    END IF
C +
C +
C +--Microphysics
C +  ============
C +
c #HY    IF (micphy)                                              THEN
C +
c #HY      open (unit=11,status='old',form='unformatted',
c #HY.                                file='MARcld.DAT')
c #HY      rewind     11
c #HY      read      (11) itever
c #HY      read      (11) iyrHYD,mmaHYD,jdaHYD,jhuHYD
c #HY      IF (itever.ne.itexpe.or.
c #HY.         iyrHYD.ne.iyrDYN.or.
c #HY.         mmaHYD.ne.mmaDYN.or.
c #HY.         jdaHYD.ne.jdaDYN.or.
c #HY.         jhuHYD.ne.jhuDYN)    
c #HY.       write(6,812)
 812         format(' ++WARNING++ MARcld improperly specified ')
C +
c #HY      read      (11) turnHY
c #HY      read      (11) ccniHY
c #HY      read      (11) qiHY
c #HY      read      (11) qsHY
C +HG      read      (11) qgHY
c #HY      read      (11) qwHY
c #HY      read      (11) qrHY
c #HY      read      (11) rainHY,rai0HY
c #HY      read      (11) snowHY,sno0HY,sfa0HY
c #HY      read      (11) crysHY
c #CA      read      (11) rainCA
c #BS      read      (11) uss_HY
C +
c #HY      close(unit=11)
C +
c #HY    END IF
C +
C +
C +--Atmospheric Tracers
C +  ===================
C +
c #TC      open (unit=11,status='old',form='unformatted',
c #TC.                                file='MARtca.DAT')
c #TC      rewind     11
c #TC      read      (11) itever
c #TC      read      (11) iyrTCA,mmaTCA,jdaTCA,jhuTCA
c #TC      read      (11) dt_ODE,dt2ODE,nt_ODE,jt_ODE
c #TC      IF (itever.ne.itexpe.or.
c #TC.         iyrTCA.ne.iyrDYN.or.
c #TC.         mmaTCA.ne.mmaDYN.or.
c #TC.         jdaTCA.ne.jdaDYN.or.
c #TC.         jhuTCA.ne.jhuDYN)    
c #TC.       write(6,813)
 813         format(' ++WARNING++ MARtca improperly specified ')
C +
c #TC      read      (11) qxTC
c #TC      read      (11) qsTC
c #TC      read      (11) uqTC
C +
c #TC      close(unit=11)
C +
C +
C +--Polynya Model
C +  =============
C +
c #PO    IF (polmod)                                              THEN
C +
c #PO      open (unit=11,status='old',form='unformatted',
c #PO.                                file='MARpol.DAT')
c #PO      rewind     11
c #PO      read      (11) itever
c #PO      read      (11) iyrPOL,mmaPOL,jdaPOL,jhuPOL
c #PO      if (itever.ne.itexpe.or.
c #PO.         iyrPOL.ne.iyrDYN.or.
c #PO.         mmaPOL.ne.mmaDYN.or.
c #PO.         jdaPOL.ne.jdaDYN.or.
c #PO.         jhuPOL.ne.jhuDYN)    
c #PO.       write(6,814)
 814         format(' ++WARNING++ MARpol improperly specified ')
C +
c #PO      read      (11) isolSL
c #PO      read      (11) iPO1,iPO2,jPO1,jPO2,iPO3,iPO4,jPO3,jPO4
c #PO      read      (11) hfraPO,vgriPO,uocnPO,vocnPO,swsaPO,focnPO
c #PO      read      (11) silfPO,hicePO,aicePO,uicePO,vicePO,dtPO
C +
c #PO      close(unit=11)
C +
c #PO    END IF
C +
C +
C +--Snow Model
C +  ==========
C +
c #SN    IF (snomod.AND..NOT.VSISVAT)                             THEN
C +
c #SN      open (unit=11,status='old',form='unformatted',
c #SN.                                file='MARsno.DAT')
c #SN      rewind     11
c #sn      read      (11) itever,ntSNo ,ntwaSN
c #sn      read      (11)        dtSNo ,dtwaSN
c #sn      read      (11) iyrSNO,mmaSNO,jdaSNO,jhuSNO
c #sn      IF (itever.ne.itexpe.or.
c #sn.         iyrSNO.ne.iyrDYN.or.
c #sn.         mmaSNO.ne.mmaDYN.or.
c #sn.         jdaSNO.ne.jdaDYN.or.
c #sn.         jhuSNO.ne.jhuDYN)    
c #sn.       write(6,815)
 815         format(' ++WARNING++ MARsno improperly specified ')
C +
c #sn      read      (11) agSNow
c #sn      read      (11) tiSNow
c #sn      read      (11) waSNow
c #sn      read      (11) roSNow
c #sn      read      (11) dzSNow
c #sn      read      (11) g1SNow
c #sn      read      (11) g2SNow
c #sn      read      (11) nhSNow
c #sn      read      (11) nsSNow
c #sn      read      (11) niSNow
c #sn      read      (11) smbalSN0
c #sn      read      (11) znSNow0
c #sn      read      (11) maskSN
c #sn      read      (11) slopSN
c #sn      read      (11) waSNru
c #BS      read      (11) FacRBS,FacSBS,FacTBS,FacUBS,
c #BS.                    g1__BS,g2__BS,sheaBS
C +
c #SN      close(unit=11)
C +
c #SN    END IF
C +
C +
C +--Turbulence
C +  ==========
C +
           open (unit=11,status='old',form='unformatted',
     .                                file='MARtur.DAT')
           rewind     11
           read      (11) itever
           read      (11) iyrTUR,mmaTUR,jdaTUR,jhuTUR
           if (itever.ne.itexpe.or.
     .         iyrTUR.ne.iyrDYN.or.
     .         mmaTUR.ne.mmaDYN.or.
     .         jdaTUR.ne.jdaDYN.or.
     .         jhuTUR.ne.jhuDYN)    
     .      write(6,816)
 816        format(' ++WARNING++ MARtur improperly specified ')
C +
           read      (11) ect_TE
           read      (11) eps_TE
           read      (11) tranTE
C +...     TURBULENT KINETIC ENERGY (TKE) and DISSIPATION (e)
C +
           read      (11) TUkvm 
           read      (11) TUkvh 
C +...     TURBULENT DIFFUSION COEFFICIENT
C +
           close(unit=11)
C +
C +
C +    ====
       else 
C +    ====
C +
C +
C +--Timing  
C +  ======
C +
        itexpe = 0
        iterun = 0
C +
C +
C +--Atmosphere
C +  ==========
C +
        DO j=1,my
        DO i=1,mx
         pstDYn(i,j) = pstDY(i,j)
        END DO
        END DO
C +

C +          ******
        call DYNgpo
C +          ******

C +
C +
C +--Microphysics and Surface
C +  ========================
C +
C +      ***********
         call INIphy
C +      ***********
C +
C +
C +--Water Vapor and Precipitation Loading
C +  -------------------------------------
C +
C +      ***********
         call DYNloa
C +      ***********
C +
C +
C +--Surface Albedo (set to underlaying Soil Albedo)
C +  --------------
C +
         DO j=1,my
         DO i=1,mx
           alb0SL(i,j) = max(albsSL(i,j),alb0SL(i,j))
           albeSL(i,j) = max(albsSL(i,j),albeSL(i,j))
         END DO
         END DO
C +
C +    ======
       end if 
C +    ======
C +
C +   ++++
      else 
C +   ++++
C +
C +  
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ INITIALISATION INCLUDING A SOUNDING ++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +--Timing  
C +  ======
C +
        itexpe = 0
        iterun = 0
C +
C +
C +--Dynamics
C +  ========
C +
C +
C +--Vertical  Grid Initialisation
C +  -----------------------------
C +  
C +                      ***********
        IF (.NOT.geoNST) call GRDsig(zmin_0,aavu_0,bbvu_0,ccvu_0,verti0)
C +                      ***********
C +
C +
C +--Auxiliary Grid Parameters
C +  -------------------------
C +  
C +     ***********
        call GRDmar
C +     ***********
C +
C +
C +--Geographical Coordinates 
C +  ------------------------
C +  
C +     ***********
        call GRDgeo
C +     ***********
C +
C +
C +--Local Time of the Model Center
C +  ------------------------------
C +  
C +     ***********
        call TIMcur
        call TIMgeo
C +     ***********
C +
C +
C +--Initialisation assuming horizontal Homogeneity
C +  ----------------------------------------------
C +
C +     ***********
        call INIsnd
C +     ***********
C +
C +     ***************
        call LBCnud_ini
C +     ***************
C +
C +     ***************
c #DA   call LBCnud_par     
C +     ***************
C +
C +
C +--Leapfrog Auxiliary Variables
C +  ============================
C +
        DO j=1,my
        DO i=1,mx
         pstDYn(i,j) = pstDY(i,j)
        END DO
        END DO
C +
C +
C +--Microphysics and Surface
C +  ========================
C +
C +     ***********
        call INIphy
C +     ***********
C +
C +
C +--Water Vapor and Precipitation Loading
C +  -------------------------------------
C +
C +     ***********
        call DYNloa
C +     ***********
C +
C +
C +--Surface Albedo (set to underlaying Soil Albedo)
C +  --------------
C +
        DO j=1,my
        DO i=1,mx
           alb0SL(i,j) = max(albsSL(i,j),alb0SL(i,j))
           albeSL(i,j) = max(albsSL(i,j),albeSL(i,j))
        END DO
        END DO
C +
C +   ++++++
      end if 
C +   ++++++
C +
C +  
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ AUXILIARY VARIABLES INITIALISATION +++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +--Parameters
C +  ==========
C +
      ipri = 0 
C +... print parameter used in Model  Validation 
C +                         on Linear Mountain Waves Simulations 
C +
C +--Atmospheric variables
C +  =====================
C +
C +
C +--Leapfrog Auxiliary Variables
C +  ----------------------------
C +
      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        ubefDY (i,j,k) =  uairDY(i,j,k)
        vbefDY (i,j,k) =  vairDY(i,j,k)
      END DO
      END DO
      END DO
C +
C +
C +--Surface Geopotential 
C +  --------------------
C +
      DO j=1,my
      DO i=1,mx
        gplvDY(i,j,mzz) = gravit * sh(i,j)
      END DO
      END DO
C +
C +
C +--Exner Potential, Temperature and Level Geopotential
C +  ---------------------------------------------------
C +
           if(openmp) then
C +            ******
            call DYNgpo_mp
C +            ******
           else
C +            ******
            call DYNgpo
C +            ******
           endif
C +
C +
C +--Mid-Level Geopotential
C +  ----------------------
C +
           k=1
      DO j=1,my
      DO i=1,mx
        gpmiDY(i,j,k) = 0.5 *(3.5*gplvDY(i,j,  1)-0.5d0*gplvDY(i,j,2))
      END DO
      END DO
C +
      DO k=kp1(1),mzz
      DO j=1,my
      DO i=1,mx
        gpmiDY(i,j,k) = 0.5 *(    gplvDY(i,j,k-1)+      gplvDY(i,j,k))
      END DO
      END DO
      END DO
C +
         k=       mzz
      DO j=1,my
      DO i=1,mx
        gpmiDY(i,j,k) =(0.5 *     z__SBL         +          sh(i,j)  )
     .                *           gravit
      END DO
      END DO
C +
C +
C +--Vertical Temperature Gradient at Sponge Base
C +  --------------------------------------------
C +
          gradTz =     1.0e+3 *grvinv
      IF (mzabso.gt.1)                                             THEN
          mzabs1 = max(mzabso-1,1)
        DO j=1,my
        DO i=1,mx
          gradTz = min(gradTz,(tairDY(i,j,mzabs1)-tairDY(i,j,mzabso))
     .                 /(epsi+ gplvDY(i,j,mzabs1)-gplvDY(i,j,mzabso)))
        END DO
        END DO
      END IF
          gradTz =     gradTz *gravit *1.0d+3
C +
C +
C +--Sigma Surfaces Initial Altitudes for Linear Mountain Wave Experiments
C +  ---------------------------------------------------------------------
C +
c #OL DO k=1,mz
c #OL DO j=1,my
c #OL DO i=1,mx
c #OL   gp00OL(i,j,k) = gplvDY(i,j,k)
c #OL END DO
c #OL END DO
c #OL END DO
C +
C +
C +--Slopes of the Sigma Surfaces
C +  ----------------------------
C +
C +        ******
c _PE call INIpen
C +        ******
C +
C +        ******
c #PE call INIpen
C +        ******
C +
C +
C +--Top / Bottom Boundaries
C +  -----------------------
C +
c #Di DO j=1,my
c #Di DO i=1,mx
c #Di   qvtoDI(i,j) =   qvDY(i,j,1)
c #Di   pkttDI(i,j) = pktaDY(i,j,1)
c #Di   uairDI(i,j) = uairDY(i,j,1)
c #Di   vairDI(i,j) = vairDY(i,j,1)
c #Di END DO
c #Di END DO
C +
C +
C +--Specific Mass
C +  -------------
C +
C +    ***********
       call DYNrho
C +    ***********
C +
C +
C +--Surface     Variables
C +  =====================
C +
C +--Land-Sea Mask
C +  -------------
C +
      DO j=1,my
      DO i=1,mx
        IF (isolSL(i,j).le.2)                                     THEN
            maskSL(i,j) = 1
        ELSE
            maskSL(i,j) = 0
        END IF
      END DO
      END DO


C +--OUTPUT
C +  ======

C +   ---------------------
      if (IO_loc.ge.1) then
C +   ---------------------

       write(21,606) jdaMAR,jhaMAR,itexpe,nboucl,nprint,
     .               0.1*pSND(1,1),pstSND,sst_SL,dtagSL,
     .               zs_SL,zn_SL,gradtz,mzabso
  606  format(//,' EXECUTION STATUS',/,' ++++++++++++++++',/,
     .  /,' Preceding Execution stopped after',i5,' day(s)',
     .                                         i5,' hour(s)',
     .  /,'  itexpe =',i8,
     . //,'  nboucl =',i8,8x,'nprint =',i8,
     . //,'  p MSL  =',f8.1,' cb',5x,'p* 0   =',f8.1,' cb',
     .  /,'  SST    =',f8.1,' K ',5x,'T0-Tg  =',f8.1,' K ',
     .  /,'  zs     =',f8.5,' m ',5x,'zn     =',f8.5,' m ',
     .  /,'  dT/dz >=',f8.2,' K/km / mzabso =',i8,' Sponge Base')
       IF (gradtz.lt.-4.0) write(6,607) gradtz,mzabso
  607  format(/,' WARNING: dT/dz Min =',f8.2,' K/km',
     .          ' at Sponge Base (k=mzabso=',i2,')')

C +   ------
      end if
C +   ------

      return
      end


      subroutine INIphy

C +------------------------------------------------------------------------+
C | MAR INPUT      ATMOS                              Thu 21-Jul-2011  MAR |
C |   SubRoutine INIphy Initializes coupling Variables  between            |
C |                                 MAR Surface and     Atmosphere         |
C |                     Calls       MAR Surface Model initializing Routines|
C |                     Initializes MAR Cloud   Microphysical      Scheme  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT:      itexpe: Experiment Iteration Counter                    |
C |    ^^^^^       micphy: Cloud Microphysics   Switch                     |
C |                fxlead: Lead (in Sea ice)    Fraction                   |
C |                polmod: Polynya Model        Switch                     |
C |                snomod: Snow    Model        Switch                     |
C |                reaVAR: Previous OR Large Scale Variables Switch        |
C |                reaLBC: LBC:        Large Scale Variables Switch        |
C |                                                                        |
C |    INPUT (via common block)                                            |
C |    ^^^^^       pstDY (mx,my)    : Atmosphere        Thickness    [kPa] |
C |    (itexpe=0): TairSL(mx,my)    : Surface Air       Temperature    [K] |
C |                                  (Sounding Extrapolated to the Surface |
C |                                   - dtagSL                            )|
C |    (itexpe=1): pktaDY(mx,my,mzz): Reduced Potential Temperature        |
C |                sh    (mx,my)    : Surface           Elevation      [m] |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^       tsrfSL(mx,my,mw) : Surface           Temperature    [K] |
C |    (itexpe=1): TairSL(mx,my)    : Surface Air       Temperature    [K] |
C |               (CAUTION: CRUDE REINITIALISATION                         |
C |                         BE CAREFULL WHEN USING PRESCRIBED TEMPERATURE) |
C |                SLsrfl(mx,my,mw) : Surface Type Area                    |
C |    (itexpe=0): pktaDY(mx,my,mzz): Reduced Potential Temperature        |
C |                gplvDY(mx,my,mzz): Geopotential                 [m2/s2] |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_LB.inc'

c #HY include 'MAR_HY.inc'
c #CA include 'MAR_CA.inc'
c #BS include 'MAR_BS.inc'

      include 'MAR_SL.inc'
c #AO include 'MAR_AO.inc'     !cpl
      include 'MAR_SV.inc'
      include 'MAR_TV.inc'


C +--Local  Variables
C +  ================

      integer n
      real    tsrf  ,rowat2


C +--First Guess Initialization
C +  ==========================

      IF (.not.reaVAR)                                            THEN


C +--Surface Geopotential
C +  --------------------

        DO j=1,my
        DO i=1,mx
          gplvDY(i,j,mzz) = sh(i,j)     *   gravit
        END DO
        END DO


C +--Grid BOXES Area     (First Guess)
C +  ---------------------------------

        DO j=1,my
        DO i=1,mx
          SLsrfl(i,j,1) = 1.0
          SLsrfl(i,j,2) = 0.0
        END DO
        END DO


C +--Surface Temperature (First Guess)
C +  ---------------------------------

        DO n=1,mw
        DO j=1,my
        DO i=1,mx
            tsrfSL(i,j,n) =     TairSL(i,j)
        END DO
        END DO 
        END DO

        DO j=1,my
        DO i=1,mx

          go to (101,102,103,104,105) isolSL(i,j)
 101      CONTINUE
          IF   (reaLBC)                                           THEN
                tsrfSL(i,j,1) =       sst_LB(i,j)
          ELSE
                tsrfSL(i,j,1) =   max(sst_SL       ,tfrwat)
          END IF
          go to 106
 102      CONTINUE
c #OM           tsrf          =       tsrfSL(i,j,1)
                tsrfSL(i,j,1) =   min(tsrfSL(i,j,1),TfSnow) 
c #OM           tsrfSL(i,j,1) =       tsrf
                tsrfSL(i,j,2) =       sst_SL
          go to 106
 103      CONTINUE
                tsrfSL(i,j,1) =   min(tsrfSL(i,j,1),TfSnow) 
          go to 106
 104      CONTINUE
          go to 106
 105      CONTINUE
          go to 106

 106      CONTINUE

        END DO
        END DO

      END IF


C +--Polynya Model
C +  =============


C +--Polynya Model Initialisation
C +  ----------------------------

C +   ***************
c #PO call SRFini_pol
C +   ***************


C +--Snow    Model
C +  =============

              rowat2     = ro_Wat**1.88
      DO j=1,my
      DO i=1,mx
              ro_SL0(i,j)=(d1_SL(i,j) / sqrt(csnow*cdice*cs2SL/rowat2))
     .                  **(1.0/1.44)
              ro_SL(i,j) = ro_SL0(i,j)
              SaltSL(i,j)= 1.e2
C +...        SaltSL: Here an impossible Value
C +                  (Preclude Saltation)
      END DO
      END DO

c #SN IF   (.not.snomod)                                          THEN

        DO j=1,my
        DO i=1,mx
          IF (isolSL(i,j).ge.2.and.tsrfSL(i,j,1).lt.TfSnow)       THEN
               ro_SL(i,j) = 0.00
              SaltSL(i,j) = 0.38
C +...        SaltSL: Threshold Friction Velocity for Blowing Snow 
C +                  (Budd et al., 1966, Byrd Snow Project)
          END IF
        END DO
        END DO

c #SN ELSE

C +                       ***************
c #sn   IF (.NOT.VSISVAT) call SRFini_sno
C +                       ***************	

c #SN END IF


C +--Soil Model
C +  ==========

      DO j=1,my
      DO i=1,mx
          roseSL(i,j) =      0.0
          hmelSL(i,j) =      0.0
      END DO
      END DO

      DO j=1,my
      DO i=1,mx
      GO TO (51,51,53,54,51) isolSL(i,j)
 51   CONTINUE
           t2_SL(i,j) =      tsrfSL(i,j,1)
      GO TO 59
 53   CONTINUE
c #SN   if (.not.snomod) then
           t2_SL(i,j) =      tsrfSL(i,j,1)
c #SN   end if
      GO TO 59
 54   CONTINUE
           t2_SL(i,j) =      tsrfSL(i,j,1)
           w2_SL(i,j) =      w20SL
           wg_SL(i,j) =      wg0SL
           wk_SL(i,j) =      wk0SL
           wx_SL(i,j) =      wx0SL
      GO TO 59
 59   CONTINUE
      END DO
      END DO


C +--Grid BOXES Area     (Update)
C +  ============================

      IF (VSISVAT)                                                THEN
        DO j=1,my
        DO i=1,mx
              nSLsrf(i,j)   =                         nvx
c #vL   END DO
c #vL   END DO
        DO n=1,nvx
c #vL   DO j=1,my
c #vL   DO i=1,mx
              SLsrfl(i,j,n) =         ifraTV(i,j,n)
              SLsrfl(i,j,n) =         SLsrfl(i,j,n) * 0.01
        END DO
        END DO
        END DO
      ELSE
        DO j=1,my
        DO i=1,mx
          IF (isolSL(i,j).le.4)                                   THEN
              nSLsrf(i,j)   = max(iun,nSLsrf(i,j)  )
              SLsrfl(i,j,1) =     1. -SLsrfl(i,j,2)
          ELSE
              nSLsrf(i,j)   =     1
              SLsrfl(i,j,1) =     1.
c #TV         nSLsrf(i,j)   =                         nvx
c #TV       DO n=1,nvx
c #TV         SLsrfl(i,j,n) =         ifraTV(i,j,n)
c #TV         SLsrfl(i,j,n) =         SLsrfl(i,j,n) * 0.01
c #TV       END DO
          END IF
        END DO
        END DO
      END IF


C +--Surface Temperature (Update)
C +  ============================

      DO j=1,my
      DO i=1,mx
          TairSL(i,j)     = 0.
        DO n=1,mw
          TairSL(i,j)     = TairSL(i,j) 
     .   +SLsrfl(i,j,n)   * tsrfSL(i,j,n)  
        END DO
          pktaDY(i,j,mzz) = TairSL(i,j)
     .                   / ((pstDY(i,j)+ptopDY)**cap)
      END DO
      END DO


C +--Microphysics
C +  ============

c #HY IF (micphy)                                                 THEN
c #HY     turnHY = .false.

c #HY     DO k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         qiHY(i,j,k) = 0.0
c #HY         qsHY(i,j,k) = 0.0
! #qg         qgHY(i,j,k) = 0.0
c #HY         qwHY(i,j,k) = 0.0
c #HY         qrHY(i,j,k) = 0.0
c #HY       hlatHY(i,j,k) = 0.0    
c #HY     END DO
c #HY     END DO
c #HY     END DO

c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       rainHY(i,j)   = 0.0
c #HY       snowHY(i,j)   = 0.0
c #HY       crysHY(i,j)   = 0.0
c #CA       rainCA(i,j)   = 0.0
c #CA       snowCA(i,j)   = 0.0
c #HY     END DO
c #HY     END DO

c #HY END IF

      return
      end


      subroutine INIlbc(ihamr_lbc,nhamr_lbc,newlbc)

C +------------------------------------------------------------------------+
C | MAR INPUT      ATMOS                               Tue 03-11-2009  MAR |
C |   SubRoutine INIlbc initializes MAR Lateral Boundaries                 |
C |                     verifies    MARlbc.DAT  EOF                        |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  ihamr_lbc : Time Digital Filter Status                       |
C |   ^^^^^   nhamr_lbc : Time Digital Filter Set Up                       |
C |                                                                        |
C |   OUTPUT: newlbc    : (0,1) ==> (NO new LBC ,new LBC)                  |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  vaxgLB,vaxdLB,vayiLB,vaysLB: Current                    LBCs |
C |           v1xgLB,v1xdLB,v1yiLB,v1ysLB: Previous Nesting Time Step LBCs |
C |           v2xgLB,v2xdLB,v2yiLB,v2ysLB: Next     Nesting Time Step LBCs |
C |           tim1LB,tim2LB              : LBC Nesting      Times  n, n+1  |
C |                                                                        |
C |   CAUTION: It is assumed that tim1LB and tim2LB do not change when the |
C |   ^^^^^^^^ Variables are reassigned after the dynamical Initialization |
C |            (Reassignation => itexpe:= nham => itimar:= itimar-nham*dt) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
      include 'MAR_LB.inc'

      include 'MAR_SL.inc'

      integer  ihamr_lbc ,nhamr_lbc
      integer  newlbc
      real              pst__1,pst_mx
      common/INIlbcRLoc/pst__1,pst_mx


C +--Local  Variables
C +  ================

      integer*8  itimar,iv_ilb
      real     rate
      real     vax_An,vax_Ap,vax_A
      real     qsat0D,qs    ,tt
c #CE real     qse_0D,qse
c #FS real     rh_min,qq
c #FS real     fac_qq

c #FS data     rh_min/0.80/   ! relative humidity above which clouds exist
c #FS data     fac_qq/1.50/   ! prescribed specific humidity tuning at LBC
!                     1.50  ==> 0.8 + 1.5 * 0.2 = 1.1

C +--Current Time
C +  ============

          itimar=ou2sGE(iyrrGE,mmarGE,jdarGE,jhurGE,minuGE,jsecGE)
c #HF.          + (ihamr_lbc+nhamr_lbc)                           * idt

cXF
C WARNING Compile with -i8 if the simulation run > 50yrs!!
cXF

C +--New LBC
C +  =======

      IF (itimar.gt.   tim2LB)                                    THEN

          tim1LB =     tim2LB

          write(6,6001)jda_LB,labmGE(mma_LB),iyr_LB,
     .                 jhu_LB,                      tim1LB,
     .                 jdarGE,labmGE(mmarGE),iyrrGE,
     .                 jhurGE,minuGE,        jsecGE,itimar
 6001     format(/, '  1st LBC /',i3,'-',a3,'-',i4,i3,' ',2x,'/',2x,
     .              '   t =',i12,'s A.P.',
     .           /, '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12)

       IF (jdh_LB.eq.0)jdh_LB = -1
       open (unit=11,status='old',form='unformatted',file='MARlbc.DAT')
       rewind     11
 11    CONTINUE
       IF (jdh_LB.le.0)                                       GO TO 10


C +--LBC at nesting time step n
C +  --------------------------

       DO iv_ilb=1,5
         DO i=1,n7mxLB
         DO k=1,mz
         DO j=1,my
           v1xgLB(i,j,k,iv_ilb) = v2xgLB(i,j,k,iv_ilb)
           v2xgLB(i,j,k,iv_ilb) = 0.0
         END DO
         END DO
         END DO

         DO i=mx-n6mxLB,mx
         DO k=1,mz
         DO j=1,my
           v1xdLB(i,j,k,iv_ilb) = v2xdLB(i,j,k,iv_ilb)
           v2xdLB(i,j,k,iv_ilb) = 0.0
         END DO
         END DO
         END DO

         DO j=1,n7myLB
         DO k=1,mz
         DO i=1,mx
           v1yiLB(i,j,k,iv_ilb) = v2yiLB(i,j,k,iv_ilb)
           v2yiLB(i,j,k,iv_ilb) = 0.0
         END DO
         END DO
         END DO

         DO j=my-n6myLB,my
         DO k=1,mz
         DO i=1,mx
           v1ysLB(i,j,k,iv_ilb) = v2ysLB(i,j,k,iv_ilb)
           v2ysLB(i,j,k,iv_ilb) = 0.0
         END DO
         END DO
         END DO

       END DO

         DO j=1,my
         DO i=1,mx
           sst1LB(i,j)      = sst2LB(i,j)     
         END DO
         END DO


C +--LBC at nesting time step n+1
C +  ----------------------------

       read      (11) iyr_LB,mma_LB,jda_LB,jhu_LB,jdh_LB
       read      (11) v2xgLB,v2xdLB,v2yiLB,v2ysLB
       read      (11) sst2LB

       tim2LB=ou2sGE(iyr_LB,mma_LB,jda_LB,jhu_LB,0,0)

       DO iv_ilb=1,2
         DO i=1,n7mxLB
         DO k=1,mz
         DO j=1,my
           v2xgLB(i,j,k,iv_ilb) = v2xgLB(i,j,k,iv_ilb)  / SFm_DY(i,j)
         END DO
         END DO
         END DO

         DO i=mx-n6mxLB,mx
         DO k=1,mz
         DO j=1,my
           v2xdLB(i,j,k,iv_ilb) = v2xdLB(i,j,k,iv_ilb)  / SFm_DY(i,j)
         END DO
         END DO
         END DO

         DO j=1,n7myLB
         DO k=1,mz
         DO i=1,mx
           v2yiLB(i,j,k,iv_ilb) = v2yiLB(i,j,k,iv_ilb)  / SFm_DY(i,j)
         END DO
         END DO
         END DO

         DO j=my-n6myLB,my
         DO k=1,mz
         DO i=1,mx
           v2ysLB(i,j,k,iv_ilb) = v2ysLB(i,j,k,iv_ilb)  / SFm_DY(i,j)
         END DO
         END DO
         END DO

       END DO

       IF(itimar.gt.tim2LB)                                   GO TO 11

          write(6,6002)jda_LB,labmGE(mma_LB),iyr_LB,
     .                 jhu_LB,jdh_LB,               tim2LB
 6002     format(   '  2nd LBC /',i3,'-',a3,'-',i4,i3,' ',2x,'/(',i1,
     .              ')  t =',i12)

 10    CONTINUE
       close(unit=11)


C +--Force Sursaturation where relative humidity larger than rh_min (i.e., 80%)
C +  --------------------------------------------------------------------------

          DO i=1,n7mxLB
          DO k=1,mz
          DO j=1,my
            tt =                    v2xgLB(i,j,k,4)
     .                 *exp(cap*log(v2xgLB(i,j,1,5)*sigma(k)+ptopDY))
            qs = qsat0D(tt,sigma(k),v2xgLB(i,j,1,5),ptopDY,0)
c #FS       qq = qs                                           * rh_min
c #CE       qse= qse_0D(tt,sigma(k),v2xgLB(i,j,1,5),ptopDY)
c #FS       v2xgLB(i,j,k,3) =   min(v2xgLB(i,j,k,3),qq)
c #FS.                  +fac_qq*max(v2xgLB(i,j,k,3)-qq,0.)
c #CE       v2xgLB(i,j,k,3) =       v2xgLB(i,j,k,3)*qs/qse
          END DO
          END DO
          END DO

          DO i=mx-n6mxLB,mx
          DO k=1,mz
          DO j=1,my
            tt =                    v2xdLB(i,j,k,4)
     .                 *exp(cap*log(v2xdLB(i,j,1,5)*sigma(k)+ptopDY))
            qs = qsat0D(tt,sigma(k),v2xdLB(i,j,1,5),ptopDY,0)
c #FS       qq = qs                                           * rh_min
c #CE       qse= qse_0D(tt,sigma(k),v2xdLB(i,j,1,5),ptopDY)
c #FS       v2xdLB(i,j,k,3) =   min(v2xdLB(i,j,k,3),qq)
c #FS.                  +fac_qq*max(v2xdLB(i,j,k,3)-qq,0.)
c #CE       v2xdLB(i,j,k,3) =       v2xdLB(i,j,k,3)*qs/qse
          END DO
          END DO
          END DO

          DO j=1,n7myLB
          DO k=1,mz
          DO i=1,mx
            tt =                    v2yiLB(i,j,k,4)
     .                 *exp(cap*log(v2yiLB(i,j,1,5)*sigma(k)+ptopDY))
            qs = qsat0D(tt,sigma(k),v2yiLB(i,j,1,5),ptopDY,0)
c #FS       qq = qs                                           * rh_min
c #CE       qse= qse_0D(tt,sigma(k),v2yiLB(i,j,1,5),ptopDY)
c #FS       v2yiLB(i,j,k,3) =   min(v2yiLB(i,j,k,3),qq)
c #FS.                  +fac_qq*max(v2yiLB(i,j,k,3)-qq,0.)
c #CE       v2yiLB(i,j,k,3) =       v2yiLB(i,j,k,3)*qs/qse
          END DO
          END DO
          END DO

          DO j=my-n6myLB,my
          DO k=1,mz
          DO i=1,mx
            tt =                    v2ysLB(i,j,k,4)
     .                 *exp(cap*log(v2ysLB(i,j,1,5)*sigma(k)+ptopDY))
            qs = qsat0D(tt,sigma(k),v2ysLB(i,j,1,5),ptopDY,0)
c #FS       qq = qs                                           * rh_min
c #CE       qse= qse_0D(tt,sigma(k),v2ysLB(i,j,1,5),ptopDY)
c #FS       v2ysLB(i,j,k,3) =   min(v2ysLB(i,j,k,3),qq)
c #FS.                  +fac_qq*max(v2ysLB(i,j,k,3)-qq,0.)
c #CE       v2ysLB(i,j,k,3) =       v2ysLB(i,j,k,3)*qs/qse
          END DO
          END DO
          END DO

      ELSE
c #WR     write(6,6003)jdarGE,labmGE(mmarGE),iyrrGE,
c #WR.                 jhurGE,minuGE,        jsecGE,itimar
 6003     format(   '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12,'s A.P.')
      END IF


C +--Time Interpolation
C +  ==================

      IF            (itimar.le.tim2LB  .and.   tim1LB.lt.tim2LB)  THEN

        rate = float(itimar  - tim1LB) / float(tim2LB  - tim1LB)
        DO iv_ilb=1,5
          DO i=1,n7mxLB
          DO k=1,mz
          DO j=1,my
            vaxgLB(i,j,k,iv_ilb)=v1xgLB(i,j,k,iv_ilb) +
     .     (v2xgLB(i,j,k,iv_ilb)-v1xgLB(i,j,k,iv_ilb))*rate
          END DO
          END DO
          END DO

          DO i=mx-n6mxLB,mx
          DO k=1,mz
          DO j=1,my
            vaxdLB(i,j,k,iv_ilb)=v1xdLB(i,j,k,iv_ilb) +
     .     (v2xdLB(i,j,k,iv_ilb)-v1xdLB(i,j,k,iv_ilb))*rate
          END DO
          END DO
          END DO

          DO j=1,n7myLB
          DO k=1,mz
          DO i=1,mx
            vayiLB(i,j,k,iv_ilb)=v1yiLB(i,j,k,iv_ilb) +
     .     (v2yiLB(i,j,k,iv_ilb)-v1yiLB(i,j,k,iv_ilb))*rate
          END DO
          END DO
          END DO

          DO j=my-n6myLB,my
          DO k=1,mz
          DO i=1,mx
            vaysLB(i,j,k,iv_ilb)=v1ysLB(i,j,k,iv_ilb) +
     .     (v2ysLB(i,j,k,iv_ilb)-v1ysLB(i,j,k,iv_ilb))*rate
          END DO
          END DO
          END DO
        END DO


C +--Zonally Averaged Version
C +  ------------------------

        IF   (mmy   .eq.1)                                        THEN
          IF (itexpe.eq.1)                                        THEN
              pst__1 = vaxgLB( 1,1,1,5)
              pst_mx = vaxdLB(mx,1,1,5)
          END IF

C +--LBC: Smooth Set up of the Large Scale Wind
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #IN     IF        (itexpe*dt.lt.86400.)                         THEN
c #IN         rate = itexpe*dt   /86400.
c #IN       DO iv_ilb=1,2
c #IN       DO i=1,n7mxLB
c #IN       DO k=1,mz
c #IN       DO j=1,my
c #IN         vaxgLB(i,j,k,iv_ilb)=vaxgLB(i,j,k,iv_ilb) * rate
c #IN       END DO
c #IN       END DO
c #IN       END DO

c #IN       DO i=mx-n6mxLB,mx
c #IN       DO k=1,mz
c #IN       DO j=1,my
c #IN         vaxdLB(i,j,k,iv_ilb)=vaxdLB(i,j,k,iv_ilb) * rate
c #IN       END DO
c #IN       END DO
c #IN       END DO
c #IN       END DO
c #IN     END IF

C +--Meridional Wind: zero Mass Flux Correction, excedent Mass Flux Reduction
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             iv_ilb=2
             j= 1
          DO i= 1,n7mxLB
                  vax_An =  0.
                  vax_Ap =  0.
              DO k=1,mz
                  vax_An =  vax_An +min(real(vaxgLB(i,j,k,iv_ilb)),0.) 
     .                                      *dsigm1(k)
                  vax_Ap =  vax_Ap +max(real(vaxgLB(i,j,k,iv_ilb)),0.) 
     .                                      *dsigm1(k)
              END DO
                  vax_A  =  vax_An+vax_Ap
            IF   (vax_A.gt.0.)                                    THEN
                  vax_A  = (vax_Ap-vax_A)/max( epsi,vax_Ap)
              DO k=1,mz
              IF (vaxgLB(i,j,k,iv_ilb).gt.0.)
     .            vaxgLB(i,j,k,iv_ilb) = vaxgLB(i,j,k,iv_ilb) * vax_A
              END DO
            ELSE
                  vax_A  = (vax_An-vax_A)/min(-epsi,vax_An)
              DO k=1,mz
              IF (vaxgLB(i,j,k,iv_ilb).lt.0.)
     .            vaxgLB(i,j,k,iv_ilb) = vaxgLB(i,j,k,iv_ilb) * vax_A
              END DO
            END IF
          END DO

          DO i=mx-n6mxLB,mx
                  vax_An =  0.
                  vax_Ap =  0.
              DO k=1,mz
                  vax_An =  vax_An +min(real(vaxdLB(i,j,k,iv_ilb)),0.) 
     .                                      *dsigm1(k)
                  vax_Ap =  vax_Ap +max(real(vaxdLB(i,j,k,iv_ilb)),0.) 
     .                                      *dsigm1(k)
              END DO
                  vax_A  =  vax_An+vax_Ap
            IF   (vax_A.gt.0.)                                    THEN
                  vax_A  = (vax_Ap-vax_A)/max( epsi,vax_Ap)
              DO k=1,mz
              IF (vaxdLB(i,j,k,iv_ilb).gt.0.)
     .            vaxdLB(i,j,k,iv_ilb) = vaxdLB(i,j,k,iv_ilb) * vax_A
              END DO
            ELSE
                  vax_A  = (vax_An-vax_A)/min(-epsi,vax_An)
              DO k=1,mz
              IF (vaxdLB(i,j,k,iv_ilb).lt.0.)
     .            vaxdLB(i,j,k,iv_ilb) = vaxdLB(i,j,k,iv_ilb) * vax_A
              END DO
            END IF
          END DO

C +--Surface Pressure:  no Mass       Variation
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          DO i= 1,n7mxLB
                  vaxgLB(i,1,1,5) = pst__1                             ! [kPa]
          END DO
          DO i=mx-n6mxLB,mx
                  vaxdLB(i,1,1,5) = pst_mx                             ! [kPa]
          END DO
        END IF


C +--Sea Surface Temperatures
C +  ------------------------

          DO j=1,my
          DO i=1,mx
c #AO       sst1LB(i,j)     =sst_LB(i,j)
c #AO       sst2LB(i,j)     =sst_LB(i,j)
            sst_LB(i,j)     =sst1LB(i,j)      +
     .     (sst2LB(i,j)     -sst1LB(i,j)     )*rate
          END DO
          END DO

        newlbc = 1

      ELSE
        newlbc = 0
      END IF

      return
      end


      subroutine INIsnd

C +------------------------------------------------------------------------+
C | MAR INPUT      ATMOS                                   19-02-2004  MAR |
C |   SubRoutine INIsnd includes Large Scale Conditions from a Sounding    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT (via common block)                                            |
C |    ^^^^^^ itexpe: Experiment Iteration Index                           |
C |           iterun: Run        Iteration Index (n Run for 1 Experiment)  |
C |           log_1D=(0,1) (before,after)  Boundary Layer Initialization   |
C |           potvor:"Potential Vorticity conserved" Initialization Switch |
C |           potvor=.T. => Potential Vorticity (PV) Conservation          |
C |                         Constraint is used (in 2-D Mode only)          |
C |           conmas:"Mass                conserved" Initialization Switch |
C |           conmas=.T. => Mass Conservation is used                      |
C |                                                                        |
C |    INPUT: Sounding(s) / File MARSND.dat                                |
C |    ^^^^^^                                                              |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  MESOSCALE VARIABLES                                          |
C |           ^^^^^^^^^^^^^^^^^^^                                          |
C |           nSND             : Sounding Number                           |
C |           pstDY (mx,my)    : Initial Model Thickness             [kPa] |
C |           pstDY1(mx,my)    : Initial Model Thickness -FIXED-     [kPa] |
C |           ugeoDY(mx,my,mz) : Initial Geo. Wind (x-Direction)     [m/s] |
C |           vgeoDY(mx,my,mz) : Initial Geo. Wind (y-Direction)     [m/s] |
C |           uairDY(mx,my,mz) : Initial      Wind (x-Direction)     [m/s] |
C |           vairDY(mx,my,mz) : Initial      Wind (y-Direction)     [m/s] |
C |           tairDY(mx,my,mz) : Initial                   Temperature [K] |
C |           TairSL(mx,my)    : Initial      Surface Air  Temperature [K] |
C |                             (Sounding Extrapolated to the Surface;     |
C |                              - dtagSL                            )     |
C |           pktaDY(mx,my,mzz): Initial Reduced Potential Temperature     |
C |             qvDY(mx,my,mz) : Initial Specific Humididity       [kg/kg] |
C |           qvapSL(mx,my)    : Initial Specific Humididity       [kg/kg] |
C |                             (Sounding Extrapolated to the Surface)     |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  LARGE SCALE VARIABLES (BOUNDARIES and DOMAIN AVERAGE)        |
C |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        |
C |        1. LBC                                                          |
C |           vaxgLB  (mx,my,mz,n):Large Scale Values of the Variables     |
C |                             (n=1,2,3,4,5) <=> (u,v,qv,pktaDY,pstDY),   |
C |                                                               for x << |
C |           vaxdLB : idem,                                          x >> |
C |           vayiLB : idem,                                          y << |
C |           vaysLB : idem,                                          y >> |
C |           zetaD  : Potential Vorticity  (CAUTION: Time Independant)    |
C |        2. UBC                                                          |
C |           uairUB, vairUB, pktaUB                                       |
C |                                                                        |
C |   METHOD: Vertical  Interpolation on Sigma Levels  is first performed  |
C |   ^^^^^^^ For two Soundings nearest in Time (before and after runtime) |
C |           Then Time Interpolation                                      |
C |           This order was preferred to the reverse because it allows    |
C |           to use Soundings having a different vertical Discretization  |
C |                                                                        |
C | # OPTIONS: _SC  Supersaturation not allowed (DO NOT USE for SCu cloud) |
C | # ^^^^^^^^ #WR  Additional Output                                      |
C |                                                                        |
C |   CAUTION: INIsnd may be used only for Large Scale Thermodynamics      |
C |   ^^^^^^^^ independant of x and y (i.e.for not too large model domain) |
C |            zeSND fixed at its initial value whenever Sounding varies   |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MARSND.inc'
c #PV include 'MAR_PV.inc'

      include 'MAR_DY.inc'
c #NH include 'MAR_NH.inc'

      include 'MAR_LB.inc'
      include 'MAR_UB.inc'

      include 'MAR_SL.inc'

      include 'MAR_WK.inc'

      include 'MAR_IO.inc'


C +--Local Variables
C +  ===============

c #CS logical   consnd

      integer   logcon
      integer   lbcfix,lsf   ,lvg   
      integer   intpol,jhsnd1,jhsnd2,i0snd ,j0snd ,ksnd  ,msnd
      integer   ishmin,jshmin,ii    ,jj    ,inew  ,jnew 
      integer   iyrnew,mmanew,jdanew,jhunew
      real      tsurf0,qsurf0,gradti,graddt,gra   ,timar ,timarn,timmar
      real      shmin ,distmn,distij,ta_inv,pksh  ,gsnd  ,ddnew
      real      zetaD ,dul   ,ttij_1,ttij_2
      real      qsat0D,acap  ,dem1  

      real      pksnd(0:40,2)
C +...          pksnd: pSND      ** (R/Cp),
C +             where (pSND/100) ** (R/Cp) : Exner Function

      real      tmsnd(0:40,2)
C +...          tmsnd: Potential Temperature 
C +                    averaged over the layer between ksnd-1/2 and ksnd+1/2

      real      pint   (2)
      real      tint   (2),qint   (2)

      real      ttij(mz,2),qvij(mz,2)
      real      ulij(mz,2),vlij(mz,2)

      real       dpt(mz),   dqa(mz)
      real       dug(mz),   dvg(mz)

      real      fftt(3),   ddtt(3)


C +--DATA
C +  ====

      data lbcfix/1/

c #CS data consnd/.true./

      data dem1  /1.0e-1/

      data lsf   /0/

c #OB      openLB=.true.
c #OB      lbcfix=0     

      lvg    = 0
C +...lvg:     is set to 1 if |Vg(sounding)| .ne. 0 anywhere

      acap   = 1.0 / cap
C +...acap:    Inverse of R / Cp

      ttij_1 = 0.0
      ttij_2 = 0.0


C +--Time Parameters
C +  ===============

      IF (iterun.eq.0)                                            THEN
        tiSND1 =                                           -99999999.99
        tiSND2 =                                           -99999999.99
         iSND  =   imez
         jSND  =   jmez
        loSND  =   1
      END IF

        timar  = ((iyrrGE *365   +iyrrGE*0.25
     .            +njyrGE(mmarGE)+jdarGE           ) *24 
     .           + jhurGE        +itizGE(iSND,jSND)     ) *36.d2
     .           + minuGE * 6.d1 +jsecGE
        timarn =   timar


C +--Interpolation Parameter
C +  =======================

      IF (tiSND1.ge.tiSND2)
     .  intpol = 0
C +...  intpol = 0 ==> No Interpolation between two soundings
C +              1 ==>    Interpolation between two soundings


C +  +++++++++++++++++++++++++++++++
C +--Search of the relevant Sounding
C +  +++++++++++++++++++++++++++++++


C +--Main Dependant Variables
C +  ========================

C +   ------------------------------------
      IF (timar .gt.tiSND2.and.loSND.eq.1)                        THEN
C +   ------------------------------------

        open (unit=2,status='old',file='MARsnd.dat')
        rewind     2
         read     (2,202)iyrSND,mmaSND,jdaSND,jhuSND
 202     format   (4i4,f4.0)
         read     (2,203)
 203     format   (1x)
         read     (2,202)iSND,jSND
         read     (2,203)
         read     (2,203)
         read     (2,204)(tSND(ksnd,1),qSND(ksnd,1),
     .                    zSND(ksnd,1),pSND(ksnd,1),
     .                    fSND(ksnd,1),dSND(ksnd,1),ksnd=40,0,-1)
 204     format((6d13.6))
         read     (2,204)zeSND     (1)
         read     (2,202)loSND

C +- Time Parameters
C +  ~~~~~~~~~~~~~~~
         jhsnd1 =  (iyrSND*365+iyrSND/4
     .      +njyrGE(mmaSND)+jdaSND)*24+jhuSND+itizGE(iSND,jSND)
         tiSND1 = ((iyrSND*365+iyrSND/4
     .      +njyrGE(mmaSND)+jdaSND)*24+jhuSND+itizGE(iSND,jSND))
     .            *3.6d3

C +     ~~~~~~~~~
C +- - -do  until
        msnd = 1
 200    CONTINUE
C +     ~~~~~~~~~

          IF (timar .gt.tiSND1.and.loSND.eq.1)                    THEN
            msnd   = msnd +1
            intpol = 1

            read     (2,202)iyrnew,mmanew,jdanew,jhunew
            read     (2,203)
            read     (2,202)inew,jnew
            read     (2,203)
            read     (2,203)
            read     (2,204)(tSND(ksnd,2),qSND(ksnd,2),
     .                       zSND(ksnd,2),pSND(ksnd,2),
     .                       fSND(ksnd,2),dSND(ksnd,2),ksnd=40,0,-1)
            read     (2,204)zeSND     (2)
            read     (2,202)loSND

            IF (abs(zeSND(2)-zeSND(1)).gt.epsi) 
     .        write(6,1)
 1            format(' **********************************',
     .                '**********************************',
     .             /,' * CAUTION: zeSND is Time Dependant',
     .               ' (NOT taken into account in MAR) *',
     .             /,' **********************************',
     .                '**********************************',/,1x)

C +- Time Parameters
C +  ~~~~~~~~~~~~~~~
            jhsnd2 =  (iyrnew*365+iyrnew/4
     .         +njyrGE(mmanew)+jdanew)*24+jhunew+itizGE(iSND,jSND)
            tiSND2 = ((iyrnew*365+iyrnew/4
     .         +njyrGE(mmanew)+jdanew)*24+jhunew+itizGE(iSND,jSND))
     .               *3.6d3

C +- Change  of Year
C +  ~~~~~~~~~~~~~~~
                timarn = timar 
            IF (mmaSND.eq.12.and.mmanew.eq.1)                     THEN
c #YR           jhsnd2 = jhsnd2 + nhyrGE 
c #YR           tiSND2 = tiSND2 + nhyrGE * 3600.0
C +...          Change in case of iyrSND and iyrnew not defined (#YR)

              IF (mmarGE.eq.1) 
     .          timarn = timar  + nhyrGE * 3600.0
            END IF

C +- Constant Sounding  IF either imposed (logcon = 1) or MARsnd.dat at EOF
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                                 logcon = 0
c #CS       IF (itexpe.eq.0    .and.consnd     ) logcon = 1
            IF (timarn.gt.tiSND2.or.logcon.eq.1)                  THEN

                intpol         = 0

                jhsnd1         = jhsnd2
                tiSND1         = tiSND2
                iyrSND         = iyrnew
                mmaSND         = mmanew
                jdaSND         = jdanew
                jhuSND         = jhunew
              DO ksnd=0,40
                 tSND(ksnd,1) =   tSND(ksnd,2)
                 qSND(ksnd,1) =   qSND(ksnd,2)
                 zSND(ksnd,1) =   zSND(ksnd,2)
                 pSND(ksnd,1) =   pSND(ksnd,2)
                 fSND(ksnd,1) =   fSND(ksnd,2)
                 dSND(ksnd,1) =   dSND(ksnd,2)
              END DO
            END IF

          ELSE

C +- Constant Sounding  IF Simulation starts before 1st Sounding Time
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                intpol         = 0

                jhsnd2         = jhsnd1
                tiSND2         = tiSND1
                iyrnew         = iyrSND
                mmanew         = mmaSND
                jdanew         = jdaSND
                jhunew         = jhuSND
              DO ksnd=0,40
                 tSND(ksnd,2) =   tSND(ksnd,1)
                 qSND(ksnd,2) =   qSND(ksnd,1)
                 zSND(ksnd,2) =   zSND(ksnd,1)
                 pSND(ksnd,2) =   pSND(ksnd,1)
                 fSND(ksnd,2) =   fSND(ksnd,1)
                 dSND(ksnd,2) =   dSND(ksnd,1)
              END DO

          END IF

C +- Continue Read
C +  ~~~~~~~~~~~~~

C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if (timarn.gt.tiSND2.and.loSND.eq.1)                 go to 200
C +- - -end  do until
C +     ~~~~~~~~~~~~~

C +- STOP     Read
C +  ~~~~~~~~~~~~~

        close(unit=2)

C +- Output  Listing
C +  ~~~~~~~~~~~~~~~
        write(4,205)msnd-intpol,jdaSND,labmGE(mmaSND),iyrSND,
     .                          jhuSND,jhuSND+itizGE(iSND,jSND)
 205    format(/,' SOUNDING No',i2,i6,1x,a3,i5,i4,' TU  (',i2,' LT)',
     .             ' --- MARsnd ---',
     .           /,' =============',
     .           /,' z   (m) | p  (Pa) | T   (K) | qv (kg/kg) |',
     .             ' ff(m/s) | dd(deg) |'
     .           /,'---------+---------+---------+------------+',
     .             '---------+---------+')

        write(4,206)(zSND(ksnd,1), pSND(ksnd,1),
     .               tSND(ksnd,1), qSND(ksnd,1),
     .               fSND(ksnd,1), dSND(ksnd,1), ksnd=40,0,-1)
 206    format((2(f8.0,' |'),f8.2,' |',d11.3,' |',f8.2,' |',f8.1,' |'))
C +
        IF (intpol.eq.1)                                          THEN
          write(4,205)msnd  ,jdanew,labmGE(mmanew),iyrnew,
     .                       jhunew,jhunew+itizGE(iSND,jSND)
          write(4,206)(zSND(ksnd,2), pSND(ksnd,2),
     .                 tSND(ksnd,2), qSND(ksnd,2),
     .                 fSND(ksnd,2), dSND(ksnd,2), ksnd=40,0,-1)
        END IF

C +   ------
      END IF
C +   ------


C +--Additional Variables
C +  ====================

C +--Time Parameters
C +  ---------------

      IF (tiSND2.gt.tiSND1)                                       THEN
          gradti = (timarn-tiSND1)/(tiSND2-tiSND1)
          graddt =  dt            /(tiSND2-tiSND1)
      ELSE
          gradti =  0.0
          graddt =  0.0
      END IF


C +--Exner Function and Potential Temperature
C +  ----------------------------------------

        DO    nSND=1,intpol+1
          DO  ksnd=0,40
            pksnd(ksnd,nSND) = exp(cap*log(dem1*pSND(ksnd,nSND)))
            tpSND(ksnd,nSND) = tSND(ksnd,nSND) *pcap/pksnd(ksnd,nSND)
          END DO


C +--Potential Temperature Averaging 
C +  -------------------------------

            tmsnd(   0,nSND) =       tpSND(     1,nSND)
          DO ksnd=1,39
            tmsnd(ksnd,nSND) = 0.5 *(tpSND(ksnd  ,nSND)
     .                              +tpSND(ksnd+1,nSND))
          END DO
            tmsnd(  40,nSND) =       tpSND(  40,nSND)
        END DO


C +  ++++++++++++++
C +--INITIALISATION
C +  ++++++++++++++

C +   ++++++++++++++++
      IF (itexpe.eq.0)                                            THEN
C +   ++++++++++++++++


C +--Reference Sea Level Air Temperature (K)
C +  =======================================

c #NH   taNH    =          tSND(1,1)


C +--Initialisation   of  the  main    Thermodynamical   Variables 
C +  Pressure Thickness, Surface Temperature and Specific Humidity
C +  =============================================================

        gra    = -gravit/RDryAi
        pstSND =  0.1 *(pSND(1,1)+gradti*(pSND(1,intpol+1)-pSND(1,1)))
     .                 -ptopDY
        tsurf0 =        tSND(1,1)+gradti*(tSND(1,intpol+1)-tSND(1,1))
        qsurf0 =        qSND(1,1)+gradti*(qSND(1,intpol+1)-qSND(1,1))

C +- Reference Grid Point for Temperature Vertical Profile Initialisation
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  ishmin = iSND
                  jshmin = jSND
C +...            indices for the lowest grid point

                   shmin = sh(ishmin,jshmin)
                  distmn =    mx    +my

        DO j=1,my
        DO i=1,mx

          IF   (sh(i,j).lt.shmin)                                 THEN
C +...    Constraint 1: Reference Grid Point must be the lowest  One

                  ishmin = i
                  jshmin = j
                   shmin = sh(ishmin,jshmin)
                  distmn = (i-iSND)*(i-iSND)+(j-jSND)*(j-jSND)
          ELSE
            IF (sh(i,j).eq.shmin)                                 THEN
C +...      Constraint 2: Reference Grid Point must be the closest One
C +                       from the Sounding Grid Point

                  distij = (i-iSND)*(i-iSND)+(j-jSND)*(j-jSND)
              IF (distij.lt.distmn)                               THEN
                  ishmin = i
                  jshmin = j
                   shmin = sh(ishmin,jshmin)
                  distmn = distij
              END IF
            END IF
          END IF

C +- Surface Elevation is      MSL
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   pstDY(i,j) = pstSND
                  TairSL(i,j) = tsurf0 - dtagSL
                  qvapSL(i,j) = qsurf0

C +- Surface Elevation is NOT  MSL ==> Integration
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF (sh(i,j).ne.zero)                                    THEN
C +
            DO  nSND=1,intpol+1
C +
              ksnd    =  1
C +...        ksnd    =  1 (when pSND(mz) -> pSND(0:mz), etc...)
C +                                          zSND(0) = -500m
C +
C + - - - - - do until
 110          CONTINUE
              if (zSND(ksnd,nSND).gt.sh(i,j))                go to 111
                  ksnd   =  ksnd + 1
              go to 110
 111          CONTINUE
C + - - - - - end do until
C +
              pksh      = pksnd(ksnd-1,nSND) 
     .                  + gravit *(zSND(ksnd-1,nSND)-sh(i,j))
     .                           *pcap/(cp*tmsnd(ksnd-1,nSND))
              pint(nSND)= exp(acap*log(pksh))
C +
              gsnd      = (tSND(ksnd,nSND)  - tSND(ksnd-1,nSND))
     .                  / (zSND(ksnd,nSND)  - zSND(ksnd-1,nSND))
              tint(nSND)=  tSND(ksnd-1,nSND)
     .                    +gsnd *(sh(i,j)-zSND(ksnd-1,nSND))
              gsnd      = (qSND(ksnd,nSND)  - qSND(ksnd-1,nSND))
     .                  / (zSND(ksnd,nSND)  - zSND(ksnd-1,nSND))
              qint(nSND)=  qSND(ksnd-1,nSND)
     .                    +gsnd *(sh(i,j)-zSND(ksnd-1,nSND))
C +
            END DO
C +
            pstDY (i,j) =  pint(1)+gradti*(pint(intpol+1)-pint(1))
     .                  -  ptopDY
            TairSL(i,j) =  tint(1)+gradti*(tint(intpol+1)-tint(1)) 
     .                  -  dtagSL
            qvapSL(i,j) =  qint(1)+gradti*(qint(intpol+1)-qint(1))
C +
          END IF
C +
c _SC     qmax        =  qsat0D(TairSL(i,j),unun,pstDY(i,j),ptopDY,lsf)
c _SC     qvapSL(i,j) =    min (qvapSL(i,j),qmax)
C +...    avoids supersaturation (_SC)
C +
          pstDY1(i,j) = pstDY(i,j)
        END DO
        END DO
C +
C +
C +--Temperature and Specific Humidity Vertical Profiles Initialisation
C +  ==================================================================
C +
        DO j=1,my
        DO i=1,mx
C +
          DO nSND=1,intpol+1
C +
C +         **************
            call INIsnd_th(pstDY(i,j),ptopDY,sigmid,sigma,ttij,qvij)
C +         **************
C +
          END DO
C +
        DO k=mz,1,-1
         tairDY(i,j,k) =  ttij(k,1)+gradti*(ttij(k,intpol+1)-ttij(k,1))
         ta_inv        =   min(tairDY(i,j,k),    tairDY(i,j,mz)-dtagSL)
           qvDY(i,j,k) = (qvij(k,1)+gradti*(qvij(k,intpol+1)-qvij(k,1)))
     .                 *  qsat0D(ta_inv       ,sigma(k),
     .                            pstDY(i,j),ptopDY,lsf)
     .                 /  qsat0D(tairDY(i,j,k),sigma(k),
     .                            pstDY(i,j),ptopDY,lsf)
C +...     Last two Lines: Correction for possible Surface Inversion
C +
c _SC      qmax        =  qsat0D(tairDY(i,j,k),sigma(k),
c _SC.                            pstDY(i,j),ptopDY,lsf)
c _SC      qvDY(i,j,k) =  min (qvDY(i,j,k),qmax)
c #OM    tairDY(i,j,k) =  tSND(1,1)+gradti*(tSND(intpol+1,1)-tSND(1,1))
c #OM      qvDY(i,j,k) =  zero
        END DO
        END DO
        END DO
C +
C +
C +--Reduced Potential Temperature     Vertical Profiles Initialisation
C +  ==================================================================
C +
        DO j=1,my
        DO i=1,mx
          pktaDY(i,j,mzz) = TairSL(i,j)  
     .                   /((pstDY1(i,j)         +ptopDY)**cap)
        END DO
        END DO
C +
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          pktaDY(i,j,k)   = tairDY(i,j,k)
     .                   /((pstDY1(i,j)*sigma(k)+ptopDY)**cap)
        END DO
        END DO
        END DO
C +
C +
C +--Geostrophic Wind Vertical Profile 1st Initialisation
C +  ====================================================
C +
        DO j=1,my
        DO i=1,mx
C +
          DO nSND=1,intpol+1
C +
C +
C +--Rotation from x in the West-East Direction to x in Direction GEddxx
C +  -------------------------------------------------------------------
C +
            DO ksnd=0,40
              ddnew       = (GEddxx - dSND(ksnd,nSND))  * degrad
              uuSND(ksnd) =           fSND(ksnd,nSND)   * cos(ddnew)
              vvSND(ksnd) =           fSND(ksnd,nSND)   * sin(ddnew)
            END DO
C +
C +
C +--Vertical Interpolation
C +  ----------------------
C +
C +         **************
            call INIsnd_vl(pstDY(i,j),ptopDY,sigmid,sigma,ulij,vlij)
C +         **************
C +
          END DO
C +
C +
C +--Time Interpolation
C +  ------------------
C +
          DO k=1,mz
            ugeoDY(i,j,k)= ulij(k,1)+gradti*(ulij(k,intpol+1)-ulij(k,1))
            vgeoDY(i,j,k)= vlij(k,1)+gradti*(vlij(k,intpol+1)-vlij(k,1))
          END DO
        END DO
        END DO
C +
            zetaD        =  zeSND(1)+gradti*( zeSND(intpol+1)- zeSND(1))
C +...      zetaD: Large Scale Local Vorticity (CAUTION: Time Independant)
C +
C +
C +--Large Scale Wind Vertical Profile 1st Initialisation
C +  ====================================================
C +
C +
C +--Auxiliary Variable for Mass Flux Computation
C +  --------------------------------------------
C +
        shmin = 100000.0
C +...  shmin : minimum surface elevation (for mass flux computation)
C +
        DO j=1,my
        DO i=1,mx
          IF (sh(i,j).lt.shmin)                                   THEN
            i0snd   = i
            j0snd   = j
            shmin = sh(i,j)
          END IF
        END DO
        END DO
C +
C +
C +--Wind Initialisation, under Constant Potential Vorticity Constraint
C +  ------------------------------------------------------------------
C +
c #PV   IF (potvor.and.mmx.gt.1.and.mmy.eq.1)                     THEN
C +
c #PV     DO k=1,mz
c #PV       ulscPV(k) = ugeoDY(iSND,jSND,k)
c #PV       vlscPV(k) = vgeoDY(iSND,jSND,k)
c #PV       if (abs(ulscPV(k)).gt.zero.or.abs(vlscPV(k)).gt.zero) lvg= 1
c #PV     END DO
C +
C +                                  **************
c #PV     IF (mmx.gt.1.and.lvg.eq.1) call INIsnd_PV(zetaD)
C +                                  **************
C +
C +...  Initialisation based on Potential Vorticity Conservation
C +     Based on the Direct Integration of the Relative Vorticity
C +
C +
C +--Wind Initialisation under Constant Mass Flux Constraint
C +  -------------------------------------------------------
C +
c #PV   ELSE
C +
          IF (conmas)                                             THEN
              DO k=1,mz
              DO j=1,my
              DO i=1,mx
                WKxyz1(i,j,k) = pstDY(i0snd,j0snd) * ugeoDY(i,j,k)
                WKxyz2(i,j,k) = pstDY(i0snd,j0snd) * vgeoDY(i,j,k)
                uairDY(i,j,k) = WKxyz1(i,j,k)      /  pstDY(i,j)
                vairDY(i,j,k) = WKxyz2(i,j,k)      /  pstDY(i,j)
C +...          Geostrophic Wind only used in Large Scale Press.Grad.Force
C +             Real        Wind takes into Account Mass Conservation
C +
              END DO
              END DO
              END DO
C +
            IF (mmy.eq.1)                                         THEN
              DO k=1,mz
              DO j=1,my
              DO i=1,mx
                vairDY(i,j,k) =                      vgeoDY(i,j,k)
              END DO
              END DO
              END DO
            END IF
C +
          ELSE
C +
              DO k=1,mz
              DO j=1,my
              DO i=1,mx
                uairDY(i,j,k) =                      ugeoDY(i,j,k)
                vairDY(i,j,k) =                      vgeoDY(i,j,k)
              END DO
              END DO
              END DO
          END IF
c #PV   END IF
C +
C +
C +--Output
C +  ------
C +
c #PV   write(21,182)(vgeoDY(i,1,mz),i=1,mx)
 182    format(/,  '  Vg(i,1,mz)      :',/,(15f8.2))
c #PV   write(21,183)(vairDY(i,1,mz),i=1,mx)
 183    format(/,  '  V (i,1,mz)      :',/,(15f8.2))
c #PV   write(21,184)(ugeoDY(i,1,mz),i=1,mx)
 184    format(/,  '  Ug(i,1,mz)      :',/,(15f8.2))
c #PV   write(21,185)(uairDY(i,1,mz),i=1,mx)
 185    format(/,  '  U (i,1,mz)      :',/,(15f8.2))
C +
        IF (IO_loc.ge.2)                                          THEN
            write(21,1860)
 1860       format(1x)
            write(21,1861) (ugeoDY(iSND,jSND,k),k=1,mz)
 1861       format('  ug     =',/,(15f7.1,' m/sec'))
C +
c #PV     IF (potvor.and.mmx.gt.1.and.mmy.eq.1)                   THEN
c #PV       write(21,1860)
c #PV       write(21,1862)  adugPV            
 1862       format('  adugPV =',  f7.3,' m/sec')
c #PV     END IF
C +
            write(21,1860)
            write(21,1863)  (vgeoDY(iSND,jSND,k),k=1,mz)
 1863       format('  vg     =',/,(15f7.1,' m/sec'))
C +
c #PV     IF (potvor.and.mmx.gt.1.and.mmy.eq.1)                   THEN
c #PV       write(21,1860)
c #PV       write(21,1864) (1.d3*advgPV(iSND, k),k=1,mz)
 1864       format('  advgPV =',/,(15f7.3,' mm/sec'))
c #PV     END IF
C +
            write(21,1860)
        END IF
C +
C +
C +   ++++++
      END IF
C +   ++++++


C +  +++++++++++++++++++++++++++++++++++++
C +--INITIALIZATION of BOUNDARY CONDITIONS
C +  +++++++++++++++++++++++++++++++++++++

C +   ++++++++++++++++++
      IF   (itexpe.eq.0)                                          THEN
C +   ++++++++++++++++++


C +     ================
        IF (log_1D.eq.0)                                          THEN
C +     ================

C +--Upper 
C +  -----
c #RF       DO     k=1,mzabso
c #RF         DO   j=1,my
c #RF           DO i=1,mx
c #RF             uairUB(i,j,k)   = uairDY(i,j,k)
c #RF             vairUB(i,j,k)   = vairDY(i,j,k)
c #RF             pktaUB(i,j,k)   = pktaDY(i,j,k)
c #RF           END DO
c #RF         END DO
c #RF       END DO

C +--x Axis
C +  ------
          IF (mmx.gt.1)                                           THEN

            DO     k=1,mz

              DO   j=1,my
                DO i=1,n7mxLB
                  vaxgLB(i,j,k,1) = uairDY(i,j,k)
                  vaxgLB(i,j,k,2) = vairDY(i,j,k)
                  vaxgLB(i,j,k,3) =   qvDY(i,j,k)
                  vaxgLB(i,j,k,4) = pktaDY(i,j,k)
                  vaxgLB(i,j,1,5) =  pstDY(i,j)
                END DO
                DO i=mx-n6mxLB,mx
                  vaxdLB(i,j,k,1) = uairDY(i,j,k)
                  vaxdLB(i,j,k,2) = vairDY(i,j,k)
                  vaxdLB(i,j,k,3) =   qvDY(i,j,k)
                  vaxdLB(i,j,k,4) = pktaDY(i,j,k)
                  vaxdLB(i,j,1,5) =  pstDY(i,j)
                END DO
              END DO

            END DO

          END IF

C +- y Axis
C +  ------
          IF (mmy.gt.1)                                           THEN

            DO     k=1,mz

              DO   i=1,mx
                DO j=1,n7myLB
                  vayiLB(i,j,k,1) = uairDY(i,j,k)
                  vayiLB(i,j,k,2) = vairDY(i,j,k)
                  vayiLB(i,j,k,3) =   qvDY(i,j,k)
                  vayiLB(i,j,k,4) = pktaDY(i,j,k)
                  vayiLB(i,j,1,5) =  pstDY(i,j)
                END DO
                DO j=my-n6myLB,my
                  vaysLB(i,j,k,1) = uairDY(i,j,k)
                  vaysLB(i,j,k,2) = vairDY(i,j,k)
                  vaysLB(i,j,k,3) =   qvDY(i,j,k)
                  vaysLB(i,j,k,4) = pktaDY(i,j,k)
                  vaysLB(i,j,1,5) =  pstDY(i,j)
                END DO
              END DO

            END DO

          END IF


C +     ====
        ELSE
C +     ====

          IF (tequil.gt.0.0)                                      THEN

C +--Upper 
C +  -----
c #RF       DO     k=1,mzabso
c #RF         DO   j=1,my
c #RF           DO i=1,mx
c #RF             uairUB(i,j,k)   = uairDY(i,j,k)
c #RF             vairUB(i,j,k)   = vairDY(i,j,k)
c #RF             pktaUB(i,j,k)   = pktaDY(i,j,k)
c #RF           END DO
c #RF         END DO
c #RF       END DO

C +--x Axis
C +  ------
            IF (mmx.gt.1)                                         THEN

              DO       k=1,mz

                DO     j=1,my
                  DO   i=2,n7mxLB
                    vaxgLB( i,j,k,1) = uairDY(i,             j,k)
                    vaxgLB( i,j,k,2) = vairDY(i,             j,k)
                    vaxgLB( i,j,1,5) = pstDYn(i,             j)  
                  END DO
                    vaxgLB( 1,j,k,1) = uairDY(ip11-lbcfix,j,k)
                    vaxgLB( 1,j,k,2) = vairDY(ip11-lbcfix,j,k)
                    vaxgLB( 1,j,1,5) = pstDYn(ip11-lbcfix,j)  

                  DO   i=mx-n6mxLB,mx1
                    vaxdLB( i,j,k,1) = uairDY(i,             j,k)
                    vaxdLB( i,j,k,2) = vairDY(i,             j,k)
                    vaxdLB( i,j,1,5) = pstDYn(i,             j)  
                  END DO
                    vaxdLB(mx,j,k,1) = uairDY(mx1+lbcfix,j,k)
                    vaxdLB(mx,j,k,2) = vairDY(mx1+lbcfix,j,k)
                    vaxdLB(mx,j,1,5) = pstDYn(mx1+lbcfix,j)  
                END DO

              END DO

            END IF

C +- y Axis
C +  ------
            IF (mmy.gt.1)                                         THEN

              DO  k=1,mz

                DO  i=1,mx
                  DO  j=1,n7myLB
                    vayiLB(i, j,k,1) = uairDY(i,j,             k)
                    vayiLB(i, j,k,2) = vairDY(i,j,             k)
                    vayiLB(i, j,k,5) = pstDYn(i,j)
                  END DO
                    vayiLB(i, 1,k,1) = uairDY(i,jp11-lbcfix,k)
                    vayiLB(i, 1,k,2) = vairDY(i,jp11-lbcfix,k)
                    vayiLB(i, 1,k,5) = pstDYn(i,jp11-lbcfix)  
                  DO  j=my-n6myLB,my1
                    vaysLB(i, j,k,1) = uairDY(i,j,             k)
                    vaysLB(i, j,k,2) = vairDY(i,j,             k)
                    vaysLB(i, j,k,5) = pstDYn(i,j)
                  END DO
                    vaysLB(i,my,k,1) = uairDY(i,my1+lbcfix,k)
                    vaysLB(i,my,k,2) = vairDY(i,my1+lbcfix,k)
                    vaysLB(i,my,k,5) = pstDYn(i,my1+lbcfix)  
                END DO

              END DO

            END IF

          END IF


C +     ======
        END IF
C +     ======


C +  +++++++++++++++++++++++++++++++++++++
C +--UPDATE of LATERAL BOUNDARY CONDITIONS
C +  +++++++++++++++++++++++++++++++++++++
C +
C +   ++++
      ELSE
C +   ++++
C +
C +
C +     ================
        IF (intpol.gt.0)                                          THEN
C +     ================
C +
C +
C +--Temperature and Specific Humidity Vertical Profiles Interpolation 
C +  =================================================================
C +
C +
C +--x Axis / x <<
C +  -------------
C +
          IF  (mmx.gt.1)                                          THEN
C +
               i=1
            DO j=1,my
c #pv          i=iSND
C +
C +- Vertical  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~~~~~
              DO nSND=1,2
C +
C +             **************
                call INIsnd_th(pstDY(i,j),ptopDY,sigmid,sigma,ttij,qvij)
C +             **************
C +
              END DO
c #pv          i=1   
C +...CAUTION: vaxgLB assumed at i=1 assumed to be that of the Sounding Point 
C +            when Potential Temperature is conserved  at the Synoptic Scale
C +
C +- Time  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~
              DO k=1,mz
                dpt(k) = (ttij(k,1) + gradti*(ttij(k,2)-ttij(k,1)))
     .                 /  exp(cap*log(pstDY(i,j)*sigma(k)+ptopDY))
     .                 -vaxgLB(i,j,k,4)
                dqa(k) =  qvij(k,1) + gradti*(qvij(k,2)-qvij(k,1))
     .                 -vaxgLB(i,j,k,3)
              END DO
C +
              IF (openLB)                                         THEN
                DO ii=1,n7mxLB
                DO  k=1,mz
                  vaxgLB(ii,j,k,4) =  vaxgLB(ii,j,k,4) + dpt(k)
                  vaxgLB(ii,j,k,3) =  vaxgLB(ii,j,k,3) + dqa(k)
                END DO
                END DO
              ELSE
                DO ii=1,n7mxLB
                DO  k=1,mz
                  vaxgLB(ii,j,k,4) =  pktaDY( 1,j,k)   + dpt(k)
                  vaxgLB(ii,j,k,3) =    qvDY( 1,j,k)   + dqa(k)
                END DO
                END DO
              END IF
C +
            END DO
C +
C +
C +- x Axis / x >>
C +  -------------
C +
               i=  mx
            DO j=1,my
c #pv          i=iSND
C +
C +- Vertical  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~~~~~
              DO nSND=1,2
C +
C +             **************
                call INIsnd_th(pstDY(i,j),ptopDY,sigmid,sigma,ttij,qvij)
C +             **************
C +
              END DO
C +
c #pv          i=mx  
C +
C +- Time  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~
              DO k=1,mz
                dpt(k) = (ttij(k,1) + gradti*(ttij(k,2)-ttij(k,1)))
     .                 /  exp(cap*log(pstDY(i,j)*sigma(k)+ptopDY))
     .                 -vaxdLB(i,j,k,4)
                dqa(k) =  qvij(k,1) + gradti*(qvij(k,2)-qvij(k,1))
     .                 -vaxdLB(i,j,k,3)
              END DO
                ttij_1 = ttij(mz,1)
                ttij_2 = ttij(mz,2)
C +
              IF (openLB)                                         THEN
                DO ii=mx-n6mxLB,mx
                DO  k=1,mz
                  vaxdLB(ii,j,k,4) =  vaxdLB(ii,j,k,4) + dpt(k)
                  vaxdLB(ii,j,k,3) =  vaxdLB(ii,j,k,3) + dqa(k)
                END DO
                END DO
              ELSE
                DO ii=mx-n6mxLB,mx
                DO  k=1,mz
                  vaxdLB(ii,j,k,4) =  pktaDY(mx,j,k)   + dpt(k)
                  vaxdLB(ii,j,k,3) =    qvDY(mx,j,k)   + dqa(k)
                END DO
                END DO
              END IF
C +
            END DO
C +
c #WR       IF (mod(minuGE,30).eq.0.and.jsecGE.eq.0)
c #WR.        write(6,608)mmaSND,jdaSND,jhuSND+itizGE(iSND,jSND),
c #WR.                    mmarGE,jdarGE,jhurGE,
c #WR.                    mmanew,jdanew,jhunew+itizGE(iSND,jSND),
c #WR.                    tiSND1,timmar,tiSND2,
c #WR.                    gradti,vaxdLB(mx,my,mz,4)*pcap
 608          format(3(i6,'/',i2,'/',i2,'LT'),3f13.0,
     .               ' |Time| =',f5.2,5x,' Theta_CLS =',f7.2)
C +
          END IF                                         ! {end mmx > 1} CTR
C +
C +
C +- y Axis / y <<
C +  -------------
C +
          IF  (mmy.gt.1)                                          THEN
C +
               j=1
            DO i=1,mx
C +
C +- Vertical  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~~~~~
            DO nSND=1,2
C +
C +           **************
              call INIsnd_th(pstDY(i,j),ptopDY,sigmid,sigma,ttij,qvij)
C +           **************
C +
            END DO
C +
C +- Time  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~
            DO  k=1,mz
              dpt(k) = (ttij(k,1) + gradti*(ttij(k,2)-ttij(k,1)))
     .               /  exp(cap*log(pstDY(i,j)*sigma(k)+ptopDY))
     .               -vayiLB(i,j,k,4)
              dqa(k) =  qvij(k,1) + gradti*(qvij(k,2)-qvij(k,1))
     .               -vayiLB(i,j,k,3)
            END DO
C +
            IF (openLB)                                           THEN
              DO jj=1,n7myLB
              DO  k=1,mz
                vayiLB(i,jj,k,4) =  vayiLB(i,jj,k,4) + dpt(k)
                vayiLB(i,jj,k,3) =  vayiLB(i,jj,k,3) + dqa(k)
              END DO
              END DO
            ELSE
              DO jj=1,n7myLB
              DO  k=1,mz
                vayiLB(i,jj,k,4) =  pktaDY(i, 1,k)   + dpt(k)
                vayiLB(i,jj,k,3) =    qvDY(i, 1,k)   + dqa(k)
              END DO
              END DO
            END IF
C +
            END DO
C +
C +
C +- y Axis / y >>
C +  -------------
C +
               j=  my
            DO i=1,mx
C +
C +- Vertical  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~~~~~
              DO nSND=1,2
C +
C +             **************
                call INIsnd_th(pstDY(i,j),ptopDY,sigmid,sigma,ttij,qvij)
C +             **************
C +
              END DO
C +
C +- Time  Interpolation
C +  ~~~~~~~~~~~~~~~~~~~
              DO  k=1,mz
                dpt(k) = (ttij(k,1) + gradti*(ttij(k,2)-ttij(k,1)))
     .                 /  exp(cap*log(pstDY(i,j)*sigma(k)+ptopDY))
     .                 -vaysLB(i,j,k,4)
                dqa(k) =  qvij(k,1) + gradti*(qvij(k,2)-qvij(k,1))
     .                 -vaysLB(i,j,k,3)
              END DO
C +
              IF (openLB)                                         THEN
                DO jj=my-n6myLB,my
                DO  k=1,mz
                  vaysLB(i,jj,k,4) =  vaysLB(i,jj,k,4) + dpt(k)
                  vaysLB(i,jj,k,3) =  vaysLB(i,jj,k,3) + dqa(k)
                END DO
                END DO
              ELSE
                DO jj=my-n6myLB,my
                DO  k=1,mz
                  vaysLB(i,jj,k,4) =  pktaDY(i,my,k)   + dpt(k)
                  vaysLB(i,jj,k,3) =    qvDY(i,my,k)   + dqa(k)
                END DO
                END DO
              END IF
C +
            END DO
C +
          END IF                                         ! {end mmy > 1} CTR
C +
C +
C +--Large Scale Wind Vertical Profiles Interpolation / Dynamical Adjustment
C +  =======================================================================
C +
C +
C +--Mass Flux Auxiliary Variable
C +  ----------------------------
C +
          IF  (conmas)                                            THEN
C +
            DO j=1,my
            DO i=1,mx
              WKxy1(i,j) = pstDY1(iSND,jSND)/pstDY1(i,j)
            END DO
            END DO
C +
          ELSE
C +
            DO j=1,my
            DO i=1,mx
              WKxy1(i,j) = 1.0
            END DO
            END DO
C +
          END IF
C +
C +
C +--Large Scale Wind Sounding: Default
C +  ----------------------------------
C +
          DO k=1,mz
            dug(k) = 0.0
            dvg(k) = 0.0
          END DO
C +
C +
C +--Rotation from x in the West-East Direction to x in Direction GEddxx
C +  -------------------------------------------------------------------
C +
          DO nSND=1,intpol+1
            DO ksnd=0,40
              ddnew       = (GEddxx - dSND(ksnd,nSND))  * degrad
              uuSND(ksnd) =           fSND(ksnd,nSND)   * cos(ddnew)
              vvSND(ksnd) =           fSND(ksnd,nSND)   * sin(ddnew)
            END DO
C +
C +
C +--Vertical Interpolation
C +  ----------------------
C +
C +           **************
              call INIsnd_vl(pstDY(iSND,jSND),ptopDY,sigmid,sigma,
     .                       ulij,vlij)
C +           **************
C +
          END DO
C +
C +
C +--Time Interpolation
C +  ------------------
C +
          DO k=1,mz
            dug(k) = graddt*(ulij(k,intpol+1)-ulij(k,1))
            dvg(k) = graddt*(vlij(k,intpol+1)-vlij(k,1))
          END DO
C +
C +
C +--Update of Direct Integration of Wind constrained by PV Conservation
C +  -------------------------------------------------------------------
C +
c #PV     IF (potvor.and.mmx.gt.1.and.mmy.eq.1)                   THEN
C +
c #PV       DO k=1,mz
c #PV         ulscPV(  k) =   ulscPV(k) + dug(k)
c #PV         vlscPV(  k) =   vlscPV(k) + dvg(k)
c #PV       END DO
C +
c #PV       DO k=1,mz
c #PV       DO j=1,my
c #PV       DO i=1,mx
c #PV         advbPV(i,k) = advbPV(i,k) + dvg(k)
c #PV       END DO
c #PV       END DO
c #PV       END DO
c #PV     END IF
C +
C +- PV   Conservation
C +  ~~~~~~~~~~~~~~~~~
c #PV     IF (potvor.and.mmx.gt.1.and.mmy.eq.1)                   THEN
C +
c #PV       DO k=1,mz
c #PV       DO j=1,my
c #PV       DO i=1,mx
c #PV         ugeoDY(i,j,k) =             adugPV       *ulscPV    (k)        
c #PV         vgeoDY(i,j,k) = advbPV(i,k) 
c #PV.                       +advgPV(i,k)*ugeoDY(i,j,k)*ugeoDY(i,j,k)
C +...        PV Conservation Constraint is included
C +
c #PV         dul           =   dug(k)   *adugPV       *adubPV(i,  k)
C +...        uairDY_Synop := uairDY        +dul        
C +           vairDY_Synop := vairDY        +dvg(k)              
C +           isallobaric wind contained in (dul,dvl=dvg)
C +
c #PV         ugeoDY(i,j,k) = ugeoDY(i,j,k) +dvg(k) 
c #PV.                      /(fcorDY(imez,jmez)*dt)
c #PV         vgeoDY(i,j,k) = vgeoDY(i,j,k) -dul    
c #PV.                      /(fcorDY(imez,jmez)*dt)
c #PV       END DO
c #PV       END DO
c #PV       END DO
c #PV     ELSE
C +
            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              ugeoDY(i,j,k) = ugeoDY(i,j,k) +dug(k)
              vgeoDY(i,j,k) = vgeoDY(i,j,k) +dvg(k)
              uairDY(i,j,k) = uairDY(i,j,k) +dug(k) *WKxy1(i,j) 
              vairDY(i,j,k) = vairDY(i,j,k) +dvg(k) *WKxy1(i,j) 
            END DO
            END DO
            END DO
c #PV     END IF
C +
C +
C +--Lateral Boundaries
C +  ------------------
C +
          IF (openLB)                                             THEN
C +
C +- x Axis / x <<
C +  ~~~~~~~~~~~~~
            DO i=1,n7mxLB
            DO j=1,my
c #PV         IF (potvor.and.mmx.gt.1.and.mmy.eq.1)               THEN
c #PV           DO k=1,mz
c #PV             vaxgLB(i,j,k,1)= 
c #PV.            vaxgLB(i,j,k,1)+dug(k)*adubPV(i,k)*adugPV
c #PV             vaxgLB(i,j,k,2)= 
c #PV.            vaxgLB(i,j,k,2)+dvg(k)
c #PV           END DO
c #PV         ELSE
                DO k=1,mz
                  vaxgLB(i,j,k,1)= 
     .            vaxgLB(i,j,k,1)+dug(k)            *WKxy1(i,j) 
                  vaxgLB(i,j,k,2)= 
     .            vaxgLB(i,j,k,2)+dvg(k)            *WKxy1(i,j) 
                END DO
c #PV         END IF
            END DO
            END DO
C +
C +- x Axis / x >>
C +  ~~~~~~~~~~~~~
            DO i=mx-n6mxLB,mx
            DO j=1,my
c #PV         IF (potvor.and.mmx.gt.1.and.mmy.eq.1)               THEN
c #PV           DO k=1,mz
c #PV             vaxdLB(i,j,k,1)= 
c #PV.            vaxdLB(i,j,k,1)+dug(k)*adubPV(i,k)*adugPV
c #PV             vaxdLB(i,j,k,2)= 
c #PV.            vaxdLB(i,j,k,2)+dvg(k)            
c #PV           END DO
c #PV         ELSE
                DO k=1,mz
                  vaxdLB(i,j,k,1)= 
     .            vaxdLB(i,j,k,1)+dug(k)            *WKxy1(i,j)
                  vaxdLB(i,j,k,2)= 
     .            vaxdLB(i,j,k,2)+dvg(k)            *WKxy1(i,j) 
                END DO
c #PV         END IF
            END DO
            END DO
C +
C +- y Axis / y <<
C +  ~~~~~~~~~~~~~
            IF (mmy.gt.1)                                         THEN
C +
              DO i=1,mx
              DO j=1,n7myLB
              DO k=1,mz
                vayiLB(i,j,k,1)= 
     .          vayiLB(i,j,k,1)+dug(k)            *WKxy1(i,j) 
                vayiLB(i,j,k,2)= 
     .          vayiLB(i,j,k,2)+dvg(k)            *WKxy1(i,j) 
              END DO
              END DO
              END DO
C +
C +- y Axis / y >>
C +  ~~~~~~~~~~~~~
              DO i=1,mx
              DO j=my-n6myLB,my
              DO k=1,mz
                vaysLB(i,j,k,1)= 
     .          vaysLB(i,j,k,1)+dug(k)            *WKxy1(i,j) 
                vaysLB(i,j,k,2)= 
     .          vaysLB(i,j,k,2)+dvg(k)            *WKxy1(i,j) 
              END DO
              END DO
              END DO
C +
            END IF
C +
          ELSE                       ! {end openLB / begin .NOT. openLB} CTR
C +
C +- x Axis / x <<
C +  ~~~~~~~~~~~~~
            IF (mmx.gt.1)                                         THEN
              DO i=1,n7mxLB
              DO j=1,my
              DO k=1,mz
                vaxgLB(i,j,k,1)= uairDY( 1,j,k)
                vaxgLB(i,j,k,2)= vairDY( 1,j,k)
              END DO
              END DO
              END DO
C +
C +- x Axis / x >>
C +  ~~~~~~~~~~~~~
              DO i=mx-n6mxLB,mx
              DO j=1,my
              DO k=1,mz
                vaxdLB(i,j,k,1)= uairDY(mx,j,k)
                vaxdLB(i,j,k,2)= vairDY(mx,j,k)
              END DO
              END DO
              END DO
            END IF
C +
C +- y Axis / y <<
C +  ~~~~~~~~~~~~~
            IF (mmy.gt.1)                                         THEN
              DO k=1,mz
              DO j=1,n7myLB
              DO i=1,mx
                vayiLB(i,j,k,1)= uairDY(i, 1,k)
                vayiLB(i,j,k,2)= vairDY(i, 1,k)
              END DO
              END DO
              END DO
C +
C +- y Axis / y >>
C +  ~~~~~~~~~~~~~
              DO k=1,mz
              DO j=1,n7myLB
              DO i=1,mx
                vaysLB(i,j,k,1)= uairDY(i,my,k)
                vaysLB(i,j,k,2)= vairDY(i,my,k)
              END DO
              END DO
              END DO
            END IF
          END IF                                    ! {end .NOT. openLB} CTR 
C +
C +     ======
        END IF
C +     ======
C +
C +
C +   ++++++
      END IF
C +   ++++++
C +
C +
C +--OUTPUT (Each Hour)
C +  ==================
C +
C +   --------------------------------
      IF (minuGE.eq.0.and.jsecGE.eq.0)                            THEN
C +   --------------------------------
C +
        DO  nSND  = 1,2
              fftt(nSND) = sqrt(ulij(mz,nSND)*ulij(mz,nSND)
     .                         +vlij(mz,nSND)*vlij(mz,nSND))
          IF                   (ulij(mz,nSND).ne.0.0)             THEN
              ddtt(nSND) = atan(vlij(mz,nSND)/ulij(mz,nSND))
            IF                 (ulij(mz,nSND).lt.zero)
     .        ddtt(nSND) = ddtt(nSND) + pi
          ELSE
            IF                 (vlij(mz,nSND).gt.zero)            THEN
              ddtt(nSND) =  0.5 * pi
            ELSE
              ddtt(nSND) = -0.5 * pi
            END IF
          END IF
        END DO
C +
            fftt(   3) = sqrt(ugeoDY(iSND,jSND,mz)*ugeoDY(iSND,jSND,mz)
     .                       +vgeoDY(iSND,jSND,mz)*vgeoDY(iSND,jSND,mz))
        IF                   (ugeoDY(iSND,jSND,mz).ne.zero)       THEN
            ddtt(   3) = atan(vgeoDY(iSND,jSND,mz)/ugeoDY(iSND,jSND,mz))
          IF                 (ugeoDY(iSND,jSND,mz).lt.zero)
     .      ddtt(   3) = ddtt(nSND) + pi
        ELSE
          IF                (vgeoDY(iSND,jSND,mz).gt.zero)        THEN
            ddtt(   3) =  0.5 * pi
          ELSE
            ddtt(   3) = -0.5 * pi
          END IF
        END IF
C +
        DO  nSND  = 1,3
           ddtt(nSND) = ddtt(nSND) * 180.0 / pi
           ddtt(nSND) =-ddtt(nSND) +  90.0
        END DO
C +
        write(4,442) 
 442    format(
     .  /,' yyyy-MM-jj-UT-mm |  uL m/s |  vL m/s |  VL m/s |  dd deg |',
     .     ' T(mx,mz) K |',
     .  /,' -----------------+---------+---------+---------+---------+',
     .     '------------+')
C +
        i = iSND
        j = jSND
C +
C +     ***********
        call TIMcor
C +     ***********
C +
        write(4,443)iyrSND,mmaSND,jdaSND,jhuSND,izr,
     .              ulij      (mz,1),vlij      (mz,1),
     .              fftt(1),ddtt(1),ttij_1
        write(4,443)iyrrGE,mmplus,jdplus,jhurGE,minuGE,
     .              ugeoDY(iSND,jSND,mz),vgeoDY(iSND,jSND,mz),
     .              fftt(3),ddtt(3),
     .              vaxdLB(mx,1,mz,4)
     .             *exp(cap*log(pstDY(mx,1)*sigma(mz)+ptopDY))
        if         (mmanew.gt.0) 
     .  write(4,443)iyrnew,mmanew,jdanew,jhunew,izr,
     .              ulij      (mz,2),vlij      (mz,2),
     .              fftt(2),ddtt(2),ttij_2
 443    format(i5,4('-',i2),
     .                  ' |',f8.2, ' |',f8.2,' |',f8.2,' |',f8.1,' |',
     .                      f10.3,'  |')
        write(4,444)
 444    format(/,1x)
C +
C +
C +   ------
      END IF
C +   ------
C +
C +
C +--Work Arrays Reset
C +  =================
C +
C +
      DO j=1,my
      DO i=1,mx
        WKxy1(i,j) = 0.0
      END DO
      END DO
C +
      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
      END DO
      END DO
      END DO
C +
      return
C +
      end
      subroutine INIsnd_th(pij,ptopDY,sigmid,sigma,t_ij,q_ij)
C +
C +------------------------------------------------------------------------+
C | MAR INPUT      ATMOS                                   25-09-2001  MAR |
C |   SubRoutine INIsnd_th initializes                                     |
C |     ATMOSPHERIC TEMPERATURES and SPECIFIC HUMIDITIES vertical profiles |
C |     from sounding data (observations or academic situation)            |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:    pij -> pstDY (i,j) : Model Pressure Thickness              |
C |   ^^^^^     ptopDY               Model Pressure Top                    |
C |             sigmid               Model Layer    Interface Coordinate   |
C |             sigma                Model Level              Coordinate   |
C |                                                                        |
C |   INPUT (via common)                                                   |
C |   ^^^^^     tpSND                Sounding       Potential Temperature  |
C |                                                                        |
C |   OUTPUT:    t_ij       -> tairDY(i,j,1->mz)                           |
C |   ^^^^^^     q_ij       ->   qvDY(i,j,1->mz)                           |
C |                                                                        |
C |   CAUTION:  The Sounding must be in Hydrostatic Balance                |
C |   ^^^^^^^                                                              |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
C +
      include 'MARSND.inc'
C +
      real      pij   ,ptopDY
      real      sigmid(mzz)
      real       sigma(mz)
C +
      real      t_ij(mz,2),q_ij(mz,2)
C +
C +
C +--Local  Variables
C +  ================
C +
      integer   k     ,ksnd  ,lsnd
      real      gra   ,prl   ,pr1   ,pr2
      real      gsnd  ,tt1   ,tt2   ,ttav
      real      gqv   ,qv1   ,qv2   ,qvav
C +
C +
C +--Scheme Initialisation
C +  =====================
C +
           gra     = -gravit / RDryAi
C +
C +--Temperature Vertical Profile
C +  ============================
C +
           k       =  mz
           ksnd    =  1
C +...     ksnd    =  1 (when pSND(mz) -> pSND(0:mz), etc...)
C +
C + - -do until
 100   CONTINUE
           prl     =  pij      *  sigma(k)     +ptopDY
        if(k  .eq.1) then
           pr1     = (pij *0.5 *  sigma(1)     +ptopDY) *10.0
        else
           pr1     = (pij      * sigmid(k)     +ptopDY) *10.0
        end if
           pr2     = (pij      * sigmid(k+1)   +ptopDY) *10.0
C +...     Factor 10 is needed for [cb] --> [mb]
C +
C + - - do until
 110    CONTINUE
        if (pSND(ksnd,nSND).lt.pr2    ) go to 111
           ksnd    =  ksnd + 1 
        go to 110
 111    CONTINUE
C + - - end do
C +
           gsnd    = (tpSND(ksnd,nSND)  - tpSND(ksnd-1,nSND))
     .             / ( pSND(ksnd,nSND)  -  pSND(ksnd-1,nSND))
           tt2     =  tpSND(ksnd-1,nSND)+  gsnd*(pr2-pSND(ksnd-1,nSND))
C +
           gqv     = ( qsnd(ksnd,nSND)  -  qSND(ksnd-1,nSND))
     .             / ( pSND(ksnd,nSND)  -  pSND(ksnd-1,nSND))
           qv2     =   qSND(ksnd-1,nSND)+  gqv *(pr2-pSND(ksnd-1,nSND))
C +
        if(pSND(ksnd,nSND).ge.pr1    ) then
           ttav    =  (tt2              + tpSND(ksnd,nSND)) 
     .              * (pr2              -  pSND(ksnd,nSND))
           qvav    =  (qv2              +  qSND(ksnd,nSND))
     .              * (pr2              -  pSND(ksnd,nSND))
        else
           ttav    =  zero
           qvav    =  zero
        end if
C +
C + - - do until
           lsnd    =         0
 120    CONTINUE
        if(pSND(ksnd,nSND).lt.pr1    ) go to 121
           ksnd    =  ksnd + 1
           lsnd    =         1
        if(pSND(ksnd,nSND).ge.pr1    ) then      
           ttav    =  ttav
     .             + (tpSND(ksnd-1,nSND)+ tpSND(ksnd,nSND)) 
     .              *( pSND(ksnd-1,nSND)-  pSND(ksnd,nSND))
           qvav    =  qvav
     .             + ( qSND(ksnd-1,nSND)+  qSND(ksnd,nSND)) 
     .              *( pSND(ksnd-1,nSND)-  pSND(ksnd,nSND))
        else
           gsnd    = (tpSND(ksnd,nSND)  - tpSND(ksnd-1,nSND))
     .             / ( pSND(ksnd,nSND)  -  pSND(ksnd-1,nSND))
           tt1     =  tpSND(ksnd-1,nSND)+  gsnd*(pr1-pSND(ksnd-1,nSND))
           ttav    =  ttav
     .             + (tpSND(ksnd-1,nSND)+   tt1) 
     .              *( pSND(ksnd-1,nSND)-   pr1)
           ttav    =  ttav * 0.5 / (pr2-pr1)
C +
           gqv     = ( qSND(ksnd,nSND)  -  qSND(ksnd-1,nSND))
     .             / ( pSND(ksnd,nSND)  -  pSND(ksnd-1,nSND))
           qv1     =   qSND(ksnd-1,nSND)+  gqv *(pr1-pSND(ksnd-1,nSND))
           qvav    =  qvav
     .             + ( qSND(ksnd-1,nSND)+   qv1) 
     .              *( pSND(ksnd-1,nSND)-   pr1)
           qvav    =  qvav * 0.5 / (pr2-pr1)
        end if
        go to 120
 121    CONTINUE
C + - - end do
C +
        if(lsnd.eq.0) then
           tt1     =  tpSND(ksnd-1,nSND)+  gsnd*(pr1-pSND(ksnd-1,nSND))
           ttav    = (tt2+tt1) * 0.5
C +
           qv1     =   qSND(ksnd-1,nSND)+  gqv *(pr1-pSND(ksnd-1,nSND))
           qvav    = (qv2+qv1) * 0.5
        end if
C +
C +
C +--Interpolated/Integrated Values
C +  ==============================
C +
           t_ij(k,nSND)=  ttav * prl**cap / pcap
           q_ij(k,nSND)=  qvav
C +
C +
C +--Continue Interpolation
C +  ======================
C +
       if (k         .le.1      ) go to 101
           k       =  k    - 1
       go to 100
 101   CONTINUE
C + - -end do
C +
      return
      end
      subroutine INIsnd_vl(pij,ptopDY,sigmid,sigma,u_ij,v_ij)

C +------------------------------------------------------------------------+
C | MAR INPUT      ATMOS                                   17-02-2004  MAR |
C |   SubRoutine INIsnd_vl initializes                                     |
C |     HORIZONTAL WIND COMPONENTS                     vertical profiles   |
C |     from sounding data (observations or academic situation)            |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:    pij -> pstDY (i,j) : Model Pressure Thickness              |
C |   ^^^^^     ptopDY               Model Pressure Top                    |
C |             sigmid               Model Layer    Interface Coordinate   |
C |             sigma                Model Level              Coordinate   |
C |                                                                        |
C |   INPUT (via common)                                                   |
C |   ^^^^^     uuSND                Sounding       U-Wind    Speed        |
C |             vvSND                Sounding       V-Wind    Speed        |
C |                                                                        |
C |   OUTPUT:    u_ij       -> ugeoDY(i,j,1->mz)                           |
C |   ^^^^^^     v_ij       -> vgeoDY(i,j,1->mz)                           |
C |                                                                        |
C |   CAUTION:   non-zero loav generates erroneous results                 |
C |   ^^^^^^^                                                              |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'
      include 'MARdim.inc'
      include 'MARSND.inc'

      real      pij   ,ptopDY         
      real       sigma(mz)
      real      sigmid(mzz)

      real       u_ij(mz,2),v_ij(mz,2)


C +--Local  Variables
C +  ================

      integer   k     ,ksnd  ,loav
      real      gra   ,prl   ,pr1   ,pr2
      real      guu   ,uu1   ,uu2   ,uuav
      real      gvv   ,vv1   ,vv2   ,vvav


C +--Scheme Initialisation
C +  =====================

           gra     = -gravit / RDryAi
           loav    =       0


C +--Geostrophic Wind Vertical Profile
C +  =================================

           k       =  mz
           ksnd    =  1
C +...     ksnd    =  1 (when pSND(mz) -> pSND(0:mz), etc...)

C + - -do until
 100   CONTINUE
        if(k  .eq.1) then
           pr1     =  pij *0.5d1 *  sigma(1)     +ptopDY
        else
           pr1     =  pij *1.0d1 * sigmid(k)     +ptopDY
        end if
           pr2     =  pij *1.0d1 * sigmid(k+1)   +ptopDY
C +...     Factor 10 is needed for [cb] --> [mb]

C + - - do until
 110    CONTINUE
        if (pSND(ksnd,nSND).lt.pr2    ) go to 111
           ksnd    =  ksnd + 1 
        go to 110
 111    CONTINUE
C + - - end do

           guu     = (uuSND(ksnd)      - uuSND(ksnd-1)     )
     .             / ( pSND(ksnd,nSND) -  pSND(ksnd-1,nSND))
           uu2     =  uuSND(ksnd-1)     +guu *(pr2-pSND(ksnd-1,nSND))
           gvv     = (vvSND(ksnd)      - vvSND(ksnd-1)     )
     .             / ( pSND(ksnd,nSND) -  pSND(ksnd-1,nSND))
           vv2     =  vvSND(ksnd-1)     +gvv *(pr2-pSND(ksnd-1,nSND))

        if(pSND(ksnd,nSND).ge.pr1    ) then
           uuav    =-(uu2          + uuSND(ksnd)     )
     .              *(pr2          -  pSND(ksnd,nSND)) *0.5
           vvav    =-(vv2          + vvSND(ksnd)     )
     .              *(pr2          -  pSND(ksnd,nSND)) *0.5
        else
           loav    =     0
           uuav    =  zero
           vvav    =  zero
        end if

C + - - do until
 120    CONTINUE
        if(pSND(ksnd,nSND).lt.pr1    ) go to 121
           ksnd    =  ksnd + 1
        go to 120
 121    CONTINUE
C + - - end do

           guu     = (uuSND(ksnd)      - uuSND(ksnd-1)     )
     .             / ( pSND(ksnd,nSND) -  pSND(ksnd-1,nSND))
           uu1     =  uuSND(ksnd-1)      + guu *(pr1 -pSND(ksnd-1,nSND))
           gvv     = (vvSND(ksnd)      - vvSND(ksnd-1)     )
     .             / ( pSND(ksnd,nSND) -  pSND(ksnd-1,nSND))
           vv1     =  vvSND(ksnd-1)      + gvv *(pr1 -pSND(ksnd-1,nSND))

        if(loav.gt.   0)          then
           uuav    =  uuav
     .             + (uuSND(ksnd-1)      + uu1       ) 
     .              *( pSND(ksnd-1,nSND) - pr1       ) *0.5
           vvav    =  vvav
     .             + (vvSND(ksnd-1)      + vv1       ) 
     .              *( pSND(ksnd-1,nSND) - pr1       ) *0.5
        else
           uuav    =      
     .               (uu2                + uu1       )
     .              *(pr2                - pr1       ) *0.5
           vvav    =      
     .               (vv2                + vv1       )
     .              *(pr2                - pr1       ) *0.5
        end if


C +--Layer Average
C +  =============

            uuav   =  uuav / (pr2-pr1)
            vvav   =  vvav / (pr2-pr1)


C +--Large Scale Wind Components in the MAR Coordinate System
C +  ========================================================

            u_ij(k,nSND)=  uuav
            v_ij(k,nSND)=  vvav

       if (k         .le.1      ) go to 101
           k       =  k    - 1
       go to 100
 101   CONTINUE
C + - -end do

      return
      end
      subroutine INIsnd_PV(zetaD)
C +
C +------------------------------------------------------------------------+
C | MAR INPUT      ATMOS                                    3-12-2000  MAR |
C |   SubRoutine INIsnd_PV initializes the Wind     (if Vg(sounding).ne.0) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  zetaD        : Large Scale Wind Potent. Vort. at (iSND,jSND) |
C |   ^^^^^                                                                |
C |                                                                        |
C |   INPUT  (via common block)                                            |
C |   ^^^^^   ulscPV(mz)   : Large Scale Wind (x-Direction) at (iSND,jSND) |
C |           vlscPV(mz)   : Large Scale Wind (y-Direction) at (iSND,jSND) |
C |           zeSND        : Large Scale Relative Vorticity at (iSND,jSND) |
C |                          (assumed constant in time)                    |
C |            pstDY(mx,my): Model (Pressure) Thickness              [kPa] |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  adugPV       : Constant in Time                              |
C |           advgPV(mx,mz): Constant in Time                              |
C |           adubPV(mx,mz): Constant in Time                              |
C |           advbPV(mx,mz): Updated by `dvg' ( d(vlscPV) ) each time step |
C |                                                                        |
C |   ASSUMPTION: Potential Vorticity Conservation & Barotropic            |
C |   ^^^^^^^^^^^ Barotropic (but works with (ulscPV,vlscPV) varying with z|
C |               2-D Mode:                                                |
C |               u satisfies Mass                Conservation Constraint  |
C |               v satisfies Potential Vorticity Conservation Constraint  |
C |                                                                        |
C |   METHOD used is the Direct Integration of the Weighted Vorticity      |
C |   ^^^^^^                                                               |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MARSND.inc'
      include 'MAR_PV.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_LB.inc'
C +
      include 'MAR_WK.inc'
C +
      real     zetaD
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  ips   ,jps   ,n6mxPV,n7mxPV,isrfmx
      real     Pa_hPA,thetaz,ertel ,fertel,zsrfmx
      real     forceK,signeU,uairLK,signeK
C +
C +
C +--Auxiliary Variables Initialization
C +  ==================================
C +
        j   =    1
        ips = iSND
        jps = jSND
        n7mxPV = 2
        n6mxPV = 1
C +
        Pa_hPA = 1.d3**cap
C +
      DO i=1,mx
        WKxy1(i,1) = 0.0
        WKxy2(i,1) = 0.0
      END DO
C +
      DO k=1,mz
      DO i=1,mx
        WKxza(i,k) = 0.0
        WKxzb(i,k) = uairDY(i,1,k)
      END DO
      END DO
C +
C +
C +--Large Scale Invariant
C +  =====================
C +
         adugPV = (zetaD +fcorDY(imez,jmez)) / fcorDY(imez,jmez)
C +
      DO  k=1,mz
      DO  i=n7mxPV,mx-n6mxPV
          ertel = (fcorDY(imez,jmez) +zetaD) / (pstDY(ips ,jps))
         fertel =  fcorDY(imez,jmez) /ertel
C +
C +
C +--Synoptic Scale Wind Initialization / Homogeneity along y axis
C +  =============================================================
C +
         WKxza(i,k) = ertel *0.5 *(pstDY(i,j)+pstDY(ip1(i),j)) 
     .              - fcorDY(imez,jmez)
C +...   WKxza(i,k) : Relative Vorticity (i+1/2,j)
C +                  - satisfy potential vorticity conservation constraint
C +                  - assumed to be zetaD for grid points
C +                    localized near the axis origin (ips,jps) and
C +                    having the same surface height
C +...   CAUTION   : Coriolis parameter variations not taken into account
C +
C +
         adubPV(i,k) = fertel /  pstDY(i,j)
         advgPV(i,k) =          fcorDY(imez,jmez) 
     .              * (pstDY(ip1(i),j)-pstDY(im1(i),j))*0.5
     .              / (dx*(WKxza(i,k)+fcorDY(imez,jmez))
     .                   *(WKxza(i,k)+fcorDY(imez,jmez))* pstDY(i,j)) 
      END DO
      END DO
C +
C +
C +--Contribution of the PGF forced by the Topography
C +  ------------------------------------------------
C +
c #pv DO i=n7mxPV,mx-n6mxPV
c #pv   afgzPV(i)   = gravit *(sh   (i-1,j)     -sh   (i+1,j))/(2.0*dx)
c #pv   afpsPV(i)   = Pa_Hpa *(pstDY(i-1,j)**cap-pstDY(i+1,j)**cap)
c #pv.                                                        /(2.0*dx)
c #pv END DO
C +
C +
C +--Boundaries
C +  ----------
C +
      IF (n7mxPV.gt.1)                                            THEN
        DO k=1,mz
        DO i=1,n7mxPV-1
          adubPV(i,k) = adubPV(   n7mxPV,k)
          advgPV(i,k) = advgPV(   n7mxPV,k)
        END DO
        END DO
      END IF
C +
      IF (n6mxPV.gt.0)                                            THEN
        DO k=1,mz
        DO i=mx-n6mxPV+1,mx
          adubPV(i,k) = adubPV(mx-n6mxPV,k)
          advgPV(i,k) = advgPV(mx-n6mxPV,k)
        END DO
        END DO
      END IF
C +
      DO   k = 1,mz
            advbPV (ips,k) = vlscPV (    k)
C +
          DO  i=ips,mx-max(n6mxPV,1)
            advbPV (i+1,k) = advbPV(      i,k) + dx * WKxza(i,k)
C +...      advbPV         : 'barotropic' wind v component
          END DO
C +
          DO  i=ips,max(n7mxPV,2),-1
            advbPV (i-1,k) = advbPV(      i,k) - dx * WKxza(i-1,k)
          END DO
C +
        IF (n7mxPV.gt.1)                                          THEN
          DO  i=1,n7mxPV-1
            advbPV (i  ,k) = advbPV(   n7mxPV,k)
          END DO
        END IF
C +
        IF (n6mxPV.gt.0) then
          DO  i=mx-n6mxPV+1,mx
            advbPV (i  ,k) = advbPV(mx-n6mxPV,k)
          END DO
        END IF
C +
      END DO
C +
      DO k=1,mz
      DO i=1,mx
        ugeoDY(i,j,k) = ulscPV(    k)*adugPV
        uairDY(i,j,k) = ugeoDY(i,j,k)*adubPV(i,k)
        vairDY(i,j,k) = advbPV(i,  k)
        vgeoDY(i,j,k) = advbPV(i,  k)  
     .                 +advgPV(i,  k)*ugeoDY(i,j,k)*ugeoDY(i,j,k)
      END DO
      END DO
C +
C +
C +--Adiabatic Initialisation
C +  ========================
C +
C +
C +--Surface Top of the Model Domain
C +  -------------------------------
C +
c #pv       zsrfmx = 0.0
c #pv DO i=n7mxPV,mx-n6mxPV
c #pv   IF (sh(i,1).gt.zsrfmx) then 
c #pv       isrfmx =    i
c #pv       zsrfmx = sh(i,1)
c #pv   END IF
c #pv END DO
C +
C +
C +--Reduced Mass Flux
C +  -----------------
C +
c #pv DO i=1,mx
c #pv      WKxy1(i,1) = 0.0
c #pv DO k=1,mz
c #pv      WKxy1(i,1) = WKxy1(i,1) + uairDY(i,1,k)*dsigm1(k)
c #pv END DO
c #pv END DO
C +
C +
C +--Contribution from Topography to the PGF and the Initial Wind
C +  ------------------------------------------------------------
C +
c #pv     thetaz = 0.0
c #pv DO k=mz,1,-1
c #pv     thetaz = thetaz + cp*pktaDY(iSND,jSND,k)*dsigm1(k)
C +
c #pv   DO i=isrfmx+1,mx-n6mxPV
c #pv     forceK = 2.0 *(afgzPV(i)+afpsPV(i)*thetaz) *dx
c #pv     signeU = sign(unun,  uairDY(i-1,j,k))
c #pv     uairLK =             uairDY(i-1,j,k)*uairDY(i-1,j,k)
c #pv.                        -forceK*signeU
c #pv     signeK = sign(unun,  uairLK       )
c #pv     uairLK = sqrt(signeK*uairLK)*signeK*signeU 
c?#pv     uairDY(i,j,k) =      uairLK
c #pv   END DO
C +
c #pv   DO i=isrfmx,n7mxPV,-1
c #pv     forceK = 2.0 *(afgzPV(i)+afpsPV(i)*thetaz) *dx
c #pv     signeU = sign(unun,  uairDY(i+1,j,k))
c #pv     uairLK =             uairDY(i+1,j,k)*uairDY(i+1,j,k)
c #pv.                        +forceK*signeU
c #pv     signeK = sign(unun,  uairLK       )
c #pv     uairLK = sqrt(signeK*uairLK)*signeK*signeU 
c?#pv     uairDY(i,j,k) =      uairLK
c #pv   END DO
c #pv END DO
C +
C +
C +--RMSE
C +  ----
C +
c?#pv   rmse = 0.0
c?#pv DO k=1,mz
c?#pv DO i=1,mx
c?#pv   squa = uairDY(i,1,k)-WKxzb(i,k)
c?#pv          WKxzb(i,k)=uairDY(i,1,k)
c?#pv   rmse = rmse + squa * squa
c?#pv END DO
c?#pv END DO
c?#pv   rmse = rmse /  (mx * mz)
C +
C +
C +--Reduced Mass Flux
C +  -----------------
C +
c #pv DO i=1,mx
c #pv      WKxy2(i,1) = 0.0
c #pv DO k=1,mz
c #pv      WKxy2(i,1) = WKxy2(i,1) + uairDY(i,1,k)*dsigm1(k)
c #pv END DO
c #pv END DO
C +
C +
C +--Mass Conservation
C +  -----------------
C +
c?#pv DO i=1,mx
c?#pv   IF (WKxy1(i,1) .ne. 0.0  .and. WKxy2(i,1) .ne.  0.0)
c?#pv.      pstDY(i,1)  = pstDY(i,1) * WKxy1(i,1)/WKxy2(i,1) 
c?#pv END DO
C +
c?#pv DO i=1,mx
c?#pv      pstDYn(i,1)  = pstDY(i,1)
c?#pv END DO
C +
c?#pv  write(21,316)rmse,(uairDY(imez+1,1,k),k=mz,1,-1)
 316   format(/,'   --- Initialisation / INIsnd_PV ---',
     .        /,'        (Adiabatic)   / RMSE(U) [#pv] = ',d15.6,
     .        /,'         U  (mez+1):',10f7.2,
     .       (/,'                    ',10f7.2))
C +
C +
C +--Thermodynamics
C +  --------------
C +
c #pv DO k=1,mz
c #pv DO j=1,my
c #pv DO i=1,mx
c #pv     qvDY(i,j,k) =   qvDY(iSND,jSND,k)
c #pv   pktaDY(i,j,k) = pktaDY(iSND,jSND,k)
c #pv END DO
c #pv END DO
c #pv END DO
C +
C +
C +--Work Arrays Reset
C +  =================
C +
      DO i=1,mx
        WKxy1(i,1) = 0.0
        WKxy2(i,1) = 0.0
      END DO
C +
      DO k=1,mz
      DO i=1,mx
        WKxza(i,k) = 0.0
        WKxzb(i,k) = 0.0
      END DO
      END DO
C +
      return
      end
      subroutine INIubc(ihamr_ubc,nhamr_ubc,newubcINI)

C +------------------------------------------------------------------------+
C | MAR INPUT    Upper Sponge                          Thu 05-11-2009  MAR |
C |   SubRoutine INIubc is used to initialize MAR Upper Sponge Refer.State |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  ihamr_ubc: Time Digital Filter Status                        |
C |   ^^^^^   nhamr_ubc: Time Digital Filter Set Up                        |
C |                                                                        |
C |   OUTPUT: newubcINI: (0,1) ==> (NO new ubc , new ubc)                  |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   OUTPUT: uairUB: Current                     x-Wind Speed Component   |
C |   ^^^^^^^ ua1_UB: Previous Nesting Time Step  x-Wind Speed Component   |
C |           ua2_UB: Next     Nesting Time Step  x-Wind Speed Component   |
C |           vairUB, va1_UB, va2_UB, pktaUB, pkt1UB, pkt2UB: idem         |
C |           tim1UB,tim2UB:   Times  n, n+1  of  uairUB, vairUB, pktaUB   |
C |                                                                        |
C |   CAUTION: It is assumed that tim1UB and tim2UB do not change when the |
C |   ^^^^^^^^ Variables are reassigned after the dynamical Initialization |
C |            (Reassignation => itexpe := nham => timar := timar-nham*dt) |
C |                                                                        |
C |   MODIF.   5 Nov 2009   : Map Scaling Factor SFm_DY scales (u,v) at UB |
C |   ^^^^^                   (i.e., ua2_UB, va2_UB are divided by SFm_DY) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
      include 'MAR_UB.inc'

      integer  ihamr_ubc,nhamr_ubc
      integer  newubcINI


C +--Local  Variables
C +  ================

      integer*8  itimUB
      real       rate


C +--Current Time
C +  ============

          itimUB=ou2sGE(iyrrGE,mmarGE,jdarGE,jhurGE,minuGE,jsecGE)
c #HF.           + (ihamr_ubc+nhamr_ubc)                           * idt


C +--Reinitialization of the Upper Sponge Reference State
C +  ----------------------------------------------------

      IF (iterun.eq.0)                                            THEN
          jdh_UB = 1
          iyr_UB = iyrrGE
          mma_UB = mmarGE
          jda_UB = jdarGE
          jhu_UB = jhurGE
          tim1UB = itimUB
          tim2UB = itimUB
       DO k=1,mzabso
       DO j=1,my
       DO i=1,mx
         ua1_UB(i,j,k) = uairUB(i,j,k)
         ua2_UB(i,j,k) = uairUB(i,j,k)
         va1_UB(i,j,k) = vairUB(i,j,k)
         va2_UB(i,j,k) = vairUB(i,j,k)
         pkt1UB(i,j,k) = pktaUB(i,j,k)
         pkt2UB(i,j,k) = pktaUB(i,j,k)
       END DO
       END DO
       END DO

      END IF


C +--New UBC
C +  =======

      IF (itimUB.gt.   tim2UB)                                    THEN

          tim1UB =     tim2UB

          write(6,6001)jda_UB,labmGE(mma_UB),iyr_UB,
     .                 jhu_UB,                      tim1UB,
     .                 jdarGE,labmGE(mmarGE),iyrrGE,
     .                 jhurGE,minuGE,        jsecGE,itimUB
 6001     format(/, '  1st UBC /',i3,'-',a3,'-',i4,i3,' ',2x,'/',2x,
     .              '   t =',i12,'s A.P.',
     .           /, '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12)
C +
       IF (jdh_UB.eq.0)jdh_UB = -1
       open (unit=11,status='old',form='unformatted',file='MARubc.DAT')
       rewind     11
 11    CONTINUE
       IF (jdh_UB.le.0)                                       GO TO 10


C +--UBC at nesting time step n
C +  --------------------------

       DO k=1,mzabso
       DO j=1,my
       DO i=1,mx
         ua1_UB(i,j,k) = ua2_UB(i,j,k)
         va1_UB(i,j,k) = va2_UB(i,j,k)
         pkt1UB(i,j,k) = pkt2UB(i,j,k)
         ua2_UB(i,j,k) = 0.d0
         va2_UB(i,j,k) = 0.d0
         pkt2UB(i,j,k) = 0.d0
       END DO
       END DO
       END DO


C +--UBC at nesting time step n+1
C +  ----------------------------

       read      (11) iyr_UB,mma_UB,jda_UB,jhu_UB,jdh_UB
       read      (11) ua2_UB,va2_UB,pkt2UB

       tim2UB=ou2sGE(iyr_UB,mma_UB,jda_UB,jhu_UB,0,0)

       DO k=1,mzabso
       DO j=1,my
       DO i=1,mx
            ua2_UB(i,j,k)=ua2_UB(i,j,k) / SFm_DY(i,j)
            va2_UB(i,j,k)=va2_UB(i,j,k) / SFm_DY(i,j)
       END DO
       END DO
       END DO

       IF(itimUB.gt.tim2UB)                                   GO TO 11

          write(6,6002)jda_UB,labmGE(mma_UB),iyr_UB,
     .                 jhu_UB,jdh_UB,               tim2UB
 6002     format(   '  2nd UBC /',i3,'-',a3,'-',i4,i3,' ',2x,'/(',i1,
     .              ')  t =',i12)

 10    CONTINUE
       close(unit=11)

      ELSE
c #WR     write(6,6003)jdarGE,labmGE(mmarGE),iyrrGE,
c #WR.                 jhurGE,minuGE,        jsecGE,itimUB
 6003     format(   '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12,'s A.P.')
      END IF


C +--Time Interpolation
C +  ==================

      IF            (itimUB.le.tim2UB  .and.   tim1UB.lt.tim2UB)  THEN

        rate = float(itimUB  - tim1UB) / float(tim2UB  - tim1UB)
        DO k=1,mzabso
        DO j=1,my
        DO i=1,mx
            uairUB(i,j,k)=ua1_UB(i,j,k) +
     .     (ua2_UB(i,j,k)-ua1_UB(i,j,k))*rate
            vairUB(i,j,k)=va1_UB(i,j,k) +
     .     (va2_UB(i,j,k)-va1_UB(i,j,k))*rate
            pktaUB(i,j,k)=pkt1UB(i,j,k) +
     .     (pkt2UB(i,j,k)-pkt1UB(i,j,k))*rate
        END DO
        END DO
        END DO

        newubcINI = 1

      ELSE
        newubcINI = 0
      END IF

      return
      end


      subroutine INIpen

C +------------------------------------------------------------------------+
C | MAR INPUT      ATMOS                                   25-07-2004  MAR |
C |   Subroutine INIpen is used to initialize Sigma Surface Slopes         |
C |     (ROUTINE is NOT STANDARD,                                          |
C |              is used only with Horizontal Correction of Diffusion)     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    gplvDY(i,j,k): Geopotential Level    Sigma=k        (m2/s2) |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^   slopex(i,j,k): x-Slope of Sigma=k Surface (Grid Point i,j)  |
C |            slopey(i,j,k): y-Slope of Sigma=k Surface (Grid Point i,j)  |
C |                                                                        |
C | # OPTIONS: #2D  2-D Horizontal Filtering of the Slopes                 |
C | # ^^^^^^^^ #3D  3-D Horizontal Filtering of the Slopes                 |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MARpen.inc'

      include 'MAR_IO.inc'


C +--Local  Variables
C +  ================

      include 'MARvec.inc'

c #OB logical  openLB
      real     deltaa
      integer  kdim


C +--DATA
C +  ====

c #OB data openLB/.true./
      data deltaa/0.5e0/
C +...     deltaa Filter Parameter


C +--Entry Checking Point
C +  ====================

      if (IO_loc.ge.2) write(21,999)
  999 format(/,'   --- Initialisation / INIpen ---',/,1x)


C +--Sigma Surfaces Slopes: x-Direction
C +  ==================================

           kdim = mz

      DO   k=1,mz
          dumeps(     k) =  deltaa
        DO j=1,my
          dumy3D( 1,j,k) =  0.0
          dumy3D(mx,j,k) =  0.0
        END DO
      END DO

      DO   k=1,mz
        DO i=ip11,mx1
        DO j=1,my
          dumy3D( i,j,k) = (gplvDY(ip1(i),j,k)-gplvDY(im1(i),j,k))
     .                   / (2.0*dx*gravit)
        END DO
        END DO
      END DO

      IF (mmy.le.1)                                               THEN 
c #OB   IF (openLB)                                               THEN

          DO k=1,mz

C +         ***************
c #OB       call DYNfil_1D0(dumy3D,dumeps,kdim)
C +         ***************

          END DO

c #OB   ELSE

          DO k=1,mz

C +         **************
            call DYNfil_1D(dumy3D,dumeps,kdim)
C +         **************

          END DO

c #OB   END IF

      ELSE 
c #OB   IF (openLB)                                               THEN

C +         ***************
c #OB       call DYNfil_3D0(dumy3D,dumeps,kdim)
C +         ***************

c #OB   ELSE

c #NV     IF (no_vec)                                             THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV     ELSE

C +         **************
            call DYNfilv3D (dumy3D,dumeps,kdim)
C +         **************

c #NV     END IF

c #OB   END IF
      END IF 

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
          slopex(i,j,k)   = dumy3D(i,j,k)
          dumy3D(i,j,k)   = 0.
        END DO
        END DO
      END DO
        DO j=1,my
        DO i=1,mx
          slopex(i,j,mzz) = slopex(i,j,mz)
        END DO
        END DO


C +--Sigma Surfaces Slopes: y-Direction
C +  ==================================

C +   -------------
      IF (mmy.gt.1)                                               THEN 
C +   -------------

        DO   k=1,mz
          DO j=jp11,my1
          DO i=1,mx
            dumy3D(i,j,k) = (gplvDY(i,jp1(i),k)-gplvDY(i,jm1(i),k))
     .                    / (2.0*dy*gravit)
          END DO
          END DO
        END DO

c #OB   IF (openLB)                                               THEN

C +         ***************
c #OB       call DYNfil_3D0(dumy3D,dumeps,kdim)
C +         ***************

c #OB   ELSE

c #NV     IF (no_vec)                                             THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV     ELSE

C +         **************
            call DYNfilv3D (dumy3D,dumeps,kdim)
C +         **************

c #NV     END IF

c #OB   END IF

        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
            slopey(i,j,k)   = dumy3D(i,j,k)
          END DO
          END DO
        END DO
          DO j=1,my
          DO i=1,mx
            slopey(i,j,mzz) = slopey(i,j,mz)
          END DO
          END DO

C +   ------
      end if 
C +   ------

      return
      end


      subroutine DYNrho

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           16-12-2000  MAR |
C |   SubRoutine DYNrho computes the Air Specific Mass                     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^   pstDY(mx,my)   : Atmosphere Thickness                  [kPa] |
C |          tairDY(mx,my,mz): Air Temperature                         [K] |
C |           virDY(mx,my,mz): Air Loading by Water Vapor and Hydrometeors |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^ rolvDY(mx,my,mz): Air Specific Mass at Sigma Levels    [T/m3] |
C |          romiDY(mx,my,mz): Air Specific Mass in Sigma Layers    [T/m3] |
C |          pstDY2(mx,my)   : Atmosphere Thickness Squared         [kPa2] |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_SL.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      real    sigmmz
C +
C +
C +--Perfect Gas Law Relationship
C +  ----------------------------
C +
      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        rolvDY(i,j,k)=(pstDYn(i,j)*sigma(k)+ptopDY)
     .               /(RDryAi
     .               * tairDY(i,j,k)*(1.0+0.715*virDY(i,j,k)))
C +...  rolvDY(i,j,k) : Air Specific Mass at grid point (i,j,k)
C +                  0.715 allows to include vir by 0.715=0.608/0.850
C +
      END DO
      END DO
      END DO
C +
      DO k=1,mmz1
      DO j=1,my
      DO i=1,mx
        romiDY(i,j,k) =(pstDYn(i,j)*sigmid(kp1(k))+ptopDY)
     .                /(RDryAi
     .      *0.5*(tairDY(i,j,k)     *(1.0+0.715*virDY(i,j,k))
     .           +tairDY(i,j,kp1(k))*(1.0+0.715*virDY(i,j,kp1(k)))))
C +...  romiDY(i,j,k) : Air Specific Mass at grid point (i,j,k+1/2)
C +
      END DO
      END DO
      END DO
C +
                                    sigmmz = 0.500 *(1.0+sigma(mz))
      DO j=1,my
      DO i=1,mx
        romiDY(i,j,mz)=(pstDYn(i,j)*sigmmz         +ptopDY)
     .                /(RDryAi*0.50*(tairDY(i,j,mz)+TairSL(i,j))
     .                             *(1.0  +  0.715 * virDY(i,j,mz)))
        pstDY2(i,j)   = pstDY(i,j)*pstDY(i,j)
      END DO
      END DO
C +
      return
      end


      subroutine DYNloa

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                      Mon 11-Apr-2011  MAR |
C |   SubRoutine DYNloa computes the Air Loading due to the Precipitation  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^   qvDY(mx,my,mz) : Air Specific Humidity               [kg/kg] |
C |           qwHY(mx,my,mz) : Cloud Droplets     Concentration    [kg/kg] |
C |           qiHY(mx,my,mz) : Cloud ice Crystals Concentration    [kg/kg] |
C |           qrHY(mx,my,mz) : Rain  Drops        Concentration    [kg/kg] |
C |           qsHY(mx,my,mz) : Snow  Flakes       Concentration    [kg/kg] |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^ virDY(mx,my,mz) : Air Loading by Water Vapor & Hydrometeors   |
C |          virSL(mx,my)    : Air Loading by Water Vapor & Hydrometeors   |
C |                            (in the Surface Layer)                      |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_HY.inc'
c #TC include 'MAR_TC.inc'

      include 'MAR_SL.inc'


C +--Local  Variables
C +  ================

c #BV include 'MARvec.inc'
c #BV integer  kdim

c #BV real     deltav


C +--DATA
C +  ====

c #BV data    deltav/0.20/


C +--Air Loading including Specific Humidity (Level 0)
C +  =================================================

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        virDY( i,j,k) = qvDY(i,j,k)
      END DO
      END DO
      END DO


C +--Air Loading including all Hydrometeors  (Level 1)
C +  =================================================

c #HV DO k=1,mz
c #HV DO j=1,my
c #HV DO i=1,mx
c #HV   virDY( i,j,k) = qvDY(i,j,k) 
c #HV.   -1.64*min(demi,qwHY(i,j,k)+qiHY(i,j,k)+qrHY(i,j,k)+qsHY(i,j,k) 
c #DV.                 +qxTC(i,j,k,1)
c #HV.                                                                 )
c #HV END DO
c #HV END DO
c #HV END DO


C +--Air Loading including Correction Factor (Level 2)
C +  =================================================

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        virDY( i,j,k) = 0.850 * virDY( i,j,k)
      END DO
      END DO
      END DO


C +--Lateral Boundary Conditions
C +  ===========================

      DO   k=1,mz
        DO j=1,my
          virDY( 1,j,k) = virDY(ip11,j,k)
          virDY(mx,j,k) = virDY(mx1,j,k)
        END DO

        DO i=1,mx
          virDY(i, 1,k) = virDY(i,jp11,k)
          virDY(i,my,k) = virDY(i,my1,k)
        END DO

      END DO


C +--Air Loading for SBL Parameterization
C +  ====================================

c #BV    dumeps(    1)  = deltav
c #BV DO j=1,my
c #BV DO i=1,mx
c #BV    dumy3D(i,j,1)  = fracSL*0.715*virDY(i,j,mz) 
c #BV.             + (1.0-fracSL)     *virSL(i,j) 
c #BV END DO
c #BV END DO
c #BV    kdim           = 1


C +--Filtering
C +  ---------

c #BV IF   (mmx.gt.1)                                             THEN
c #BV   IF (mmy.eq.1)                                             THEN

C +            *********
c #BV     call DYNfil_1D(dumy3D,dumeps,kdim)
C +            *********

c #BV   ELSE

c #bv     IF (no_vec)                                             THEN

c #bv               if(openmp) then
C +                      **********
c #bv               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #bv               else
C +                      **********
c #bv               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #bv               endif

c #bv     ELSE

C +              *********
c #BV       call DYNfilv3D (dumy3D,dumeps,kdim)
C +              *********

c #bv     END IF

c #BV   END IF
c #BV END IF

c #BV DO j=1,my
c #BV DO i=1,mx
c #BV     virSL(i,j)   = dumy3D(i,j,1)
c #BV END DO
c #BV END DO


C +--NO Loading included in case of Mountain Waves Tests
C +  ===================================================

c #OM DO k=1,mz
c #OM DO j=1,my
c #OM DO i=1,mx
c #OM     virDY(i,j,k) = 0.0d+0
c #OM END DO
c #OM END DO
c #OM END DO

      return
      end


      subroutine DYNgpo

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                    16-12-2000  MAR |
C |   SubRoutine DYNgpo contains the Integration of Hydrostatic Relation   |
C |                          and the Computation of Real Temperature t [K] |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^   pktaDY(mx,my,mzz): Reduced Potential Temperature             |
C |           gplvDY(mx,my,mzz): Surface Geopotential (i.e. for k=mzz)     |
C |            virDY(mx,my,mz) : Air Loading by water vapor & hydrometeors |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^    pkDY(mx,my,mz) : Exner Potential                           |
C |           tairDY(mx,my,mz) : Temperature                           [K] |
C |           gplvDY(mx,my,mzz):    Geopotential                   [m2/s2] |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

      real    ab


C +--EXNER Potential and Temperature
C +  ===============================

      ab=0.5*(1.0-sigmid(mz))/(1.0-sigmid(mmz1))

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
          pkDY(i,j,k) = exp(cap *log(pstDYn(i,j)*sigma(k)+ptopDY))
        tairDY(i,j,k) = pktaDY(i,j,k) *pkDY(i,j,k)
        WKxyz1(i,j,k) = cp            *pkDY(i,j,k)
      END DO
      END DO
      END DO

      DO k=1,mmz1
      DO j=1,my
      DO i=1,mx
        WKxyz2(i,j,k) = cp            *pkDY(i,j,kp1(k))
      END DO
      END DO
      END DO

      DO j=1,my
      DO i=1,mx
        WKxyz2(i,j,mz)= cp * 
     .                  exp(cap *log(pstDYn(i,j)         +ptopDY))
      END DO
      END DO


C +--Integration of the Hydrostatic Equation / Work Arrays Reset
C +  ===========================================================

      DO j=1,my
      DO i=1,mx
        gplvDY(i,j,mz)=gplvDY(i,j,mzz) +(WKxyz2(i,j,mz)-WKxyz1(i,j,mz))
     .      *((1.0+ab)*pktaDY(i,j,mz)  *(1.0+virDY(i,j,mz ))
     .            -ab *pktaDY(i,j,mmz1)*(1.0+virDY(i,j,mmz1)))

        WKxyz1(i,j,mz)=   0.0
        WKxyz2(i,j,mz)=   0.0
      END DO
      END DO

      DO  k=mmz1,1,-1
      DO  j=1,my
      DO  i=1,mx
        gplvDY(i,j,k)=gplvDY(i,j,kp1(k))+(WKxyz2(i,j,k )-WKxyz1(i,j,k ))
     .              *(pktaDY(i,j,k)     *(1.0+virDY(i,j,k))
     .               +pktaDY(i,j,kp1(k))*(1.0+virDY(i,j,kp1(k))))*0.5

        WKxyz1(i,j,k) =   0.0
        WKxyz2(i,j,k) =   0.0
      END DO
      END DO 
      END DO

      return
      end


      subroutine DYNgpo_mp

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                    16-12-2000  MAR |
C |   SubRoutine DYNgpo contains the Integration of Hydrostatic Relation   |
C |                          and the Computation of Real Temperature t [K] |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^   pktaDY(mx,my,mzz): Reduced Potential Temperature             |
C |           gplvDY(mx,my,mzz): Surface Geopotential (i.e. for k=mzz)     |
C |            virDY(mx,my,mz) : Air Loading by water vapor & hydrometeors |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^    pkDY(mx,my,mz) : Exner Potential                           |
C |           tairDY(mx,my,mz) : Temperature                           [K] |
C |           gplvDY(mx,my,mzz):    Geopotential                   [m2/s2] |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

      real    ab


C +--EXNER Potential and Temperature
C +  ===============================

      ab=0.5*(1.0-sigmid(mz))/(1.0-sigmid(mmz1))

!$OMP PARALLEL DO
!$OMP.private(i,j,k)
      DO j=1,my 
      DO k=1,mz
      DO i=1,mx
          pkDY(i,j,k) = exp(cap *log(pstDYn(i,j)*sigma(k)+ptopDY))
        tairDY(i,j,k) = pktaDY(i,j,k) *pkDY(i,j,k)
        WTxyz1(i,j,k) = cp            *pkDY(i,j,k)
      END DO
c      END DO
      END DO

      DO k=1,mmz1
c      DO j=1,my
      DO i=1,mx
        WTxyz2(i,j,k) = cp            *pkDY(i,j,kp1(k))
      END DO
c      END DO
      END DO

c      DO j=1,my
      DO i=1,mx
        WTxyz2(i,j,mz)= cp * 
     .                  exp(cap *log(pstDYn(i,j)         +ptopDY))
      END DO
c      END DO


C +--Integration of the Hydrostatic Equation / Work Arrays Reset
C +  ===========================================================

c      DO j=1,my
      DO i=1,mx
        gplvDY(i,j,mz)=gplvDY(i,j,mzz) +(WTxyz2(i,j,mz)-WTxyz1(i,j,mz))
     .      *((1.0+ab)*pktaDY(i,j,mz)  *(1.0+virDY(i,j,mz ))
     .            -ab *pktaDY(i,j,mmz1)*(1.0+virDY(i,j,mmz1)))

        WTxyz1(i,j,mz)=   0.0
        WTxyz2(i,j,mz)=   0.0
      END DO
c      END DO

      DO  k=mmz1,1,-1
c      DO  j=1,my
      DO  i=1,mx
        gplvDY(i,j,k)=gplvDY(i,j,kp1(k))+(WTxyz2(i,j,k )-WTxyz1(i,j,k ))
     .              *(pktaDY(i,j,k)     *(1.0+virDY(i,j,k))
     .               +pktaDY(i,j,kp1(k))*(1.0+virDY(i,j,kp1(k))))*0.5

      END DO
      END DO 
      END DO
!$OMP END PARALLEL DO

      return
      end

      subroutine DYNdps(norder)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                    10-08-2004  MAR |
C |   SubRoutine DYNdps solves the Mass Conservation Equation              |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   ^^^^^         iterun          : long  time step counter              |
C |                 itFast          : short time step counter              |
C |                 norder          : numerical scheme: order of precision |
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   OUTPUT        pstDYn(mx,my)   : Pressure Depth p*(t)           (kPa) |
C |   ^^^^^^         pstDY(mx,my)   : Pressure Depth p*(t-dt)              |
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^         uairDY(mx,my,mz): x-Wind Speed                   (m/s) |
C |                 vairDY(mx,my,mz): y-Wind Speed                   (m/s) |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^  psigDY: p* X Vertical Wind Speed; Sigma Syst.(i.e. p* Ds/Dt) |
C |                   psigDY Computed  ON the Sigma Levels   (unstaggered) |
C |                                    IN           Layers     (staggered) |
C |                                                                        |
C |   METHOD: Implicit Time Scheme (pImplc  Switch is .true. )             |
C |   ^^^^^^       2th order accurate Time  Scheme (semi-implicit)   .AND. |
C |                2th order accurate Space Scheme on Arakawa A grid       |
C |                                                                        |
C |           Explicit Time Scheme (pImplc  Switch is .false.)             |
C |            Centered     Scheme (center  Switch is .true. )             |
C |                2th order accurate Time  Scheme (leapfrog backw.) .AND. |
C |   norder.EQ.2 (2th order accurate Space Scheme on Arakawa A grid .OR.  |
C |   norder.NE.2  4th order accurate Space Scheme on Arakawa A grid)      |
C |                                                                   .OR. |
C |            Non-Centered Scheme (center  Switch is .false.)             |
C |                0th order accurate Space Scheme (Bott) (norder=0)  .OR. |
C |                4th order accurate Space Scheme (Bott) (norder=4)       |
C |                                                                        |
C |            Robert Time Filter may be used to remove computational mode |
C |                                                                        |
C |   REFER.:  Use of A grid: Purser and Leslie, MWR 116, 2069--2080, 1988 |
C |   ^^^^^^   Time Scheme  : Lin    and Rood    MWR 124, 2046--2070, 1996 |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
c #ON include 'MAR_TE.inc'

      include 'MAR_WK.inc'

      integer  norder


C +--Local  Variables
C +  ================

      logical  pImplc,locorr

      integer   mxx     ,myy
      parameter(mxx=mx+1,myy=my+1)
      real      vecx(0:mxx),flux(0:mxx)
      real      aa0x(0:mxx),aa1x(0:mxx),aa2x(0:mxx)
      real                  aa3x(0:mxx),aa4x(0:mxx)
      real      cnpx(0:mxx),cnmx(0:mxx)
      real      sipx(0:mxx),simx(0:mxx),sidx(0:mxx)
      real      vecy(0:myy),fluy(0:myy)
      real      aa0y(0:myy),aa1y(0:myy),aa2y(0:myy)
      real                  aa3y(0:myy),aa4y(0:myy)
      real      cnpy(0:myy),cnmy(0:myy)
      real      sipy(0:myy),simy(0:myy),sidy(0:myy)

      integer it_pst,nt_pst,idir_x,jdir_y
      integer i1_dps,i2_dps,j1_dps,j2_dps,k1_dps,k2_dps
      real    alphpp,betapp,Fp__pp,Fpa_pp,Fpb_pp,facovr
      real    CorArg,CorrNH,SRes_0,SRes_1,SRes10,pst_n1
      real    dtcorr,dtxfas,dtyfas,uuface,vvface

      integer              numdps,ntpsig
      common  /DYNdps_int/ numdps,ntpsig

      real                 psigad(mx,my,mz)
      common  /DYNdps_rea/ psigad


C +--DATA
C +  ====

      data     pImplc/.false./
C +...         pImplc=.true.  ==> Implicit Scheme is used to damp Lamb Waves

               numdps    = numdps+1


C +--Save Mass at the Lateral Boundaries
C +  ===================================

        do     j=1,my
        do     i=1,mx
           WKxy1( i, j) = pstDY( i,j)
C +                       p*(n-1)
           WKxy2( i, j) = pstDYn(i,j)
C +                       p*(n)
        end do
        end do

         do    j=1,my
           pstDY(  1,j) = pstDYn( 1,j)
           pstDY( mx,j) = pstDYn(mx,j)
         end do

        if (mmy.gt.1) then
         do    i=1,mx
           pstDY( i, 1) = pstDYn(i, 1)
           pstDY( i,my) = pstDYn(i,my)
         end do
        end if


C ++++++++++++++++++++++++++++++++++
C +--IMPLICIT SCHEME       (BEGIN) +
C ++++++++++++++++++++++++++++++++++


      IF   (pImplc)                                                 THEN
        IF (it_Mix.EQ.1.AND.itFast.EQ.1)                            THEN


C +--Horizontal Wind Speed: Average along the Vertical
C +  -------------------------------------------------

          DO j=1,my
          DO i=1,mx
            WKxy3(i,j) = 0.0
            WKxy4(i,j) = 0.0
          END DO
          END DO

          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            WKxy3(i,j) = WKxy3(i,j) + uairDY(i,j,k) * dsigm1(k)
            WKxy4(i,j) = WKxy4(i,j) + vairDY(i,j,k) * dsigm1(k)
          END DO
          END DO
          END DO


C +--Tridiagonal Matrix Coefficients
C +  -------------------------------

            betapp    = 0.6
            alphpp    = 1.0    - betapp
            Fp__pp    = dt     / dx
            Fpa_pp    = Fp__pp * alphpp
            Fpb_pp    = Fp__pp * betapp
          DO  i = ip11,mx1
          DO  j = jp11,my1
            WKxyz1(i,j,1) = Fpb_pp *WKxy3(ip1(i),j) ! k=1: 3-Diag Matrix, x-Dir
            WKxyz3(i,j,1) =-Fpb_pp *WKxy3(im1(i),j) ! k=1: 3-Diag Matrix, x-Dir
c #vL     END DO
c #vL     END DO

c #vL     DO  j = jp11,my1
c #vL     DO  i = ip11,mx1
            WKxyz1(i,j,2) = Fpb_pp *WKxy4(i,jp1(j)) ! k=2: 3-Diag Matrix, y-Dir
            WKxyz3(i,j,2) =-Fpb_pp *WKxy4(i,jm1(j)) ! k=2: 3-Diag Matrix, y-Dir
          END DO
          END DO


C +--Overrelaxation Starting Block
C +  -----------------------------

C +--Independant Term: constant contribution        !                     x-Dir
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          DO i=ip11,mx1
          DO j=jp11,my1
              WKxyz8(i,j,1) =                   pstDY(    i ,j)
     .              - Fpa_pp *WKxy3(ip1(i),j) * pstDY(ip1(i),j)
     .              + Fpa_pp *WKxy3(im1(i),j) * pstDY(im1(i),j)
c #vL     END DO
c #vL     END DO

c #vL     DO  j = jp11,my1
c #vL     DO  i = ip11,mx1
c #vL         WKxyz8(i,j,1) =                  WKxyz8(i,    j ,1)
     .              - Fpa_pp *WKxy4(i,jp1(j)) * pstDY(i,jp1(j))
     .              + Fpa_pp *WKxy4(i,jm1(j)) * pstDY(i,jm1(j))
          END DO
          END DO

C +--Dirichlet Condition x-LBC                      !                     x-Dir
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
               i=     mx1
            DO j=jp11,my1
              WKxyz8(i,j,1) =                  WKxyz8(    i ,j,1)
     .              - Fpb_pp *WKxy3(ip1(i),j) * pstDY(ip1(i),j)
              WKxyz1(i,j,1) = 0.0
c #WR         write(6,*)            ip1(i),' ', pstDY(ip1(i),j)
            END DO

               i=ip11
            DO j=jp11,my1
              WKxyz8(i,j,1) =                  WKxyz8(    i ,j,1)
     .              + Fpb_pp *WKxy3(im1(i),j) * pstDY(im1(i),j)
              WKxyz3(i,j,1) = 0.0
c #WR         write(6,*)            im1(i),' ', pstDY(im1(i),j)
            END DO

C +--Dirichlet Condition y-LBC
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
          IF (mmy.gt.1)                                             THEN
               j=     my1
            DO i=ip11,mx1
              WKxyz8(i,j,1) =                  WKxyz8(i,    j,1)
     .              - Fpb_pp *WKxy3(i,jp1(j)) * pstDY(i,jp1(j))
              WKxyz1(i,j,2) = 0.0
c #WR         write(6,*)            jp1(j),' ', pstDY(i,jp1(j))
            END DO
C +
               j=jp11
            DO i=ip11,mx1
              WKxyz8(i,j,1) =                  WKxyz8(i,    j,1)
     .              + Fpb_pp *WKxy3(i,jm1(j)) * pstDY(i,jm1(j))
              WKxyz3(i,j,2) = 0.0
c #WR         write(6,*)            jm1(j),' ', pstDY(i,jm1(j))
            END DO
          END IF

C +--First Estimate
C +  ~~~~~~~~~~~~~~
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz7(i,j,1) =  pstDY(i,j)              ! Previous       Estimate
            WKxyz7(i,j,2) =  0.0                     ! Half-Iteration Estimate
            WKxyz7(i,j,3) =  pstDY(i,j)              ! Next to update Estimate
          END DO
          END DO

C +--Recurrence
C +  ~~~~~~~~~~
          facovr= 1.1
          nt_pst= 4
          it_pst= 0
          SRes_1= 0.0
 1000     CONTINUE
          it_pst= it_pst + 1


C +--Resolution along the x-Direction
C +  --------------------------------

C +--Tridiagonal Matrix Coefficients
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              DO j=jp11,my1
              DO i=ip11,mx1
                WKxyz1(i,j,3) = WKxyz1(i,j,1)        ! Index 1 ==>      x-Dir
                WKxyz2(i,j,3) = 1.0d+0               !
                WKxyz3(i,j,3) = WKxyz3(i,j,1)        !
              END DO
              END DO

C +--Independant Term
C +  ~~~~~~~~~~~~~~~~
              DO j=jp11,my1
              DO i=ip11,mx1
                WKxyz4(i,j,3) = WKxyz8(i,j,1)        ! Index 1 ==>    ALL-Dir
     .                        - WKxyz1(i,j,2) *WKxyz7(i,jp1(j),1)
     .                        - WKxyz3(i,j,2) *WKxyz7(i,jm1(j),1)
              END DO
              END DO

C +--Tridiagonal Matrix Inversion                    ! OUTPUT is WKxyz7(i,j,3)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            i1_dps = ip11
            i2_dps = mx1
            j1_dps = jp11
            j2_dps = my1
            k1_dps = 3
            k2_dps = 3

C +              ********
            call MARgau_x(i1_dps,i2_dps,j1_dps,j2_dps,k1_dps,k2_dps)
C +              ********


C +--Resolution along the y-Direction
C +  --------------------------------

            IF (mmy.gt.1)                                           THEN

C +--Tridiagonal Matrix Coefficients                 ! Index 2 ==>      y-Dir
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              DO j=jp11,my1
              DO i=ip11,mx1
                WKxyz1(i,j,3) = WKxyz1(i,j,2)
                WKxyz2(i,j,3) = 1.
                WKxyz3(i,j,3) = WKxyz3(i,j,2)
                WKxyz7(i,j,2) = WKxyz7(i,j,3)        ! Half-Iteration Estimate
              END DO
              END DO

C +--Independant Term                                !                  y-Dir
C +  ~~~~~~~~~~~~~~~~
              DO i=ip11,mx1
              DO j=jp11,my1
                WKxyz4(i,j,3) = WKxyz8(i,j,1)        ! Index 1 ==>    ALL-Dir
     .                        - WKxyz1(i,j,1) *WKxyz7(ip1(i),j,2)
     .                        - WKxyz3(i,j,1) *WKxyz7(im1(i),j,2)
              END DO
              END DO

C +--Tridiagonal Matrix Inversion                    ! OUTPUT is WKxyz7(i,j,3)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              i1_dps = ip11
              i2_dps = mx1
              j1_dps = jp11
              j2_dps = my1
              k1_dps = 3
              k2_dps = 3

C +                ********
              call MARgau_y(i1_dps,i2_dps,j1_dps,j2_dps,k1_dps,k2_dps)
C +                ********

            END IF

C +--Residual is obtained by substracting next from former estimated Equation
C +  ------------------------------------------------------------------------

            DO  i = ip11,mx1
            DO  j = jp11,my1
              WKxyz6(i,j,1) = WKxyz1(i,j,1) * WKxyz7(ip1(i),j,3)
     .                      + WKxyz3(i,j,1) * WKxyz7(im1(i),j,3)
c #vL       END DO
c #vL       END DO

c #vL       DO  j = jp11,my1
c #vL       DO  i = ip11,mx1
c #vL         WKxyz6(i,j,1) = WKxyz6(i,j,1)
     .                      + WKxyz1(i,j,2) * WKxyz7(i,jp1(j),3)
     .                      + WKxyz3(i,j,2) * WKxyz7(i,jm1(j),3)
     .                      +                 WKxyz7(i,j     ,3)
     .                      - WKxyz8(i,j,1)
            END DO
            END DO

              SRes_1        =  0.0
            DO  j = jp11,my1
            DO  i = ip11,mx1
              SRes_1        =  SRes_1   + abs(WKxyz6(i,j,1))
            END DO
            END DO

            IF (it_pst.gt.1)                                      THEN
              SRes10        =  SRes_1 / SRes_0
            ELSE
              SRes_0        =  SRes_1
              SRes10        =  1.0
            END IF


C +--New Estimate
C +  ------------

            IF (SRes10.gt.0.1   .and.it_pst.lt.nt_pst
     .                          .and.mmy   .gt.     1)              THEN
              DO  j = jp11,my1
              DO  i = ip11,mx1
                WKxyz7(i,j,1) = WKxyz7(i,j,3)
     .                - facovr* WKxyz6(i,j,1)/WKxyz2(i,j,1)
                WKxyz7(i,j,3) = WKxyz7(i,j,1)
              END DO
              END DO
            END IF
C +
c #WR         write(6,1001) iterun,it_pst,SRes10
 1001         format(2i9,f21.15)
C +
          IF    (SRes10.gt.1.0d-1.and.it_pst.lt.nt_pst
     .                           .and.mmy   .gt.     1)       GO TO 1000


C +--Final Estimate
C +  --------------

          DO j=jp11,my1
          DO i=ip11,mx1
                pstDY( i,j)   = WKxyz7(i,j,3)
                pstDYn(i,j)   = WKxyz7(i,j,3)
          END DO
          END DO

C +--Lateral Boundary Conditions
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
            DO j=jp11,my1
                pstDY(  1,j) = WKxy1( 1,j)
                pstDY( mx,j) = WKxy1(mx,j)
                pstDYn( 1,j) = WKxy1( 1,j)
                pstDYn(mx,j) = WKxy1(mx,j)
            END DO

          IF (mmy.gt.1)                                             THEN
            DO i=ip11,mx1
                pstDY( i, 1) = WKxy1(i, 1)
                pstDY( i,my) = WKxy1(i,my)
                pstDYn(i, 1) = WKxy1(i, 1)
                pstDYn(i,my) = WKxy1(i,my)
            END DO
          END IF


C +--Contribution to Vertical Material Speed
C +  ---------------------------------------

               DO k=1,mz

                 DO j=1,my
                 DO i=1,mx
                   WKxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
                   WKxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
                   WKxyz8(i,j,k)=                0.
                 END DO
                 END DO

                 DO  j=1,my
                 DO  i=1,mx
                   WKxyz7(i,j,k)=(WKxyz3(im1(i),j,k)-WKxyz3(ip1(i),j,k)
c #vL.                           )
c #vL            ENDDO
c #vL            ENDDO

c #vL            DO  i=1,mx
c #vL            DO  j=1,my
c #vL              WKxyz7(i,j,k)=(WKxyz7(i,    j ,k)
     .                           +WKxyz4(i,jm1(j),k)-WKxyz4(i,jp1(j),k)
     .                           )                  *dxinv2
                 END DO
                 END DO

 ! Two previous Loops are the vectorized version of the following Loop
 !               DO  j=1,my
 !               DO  i=1,mx
 !                 WKxyz7(i,j,k)=               -dxinv2
 !   .                      *(WKxyz3(ip1(i),j,k)-WKxyz3(im1(i),j,k)
 !   .                       +WKxyz4(i,jp1(j),k)-WKxyz4(i,jm1(j),k))
 !               END DO
 !               END DO

               END DO

        END IF


C ++++++++++++++++++++++++++++++++++
C +--IMPLICIT SCHEME         (END) +
C ++++++++++++++++++++++++++++++++++


C ++++++++++++++++++++++++++++++++++
C +--EXPLICIT SCHEME       (BEGIN) +
C ++++++++++++++++++++++++++++++++++


      ELSE


C ++++++++++++++++++++++++++++++++++
C +--ERROR TEST            (BEGIN) +
C ++++++++++++++++++++++++++++++++++


        IF  (norder.lt.0)                                         THEN

          stop
     .   '++++++++ Horizontal Advection badly conditioned / Order<0 ++'

        ELSE


C ++++++++++++++++++++++++++++++++++
C +...Is  Centered Scheme  (BEGIN) +
C ++++++++++++++++++++++++++++++++++


          IF (center)                                             THEN

              locorr = .false.
              dtcorr =  1.000


C +--Mass Divergence / First  Direction
C +  ==================================


C +--Mass Flux Update / x-Direction
C +  ------------------------------

c #SP       IF (mod(numdps,2).eq.0.or.mmy.eq.1)                     THEN

              IF (norder.EQ.2)                                      THEN

               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WKxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #2Z.                          *clatGE(i,j)
               END DO
               END DO
c #vL          END DO

c #vL          DO k=1,mz
               DO i=1,mx
               DO j=1,my
                   WKxyz7(i,j,k)=                dxinv2          *  (
     .                        WKxyz3(im1(i),j,k)-WKxyz3(ip1(i),j,k) )
c #2Z.                          /clatGE(i,j)
               END DO
               END DO
               END DO

              ELSE

               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WKxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #2Z.                          *clatGE(i,j)
               END DO
               END DO
c #vL          END DO

c #vL          DO k=1,mz
               DO i=1,mx
               DO j=1,my
                   WKxyz7(i,j,k)=                dxinv2 * fac43  *  (
     .                 0.125*(WKxyz3(ip2(i),j,k)-WKxyz3(im2(i),j,k))
     .                       -WKxyz3(ip1(i),j,k)+WKxyz3(im1(i),j,k) )
c #2Z.                          /clatGE(i,j)
               END DO
               END DO
               END DO

              END IF


C +--Mass Flux Update / y-Direction
C +  ------------------------------
C +
c #SP       ELSE

              IF (norder.EQ.2)                                      THEN

               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WKxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
               END DO
               END DO
c #vL          END DO

c #vL          DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WKxyz8(i,j,k)=                dyinv2          *  (
     .                        WKxyz4(i,jm1(j),k)-WKxyz4(i,jp1(j),k) )
               END DO
               END DO

c #SP          DO j=1,my
c #SP          DO i=1,mx
c #SP              WKxyz7(i,j,k)=                WKxyz8(i,j,k)
c #SP              WKxyz8(i,j,k)=                0.0
c #SP          END DO
c #SP          END DO
               END DO

              ELSE

               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WKxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
               END DO
               END DO
c #vL          END DO

c #vL          DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WKxyz8(i,j,k)=                dyinv2 * fac43  *  (
     .                 0.125*(WKxyz4(i,jp2(j),k)-WKxyz4(i,jm2(j),k))
     .                       -WKxyz4(i,jp1(j),k)+WKxyz4(i,jm1(j),k) )
               END DO
               END DO

c #SP          DO j=1,my
c #SP          DO i=1,mx
c #SP              WKxyz7(i,j,k)=                WKxyz8(i,j,k)
c #SP              WKxyz8(i,j,k)=                0.0
c #SP          END DO
c #SP          END DO
               END DO

              ENDIF

c #SP       END IF


C +--Pressure Depth Increment
C +  ------------------------

               DO j=1,my
               DO i=1,mx
                 WKxy3(i,j)=0.0
               END DO
               END DO

               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                 WKxy3(i,j)=WKxy3(i,j)
     .                   -(WKxyz7(i,j,k)+WKxyz8(i,j,k))*dsigm1(k)
               END DO
               END DO
               END DO


C +--Pressure Depth    Update (Leapfrog-Backward)
C +  --------------------------------------------

            IF  (itFast.eq.1)                                       THEN
                DO j=1,my
                DO i=1,mx
                  pstDY( i,j)   = WKxy2(i,j) -  WKxy3(i,j)      *dtfast
                  pstDYn(i,j)   = WKxy2(i,j) -  WKxy3(i,j) *2.0 *dtfast
                END DO
                END DO
            ELSE
              IF (itFast.le.ntFast)                                 THEN
                DO j=1,my
                DO i=1,mx
                  pstDY( i,j)   = WKxy2(i,j)
                  pstDYn(i,j)   = WKxy1(i,j) -  WKxy3(i,j) *2.0*dtfast

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             pstDY( i,j)   = pstDY( i,j)+  
c #rt.               Robert*(0.5*(pstDYn(i,j)+WKxy1(i,j))-pstDY( i,j))
                END DO
                END DO
              ELSE
                DO j=1,my
                DO i=1,mx
                  pstDY( i,j)   = WKxy2(i,j)
                  pstDYn(i,j)   = WKxy1(i,j) -  WKxy3(i,j)      *dtfast
                END DO
                END DO
C +***          Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

              END IF
            END IF


C +--Mass Divergence / Second Direction
C +  ==================================

c #SP       IF  (mmy.gt.1)                                          THEN


C +--Mass Flux Update / x-Direction
C +  ------------------------------

c #SP         IF (mod(numdps,2).eq.1)                               THEN

c #SP          IF    (norder   .EQ.2)                               THEN

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WKxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO  j=1,my
c #SP             DO  i=1,mx
c #SP               WKxyz8(i,j,k)=                dxinv2          *  (
c #SP.                         WKxyz3(im1(i),j,k)-WKxyz3(ip1(i),j,k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          ELSE

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WKxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO  j=1,my
c #SP             DO  i=1,mx
c #SP               WKxyz8(i,j,k)=                dxinv2 * fac43  *  (
c #SP.                  0.125*(WKxyz3(ip2(i),j,k)-WKxyz3(im2(i),j,k))
c #SP.                        -WKxyz3(ip1(i),j,k)+WKxyz3(im1(i),j,k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          END IF


C +--Mass Flux Update / y-Direction
C +  ------------------------------

c #SP         ELSE

c #SP          IF    (norder   .EQ.2)                               THEN

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WKxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WKxyz8(i,j,k)=                dyinv2          *  (
c #SP.                         WKxyz4(i,jm1(j),k)-WKxyz4(i,jp1(j),k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          ELSE

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WKxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WKxyz8(i,j,k)=                dyinv2 * fac43  *  (
c #SP.                  0.125*(WKxyz4(i,jp2(j),k)-WKxyz4(i,jm2(j),k))
c #SP.                        -WKxyz4(i,jp1(j),k)+WKxyz4(i,jm1(j),k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          END IF

c #SP         END IF


C +--Pressure Depth Increment
C +  ------------------------

                DO j=1,my
                DO i=1,mx
                  WKxy4(i,j)=0.0
                END DO
                END DO

c #SP           DO k=1,mz
c #SP           DO j=1,my
c #SP           DO i=1,mx
c #SP             WKxy4(i,j)=WKxy4(i,j)-WKxyz8(i,j,k)*dsigm1(k)
c #SP           END DO
c #SP           END DO
c #SP           END DO

c #SP           DO j=1,my
c #SP           DO i=1,mx
c #SP             WKxy3(i,j)=WKxy3(i,j)+ WKxy4(i,j)
c #SP           END DO
c #SP           END DO


C +--Pressure Depth    Update (Leapfrog-Backward)
C +  --------------------------------------------

c #SP         IF  (itFast.eq.1)                                     THEN
c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               pstDY( i,j) = pstDY( i,j) - WKxy4(i,j)     *dtfast
c #SP               pstDYn(i,j) = pstDYn(i,j) - WKxy4(i,j) *2.0*dtfast
c #SP             END DO
c #SP             END DO
c #SP         ELSE
c #SP           IF (itFast.le.ntFast)                               THEN
c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               pstDY( i,j) = WKxy2( i,j)
c #SP               pst_n1      = pstDYn(i,j)
c #SP               pstDYn(i,j) = pstDYn(i,j) - WKxy4(i,j) *2.0*dtfast

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             pstDY( i,j)   = pstDY( i,j)+  
c #rt.               Robert*(0.5*(pstDYn(i,j)+pst_n1    )-pstDY( i,j))
c #SP             END DO
c #SP             END DO
c #SP           ELSE
c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               pstDY( i,j) = WKxy2( i,j)
c #SP               pstDYn(i,j) = pstDYn(i,j) - WKxy4(i,j)      *dtfast
c #SP             END DO
c #SP             END DO
C +***            Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

c #SP           END IF
c #SP         END IF

c #SP       END IF

            norder = -1

C ++++++++++++++++++++++++++++++++++
C +...Is  Centered Scheme    (END) +
C +...Non Centered Schemes (BEGIN) +
C ++++++++++++++++++++++++++++++++++


          ELSE

            locorr = .true.
            dtcorr = dtfast


C +--Vector for Positive Definite Variables
C +  ======================================

            dtxfas = dtx /(ntFast+1)
            dtyfas = dty /(ntFast+1)

            DO     k=1,mz

            DO     j=1,my
            DO     i=1,mx
              WKxyz1(i,j,k) =       - uairDY(i,j,k)             *dtxfas
              WKxyz2(i,j,k) =       - vairDY(i,j,k)             *dtyfas
              uuface        = 0.5  * (uairDY(i,j,k)+uairDY(ip1(i),j,k))
              vvface        = 0.5  * (vairDY(i,j,k)+vairDY(i,jp1(j),k))
              WKxyz3(i,j,k) = 0.5  * (abs(uuface ) +  uuface  ) *dtxfas
              WKxyz5(i,j,k) = 0.5  * (abs(uuface ) -  uuface  ) *dtxfas
              WKxyz4(i,j,k) = 0.5  * (abs(vvface ) +  vvface  ) *dtyfas
              WKxyz6(i,j,k) = 0.5  * (abs(vvface ) -  vvface  ) *dtyfas
            END DO
            END DO

            END DO


C +--Advection (Time Splitting)
C +  ==========================

C +--Mass and Mass Flux
C +  ~~~~~~~~~~~~~~~~~~
            do     j=1,my
            do     i=1,mx
              WKxy5(i,j)=          pstDY(    i ,j)
              WKxy1(i,j)=          WKxy5(    i ,j)
              WKxy2(i,j)=          WKxy5(    i ,j)
              WKxy3(i,j)=          0.
            end do
            end do


C +--Conservative Scheme Order 0
C +  ===========================
C +
            IF (norder.eq.0)                                      THEN
                norder = -1


C +--Time Splitting
C +  --------------

C +--x-Direction First
C +  ~~~~~~~~~~~~~~~~~
              IF (mod(numdps,2).eq.0)                             THEN

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WKxyz7(    i ,    j ,k)  =

     .         - WKxyz3(    i ,    j ,k)  *  WKxy5(    i ,    j )
     .         + WKxyz5(    i ,    j ,k)  *  WKxy5(ip1(i),    j )
     .         + WKxyz3(im1(i),    j ,k)  *  WKxy5(im1(i),    j )
     .         - WKxyz5(im1(i),    j ,k)  *  WKxy5(    i ,    j )

                  WKxy3(    i ,    j   )  =  WKxy3(    i ,    j )
     .         + WKxyz7(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WKxyz8(    i ,    j ,k)  =

     .         - WKxyz4(    i ,    j ,k)  *  WKxy3(    i,     j )
     .         + WKxyz6(    i ,    j ,k)  *  WKxy3(    i ,jp1(j))
     .         + WKxyz4(    i ,jm1(j),k)  *  WKxy3(    i ,jm1(j))
     .         - WKxyz6(    i ,jm1(j),k)  *  WKxy3(    i ,    j )

                  WKxy3(i,j)  =              WKxy3(    i ,    j )
     .         + WKxyz8(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

C +--y-Direction First
C +  ~~~~~~~~~~~~~~~~~
              ELSE

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WKxyz7(    i ,    j ,k)  =

     .         - WKxyz4(    i ,    j ,k)  *  WKxy5(    i,     j )
     .         + WKxyz6(    i ,    j ,k)  *  WKxy5(    i ,jp1(j))
     .         + WKxyz4(    i ,jm1(j),k)  *  WKxy5(    i ,jm1(j))
     .         - WKxyz6(    i ,jm1(j),k)  *  WKxy5(    i ,    j )

                  WKxy3(i,j)  =              WKxy3(    i ,    j )
     .         + WKxyz7(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WKxyz8(    i ,    j ,k)  =

     .         - WKxyz3(    i ,    j ,k)  *  WKxy3(    i ,    j )
     .         + WKxyz5(    i ,    j ,k)  *  WKxy3(ip1(i),    j )
     .         + WKxyz3(im1(i),    j ,k)  *  WKxy3(im1(i),    j )
     .         - WKxyz5(im1(i),    j ,k)  *  WKxy3(    i ,    j )

                  WKxy3(i,j)  =              WKxy3(    i ,    j )
     .         + WKxyz8(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

              END IF

            END IF


C +--Conservative Scheme order 4
C +  ===========================

            IF (norder.eq.4)                                      THEN
                norder = -1


C +--Time Splitting
C +  --------------

C +--Parameters
C +  ~~~~~~~~~~
              IF (mod(numdps,2).eq.0)                             THEN
                   idir_x = 2
                   jdir_y = 3
              ELSE
                   idir_x = 3
                   jdir_y = 2
              END IF

C +--Auxiliary  Variables
C +  ~~~~~~~~~~~~~~~~~~~~
              do j=1,my
              do i=1,mx
                WKxy3(i,j) =  WKxy5(i,j)
                WKxy4(i,j) =  WKxy5(i,j)
              end do
              end do


C +--1D Computation
C +  --------------

 401          CONTINUE

              IF (idir_x.eq.0 .or.
     .            jdir_y.eq.3)                               GO TO 402

C +--x-Direction  here
C +  ~~~~~~~~~~~~~~~~~
                DO  k=1,mz
                DO  j=1,my
                  DO i=1,mx
                    cnpx(i)   = WKxyz3( i,j,k)
                    cnmx(i)   = WKxyz5( i,j,k)
                    vecx(i)   =  WKxy2( i,j)
                  END DO
                    cnpx(  0) = WKxyz3( 1,j,k)
                    cnpx(mxx) = WKxyz3(mx,j,k)
                    cnmx(  0) = WKxyz5( 1,j,k)
                    cnmx(mxx) = WKxyz5(mx,j,k)
                    vecx(  0) =  WKxy2( 1,j)
                    vecx(mxx) =  WKxy2(mx,j)

C +                      ********
                    call ADVbot_4(flux,vecx,aa0x,aa1x,aa2x,aa3x,aa4x,
     .                                 cnpx,cnmx,sipx,simx,sidx,mxx,1)
C +                      ********

                  DO i=1,mx
                    WKxyz7(i,j,k)=            - flux(i) + flux(im1(i))
                  END DO

                  DO i=1,mx
                     WKxy3(i,j)  = WKxy3(i,j) + WKxyz7(i,j,k)*dsigm1(k)
                  END DO
                END DO
                END DO

C +--Assignation in case of Time Splitting
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                IF (idir_x.gt.1.or.
     .              jdir_y.gt.1)                                  THEN
                  do j=1,my
                  do i=1,mx
                    WKxy1(i,j) = WKxy3(i, j)
                    WKxy4(i,j) = WKxy3(i, j)
                  end do
                  end do
                END IF

                    idir_x =  0

 402          CONTINUE

              IF (idir_x.eq.0 .and.
     .            jdir_y.eq.0)                               GO TO 403

C +--y-Direction  here
C +  ~~~~~~~~~~~~~~~~~
                DO  k=1,mz
                DO  i=1,mx
                  DO j=1,my
                    cnpy(j)   = WKxyz4(i, j,k)
                    cnmy(j)   = WKxyz6(i, j,k)
                    vecy(j)   =  WKxy1(i, j)
                  END DO
                    cnpy(  0) = WKxyz4(i, 1,k)
                    cnpy(myy) = WKxyz4(i,my,k)
                    cnmy(  0) = WKxyz6(i, 1,k)
                    cnmy(myy) = WKxyz6(i,my,k)
                    vecy(  0) =  WKxy1(i, 1)
                    vecy(myy) =  WKxy1(i,my)

C +                      ********
                    call ADVbot_4(fluy,vecy,aa0y,aa1y,aa2y,aa3y,aa4y,
     .                                 cnpy,cnmy,sipy,simy,sidy,myy,1)
C +                      ********

                  DO j=1,my
                    WKxyz8(i,j,k)=         - fluy(j) + fluy(jm1(j))
                  END DO

                  DO j=1,my
                    WKxy4(i,j)= WKxy4(i,j) + WKxyz8(i,j,k)*dsigm1(k)
                  END DO
                END DO
                END DO

C +--Assignation in case of Time Splitting
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                IF (idir_x.gt.1.or.
     .              jdir_y.gt.1)                                  THEN
                  do j=1,my
                  do i=1,mx
                    WKxy2(i,j) = WKxy4(i, j)
                    WKxy3(i,j) = WKxy4(i, j)
                  end do
                  end do
                END IF

                    jdir_y =  0

                                                             GO TO 401

 403          CONTINUE

            END IF


C +--Update
C +  ======

              DO j=1,my
              DO i=1,mx
                pstDYn(i,j) =             WKxy3(i,j)
C +...          New Pressure Thickness

                 WKxy3(i,j) = pstDY(i,j) -WKxy3(i,j)
C +...          New Pressure Thickness Increment

              END DO
              END DO


C ++++++++++++++++++++++++++++++++++
C +...Non Centered Schemes   (END) +
C ++++++++++++++++++++++++++++++++++


          END IF


C ++++++++++++++++++++++++++++++++++
C +--ERROR TEST              (END) +
C ++++++++++++++++++++++++++++++++++


        END IF
        IF (norder.ge.0)
     .    stop
     .   '++++++++ Horizontal Advection badly conditioned ++++++++++++'

      END IF


C ++++++++++++++++++++++++++++++++++
C +--EXPLICIT SCHEME         (END) +
C ++++++++++++++++++++++++++++++++++


C +--Vertical Wind Speed (sigma coordinate)
C +  ======================================

C +--Staggered Vertical Grid
C +  -----------------------

        IF (  itFast.eq.       1                      )           THEN
              ntpsig = 0
            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              psigad(i,j,k) = 0.
            END DO
            END DO
            END DO
        ENDIF

        IF (staggr)                                                 THEN

            DO j=1,my
            DO i=1,mx
              WKxyz3(i,j,1)=sigmid(2)*  WKxy3(i,j)
     .                     +dsigm1(1)*(WKxyz7(i,j,1)+WKxyz8(i,j,1))
            END DO
            END DO

            DO k=kp1(1),mmz
            DO j=1,my
            DO i=1,mx
              WKxyz3(i,j,k)= dsigm1(k)*(WKxy3(i,j)
     .                 +(WKxyz7(i,j,k)
     .                  +WKxyz8(i,j,k)            ))+WKxyz3(i,j,k-1)
C +...        Computation of p*Sigma. BETWEEN Sigma Levels

            END DO
            END DO
            END DO


C +--Unstaggered Vertical Grid
C +  -------------------------

        ELSE

            DO j=1,my
            DO i=1,mx
              WKxyz3(i,j,1)= sigma(1)*  WKxy3(i,j)
     .                     + sigma(1)*(WKxyz7(i,j,1)+WKxyz8(i,j,1))
C +...        Open Upper Boundary Condition: WKxyz7(i,j,0)=WKxyz7(i,j,1)
C +                                          WKxyz8(i,j,0)=WKxyz8(i,j,1)
            END DO
            END DO

            DO k=kp1(1),mz
            DO j=1,my
            DO i=1,mx
              WKxyz3(i,j,k)= dsig_1(k-1) * (WKxy3(i,j)
     .            +0.50*(WKxyz7(i,j,k)+WKxyz7(i,j,k-1)
     .                  +WKxyz8(i,j,k)+WKxyz8(i,j,k-1)))
     .                  +WKxyz3(i,j,k-1)
C +...        Computation of p*Sigma. ON      Sigma Levels

            END DO
            END DO
            END DO

        END IF

              ntpsig       = 1    +    ntpsig
            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              psigad(i,j,k)=           psigad(i,j,k)
     .                     +           WKxyz3(i,j,k)
            END DO
            END DO
            END DO

        IF (((itFast.eq.ntFast+1).and..not.pImplc).OR.
     .      ((itFast.eq.       1).and.     pImplc)    )           THEN

            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              psigDY(i,j,k)=           psigad(i,j,k)
     .                     /           ntpsig
            END DO
            END DO
            END DO

          IF (locorr)                                             THEN
            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              psigDY(i,j,k)=psigDY(i,j,k) / dtcorr
            END DO
            END DO
            END DO
          END IF

        END IF


C +--Simple non-hydrostatic Correction
C +  =================================

C +--Filtering
C +  ~~~~~~~~~
c #ON   do     j=1,my
c #ON   do     i=1,mx
c #ON     WKxy4(i,j) =
c #ON.          zi__TE(im1(i),jp1(j))+2.0*zi__TE(    i ,jp1(j))
c #ON.                               +    zi__TE(ip1(i),jp1(j))
c #ON.    + 2.0*zi__TE(im1(i),j)     +4.0*zi__TE(    i ,    j )
c #ON.                               +2.0*zi__TE(ip1(i),    j )
c #ON.    +     zi__TE(im1(i),jm1(j))+2.0*zi__TE(    i ,jm1(j))
c #ON.                             +      zi__TE(ip1(i),jm1(j))
c #ON   end do
c #ON   end do
c #ON   do     j=1,my
c #ON   do     i=1,mx
c #ON     WKxy4(i,j) = 0.0625* WKxy4(i,j)
c #ON   end do
c #ON   end do


C +--Correction
C +  ~~~~~~~~~~

c #ON   do     j=1,my
c #ON   do     i=1,mx
c #ON       CorArg = 1.0 + WKxy4(i,j) * WKxy4(i,j) / (4.0 * dx * dx)
c #ON       CorrNH = 1.0 / sqrt(CorArg)
C +...      Weisman et al., 1997, MWR125, p.541
C +
c #ON     do     k=1,mz
c #ON       psigDY(i,j,k)= psigDY(i,j,k)*CorrNH
c #ON     end do
c #ON   end do
c #ON   end do


C +--Vertical Velocity (sigma coordinates)
C +  =====================================

        IF (staggr)                                                 THEN
          DO       k=   1,mz
            DO     j=jp11,my1
            DO     i=ip11,mx1
              wsigDY(i,j,k)=   psigDY(i,j,k)
     .                       / pstDYn(i,j)
            END DO
            END DO
          END DO

        ELSE
          DO       k=   1,mz1
            DO     j=jp11,my1
            DO     i=ip11,mx1
              wsigDY(i,j,k)=  (psigDY(i,j,k)+psigDY(i,j,kp1(k)))*0.5
     .                       / pstDYn(i,j)
            END DO
            END DO
          END DO
                   k=     mz 
            DO     j=jp11,my1
            DO     i=ip11,mx1
              wsigDY(i,j,k)=   psigDY(i,j,k)                    *0.5
     .                       / pstDYn(i,j)
            END DO
            END DO
        END IF


C +--Maximum Vertical Courant Number
C +  ===============================

              CFLzDY     =     0.0
      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
              CFLzDY     = max(CFLzDY 
     .                    ,abs(wsigDY(i,j,k))*2.0*dt/dsigm1(k))
        END DO
        END DO
      END DO


C +--Slip condition for Mountain Wave Experiments
C +  ============================================

c #OM   DO       j=1,my
c #OM   DO       i=1,mx
c #OM     psigDY(i,j,mz)=0.0
c #OM   END DO
c #OM   END DO


C +--Work Arrays Reset
C +  =================

        DO j=1,my
        DO i=1,mx
          WKxy1(i,j)    = 0.0
          WKxy2(i,j)    = 0.0
          WKxy3(i,j)    = 0.0
          WKxy4(i,j)    = 0.0
        END DO
        END DO

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz1(i,j,k) = 0.0
          WKxyz2(i,j,k) = 0.0
          WKxyz3(i,j,k) = 0.0
          WKxyz4(i,j,k) = 0.0
          WKxyz5(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
          WKxyz7(i,j,k) = 0.0
          WKxyz8(i,j,k) = 0.0
        END DO
        END DO
        END DO

      return
      end

      subroutine DYNdps_mp(norder)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                    10-08-2004  MAR |
C |   SubRoutine DYNdps solves the Mass Conservation Equation              |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   ^^^^^         iterun          : long  time step counter              |
C |                 itFast          : short time step counter              |
C |                 norder          : numerical scheme: order of precision |
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   OUTPUT        pstDYn(mx,my)   : Pressure Depth p*(t)           (kPa) |
C |   ^^^^^^         pstDY(mx,my)   : Pressure Depth p*(t-dt)              |
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^         uairDY(mx,my,mz): x-Wind Speed                   (m/s) |
C |                 vairDY(mx,my,mz): y-Wind Speed                   (m/s) |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^  psigDY: p* X Vertical Wind Speed; Sigma Syst.(i.e. p* Ds/Dt) |
C |                   psigDY Computed  ON the Sigma Levels   (unstaggered) |
C |                                    IN           Layers     (staggered) |
C |                                                                        |
C |   METHOD: Implicit Time Scheme (pImplc  Switch is .true. )             |
C |   ^^^^^^       2th order accurate Time  Scheme (semi-implicit)   .AND. |
C |                2th order accurate Space Scheme on Arakawa A grid       |
C |                                                                        |
C |           Explicit Time Scheme (pImplc  Switch is .false.)             |
C |            Centered     Scheme (center  Switch is .true. )             |
C |                2th order accurate Time  Scheme (leapfrog backw.) .AND. |
C |   norder.EQ.2 (2th order accurate Space Scheme on Arakawa A grid .OR.  |
C |   norder.NE.2  4th order accurate Space Scheme on Arakawa A grid)      |
C |                                                                   .OR. |
C |            Non-Centered Scheme (center  Switch is .false.)             |
C |                0th order accurate Space Scheme (Bott) (norder=0)  .OR. |
C |                4th order accurate Space Scheme (Bott) (norder=4)       |
C |                                                                        |
C |            Robert Time Filter may be used to remove computational mode |
C |                                                                        |
C |   REFER.:  Use of A grid: Purser and Leslie, MWR 116, 2069--2080, 1988 |
C |   ^^^^^^   Time Scheme  : Lin    and Rood    MWR 124, 2046--2070, 1996 |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
c #ON include 'MAR_TE.inc'

      include 'MAR_WK.inc'

      integer  norder


C +--Local  Variables
C +  ================

      logical  pImplc,locorr

      integer   mxx     ,myy
      parameter(mxx=mx+1,myy=my+1)
      real      vecx(0:mxx),flux(0:mxx)
      real      aa0x(0:mxx),aa1x(0:mxx),aa2x(0:mxx)
      real                  aa3x(0:mxx),aa4x(0:mxx)
      real      cnpx(0:mxx),cnmx(0:mxx)
      real      sipx(0:mxx),simx(0:mxx),sidx(0:mxx)
      real      vecy(0:myy),fluy(0:myy)
      real      aa0y(0:myy),aa1y(0:myy),aa2y(0:myy)
      real                  aa3y(0:myy),aa4y(0:myy)
      real      cnpy(0:myy),cnmy(0:myy)
      real      sipy(0:myy),simy(0:myy),sidy(0:myy)

      integer it_pst,nt_pst,idir_x,jdir_y
      integer i1_dps,i2_dps,j1_dps,j2_dps,k1_dps,k2_dps
      real    alphpp,betapp,Fp__pp,Fpa_pp,Fpb_pp,facovr
      real    CorArg,CorrNH,SRes_0,SRes_1,SRes10,pst_n1
      real    dtcorr,dtxfas,dtyfas,uuface,vvface

      integer              numdps,ntpsig
      common  /DYNdps_int/ numdps,ntpsig

      real                 psigad(mx,my,mz)
      common  /DYNdps_rea/ psigad


C +--DATA
C +  ====

      data     pImplc/.false./
C +...         pImplc=.true.  ==> Implicit Scheme is used to damp Lamb Waves

               numdps    = numdps+1


C +--Save Mass at the Lateral Boundaries
C +  ===================================

        do     j=1,my
        do     i=1,mx
           WTxy1( i, j) = pstDY( i,j)
C +                       p*(n-1)
           WTxy2( i, j) = pstDYn(i,j)
C +                       p*(n)
        end do
        end do

         do    j=1,my
           pstDY(  1,j) = pstDYn( 1,j)
           pstDY( mx,j) = pstDYn(mx,j)
         end do

        if (mmy.gt.1) then
         do    i=1,mx
           pstDY( i, 1) = pstDYn(i, 1)
           pstDY( i,my) = pstDYn(i,my)
         end do
        end if


C ++++++++++++++++++++++++++++++++++
C +--IMPLICIT SCHEME       (BEGIN) +
C ++++++++++++++++++++++++++++++++++


      IF   (pImplc)                                                 THEN
        IF (it_Mix.EQ.1.AND.itFast.EQ.1)                            THEN


C +--Horizontal Wind Speed: Average along the Vertical
C +  -------------------------------------------------

          DO j=1,my
          DO i=1,mx
            WTxy3(i,j) = 0.0
            WTxy4(i,j) = 0.0
          END DO
          END DO

          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            WTxy3(i,j) = WTxy3(i,j) + uairDY(i,j,k) * dsigm1(k)
            WTxy4(i,j) = WTxy4(i,j) + vairDY(i,j,k) * dsigm1(k)
          END DO
          END DO
          END DO


C +--Tridiagonal Matrix Coefficients
C +  -------------------------------

            betapp    = 0.6
            alphpp    = 1.0    - betapp
            Fp__pp    = dt     / dx
            Fpa_pp    = Fp__pp * alphpp
            Fpb_pp    = Fp__pp * betapp
          DO  i = ip11,mx1
          DO  j = jp11,my1
            WTxyz1(i,j,1) = Fpb_pp *WTxy3(ip1(i),j) ! k=1: 3-Diag Matrix, x-Dir
            WTxyz3(i,j,1) =-Fpb_pp *WTxy3(im1(i),j) ! k=1: 3-Diag Matrix, x-Dir
c #vL     END DO
c #vL     END DO

c #vL     DO  j = jp11,my1
c #vL     DO  i = ip11,mx1
            WTxyz1(i,j,2) = Fpb_pp *WTxy4(i,jp1(j)) ! k=2: 3-Diag Matrix, y-Dir
            WTxyz3(i,j,2) =-Fpb_pp *WTxy4(i,jm1(j)) ! k=2: 3-Diag Matrix, y-Dir
          END DO
          END DO


C +--Overrelaxation Starting Block
C +  -----------------------------

C +--Independant Term: constant contribution        !                     x-Dir
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          DO i=ip11,mx1
          DO j=jp11,my1
              WTxyz8(i,j,1) =                   pstDY(    i ,j)
     .              - Fpa_pp *WTxy3(ip1(i),j) * pstDY(ip1(i),j)
     .              + Fpa_pp *WTxy3(im1(i),j) * pstDY(im1(i),j)
c #vL     END DO
c #vL     END DO

c #vL     DO  j = jp11,my1
c #vL     DO  i = ip11,mx1
c #vL         WTxyz8(i,j,1) =                  WTxyz8(i,    j ,1)
     .              - Fpa_pp *WTxy4(i,jp1(j)) * pstDY(i,jp1(j))
     .              + Fpa_pp *WTxy4(i,jm1(j)) * pstDY(i,jm1(j))
          END DO
          END DO

C +--Dirichlet Condition x-LBC                      !                     x-Dir
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
               i=     mx1
            DO j=jp11,my1
              WTxyz8(i,j,1) =                  WTxyz8(    i ,j,1)
     .              - Fpb_pp *WTxy3(ip1(i),j) * pstDY(ip1(i),j)
              WTxyz1(i,j,1) = 0.0
c #WR         write(6,*)            ip1(i),' ', pstDY(ip1(i),j)
            END DO

               i=ip11
            DO j=jp11,my1
              WTxyz8(i,j,1) =                  WTxyz8(    i ,j,1)
     .              + Fpb_pp *WTxy3(im1(i),j) * pstDY(im1(i),j)
              WTxyz3(i,j,1) = 0.0
c #WR         write(6,*)            im1(i),' ', pstDY(im1(i),j)
            END DO

C +--Dirichlet Condition y-LBC
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
          IF (mmy.gt.1)                                             THEN
               j=     my1
            DO i=ip11,mx1
              WTxyz8(i,j,1) =                  WTxyz8(i,    j,1)
     .              - Fpb_pp *WTxy3(i,jp1(j)) * pstDY(i,jp1(j))
              WTxyz1(i,j,2) = 0.0
c #WR         write(6,*)            jp1(j),' ', pstDY(i,jp1(j))
            END DO
C +
               j=jp11
            DO i=ip11,mx1
              WTxyz8(i,j,1) =                  WTxyz8(i,    j,1)
     .              + Fpb_pp *WTxy3(i,jm1(j)) * pstDY(i,jm1(j))
              WTxyz3(i,j,2) = 0.0
c #WR         write(6,*)            jm1(j),' ', pstDY(i,jm1(j))
            END DO
          END IF

C +--First Estimate
C +  ~~~~~~~~~~~~~~
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WTxyz7(i,j,1) =  pstDY(i,j)              ! Previous       Estimate
            WTxyz7(i,j,2) =  0.0                     ! Half-Iteration Estimate
            WTxyz7(i,j,3) =  pstDY(i,j)              ! Next to update Estimate
          END DO
          END DO

C +--Recurrence
C +  ~~~~~~~~~~
          facovr= 1.1
          nt_pst= 4
          it_pst= 0
          SRes_1= 0.0
 1000     CONTINUE
          it_pst= it_pst + 1


C +--Resolution along the x-Direction
C +  --------------------------------

C +--Tridiagonal Matrix Coefficients
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              DO j=jp11,my1
              DO i=ip11,mx1
                WTxyz1(i,j,3) = WTxyz1(i,j,1)        ! Index 1 ==>      x-Dir
                WTxyz2(i,j,3) = 1.0d+0               !
                WTxyz3(i,j,3) = WTxyz3(i,j,1)        !
              END DO
              END DO

C +--Independant Term
C +  ~~~~~~~~~~~~~~~~
              DO j=jp11,my1
              DO i=ip11,mx1
                WTxyz4(i,j,3) = WTxyz8(i,j,1)        ! Index 1 ==>    ALL-Dir
     .                        - WTxyz1(i,j,2) *WTxyz7(i,jp1(j),1)
     .                        - WTxyz3(i,j,2) *WTxyz7(i,jm1(j),1)
              END DO
              END DO

C +--Tridiagonal Matrix Inversion                    ! OUTPUT is WTxyz7(i,j,3)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            i1_dps = ip11
            i2_dps = mx1
            j1_dps = jp11
            j2_dps = my1
            k1_dps = 3
            k2_dps = 3

C +              ********
            call MARgau_x(i1_dps,i2_dps,j1_dps,j2_dps,k1_dps,k2_dps)
C +              ********


C +--Resolution along the y-Direction
C +  --------------------------------

            IF (mmy.gt.1)                                           THEN

C +--Tridiagonal Matrix Coefficients                 ! Index 2 ==>      y-Dir
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              DO j=jp11,my1
              DO i=ip11,mx1
                WTxyz1(i,j,3) = WTxyz1(i,j,2)
                WTxyz2(i,j,3) = 1.
                WTxyz3(i,j,3) = WTxyz3(i,j,2)
                WTxyz7(i,j,2) = WTxyz7(i,j,3)        ! Half-Iteration Estimate
              END DO
              END DO

C +--Independant Term                                !                  y-Dir
C +  ~~~~~~~~~~~~~~~~
              DO i=ip11,mx1
              DO j=jp11,my1
                WTxyz4(i,j,3) = WTxyz8(i,j,1)        ! Index 1 ==>    ALL-Dir
     .                        - WTxyz1(i,j,1) *WTxyz7(ip1(i),j,2)
     .                        - WTxyz3(i,j,1) *WTxyz7(im1(i),j,2)
              END DO
              END DO

C +--Tridiagonal Matrix Inversion                    ! OUTPUT is WTxyz7(i,j,3)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              i1_dps = ip11
              i2_dps = mx1
              j1_dps = jp11
              j2_dps = my1
              k1_dps = 3
              k2_dps = 3

C +                ********
              call MARgau_y(i1_dps,i2_dps,j1_dps,j2_dps,k1_dps,k2_dps)
C +                ********

            END IF

C +--Residual is obtained by substracting next from former estimated Equation
C +  ------------------------------------------------------------------------

            DO  i = ip11,mx1
            DO  j = jp11,my1
              WTxyz6(i,j,1) = WTxyz1(i,j,1) * WTxyz7(ip1(i),j,3)
     .                      + WTxyz3(i,j,1) * WTxyz7(im1(i),j,3)
c #vL       END DO
c #vL       END DO

c #vL       DO  j = jp11,my1
c #vL       DO  i = ip11,mx1
c #vL         WTxyz6(i,j,1) = WTxyz6(i,j,1)
     .                      + WTxyz1(i,j,2) * WTxyz7(i,jp1(j),3)
     .                      + WTxyz3(i,j,2) * WTxyz7(i,jm1(j),3)
     .                      +                 WTxyz7(i,j     ,3)
     .                      - WTxyz8(i,j,1)
            END DO
            END DO

              SRes_1        =  0.0
            DO  j = jp11,my1
            DO  i = ip11,mx1
              SRes_1        =  SRes_1   + abs(WTxyz6(i,j,1))
            END DO
            END DO

            IF (it_pst.gt.1)                                      THEN
              SRes10        =  SRes_1 / SRes_0
            ELSE
              SRes_0        =  SRes_1
              SRes10        =  1.0
            END IF


C +--New Estimate
C +  ------------

            IF (SRes10.gt.0.1   .and.it_pst.lt.nt_pst
     .                          .and.mmy   .gt.     1)              THEN
              DO  j = jp11,my1
              DO  i = ip11,mx1
                WTxyz7(i,j,1) = WTxyz7(i,j,3)
     .                - facovr* WTxyz6(i,j,1)/WTxyz2(i,j,1)
                WTxyz7(i,j,3) = WTxyz7(i,j,1)
              END DO
              END DO
            END IF
C +
c #WR         write(6,1001) iterun,it_pst,SRes10
 1001         format(2i9,f21.15)
C +
          IF    (SRes10.gt.1.0d-1.and.it_pst.lt.nt_pst
     .                           .and.mmy   .gt.     1)       GO TO 1000


C +--Final Estimate
C +  --------------

          DO j=jp11,my1
          DO i=ip11,mx1
                pstDY( i,j)   = WTxyz7(i,j,3)
                pstDYn(i,j)   = WTxyz7(i,j,3)
          END DO
          END DO

C +--Lateral Boundary Conditions
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
            DO j=jp11,my1
                pstDY(  1,j) = WTxy1( 1,j)
                pstDY( mx,j) = WTxy1(mx,j)
                pstDYn( 1,j) = WTxy1( 1,j)
                pstDYn(mx,j) = WTxy1(mx,j)
            END DO

          IF (mmy.gt.1)                                             THEN
            DO i=ip11,mx1
                pstDY( i, 1) = WTxy1(i, 1)
                pstDY( i,my) = WTxy1(i,my)
                pstDYn(i, 1) = WTxy1(i, 1)
                pstDYn(i,my) = WTxy1(i,my)
            END DO
          END IF


C +--Contribution to Vertical Material Speed
C +  ---------------------------------------

               DO k=1,mz

                 DO j=1,my
                 DO i=1,mx
                   WTxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
                   WTxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
                   WTxyz8(i,j,k)=                0.
                 END DO
                 END DO

                 DO  j=1,my
                 DO  i=1,mx
                   WTxyz7(i,j,k)=(WTxyz3(im1(i),j,k)-WTxyz3(ip1(i),j,k)
c #vL.                           )
c #vL            ENDDO
c #vL            ENDDO

c #vL            DO  i=1,mx
c #vL            DO  j=1,my
c #vL              WTxyz7(i,j,k)=(WTxyz7(i,    j ,k)
     .                           +WTxyz4(i,jm1(j),k)-WTxyz4(i,jp1(j),k)
     .                           )                  *dxinv2
                 END DO
                 END DO

 ! Two previous Loops are the vectorized version of the following Loop
 !               DO  j=1,my
 !               DO  i=1,mx
 !                 WTxyz7(i,j,k)=               -dxinv2
 !   .                      *(WTxyz3(ip1(i),j,k)-WTxyz3(im1(i),j,k)
 !   .                       +WTxyz4(i,jp1(j),k)-WTxyz4(i,jm1(j),k))
 !               END DO
 !               END DO

               END DO

        END IF


C ++++++++++++++++++++++++++++++++++
C +--IMPLICIT SCHEME         (END) +
C ++++++++++++++++++++++++++++++++++


C ++++++++++++++++++++++++++++++++++
C +--EXPLICIT SCHEME       (BEGIN) +
C ++++++++++++++++++++++++++++++++++


      ELSE


C ++++++++++++++++++++++++++++++++++
C +--ERROR TEST            (BEGIN) +
C ++++++++++++++++++++++++++++++++++


        IF  (norder.lt.0)                                         THEN

          stop
     .   '++++++++ Horizontal Advection badly conditioned / Order<0 ++'

        ELSE


C ++++++++++++++++++++++++++++++++++
C +...Is  Centered Scheme  (BEGIN) +
C ++++++++++++++++++++++++++++++++++


          IF (center)                                             THEN

              locorr = .false.
              dtcorr =  1.000


C +--Mass Divergence / First  Direction
C +  ==================================


C +--Mass Flux Update / x-Direction
C +  ------------------------------

c #SP       IF (mod(numdps,2).eq.0.or.mmy.eq.1)                     THEN

               DO j=1,my
               DO i=1,mx
                 WTxy3(i,j)=0.0
               END DO
               END DO

!$OMP PARALLEL DO private(i,j,k)
               DO k=1,mz

              IF (norder.EQ.2)                                      THEN

c               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WTxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #2Z.                          *clatGE(i,j)
               END DO
               END DO
cc #vL          END DO

cc #vL          DO k=1,mz
               DO i=1,mx
               DO j=1,my
                   WTxyz7(i,j,k)=                dxinv2          *  (
     .                        WTxyz3(im1(i),j,k)-WTxyz3(ip1(i),j,k) )
c #2Z.                          /clatGE(i,j)
               END DO
               END DO
c               END DO

              ELSE

c               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WTxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #2Z.                          *clatGE(i,j)
               END DO
               END DO
cc #vL          END DO

cc #vL          DO k=1,mz
               DO i=1,mx
               DO j=1,my
                   WTxyz7(i,j,k)=                dxinv2 * fac43  *  (
     .                 0.125*(WTxyz3(ip2(i),j,k)-WTxyz3(im2(i),j,k))
     .                       -WTxyz3(ip1(i),j,k)+WTxyz3(im1(i),j,k) )
c #2Z.                          /clatGE(i,j)
               END DO
               END DO
c               END DO

              END IF


C +--Mass Flux Update / y-Direction
C +  ------------------------------
C +
c #SP       ELSE

              IF (norder.EQ.2)                                      THEN

c               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WTxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
               END DO
               END DO
cc #vL          END DO

cc #vL          DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WTxyz8(i,j,k)=                dyinv2          *  (
     .                        WTxyz4(i,jm1(j),k)-WTxyz4(i,jp1(j),k) )
               END DO
               END DO

c #SP          DO j=1,my
c #SP          DO i=1,mx
c #SP              WTxyz7(i,j,k)=                WTxyz8(i,j,k)
c #SP              WTxyz8(i,j,k)=                0.0
c #SP          END DO
c #SP          END DO
c               END DO

              ELSE

c               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WTxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
               END DO
               END DO
cc #vL          END DO

cc #vL          DO k=1,mz
               DO j=1,my
               DO i=1,mx
                   WTxyz8(i,j,k)=                dyinv2 * fac43  *  (
     .                 0.125*(WTxyz4(i,jp2(j),k)-WTxyz4(i,jm2(j),k))
     .                       -WTxyz4(i,jp1(j),k)+WTxyz4(i,jm1(j),k) )
               END DO
               END DO

c #SP          DO j=1,my
c #SP          DO i=1,mx
c #SP              WTxyz7(i,j,k)=                WTxyz8(i,j,k)
c #SP              WTxyz8(i,j,k)=                0.0
c #SP          END DO
c #SP          END DO
c              END DO

              ENDIF

c #SP       END IF
            ENDDO 
!$OMP END PARALLEL DO 

C +--Pressure Depth Increment
C +  ------------------------

               DO k=1,mz
               DO j=1,my
               DO i=1,mx
                 WTxy3(i,j)=WTxy3(i,j)
     .                   -(WTxyz7(i,j,k)+WTxyz8(i,j,k))*dsigm1(k)
               END DO
               END DO
               END DO

C +--Pressure Depth    Update (Leapfrog-Backward)
C +  --------------------------------------------

            IF  (itFast.eq.1)                                       THEN
                DO j=1,my
                DO i=1,mx
                  pstDY( i,j)   = WTxy2(i,j) -  WTxy3(i,j)      *dtfast
                  pstDYn(i,j)   = WTxy2(i,j) -  WTxy3(i,j) *2.0 *dtfast
                END DO
                END DO
            ELSE
              IF (itFast.le.ntFast)                                 THEN
                DO j=1,my
                DO i=1,mx
                  pstDY( i,j)   = WTxy2(i,j)
                  pstDYn(i,j)   = WTxy1(i,j) -  WTxy3(i,j) *2.0*dtfast

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             pstDY( i,j)   = pstDY( i,j)+  
c #rt.               Robert*(0.5*(pstDYn(i,j)+WTxy1(i,j))-pstDY( i,j))
                END DO
                END DO
              ELSE
                DO j=1,my
                DO i=1,mx
                  pstDY( i,j)   = WTxy2(i,j)
                  pstDYn(i,j)   = WTxy1(i,j) -  WTxy3(i,j)      *dtfast
                END DO
                END DO
C +***          Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

              END IF
            END IF


C +--Mass Divergence / Second Direction
C +  ==================================

c #SP       IF  (mmy.gt.1)                                          THEN


C +--Mass Flux Update / x-Direction
C +  ------------------------------

c #SP         IF (mod(numdps,2).eq.1)                               THEN

c #SP          IF    (norder   .EQ.2)                               THEN

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WTxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO  j=1,my
c #SP             DO  i=1,mx
c #SP               WTxyz8(i,j,k)=                dxinv2          *  (
c #SP.                         WTxyz3(im1(i),j,k)-WTxyz3(ip1(i),j,k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          ELSE

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WTxyz3(i,j,k)=uairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO  j=1,my
c #SP             DO  i=1,mx
c #SP               WTxyz8(i,j,k)=                dxinv2 * fac43  *  (
c #SP.                  0.125*(WTxyz3(ip2(i),j,k)-WTxyz3(im2(i),j,k))
c #SP.                        -WTxyz3(ip1(i),j,k)+WTxyz3(im1(i),j,k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          END IF


C +--Mass Flux Update / y-Direction
C +  ------------------------------

c #SP         ELSE

c #SP          IF    (norder   .EQ.2)                               THEN

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WTxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WTxyz8(i,j,k)=                dyinv2          *  (
c #SP.                         WTxyz4(i,jm1(j),k)-WTxyz4(i,jp1(j),k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          ELSE

c #SP           DO  k=1,mz

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WTxyz4(i,j,k)=vairDY(i,j,k) * pstDYn(i,j)
c #SP             END DO
c #SP             END DO

c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               WTxyz8(i,j,k)=                dyinv2 * fac43  *  (
c #SP.                  0.125*(WTxyz4(i,jp2(j),k)-WTxyz4(i,jm2(j),k))
c #SP.                        -WTxyz4(i,jp1(j),k)+WTxyz4(i,jm1(j),k) )
c #SP             END DO
c #SP             END DO

c #SP           END DO

c #SP          END IF

c #SP         END IF


C +--Pressure Depth Increment
C +  ------------------------

                DO j=1,my
                DO i=1,mx
                  WTxy4(i,j)=0.0
                END DO
                END DO

c #SP           DO k=1,mz
c #SP           DO j=1,my
c #SP           DO i=1,mx
c #SP             WTxy4(i,j)=WTxy4(i,j)-WTxyz8(i,j,k)*dsigm1(k)
c #SP           END DO
c #SP           END DO
c #SP           END DO

c #SP           DO j=1,my
c #SP           DO i=1,mx
c #SP             WTxy3(i,j)=WTxy3(i,j)+ WTxy4(i,j)
c #SP           END DO
c #SP           END DO


C +--Pressure Depth    Update (Leapfrog-Backward)
C +  --------------------------------------------

c #SP         IF  (itFast.eq.1)                                     THEN
c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               pstDY( i,j) = pstDY( i,j) - WTxy4(i,j)     *dtfast
c #SP               pstDYn(i,j) = pstDYn(i,j) - WTxy4(i,j) *2.0*dtfast
c #SP             END DO
c #SP             END DO
c #SP         ELSE
c #SP           IF (itFast.le.ntFast)                               THEN
c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               pstDY( i,j) = WTxy2( i,j)
c #SP               pst_n1      = pstDYn(i,j)
c #SP               pstDYn(i,j) = pstDYn(i,j) - WTxy4(i,j) *2.0*dtfast

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             pstDY( i,j)   = pstDY( i,j)+  
c #rt.               Robert*(0.5*(pstDYn(i,j)+pst_n1    )-pstDY( i,j))
c #SP             END DO
c #SP             END DO
c #SP           ELSE
c #SP             DO j=1,my
c #SP             DO i=1,mx
c #SP               pstDY( i,j) = WTxy2( i,j)
c #SP               pstDYn(i,j) = pstDYn(i,j) - WTxy4(i,j)      *dtfast
c #SP             END DO
c #SP             END DO
C +***            Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

c #SP           END IF
c #SP         END IF

c #SP       END IF

            norder = -1

C ++++++++++++++++++++++++++++++++++
C +...Is  Centered Scheme    (END) +
C +...Non Centered Schemes (BEGIN) +
C ++++++++++++++++++++++++++++++++++


          ELSE

            locorr = .true.
            dtcorr = dtfast


C +--Vector for Positive Definite Variables
C +  ======================================

            dtxfas = dtx /(ntFast+1)
            dtyfas = dty /(ntFast+1)

            DO     k=1,mz

            DO     j=1,my
            DO     i=1,mx
              WTxyz1(i,j,k) =       - uairDY(i,j,k)             *dtxfas
              WTxyz2(i,j,k) =       - vairDY(i,j,k)             *dtyfas
              uuface        = 0.5  * (uairDY(i,j,k)+uairDY(ip1(i),j,k))
              vvface        = 0.5  * (vairDY(i,j,k)+vairDY(i,jp1(j),k))
              WTxyz3(i,j,k) = 0.5  * (abs(uuface ) +  uuface  ) *dtxfas
              WTxyz5(i,j,k) = 0.5  * (abs(uuface ) -  uuface  ) *dtxfas
              WTxyz4(i,j,k) = 0.5  * (abs(vvface ) +  vvface  ) *dtyfas
              WTxyz6(i,j,k) = 0.5  * (abs(vvface ) -  vvface  ) *dtyfas
            END DO
            END DO

            END DO


C +--Advection (Time Splitting)
C +  ==========================

C +--Mass and Mass Flux
C +  ~~~~~~~~~~~~~~~~~~
            do     j=1,my
            do     i=1,mx
              WTxy5(i,j)=          pstDY(    i ,j)
              WTxy1(i,j)=          WTxy5(    i ,j)
              WTxy2(i,j)=          WTxy5(    i ,j)
              WTxy3(i,j)=          0.
            end do
            end do


C +--Conservative Scheme Order 0
C +  ===========================
C +
            IF (norder.eq.0)                                      THEN
                norder = -1


C +--Time Splitting
C +  --------------

C +--x-Direction First
C +  ~~~~~~~~~~~~~~~~~
              IF (mod(numdps,2).eq.0)                             THEN

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WTxyz7(    i ,    j ,k)  =

     .         - WTxyz3(    i ,    j ,k)  *  WTxy5(    i ,    j )
     .         + WTxyz5(    i ,    j ,k)  *  WTxy5(ip1(i),    j )
     .         + WTxyz3(im1(i),    j ,k)  *  WTxy5(im1(i),    j )
     .         - WTxyz5(im1(i),    j ,k)  *  WTxy5(    i ,    j )

                  WTxy3(    i ,    j   )  =  WTxy3(    i ,    j )
     .         + WTxyz7(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WTxyz8(    i ,    j ,k)  =

     .         - WTxyz4(    i ,    j ,k)  *  WTxy3(    i,     j )
     .         + WTxyz6(    i ,    j ,k)  *  WTxy3(    i ,jp1(j))
     .         + WTxyz4(    i ,jm1(j),k)  *  WTxy3(    i ,jm1(j))
     .         - WTxyz6(    i ,jm1(j),k)  *  WTxy3(    i ,    j )

                  WTxy3(i,j)  =              WTxy3(    i ,    j )
     .         + WTxyz8(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

C +--y-Direction First
C +  ~~~~~~~~~~~~~~~~~
              ELSE

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WTxyz7(    i ,    j ,k)  =

     .         - WTxyz4(    i ,    j ,k)  *  WTxy5(    i,     j )
     .         + WTxyz6(    i ,    j ,k)  *  WTxy5(    i ,jp1(j))
     .         + WTxyz4(    i ,jm1(j),k)  *  WTxy5(    i ,jm1(j))
     .         - WTxyz6(    i ,jm1(j),k)  *  WTxy5(    i ,    j )

                  WTxy3(i,j)  =              WTxy3(    i ,    j )
     .         + WTxyz7(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

                do     k=1,mz
                do     j=1,my
                do     i=1,mx
                 WTxyz8(    i ,    j ,k)  =

     .         - WTxyz3(    i ,    j ,k)  *  WTxy3(    i ,    j )
     .         + WTxyz5(    i ,    j ,k)  *  WTxy3(ip1(i),    j )
     .         + WTxyz3(im1(i),    j ,k)  *  WTxy3(im1(i),    j )
     .         - WTxyz5(im1(i),    j ,k)  *  WTxy3(    i ,    j )

                  WTxy3(i,j)  =              WTxy3(    i ,    j )
     .         + WTxyz8(    i ,    j ,k)  *  dsigm1(k)
                end do
                end do
                end do

              END IF

            END IF


C +--Conservative Scheme order 4
C +  ===========================

            IF (norder.eq.4)                                      THEN
                norder = -1


C +--Time Splitting
C +  --------------

C +--Parameters
C +  ~~~~~~~~~~
              IF (mod(numdps,2).eq.0)                             THEN
                   idir_x = 2
                   jdir_y = 3
              ELSE
                   idir_x = 3
                   jdir_y = 2
              END IF

C +--Auxiliary  Variables
C +  ~~~~~~~~~~~~~~~~~~~~
              do j=1,my
              do i=1,mx
                WTxy3(i,j) =  WTxy5(i,j)
                WTxy4(i,j) =  WTxy5(i,j)
              end do
              end do


C +--1D Computation
C +  --------------

 401          CONTINUE

              IF (idir_x.eq.0 .or.
     .            jdir_y.eq.3)                               GO TO 402

C +--x-Direction  here
C +  ~~~~~~~~~~~~~~~~~
                DO  k=1,mz
                DO  j=1,my
                  DO i=1,mx
                    cnpx(i)   = WTxyz3( i,j,k)
                    cnmx(i)   = WTxyz5( i,j,k)
                    vecx(i)   =  WTxy2( i,j)
                  END DO
                    cnpx(  0) = WTxyz3( 1,j,k)
                    cnpx(mxx) = WTxyz3(mx,j,k)
                    cnmx(  0) = WTxyz5( 1,j,k)
                    cnmx(mxx) = WTxyz5(mx,j,k)
                    vecx(  0) =  WTxy2( 1,j)
                    vecx(mxx) =  WTxy2(mx,j)

C +                      ********
                    call ADVbot_4(flux,vecx,aa0x,aa1x,aa2x,aa3x,aa4x,
     .                                 cnpx,cnmx,sipx,simx,sidx,mxx,1)
C +                      ********

                  DO i=1,mx
                    WTxyz7(i,j,k)=            - flux(i) + flux(im1(i))
                  END DO

                  DO i=1,mx
                     WTxy3(i,j)  = WTxy3(i,j) + WTxyz7(i,j,k)*dsigm1(k)
                  END DO
                END DO
                END DO

C +--Assignation in case of Time Splitting
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                IF (idir_x.gt.1.or.
     .              jdir_y.gt.1)                                  THEN
                  do j=1,my
                  do i=1,mx
                    WTxy1(i,j) = WTxy3(i, j)
                    WTxy4(i,j) = WTxy3(i, j)
                  end do
                  end do
                END IF

                    idir_x =  0

 402          CONTINUE

              IF (idir_x.eq.0 .and.
     .            jdir_y.eq.0)                               GO TO 403

C +--y-Direction  here
C +  ~~~~~~~~~~~~~~~~~
                DO  k=1,mz
                DO  i=1,mx
                  DO j=1,my
                    cnpy(j)   = WTxyz4(i, j,k)
                    cnmy(j)   = WTxyz6(i, j,k)
                    vecy(j)   =  WTxy1(i, j)
                  END DO
                    cnpy(  0) = WTxyz4(i, 1,k)
                    cnpy(myy) = WTxyz4(i,my,k)
                    cnmy(  0) = WTxyz6(i, 1,k)
                    cnmy(myy) = WTxyz6(i,my,k)
                    vecy(  0) =  WTxy1(i, 1)
                    vecy(myy) =  WTxy1(i,my)

C +                      ********
                    call ADVbot_4(fluy,vecy,aa0y,aa1y,aa2y,aa3y,aa4y,
     .                                 cnpy,cnmy,sipy,simy,sidy,myy,1)
C +                      ********

                  DO j=1,my
                    WTxyz8(i,j,k)=         - fluy(j) + fluy(jm1(j))
                  END DO

                  DO j=1,my
                    WTxy4(i,j)= WTxy4(i,j) + WTxyz8(i,j,k)*dsigm1(k)
                  END DO
                END DO
                END DO

C +--Assignation in case of Time Splitting
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                IF (idir_x.gt.1.or.
     .              jdir_y.gt.1)                                  THEN
                  do j=1,my
                  do i=1,mx
                    WTxy2(i,j) = WTxy4(i, j)
                    WTxy3(i,j) = WTxy4(i, j)
                  end do
                  end do
                END IF

                    jdir_y =  0

                                                             GO TO 401

 403          CONTINUE

            END IF


C +--Update
C +  ======

              DO j=1,my
              DO i=1,mx
                pstDYn(i,j) =             WTxy3(i,j)
C +...          New Pressure Thickness

                 WTxy3(i,j) = pstDY(i,j) -WTxy3(i,j)
C +...          New Pressure Thickness Increment

              END DO
              END DO


C ++++++++++++++++++++++++++++++++++
C +...Non Centered Schemes   (END) +
C ++++++++++++++++++++++++++++++++++


          END IF


C ++++++++++++++++++++++++++++++++++
C +--ERROR TEST              (END) +
C ++++++++++++++++++++++++++++++++++


        END IF
        IF (norder.ge.0)
     .    stop
     .   '++++++++ Horizontal Advection badly conditioned ++++++++++++'

      END IF


C ++++++++++++++++++++++++++++++++++
C +--EXPLICIT SCHEME         (END) +
C ++++++++++++++++++++++++++++++++++


C +--Vertical Wind Speed (sigma coordinate)
C +  ======================================

C +--Staggered Vertical Grid
C +  -----------------------


        IF (  itFast.eq.1) ntpsig = 0

!$OMP PARALLEL DO private (i,j,k)
          DO j=1,my 

        IF (  itFast.eq.       1                      )           THEN
            DO k=1,mz
c            DO j=1,my
            DO i=1,mx
              psigad(i,j,k) = 0.
            END DO
c            END DO
            END DO
        ENDIF

        IF (staggr)                                                 THEN

c            DO j=1,my
            DO i=1,mx
              WTxyz3(i,j,1)=sigmid(2)*  WTxy3(i,j)
     .                     +dsigm1(1)*(WTxyz7(i,j,1)+WTxyz8(i,j,1))
            END DO
c            END DO

            DO k=kp1(1),mmz
c            DO j=1,my
            DO i=1,mx
              WTxyz3(i,j,k)= dsigm1(k)*(WTxy3(i,j)
     .                 +(WTxyz7(i,j,k)
     .                  +WTxyz8(i,j,k)            ))+WTxyz3(i,j,k-1)
C +...        Computation of p*Sigma. BETWEEN Sigma Levels

            END DO
c            END DO
            END DO


C +--Unstaggered Vertical Grid
C +  -------------------------

        ELSE

c            DO j=1,my
            DO i=1,mx
              WTxyz3(i,j,1)= sigma(1)*  WTxy3(i,j)
     .                     + sigma(1)*(WTxyz7(i,j,1)+WTxyz8(i,j,1))
C +...        Open Upper Boundary Condition: WTxyz7(i,j,0)=WTxyz7(i,j,1)
C +                                          WTxyz8(i,j,0)=WTxyz8(i,j,1)
            END DO
c            END DO

            DO k=kp1(1),mz
c            DO j=1,my
            DO i=1,mx
              WTxyz3(i,j,k)= dsig_1(k-1) * (WTxy3(i,j)
     .            +0.50*(WTxyz7(i,j,k)+WTxyz7(i,j,k-1)
     .                  +WTxyz8(i,j,k)+WTxyz8(i,j,k-1)))
     .                  +WTxyz3(i,j,k-1)
C +...        Computation of p*Sigma. ON      Sigma Levels

            END DO
c            END DO
            END DO

        END IF
       ENDDO
!$OMP END PARALLEL DO

              ntpsig       = 1    +    ntpsig
!$OMP PARALLEL DO private (i,j,k)
        DO k=1,mz
            DO j=1,my
            DO i=1,mx
              psigad(i,j,k)=           psigad(i,j,k)
     .                     +           WTxyz3(i,j,k)
            END DO
            END DO
c            END DO

        IF (((itFast.eq.ntFast+1).and..not.pImplc).OR.
     .      ((itFast.eq.       1).and.     pImplc)    )           THEN

c            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              psigDY(i,j,k)=           psigad(i,j,k)
     .                     /           ntpsig
            END DO
            END DO
c            END DO

          IF (locorr)                                             THEN
c            DO k=1,mz
            DO j=1,my
            DO i=1,mx
              psigDY(i,j,k)=psigDY(i,j,k) / dtcorr
            END DO
            END DO
c            END DO
          END IF
        END IF
       ENDDO
!$OMP END PARALLEL DO 

C +--Simple non-hydrostatic Correction
C +  =================================

C +--Filtering
C +  ~~~~~~~~~
c #ON   do     j=1,my
c #ON   do     i=1,mx
c #ON     WTxy4(i,j) =
c #ON.          zi__TE(im1(i),jp1(j))+2.0*zi__TE(    i ,jp1(j))
c #ON.                               +    zi__TE(ip1(i),jp1(j))
c #ON.    + 2.0*zi__TE(im1(i),j)     +4.0*zi__TE(    i ,    j )
c #ON.                               +2.0*zi__TE(ip1(i),    j )
c #ON.    +     zi__TE(im1(i),jm1(j))+2.0*zi__TE(    i ,jm1(j))
c #ON.                             +      zi__TE(ip1(i),jm1(j))
c #ON   end do
c #ON   end do
c #ON   do     j=1,my
c #ON   do     i=1,mx
c #ON     WTxy4(i,j) = 0.0625* WTxy4(i,j)
c #ON   end do
c #ON   end do


C +--Correction
C +  ~~~~~~~~~~

c #ON   do     j=1,my
c #ON   do     i=1,mx
c #ON       CorArg = 1.0 + WTxy4(i,j) * WTxy4(i,j) / (4.0 * dx * dx)
c #ON       CorrNH = 1.0 / sqrt(CorArg)
C +...      Weisman et al., 1997, MWR125, p.541
C +
c #ON     do     k=1,mz
c #ON       psigDY(i,j,k)= psigDY(i,j,k)*CorrNH
c #ON     end do
c #ON   end do
c #ON   end do


C +--Vertical Velocity (sigma coordinates)
C +  =====================================

        IF (staggr)                                                 THEN
          DO       k=   1,mz
            DO     j=jp11,my1
            DO     i=ip11,mx1
              wsigDY(i,j,k)=   psigDY(i,j,k)
     .                       / pstDYn(i,j)
            END DO
            END DO
          END DO

        ELSE
          DO       k=   1,mz1
            DO     j=jp11,my1
            DO     i=ip11,mx1
              wsigDY(i,j,k)=  (psigDY(i,j,k)+psigDY(i,j,kp1(k)))*0.5
     .                       / pstDYn(i,j)
            END DO
            END DO
          END DO
                   k=     mz 
            DO     j=jp11,my1
            DO     i=ip11,mx1
              wsigDY(i,j,k)=   psigDY(i,j,k)                    *0.5
     .                       / pstDYn(i,j)
            END DO
            END DO
        END IF


C +--Maximum Vertical Courant Number
C +  ===============================

              CFLzDY     =     0.0
      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
              CFLzDY     = max(CFLzDY 
     .                    ,abs(wsigDY(i,j,k))*2.0*dt/dsigm1(k))
        END DO
        END DO
      END DO


C +--Slip condition for Mountain Wave Experiments
C +  ============================================

c #OM   DO       j=1,my
c #OM   DO       i=1,mx
c #OM     psigDY(i,j,mz)=0.0
c #OM   END DO
c #OM   END DO

      return
      end


      subroutine ADVbot_4(flu,vec,aa0,aa1,aa2,aa3,aa4,
     .                    cnp,cnm,sip,sim,sid,mmm,logpos)
C +
C +------------------------------------------------------------------------+
C | MAR ADVECTION                                          16-12-2000  MAR |
C |   SubRoutine ADVbot_4   includes the            Advection Contribution |
C |                              for positive definite scalar Variables    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   vec                : variable to advect                     |
C |   ^^^^^    aa0,aa1,aa2,aa3,aa4: Work Area                              |
C |            cnp                : Courant Number (x+ Cell)               |
C |            cnm                : Courant Number (x- Cell)               |
C |            sip,sim,sid        : Work Area                              |
C |            mmm                : Dimension of the Variables             |
C |            logpos             : Positive definite Constraint Switch    |
C |                                                                        |
C |   OUTPUT:  flu   : advection fluxes at each cell boundaries            |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   METHOD : The Flux Form of the Equation is solved:                    |
C |   ^^^^^^^^ d(Qp*)/dt + d(uQp*)/dx + d(vQp*)/dy + d(sQp*)/ds = 0        |
C |            The scheme is that of Bott (1989) MWR, 117, 1007-1009       |
C |                              and Bott (1989) MWR, 117, 2635 (Table 1)  |
C |                                                                        |
C | # OPTIONS: STANDARD: Bott Scheme, order 0 (zero)                       |
C | # ^^^^^^^^ #B+ #B2   Bott Scheme, order 2                              |
C | #          #B+ #B4   Bott Scheme, order 4                              |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      integer   mmm,logpos
C +
      real      flu(0:mmm)
      real      vec(0:mmm)
      real      aa0(0:mmm)
      real      aa1(0:mmm)
      real      aa2(0:mmm)
      real      aa3(0:mmm)
      real      aa4(0:mmm)
      real      cnp(0:mmm)
      real      cnm(0:mmm)
      real      sip(0:mmm)
      real      sim(0:mmm)
      real      sid(0:mmm)
C +
C +
C +--Local  Variables
C +  ================
C +
      integer   i     ,im1   ,ip1   ,im2   ,ip2   
      real      epsadv,propo1,propo2,propo3,propo4,propo5
      real             prone1,prone2,prone3,prone4,prone5
C +
C +
C +--DATA
C +  ====
C +
      data epsadv/1.e-6/
C +
      DO i=0,mmm
         im1=max(i-1,0)
         ip1=min(i+1,mmm)
         im2=max(i-2,0)
         ip2=min(i+2,mmm)
C +
C +
C +--Approximation of vec
C +  --------------------
C +
C +--Polynomial Fitting, as in Bott (1989) MWR, 117, 2635 (Table 1)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        aa0(i) =        
c #B2.          (26.0 *         
     .                  vec(i  )
c #B2.                 -vec(ip1)-vec(im1))/24.0
c #B2   aa1(i) = 0.50 *(vec(ip1)-vec(im1))
c #B2   aa2(i) = 0.50 *(vec(ip1)+vec(im1)) - vec(i)
C +...  aa0, aa1, aa2 : Lagrange Polynomial Coefficients 
C +                    (see Bott 1989 MWR Table 1 p.2635)
C +
        aa0(i)=( 9.0*vec(ip2) -116.0*vec(ip1) + 2134.0*vec(i)
     .        -116.0*vec(im1) +  9.0*vec(im2))                /1920.0
        aa1(i)=(-5.0*vec(ip2) + 34.0*vec(ip1)
     .         -34.0*vec(im1) +  5.0*vec(im2))                  /48.0
        aa2(i)=(-3.0*vec(ip2) + 36.0*vec(ip1) -   66.0*vec(i)
     .         +36.0*vec(im1) -  3.0*vec(im2))                  /48.0
        aa3(i)=(     vec(ip2) -  2.0*vec(ip1)
     .          +2.0*vec(im1) -      vec(im2))                  /12.0
        aa4(i)=(     vec(ip2) -  4.0*vec(ip1) +    6.0*vec(i)
     .          -4.0*vec(im1) +      vec(im2))                  /24.0
      END DO
C +
C +--Integral (7), Bott 1989 MWR 117 p. 1007
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      DO i=0,mmm
        propo1 = 1.0-2.0*cnp(i)
        propo2 = propo1 *propo1
        propo3 = propo2 *propo1
        propo4 = propo3 *propo1
        propo5 = propo4 *propo1
        sip(i) = aa0(i  )        *     cnp(i)
     .        + (aa1(i  )/  8.0)*(1.0-propo2) 
     .        + (aa2(i  )/ 24.0)*(1.0-propo3)
     .        + (aa3(i  )/ 64.0)*(1.0-propo4)
     .        + (aa4(i  )/160.0)*(1.0-propo5)
      END DO
C +
C +--Integral (8), Bott 1989 MWR 117 p. 1008
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      DO i=0,mmm
         ip1=min(i+1,mmm)
        prone1 = 1.00-2.0*cnm(i)
        prone2 = prone1 *prone1
        prone3 = prone2 *prone1
        prone4 = prone3 *prone1
        prone5 = prone4 *prone1
        sim(i) = aa0(ip1)        *     cnm(i) 
     .        - (aa1(ip1)/  8.0)*(1.0-prone2) 
     .        + (aa2(ip1)/ 24.0)*(1.0-prone3)
     .        - (aa3(ip1)/ 64.0)*(1.0-prone4)
     .        + (aa4(ip1)/160.0)*(1.0-prone5)
      END DO
C +
C +
C +--Positive Definite Constraint, Bott 1989, MWR 117 (14) p.1008
C +  ------------------------------------------------------------
C +
      IF (logpos.eq.1)                                            THEN
C +
C +--Positive Definite Constraint is     applied
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
        DO i=0,mmm
          sip(i) = max(sip(i),zero)
          sim(i) = max(sim(i),zero)
          sid(i) = aa0(i) + aa2(i) / 12.0
     .                    + aa4(i) / 80.0
        END DO
C +
        DO i=0,mmm
           im1=max(i-1,0)
          sid(i) = max(sid(i),sip(i)+sim(im1)+epsadv)
        END DO
C +
        DO i=0,mmm
           ip1=min(i+1,mmm)
          flu(i) = sip(i)*vec(i)/sid(i)  -  sim(i)*vec(ip1)/sid(ip1)
        END DO
C +
      ELSE
C +
C +--Positive Definite Constraint is not applied
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
        DO i=0,mmm
          flu(i) = sip(i)                -  sim(i)
        END DO
C +
      END IF
C +
      return
      end
      subroutine DYNdps_cor(pav)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           18-09-2001  MAR |
C |   SubRoutine DYNdps_cor constraints the Mass Conservation Equation     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    itexpe: Experiment      Iteration Number                    |
C |                                                                        |
C |   INPUT:   pav   : Domain averaged Pressure  Thickness                 |
C |   ^^^^^                                                                |
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   OUTPUT   pstDYn(mx,my)   : Pressure Depth p*(t)           (kPa)      |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   REFER. : Yan and Anthes (MWR 1987)                                   |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_LB.inc'
C +
      real     pav
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  n
      real     flumas(mx,my)      
      real     flufix(mx,my)
      real     fluxav(mx,my)
      real     pnav  ,dpav  ,dpsdom
C +
C +
C +--Mass Flux Diagnostics
C +  =====================
C +
      IF (mod(jmmMAR,10).eq.0.and.jssMAR.eq.0)                    THEN
C +
        DO j=1,my
        DO i=1,mx
              flumas(i,j) = 0.0
              flufix(i,j) = 0.0
C +
          IF (i.le.   n7mxLB)                                     THEN
            DO  k=1,mz
              flufix(i,j) = flufix(i,j)
     .                    + vaxgLB(i,j,k,1)*(sigmid(k+1)-sigmid(k))
            END DO
          END IF
C +
          IF (i.ge.mx-n6mxLB)                                     THEN
            DO  k=1,mz
              flufix(i,j) = flufix(i,j)
     .                    + vaxdLB(i,j,k,1)*(sigmid(k+1)-sigmid(k))
            END DO
          END IF
C +
            DO  k=1,mz
              flumas(i,j) = flumas(i,j)
     .                    + uairDY(i,j,k)  *(sigmid(k+1)-sigmid(k))
            END DO
C +
              flumas(i,j) = flumas(i,j)*pstDYn( i,j)
              flufix(i,j) = flufix(i,j)*pstDYn( i,j)
        END DO
        END DO
C +
        DO  j=1,my
        DO  i=  n7mxLB,mx-n6mxLB
              fluxav(i,j) = 0.0
            DO  n=i-n6mxLB,i +n6mxLB
              fluxav(i,j) = fluxav(i,j) + flumas(i,j)
            END DO
              fluxav(i,j) = fluxav(i,j) /(n6mxLB+n7mxLB)
        END DO
        END DO
C +
              dpsdom      = 1.d1*(pstDYn(mx,jmez) - pstDYn( 1,jmez)
     .                           -pstDY1(mx,jmez) + pstDY1( 1,jmez))
        IF (abs(fcorDY(imez,jmez)).gt.epsi) 
     .        dpsdom      = 1.d2* dpsdom / (mx*dx*fcorDY(imez,jmez))
      END IF
C +
C +
C +--Current Model Averaged Mass
C +  ===========================
C +
        pnav = 0.0
      DO j=1,my
      DO i=1,mx
        pnav = pnav + pstDYn(i,j)
      END DO
      END DO
        pnav = pnav / (mx*my)
        dpav = pav  -  pnav 
C +...  dpav : Mean Error for Pressure Depth
C +
C +
C +--OUTPUT
C +  ======
C +
      IF (mod(jmmMAR,10).eq.0.and.jssMAR.eq.0)                    THEN
C +
        write(4,400) itexpe,jhaMAR,jmmMAR
     .                     ,(flufix(i,1),i= 1,n7mxLB+1)
     .                     ,(flufix(i,1),i=mx-n6mxLB-1,mx)
     .                     ,(flumas(i,1),i= 1,n7mxLB+1)
     .                     ,(flumas(i,1),i=mx-n6mxLB-1,mx)
     .      ,fluxav(   7,1),(fluxav(i,1),i=15,         mx-10,10)
     .      ,fluxav(mx-6,1),-dpav,dpsdom
 400    format(/,' Mass Diagnostic:',i6,i4,'h',i2,8f7.1,'.......',8f7.1,
     .                             /,30x,         8f7.1,'.......',8f7.1,
     .                             /,30x,'Average:',6x,13f7.1,f14.3,
     .                             /,30x,'Dp(Dom):',6x,  f7.1)
C +
      END IF
C +
C +
C +--Model Averaged Mass Constancy
C +  =============================
C +
c #OB DO j=1,my
c #OB DO i=1,mx
c #OB   pstDYn(i,j) = pstDYn(i,j) + 1.157d-5 *dt *dpav
C +...  Yan and Anthes (MWR 1987) Method, for Zero Gradient Lateral Boundaries
C +     (its use is preferable when mesoscale circulation is more active 
C +                            than synoptic scale circulation) 
c #OB END DO
c #OB END DO
C +
      return
      end


      subroutine DYNdgz_mp(norder)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                    10-08-2004  MAR |
C |   SubRoutine DYNdgz includes in the Horizontal Momentum Equations      |
C |              the terms representing the Pressure Gradient Force (PGF)  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    brocam: Brown and Campana Time Scheme Switch                |
C |            itFast: Short             Time Step  Counter                |
C |                                                                        |
C |            uairDY, vairDY, pktaDY   : u, v, and P / Time Step n        |
C |            ubefDY, vbefDY, ddux,ddvx: u, v        / Time Step n-1, n-2 |
C |            uairDY: x-wind speed component                        (m/s) |
C |            vairDY: y-wind speed component                        (m/s) |
C |            pktaDY: potential temperature divided by 100.[kPa]**(R/Cp)  |
C |             virDY: Contribution from Air Loading               (kg/kg) |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^   uairDY, vairDY, pktaDY: u, v, and P Values / Time Step n+1  |
C |            gpmiDY(i,j,k) = g * z (i,j,k-1/2),  (Geopotential)  (m2/s2) |
C |                                                                        |
C |   METHOD:  1) Solves the Hydrostatic Relation:                         |
C |   ^^^^^^       0     =- 1 /rho -dPHI/dp                                |
C |                      => gives the Geopotential PHI between Sigma Levels|
C |            2) Solves the Contributions       :                         |
C |                du/dt:=         -dPHI/dx                                |
C |                dv/dt:=         -dPHI/dy                                |
C |            3) Spatial  Numerical Scheme      :                         |
C |                Spatial Discretisation on Arakawa A Grid                |
C |   norder.EQ.2  2th Order Accurate Horizontal Spatial Differencing .OR. |
C |   norder.NE.2  4th Order Accurate Horizontal Spatial Differencing      |
C |                dPHI/dx and dPHI/dy are computed on p**(R/Cp) Surfaces  |
C |            4) Temporal Numerical Scheme      :                         |
C |                Time Split (i.e. each contribution computed separately) |
C |                Split Time Differencing, i.e. pressure Evolution and    |
C |                PGF are computed on Short Time Step dtfast=dt/(ntFast+1)|
C |                Advection and Diffusion are Computed on a Longer One)   |
C |                Brown and Campana Time Scheme used over Short Time Step |
C |                                                                        |
C |   REFER.:  1) Purser and Leslie, MWR 116, 2069--2080, 1988     (A Grid)|
C |   ^^^^^^   2) Marchuk, Numer.Meth.in Weath.Predict.,  1974 (Time Split)|
C |            3) Gadd, QJRMS 104, 569--582, 1978 (Split Time Differencing)|
C |            4) Brown and Campana, MWR 106, 1125--1136, 1978             |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_UB.inc'

      include 'MAR_WK.inc'

      integer  norder


C +--Local  Variables
C +  ================

      include 'MARvec.inc'

      real     ff_dgz(mx,my,mz)              ! Momentum Dummy Variable
      real     adv_uu(mx,my,mz)              ! Advected     u-Momentum
      real     adv_vv(mx,my,mz)              ! Advected     v-Momentum

      real     bca   ,bcb   ,c1a   ,c1b   ,ddux  ,ddvx  ,fraCLS,sigCLS
      real     Raylei


C +--DATA
C +  ====

      data bca/0.245e0/,bcb/0.510e0/
C +...Parameters of the Brown-Campana (1978, MWR, p.1125) scheme
C +   WARNING : scheme is unstable for bca maximum value (0.25)


C +--Contributions   from Momentum Advection
C +  =======================================

c!$OMP PARALLEL sections default(shared)
c!$OMP.private(ff_dgz,i,j,k)
c!$OMP section 
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          ff_dgz(i,j,k) = uairDY(i,j,k)
        ENDDO
        ENDDO
        ENDDO

        if(openmp) then
C +          **********
        call DYNadv_dLF_mp(norder,ff_dgz,adv_uu)
C +          **********
        else
C +          **********
        call DYNadv_dLF(norder,ff_dgz,adv_uu)
C +          **********
        endif
c!$OMP section

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          ff_dgz(i,j,k) = vairDY(i,j,k)
        ENDDO
        ENDDO
        ENDDO

        if(openmp) then
C +          **********
        call DYNadv_dLF_mp(norder,ff_dgz,adv_vv)
C +          **********
        else
C +          **********
        call DYNadv_dLF(norder,ff_dgz,adv_vv)
C +          **********
        endif
c!$OMP end PARALLEL sections

C +--Integration of the Hydrostatic Equation
C +  =======================================

C +--EXNER Potential
C +  ---------------

      IF (brocam)                                                   THEN

        DO j=1,my
        DO i=1,mx
          WKxy4(i,j)=exp(cap*log(pstDYn(i,j)              +ptopDY))
          WKxy1(i,j)=     cp*     WKxy4(i,j)
        END DO
        END DO

      ELSE

        DO j=1,my
        DO i=1,mx
          WKxy4(i,j)=exp(cap*log(pstDY (i,j)              +ptopDY))
          WKxy1(i,j)=     cp*     WKxy4(i,j)
        END DO
        END DO

      END IF

C +--Surface     Contribution to Exner Function
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        fraCLS    = 0.0d+0
c #IL   fraCLS    = 0.5d+0
C +...  fraCLS    : CLS Fraction where Temperature~Surface Temperature 
C +   0<fraCLS<1    and generally close to zero
C +     fraCLS    = 0.5  ==> linear variation of potential Temperature 
C +                          is assumed beween levels k=mz and k=mzz
C +
        sigCLS    =(1.0d+0 - fraCLS) + fraCLS  *sigma(mz)

      IF (brocam)                                                   THEN
        DO j=1,my
        DO i=1,mx
          WKxy5(i,j)=cp * exp(cap*log(pstDYn(i,j)*sigCLS       +ptopDY))
        END DO
        END DO
      ELSE
        DO j=1,my
        DO i=1,mx
          WKxy5(i,j)=cp * exp(cap*log(pstDY (i,j)*sigCLS       +ptopDY))
        END DO
        END DO
      END IF

C +--Atmospheric Contribution to Exner Function
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!$OMP PARALLEL DO private (i,j,k)
      DO j=1,my
      DO k=1,mz

        IF (k.ge.mz.and.ptopDY.le.0.0)                              THEN
c            DO j=1,my
            DO i=1,mx
              WKxy3(i,j)=0.0
            END DO
c            END DO
        ELSE
          IF (brocam)                                               THEN
c            DO j=1,my
            DO i=1,mx
              WKxy3(i,j)=exp(cap*log(pstDYn(i,j)*sigmid(mzz-k)+ptopDY))
            END DO
c            END DO
          ELSE
c            DO j=1,my
            DO i=1,mx
              WKxy3(i,j)=exp(cap*log(pstDY (i,j)*sigmid(mzz-k)+ptopDY))
            END DO
c            END DO
          END IF
        END IF

c            DO j=1,my
            DO i=1,mx
              WKxy2(i,j)       = cp*WKxy3(i,j)
              WKxyz4(i,j,mzz-k)=    WKxy3(i,j)
C +...        WKxyz4           :    p ** (R/Cp)

            END DO
c            END DO


C +--GEO---Potential (Mid Layer k-1/2)
C +  ---------------

C +--Of    the Surface Layer
C +  ~~~~~~~~~~~~~~~~~~~~~~~
        IF (k.eq.1)                                                 THEN

c          DO j=1,my
          DO i=1,mx
            gpmiDY(i,j,mz)=gplvDY(i,j,mzz) 
     .                 +((WKxy5(i,j)-WKxy2(i,j))*pktaDY(i,j,mz)
     .                  +(WKxy1(i,j)-WKxy5(i,j))*pktaDY(i,j,mzz))
     .                                      *(1.0+virDY(i,j,mz))
C +...      REMARK : It is assumed that the Geopotential Difference 
C +                  in Lower Layer depends only on pktaDY at 1st Sigma Lev. 

          END DO
c          END DO

        ELSE

C +--Above the Surface Layer
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c          DO j=1,my
          DO i=1,mx
            gpmiDY(i,j,mzz-k)=gpmiDY(i,j,mzz+1-k)
     .                     +(WKxy1(i,j)-WKxy2(i,j))*pktaDY(i,j,mzz-k)
     .                                         *(1.0+virDY(i,j,mzz-k))
          END DO
c          END DO

        END IF

c          DO j=1,my
          DO i=1,mx
            WKxy1(i,j)=WKxy2(i,j)
          END DO
c          END DO

      END DO
      END DO
!$OMP END PARALLEL DO


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

C +--Update of u and v at the Lateral Boundaries
C +  ===========================================

!$OMP PARALLEL DO
!$OMP. private (i,j,WKxy1,WKxy3,c1a,c1b,ddux,ddvx)
        DO   k=1,mz
          DO j=1,my
            ubefDY( 1,j,k) = uairDY( 1,j,k)
            ubefDY(mx,j,k) = uairDY(mx,j,k)
            vbefDY( 1,j,k) = vairDY( 1,j,k)
            vbefDY(mx,j,k) = vairDY(mx,j,k)
          END DO
c       END DO
      IF (mmy.gt.1)                                                 THEN
c       DO   k=1,mz
          DO i=1,mx
            ubefDY(i, 1,k) = uairDY(i, 1,k)
            ubefDY(i,my,k) = uairDY(i,my,k)
            vbefDY(i, 1,k) = vairDY(i, 1,k)
            vbefDY(i,my,k) = vairDY(i,my,k)
          END DO
c       END DO
      END IF

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

C +--Mesoscale Geopotential Gradient
C +  ===============================

c     DO k=1,mz

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF (k.eq.mz)                                          GO TO 30
          DO j=1,my
          DO i=1,mx
            WKxy1( i,j)  = WKxyz4(i,j,k+1)
            WKxyz1(i,j,k)= gpmiDY(i,j,k+1)
          END DO
          END DO
                                                              GO TO 31
 30     CONTINUE
          DO j=1,my
          DO i=1,mx
            WKxy1( i,j)  = WKxy4(i,j)
            WKxyz1(i,j,k)= gplvDY(i,j,mzz)
          END DO
          END DO
 31     CONTINUE

        DO j=1,my
        DO i=1,mx
          WKxy3( i,j)  = WKxyz4(i,j,k)-WKxy1(i,j)
        END DO
        END DO


C +--Gradient following x
C +  --------------------

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO j=jp11,my1
        DO i=   1,mx
            WKxyz2(i,j,k)=(WKxyz4(i,j,k)*WKxyz1(i,j,k)
     .                     -WKxy1(i,j)  *gpmiDY(i,j,k))/WKxy3(i,j)
            WKxyz3(i,j,k)=(gpmiDY(i,j,k)-WKxyz1(i,j,k))/WKxy3(i,j)
        END DO
        END DO

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF (norder.EQ.2)                                            THEN
          DO i=   1,mx
          DO j=jp11,my1
              WKxyz5(i,j,k)=
     .                 (WKxyz2(ip1(i),j,k)-WKxyz2(im1(i),j,k)) *dxinv2
              WKxyz6(i,j,k)=
     .                 (WKxyz3(ip1(i),j,k)-WKxyz3(im1(i),j,k)) *dxinv2
          END DO
          END DO
        ELSE
          DO i=   1,mx
          DO j=jp11,my1
              WKxyz5(i,j,k)=
     .          fac43 *(WKxyz2(ip1(i),j,k)-WKxyz2(im1(i),j,k)
     .         -0.125 *(WKxyz2(ip2(i),j,k)-WKxyz2(im2(i),j,k)))*dxinv2
              WKxyz6(i,j,k)=
     .          fac43 *(WKxyz3(ip1(i),j,k)-WKxyz3(im1(i),j,k)
     .         -0.125 *(WKxyz3(ip2(i),j,k)-WKxyz3(im2(i),j,k)))*dxinv2
          END DO
          END DO
        ENDIF


C +--Contribution to u Wind Speed Component
C +  --------------------------------------

C +- First Step
C +  ~~~~~~~~~~
          IF (itFast.eq.1)                                          THEN
            DO j=jp11,my1
            DO i=ip11,mx1
              c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    + adv_uu(i,j,k)

              c1b           =  dtfast *             c1a
              ubefDY(i,j,k) =  uairDY(i,j,k) +      c1b
              uairDY(i,j,k) =  uairDY(i,j,k) + c1b +c1b

              dg1xDY(i,j,k) =  c1a 
              dgzxDY(i,j,k) =  c1a
            END DO
            END DO


C +- Next  Step
C +  ~~~~~~~~~~
          ELSE
            IF (itFast.le.ntFast)                                   THEN
              IF (brocam)                                           THEN
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                       +  adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   + 2.0*     dtfast
     .                                    *(bcb*     dgzxDY(i,j,k)
     .                                     +bca*(c1a+dg1xDY(i,j,k)))
C +...            U (n+1)       =  U(n-1) + 2     Dt  (Du/Dt)

C +- Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             ubefDY(i,j,k) =  ubefDY(i,j,k) 
c #rt.              + Robert*(0.5*(uairDY(i,j,k)+ddux) -  ubefDY(i,j,k))

                  dg1xDY(i,j,k) =  dgzxDY(i,j,k)
                  dgzxDY(i,j,k) =  c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                        + adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   + 2.0  *dtfast *c1a
C +...            U (n+1)       =  U(n-1) + 2     Dt     (Du/Dt)

                END DO
                END DO
              END IF

C +- Last  Step
C +  ~~~~~~~~~~
            ELSE
              IF (brocam) then
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                       +  adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   +    dtfast
     .                                      *(bcb*     dgzxDY(i,j,k)
     .                                       +bca*(c1a+dg1xDY(i,j,k)))
C +...            U (n+1)       =  U(n)   +    Dt     (Du/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                  dg1xDY(i,j,k) =  dgzxDY(i,j,k)
                  dgzxDY(i,j,k) =  c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                       +  adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   +    dtfast *c1a
C +...            U (n+1)       =  U(n)   +    Dt     (Du/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                END DO
                END DO
              END IF
            END IF
          END IF


C +- Gradient following y
C +  -------------------- 

        IF (mmy.gt.1)                                               THEN

          DO j=   1,my
            WKxyz2( 1,j,k) = 0.
            WKxyz2(mx,j,k) = 0.
            WKxyz3( 1,j,k) = 0.
            WKxyz3(mx,j,k) = 0.
          ENDDO

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          DO i=ip11,mx1
          DO j=   1,my
            WKxyz2(i,j,k)=(WKxyz4(i,j,k)*WKxyz1(i,j,k)
     .                     -WKxy1(i,j)  *gpmiDY(i,j,k))/WKxy3(i,j)
            WKxyz3(i,j,k)=(gpmiDY(i,j,k)-WKxyz1(i,j,k))/WKxy3(i,j)

          END DO
          END DO

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         IF (norder.EQ.2)                                           THEN
          DO j=   1,my
          DO i=ip11,mx1
            WKxyz5(i,j,k)=
     .                  (WKxyz2(i,jp1(j),k)-WKxyz2(i,jm1(j),k) )*dyinv2
            WKxyz6(i,j,k)=
     .                  (WKxyz3(i,jp1(j),k)-WKxyz3(i,jm1(j),k) )*dyinv2
          END DO
          END DO
         ELSE
          DO j=   1,my
          DO i=ip11,mx1
            WKxyz5(i,j,k)=
     .           fac43 *(WKxyz2(i,jp1(j),k)-WKxyz2(i,jm1(j),k)
     .          -0.125 *(WKxyz2(i,jp2(j),k)-WKxyz2(i,jm2(j),k)))*dyinv2
            WKxyz6(i,j,k)=
     .           fac43 *(WKxyz3(i,jp1(j),k)-WKxyz3(i,jm1(j),k)
     .          -0.125 *(WKxyz3(i,jp2(j),k)-WKxyz3(i,jm2(j),k)))*dyinv2
          END DO
          END DO
         ENDIF


C +--Contribution to v Wind Speed Component
C +  --------------------------------------

C +- First Step
C +  ~~~~~~~~~~
          IF (itFast.eq.1)                                          THEN
            DO j=jp11,my1
            DO i=ip11,mx1
              c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                   +  adv_vv(i,j,k)

              c1b        = dtfast *                 c1a
              vbefDY(i,j,k) =  vairDY(i,j,k) +      c1b
              vairDY(i,j,k) =  vairDY(i,j,k) + c1b +c1b

              dg1yDY(i,j,k) = c1a
              dgzyDY(i,j,k) = c1a
            END DO
            END DO

C +- Next  Step
C +  ~~~~~~~~~~
          ELSE
            IF   (itFast.le.ntFast)                                 THEN
              IF (brocam)                                           THEN
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    +   2.0*     dtfast
     .                                      *(bcb*     dgzyDY(i,j,k)
     .                                       +bca*(c1a+dg1yDY(i,j,k)))
C +               V (n+1)       = V(n-1)  +   2    Dt  (Dv/Dt)

C +- Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             vbefDY(i,j,k) =  vbefDY(i,j,k) 
c #rt.              + Robert*(0.5*(vairDY(i,j,k)+ddvx) -vbefDY(i,j,k))

                  dg1yDY(i,j,k) =  dgzyDY(i,j,k)
                  dgzyDY(i,j,k) =  c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    + 2.0*dtfast *c1a
C +               V (n+1)       = V(n-1)  + 2   Dt   (Dv/Dt)

                END DO
                END DO
              END IF

C +- Last  Step
C +  ~~~~~~~~~~
            ELSE
              IF (brocam)                                           THEN
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    +   dtfast
     .                                      *(bcb*     dgzyDY(i,j,k)
     .                                       +bca*(c1a+dg1yDY(i,j,k)))
C +...            V (n+1)       =  V(n)   +   Dt (Dv/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                  dg1yDY(i,j,k) = dgzyDY(i,j,k)
                  dgzyDY(i,j,k) = c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    +    dtfast *c1a
C +...            V (n+1)       =  V(n)   +    Dt (Dv/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                END DO
                END DO
              END IF
            END IF
          END IF
        END IF

C +--Rayleigh Friction (Ref. ARPS 4.0 User's Guide, para 6.4.3 p.152)
C +  =================

c #RF if(k<= mzabso) then
c #RF   DO j=1,my
c #RF   DO i=1,mx
c #RF     uairDY(i,j,k)=(uairDY(i,j,k) + Ray_UB(k)*dtFast*uairUB(i,j,k))
c #RF.                 /(1.0           + Ray_UB(k)*dtFast              )
c #RF     vairDY(i,j,k)=(vairDY(i,j,k) + Ray_UB(k)*dtFast*vairUB(i,j,k))
c #RF.                 /(1.0           + Ray_UB(k)*dtFast              )
c #RF   END DO
c #RF   END DO
c #RF ENDIF
      ENDDO
!$OMP END PARALLEL DO
      return
      end

      subroutine DYNdgz(norder)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                    10-08-2004  MAR |
C |   SubRoutine DYNdgz includes in the Horizontal Momentum Equations      |
C |              the terms representing the Pressure Gradient Force (PGF)  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    brocam: Brown and Campana Time Scheme Switch                |
C |            itFast: Short             Time Step  Counter                |
C |                                                                        |
C |            uairDY, vairDY, pktaDY   : u, v, and P / Time Step n        |
C |            ubefDY, vbefDY, ddux,ddvx: u, v        / Time Step n-1, n-2 |
C |            uairDY: x-wind speed component                        (m/s) |
C |            vairDY: y-wind speed component                        (m/s) |
C |            pktaDY: potential temperature divided by 100.[kPa]**(R/Cp)  |
C |             virDY: Contribution from Air Loading               (kg/kg) |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^   uairDY, vairDY, pktaDY: u, v, and P Values / Time Step n+1  |
C |            gpmiDY(i,j,k) = g * z (i,j,k-1/2),  (Geopotential)  (m2/s2) |
C |                                                                        |
C |   METHOD:  1) Solves the Hydrostatic Relation:                         |
C |   ^^^^^^       0     =- 1 /rho -dPHI/dp                                |
C |                      => gives the Geopotential PHI between Sigma Levels|
C |            2) Solves the Contributions       :                         |
C |                du/dt:=         -dPHI/dx                                |
C |                dv/dt:=         -dPHI/dy                                |
C |            3) Spatial  Numerical Scheme      :                         |
C |                Spatial Discretisation on Arakawa A Grid                |
C |   norder.EQ.2  2th Order Accurate Horizontal Spatial Differencing .OR. |
C |   norder.NE.2  4th Order Accurate Horizontal Spatial Differencing      |
C |                dPHI/dx and dPHI/dy are computed on p**(R/Cp) Surfaces  |
C |            4) Temporal Numerical Scheme      :                         |
C |                Time Split (i.e. each contribution computed separately) |
C |                Split Time Differencing, i.e. pressure Evolution and    |
C |                PGF are computed on Short Time Step dtfast=dt/(ntFast+1)|
C |                Advection and Diffusion are Computed on a Longer One)   |
C |                Brown and Campana Time Scheme used over Short Time Step |
C |                                                                        |
C |   REFER.:  1) Purser and Leslie, MWR 116, 2069--2080, 1988     (A Grid)|
C |   ^^^^^^   2) Marchuk, Numer.Meth.in Weath.Predict.,  1974 (Time Split)|
C |            3) Gadd, QJRMS 104, 569--582, 1978 (Split Time Differencing)|
C |            4) Brown and Campana, MWR 106, 1125--1136, 1978             |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_UB.inc'

      include 'MAR_WK.inc'

      integer  norder


C +--Local  Variables
C +  ================

      include 'MARvec.inc'

      real     ff_dgz(mx,my,mz)              ! Momentum Dummy Variable
      real     adv_uu(mx,my,mz)              ! Advected     u-Momentum
      real     adv_vv(mx,my,mz)              ! Advected     v-Momentum

      real     bca   ,bcb   ,c1a   ,c1b   ,ddux  ,ddvx  ,fraCLS,sigCLS
      real     Raylei


C +--DATA
C +  ====

      data bca/0.245e0/,bcb/0.510e0/
C +...Parameters of the Brown-Campana (1978, MWR, p.1125) scheme
C +   WARNING : scheme is unstable for bca maximum value (0.25)


C +--Contributions   from Momentum Advection
C +  =======================================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          ff_dgz(i,j,k) = uairDY(i,j,k)
        ENDDO
        ENDDO
        ENDDO

C +          **********
        call DYNadv_dLF(norder,ff_dgz,adv_uu)
C +          **********

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          ff_dgz(i,j,k) = vairDY(i,j,k)
        ENDDO
        ENDDO
        ENDDO
C +          **********
        call DYNadv_dLF(norder,ff_dgz,adv_vv)
C +          **********

C +--Integration of the Hydrostatic Equation
C +  =======================================

C +--EXNER Potential
C +  ---------------

      IF (brocam)                                                   THEN

        DO j=1,my
        DO i=1,mx
          WKxy4(i,j)=exp(cap*log(pstDYn(i,j)              +ptopDY))
          WKxy1(i,j)=     cp*     WKxy4(i,j)
        END DO
        END DO

      ELSE

        DO j=1,my
        DO i=1,mx
          WKxy4(i,j)=exp(cap*log(pstDY (i,j)              +ptopDY))
          WKxy1(i,j)=     cp*     WKxy4(i,j)
        END DO
        END DO

      END IF

C +--Surface     Contribution to Exner Function
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        fraCLS    = 0.0d+0
c #IL   fraCLS    = 0.5d+0
C +...  fraCLS    : CLS Fraction where Temperature~Surface Temperature 
C +   0<fraCLS<1    and generally close to zero
C +     fraCLS    = 0.5  ==> linear variation of potential Temperature 
C +                          is assumed beween levels k=mz and k=mzz
C +
        sigCLS    =(1.0d+0 - fraCLS) + fraCLS  *sigma(mz)

      IF (brocam)                                                   THEN
        DO j=1,my
        DO i=1,mx
          WKxy5(i,j)=cp * exp(cap*log(pstDYn(i,j)*sigCLS       +ptopDY))
        END DO
        END DO
      ELSE
        DO j=1,my
        DO i=1,mx
          WKxy5(i,j)=cp * exp(cap*log(pstDY (i,j)*sigCLS       +ptopDY))
        END DO
        END DO
      END IF

C +--Atmospheric Contribution to Exner Function
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      DO k=1,mz

        IF (k.ge.mz.and.ptopDY.le.0.0)                              THEN
            DO j=1,my
            DO i=1,mx
              WKxy3(i,j)=0.0
            END DO
            END DO
        ELSE
          IF (brocam)                                               THEN
            DO j=1,my
            DO i=1,mx
              WKxy3(i,j)=exp(cap*log(pstDYn(i,j)*sigmid(mzz-k)+ptopDY))
            END DO
            END DO
          ELSE
            DO j=1,my
            DO i=1,mx
              WKxy3(i,j)=exp(cap*log(pstDY (i,j)*sigmid(mzz-k)+ptopDY))
            END DO
            END DO
          END IF
        END IF

            DO j=1,my
            DO i=1,mx
              WKxy2(i,j)       = cp*WKxy3(i,j)
              WKxyz4(i,j,mzz-k)=    WKxy3(i,j)
C +...        WKxyz4           :    p ** (R/Cp)

            END DO
            END DO


C +--GEO---Potential (Mid Layer k-1/2)
C +  ---------------

C +--Of    the Surface Layer
C +  ~~~~~~~~~~~~~~~~~~~~~~~
        IF (k.eq.1)                                                 THEN

          DO j=1,my
          DO i=1,mx
            gpmiDY(i,j,mz)=gplvDY(i,j,mzz) 
     .                 +((WKxy5(i,j)-WKxy2(i,j))*pktaDY(i,j,mz)
     .                  +(WKxy1(i,j)-WKxy5(i,j))*pktaDY(i,j,mzz))
     .                                      *(1.0+virDY(i,j,mz))
C +...      REMARK : It is assumed that the Geopotential Difference 
C +                  in Lower Layer depends only on pktaDY at 1st Sigma Lev. 

          END DO
          END DO

        ELSE

C +--Above the Surface Layer
C +  ~~~~~~~~~~~~~~~~~~~~~~~
          DO j=1,my
          DO i=1,mx
            gpmiDY(i,j,mzz-k)=gpmiDY(i,j,mzz+1-k)
     .                     +(WKxy1(i,j)-WKxy2(i,j))*pktaDY(i,j,mzz-k)
     .                                         *(1.0+virDY(i,j,mzz-k))
          END DO
          END DO

        END IF

          DO j=1,my
          DO i=1,mx
            WKxy1(i,j)=WKxy2(i,j)
          END DO
          END DO

      END DO


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

C +--Update of u and v at the Lateral Boundaries
C +  ===========================================

        DO   k=1,mz
          DO j=1,my
            ubefDY( 1,j,k) = uairDY( 1,j,k)
            ubefDY(mx,j,k) = uairDY(mx,j,k)
            vbefDY( 1,j,k) = vairDY( 1,j,k)
            vbefDY(mx,j,k) = vairDY(mx,j,k)
          END DO
        END DO
      IF (mmy.gt.1)                                                 THEN
        DO   k=1,mz
          DO i=1,mx
            ubefDY(i, 1,k) = uairDY(i, 1,k)
            ubefDY(i,my,k) = uairDY(i,my,k)
            vbefDY(i, 1,k) = vairDY(i, 1,k)
            vbefDY(i,my,k) = vairDY(i,my,k)
          END DO
        END DO
      END IF

C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

C +--Mesoscale Geopotential Gradient
C +  ===============================

      DO k=1,mz

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF (k.eq.mz)                                          GO TO 30
          DO j=1,my
          DO i=1,mx
            WKxy1( i,j)  = WKxyz4(i,j,k+1)
            WKxyz1(i,j,k)= gpmiDY(i,j,k+1)
          END DO
          END DO
                                                              GO TO 31
 30     CONTINUE
          DO j=1,my
          DO i=1,mx
            WKxy1( i,j)  = WKxy4(i,j)
            WKxyz1(i,j,k)= gplvDY(i,j,mzz)
          END DO
          END DO
 31     CONTINUE

        DO j=1,my
        DO i=1,mx
          WKxy3( i,j)  = WKxyz4(i,j,k)-WKxy1(i,j)
        END DO
        END DO


C +--Gradient following x
C +  --------------------

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO j=jp11,my1
        DO i=   1,mx
            WKxyz2(i,j,k)=(WKxyz4(i,j,k)*WKxyz1(i,j,k)
     .                     -WKxy1(i,j)  *gpmiDY(i,j,k))/WKxy3(i,j)
            WKxyz3(i,j,k)=(gpmiDY(i,j,k)-WKxyz1(i,j,k))/WKxy3(i,j)
        END DO
        END DO

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF (norder.EQ.2)                                            THEN
          DO i=   1,mx
          DO j=jp11,my1
              WKxyz5(i,j,k)=
     .                 (WKxyz2(ip1(i),j,k)-WKxyz2(im1(i),j,k)) *dxinv2
              WKxyz6(i,j,k)=
     .                 (WKxyz3(ip1(i),j,k)-WKxyz3(im1(i),j,k)) *dxinv2
          END DO
          END DO
        ELSE
          DO i=   1,mx
          DO j=jp11,my1
              WKxyz5(i,j,k)=
     .          fac43 *(WKxyz2(ip1(i),j,k)-WKxyz2(im1(i),j,k)
     .         -0.125 *(WKxyz2(ip2(i),j,k)-WKxyz2(im2(i),j,k)))*dxinv2
              WKxyz6(i,j,k)=
     .          fac43 *(WKxyz3(ip1(i),j,k)-WKxyz3(im1(i),j,k)
     .         -0.125 *(WKxyz3(ip2(i),j,k)-WKxyz3(im2(i),j,k)))*dxinv2
          END DO
          END DO
        ENDIF


C +--Contribution to u Wind Speed Component
C +  --------------------------------------

C +- First Step
C +  ~~~~~~~~~~
          IF (itFast.eq.1)                                          THEN
            DO j=jp11,my1
            DO i=ip11,mx1
              c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    + adv_uu(i,j,k)

              c1b           =  dtfast *             c1a
              ubefDY(i,j,k) =  uairDY(i,j,k) +      c1b
              uairDY(i,j,k) =  uairDY(i,j,k) + c1b +c1b

              dg1xDY(i,j,k) =  c1a 
              dgzxDY(i,j,k) =  c1a
            END DO
            END DO


C +- Next  Step
C +  ~~~~~~~~~~
          ELSE
            IF (itFast.le.ntFast)                                   THEN
              IF (brocam)                                           THEN
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                       +  adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   + 2.0*     dtfast
     .                                    *(bcb*     dgzxDY(i,j,k)
     .                                     +bca*(c1a+dg1xDY(i,j,k)))
C +...            U (n+1)       =  U(n-1) + 2     Dt  (Du/Dt)

C +- Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             ubefDY(i,j,k) =  ubefDY(i,j,k) 
c #rt.              + Robert*(0.5*(uairDY(i,j,k)+ddux) -  ubefDY(i,j,k))

                  dg1xDY(i,j,k) =  dgzxDY(i,j,k)
                  dgzxDY(i,j,k) =  c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                        + adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   + 2.0  *dtfast *c1a
C +...            U (n+1)       =  U(n-1) + 2     Dt     (Du/Dt)

                END DO
                END DO
              END IF

C +- Last  Step
C +  ~~~~~~~~~~
            ELSE
              IF (brocam) then
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                       +  adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   +    dtfast
     .                                      *(bcb*     dgzxDY(i,j,k)
     .                                       +bca*(c1a+dg1xDY(i,j,k)))
C +...            U (n+1)       =  U(n)   +    Dt     (Du/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                  dg1xDY(i,j,k) =  dgzxDY(i,j,k)
                  dgzxDY(i,j,k) =  c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                       +  adv_uu(i,j,k)

                  ddux          =  ubefDY(i,j,k)
                  ubefDY(i,j,k) =  uairDY(i,j,k)
                  uairDY(i,j,k) =  ddux   +    dtfast *c1a
C +...            U (n+1)       =  U(n)   +    Dt     (Du/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                END DO
                END DO
              END IF
            END IF
          END IF


C +- Gradient following y
C +  -------------------- 

        IF (mmy.gt.1)                                               THEN

          DO j=   1,my
            WKxyz2( 1,j,k) = 0.
            WKxyz2(mx,j,k) = 0.
            WKxyz3( 1,j,k) = 0.
            WKxyz3(mx,j,k) = 0.
          ENDDO

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          DO i=ip11,mx1
          DO j=   1,my
            WKxyz2(i,j,k)=(WKxyz4(i,j,k)*WKxyz1(i,j,k)
     .                     -WKxy1(i,j)  *gpmiDY(i,j,k))/WKxy3(i,j)
            WKxyz3(i,j,k)=(gpmiDY(i,j,k)-WKxyz1(i,j,k))/WKxy3(i,j)

          END DO
          END DO

C +--For Hydrostatic Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         IF (norder.EQ.2)                                           THEN
          DO j=   1,my
          DO i=ip11,mx1
            WKxyz5(i,j,k)=
     .                  (WKxyz2(i,jp1(j),k)-WKxyz2(i,jm1(j),k) )*dyinv2
            WKxyz6(i,j,k)=
     .                  (WKxyz3(i,jp1(j),k)-WKxyz3(i,jm1(j),k) )*dyinv2
          END DO
          END DO
         ELSE
          DO j=   1,my
          DO i=ip11,mx1
            WKxyz5(i,j,k)=
     .           fac43 *(WKxyz2(i,jp1(j),k)-WKxyz2(i,jm1(j),k)
     .          -0.125 *(WKxyz2(i,jp2(j),k)-WKxyz2(i,jm2(j),k)))*dyinv2
            WKxyz6(i,j,k)=
     .           fac43 *(WKxyz3(i,jp1(j),k)-WKxyz3(i,jm1(j),k)
     .          -0.125 *(WKxyz3(i,jp2(j),k)-WKxyz3(i,jm2(j),k)))*dyinv2
          END DO
          END DO
         ENDIF


C +--Contribution to v Wind Speed Component
C +  --------------------------------------

C +- First Step
C +  ~~~~~~~~~~
          IF (itFast.eq.1)                                          THEN
            DO j=jp11,my1
            DO i=ip11,mx1
              c1a        =-(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                   +  adv_vv(i,j,k)

              c1b        = dtfast *                 c1a
              vbefDY(i,j,k) =  vairDY(i,j,k) +      c1b
              vairDY(i,j,k) =  vairDY(i,j,k) + c1b +c1b

              dg1yDY(i,j,k) = c1a
              dgzyDY(i,j,k) = c1a
            END DO
            END DO

C +- Next  Step
C +  ~~~~~~~~~~
          ELSE
            IF   (itFast.le.ntFast)                                 THEN
              IF (brocam)                                           THEN
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    +   2.0*     dtfast
     .                                      *(bcb*     dgzyDY(i,j,k)
     .                                       +bca*(c1a+dg1yDY(i,j,k)))
C +               V (n+1)       = V(n-1)  +   2    Dt  (Dv/Dt)

C +- Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt             vbefDY(i,j,k) =  vbefDY(i,j,k) 
c #rt.              + Robert*(0.5*(vairDY(i,j,k)+ddvx) -vbefDY(i,j,k))

                  dg1yDY(i,j,k) =  dgzyDY(i,j,k)
                  dgzyDY(i,j,k) =  c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    + 2.0*dtfast *c1a
C +               V (n+1)       = V(n-1)  + 2   Dt   (Dv/Dt)

                END DO
                END DO
              END IF

C +- Last  Step
C +  ~~~~~~~~~~
            ELSE
              IF (brocam)                                           THEN
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    +   dtfast
     .                                      *(bcb*     dgzyDY(i,j,k)
     .                                       +bca*(c1a+dg1yDY(i,j,k)))
C +...            V (n+1)       =  V(n)   +   Dt (Dv/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                  dg1yDY(i,j,k) = dgzyDY(i,j,k)
                  dgzyDY(i,j,k) = c1a
                END DO
                END DO
              ELSE
                DO j=jp11,my1
                DO i=ip11,mx1
                  c1a     = -(WKxyz5(i,j,k)+pkDY(i,j,k)*WKxyz6(i,j,k))
     .                    +   adv_vv(i,j,k)

                  ddvx          = vbefDY(i,j,k)
                  vbefDY(i,j,k) = vairDY(i,j,k)
                  vairDY(i,j,k) = ddvx    +    dtfast *c1a
C +...            V (n+1)       =  V(n)   +    Dt (Dv/Dt)'
C +               Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

                END DO
                END DO
              END IF
            END IF
          END IF
        END IF
      END DO

C +--Rayleigh Friction (Ref. ARPS 4.0 User's Guide, para 6.4.3 p.152)
C +  =================

c #RF DO k=1,mzabso
c #RF   DO j=1,my
c #RF   DO i=1,mx
c #RF     uairDY(i,j,k)=(uairDY(i,j,k) + Ray_UB(k)*dtFast*uairUB(i,j,k))
c #RF.                 /(1.0           + Ray_UB(k)*dtFast              )
c #RF     vairDY(i,j,k)=(vairDY(i,j,k) + Ray_UB(k)*dtFast*vairUB(i,j,k))
c #RF.                 /(1.0           + Ray_UB(k)*dtFast              )
c #RF   END DO
c #RF   END DO
c #RF END DO


C +--Work Arrays Reset
C +  =================

      DO j=1,my
      DO i=1,mx
         WKxy1(i,j)   = 0.0
         WKxy2(i,j)   = 0.0
         WKxy3(i,j)   = 0.0
         WKxy4(i,j)   = 0.0
         WKxy5(i,j)   = 0.0
      END DO
      END DO

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
        WKxyz5(i,j,k) = 0.0
        WKxyz6(i,j,k) = 0.0
      END DO
      END DO
      END DO

      return
      end


      subroutine DYNadv_dLF(nordAV,ffx,advffx)


C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                     4-11-2004  MAR |
C |   SubRoutine DYNadv_dLF generates Advection Contribution               |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/           ffx(mx,my,mz): Advected  Variable                   |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   ^^^^^^        uairDY(mx,my,mz): Advection Vector: x-----Direction    |
C |                 vairDY(mx,my,mz): Advection Vector: y-----Direction    |
C |                 wsigDY(mx,my,mz): Advection Vector: sigma-Direction    |
C |                                                                        |
C |   OUTPUT        advffx(mx,my,mz): Advection Contribution               |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   METHOD:  2th order accurate Time       Scheme (leapfrog backw.) .AND.|
C |   ^^^^^^  (2th order accurate Horizontal Scheme on Arakawa A grid .OR. |
C |            4th order accurate Horizontal Scheme on Arakawa A grid     )|
C |            2th order          Vertical   Scheme                        |
C |                                                                        |
C |   REFER.:  Use of  A grid: Purser   & Leslie,   1988, MWR 116, p.2069  |
C |   ^^^^^^   Time    Scheme: Haltiner & Williams, 1980, 5-2,     p.152   |
C |            Spatial Scheme: Haltiner & Williams, 1980, 5-6-5,   p.135   |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_WK.inc'

      integer  nordAV

      real        ffx(mx,my,mz)
      real     advffx(mx,my,mz)


C +--Contribution to Advection
C +  =========================

        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
            WTxyz8(i,j,k)=     ffx(i,j,k)
          END DO
          END DO
        END DO


C +--2th centered Differences / x-----Direction
C +  ------------------------------------------

      IF (nordAV.EQ.2)                                              THEN

       DO    k=1,mz
          DO  i=1,mx
          DO  j=1,my
            WTxyz1(i,j,k)=  uairDY(i,j,k)*dxinv2          *  (
     .                 WTxyz8(im1(i),j,k)-WTxyz8(ip1(i),j,k) )

c #vL     END DO
c #vL     END DO
c #vL   END DO

C +--2th centered Differences / y-----Direction
C +  ------------------------------------------

c #vL   DO k=1,mz
c #vL     DO j=1,my
c #vL     DO i=1,mx
            WTxyz2(i,j,k)=  vairDY(i,j,k)*dyinv2          *  (
     .                 WTxyz8(i,jm1(j),k)-WTxyz8(i,jp1(j),k) )
          END DO
          END DO
        END DO

      ELSE


C +--4th centered Differences / x-----Direction
C +  ------------------------------------------

        DO    k=1,mz
          DO  i=1,mx
          DO  j=1,my
            WTxyz1(i,j,k)=  uairDY(i,j,k)*dxinv2 * fac43  *  (
     .         0.125 *(WTxyz8(ip2(i),j,k)-WTxyz8(im2(i),j,k))
     .                -WTxyz8(ip1(i),j,k)+WTxyz8(im1(i),j,k) )
c #vL     END DO
c #vL     END DO
c #vL   END DO


C +--4th centered Differences / y-----Direction
C +  ------------------------------------------

c #vL   DO k=1,mz
c #vL     DO j=1,my
c #vL     DO i=1,mx
            WTxyz2(i,j,k)=  vairDY(i,j,k)*dyinv2 * fac43  *  (
     .         0.125 *(WTxyz8(i,jp2(j),k)-WTxyz8(i,jm2(j),k))
     .                -WTxyz8(i,jp1(j),k)+WTxyz8(i,jm1(j),k) )
          END DO
          END DO
        END DO

      ENDIF

C +--2th centered Differences  / sigma-Direction  / Energy conserving
C +  --- (Haltiner and Williams, 1980, 7.2.2, Eqn. (7-47b) p.220) ---
C +      --------------------------------------------------------

          DO       k=   1,mz
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz6(i,j,k)=      ffx(i,j,k)-        ffx(i,j,kp1(k))
            END DO
            END DO
         END DO

                   k=   1
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz3(i,j,k)=   WTxyz6(i,j,k)     *wsigDY(i,j,k)  
     .                        *0.5               /dsigm1(1)
            END DO
           END DO
          DO       k=   2,mz
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz3(i,j,k)=  (WTxyz6(i,j,k)     *wsigDY(i,j,k)
     .                        +WTxyz6(i,j,km1(k))*wsigDY(i,j,km1(k)))
     .                        *0.5               /dsigm1(k)
            END DO
            END DO
          END DO


C +--Sum of the Contributions
C +  ========================

          DO     i=ip11,mx1
          DO     j=jp11,my1
          DO     k=   1,mz
              advffx(i,j,k) = WTxyz1(i,j,k)+WTxyz2(i,j,k)+WTxyz3(i,j,k)
          END DO
          END DO
          END DO

      return
      end

      subroutine DYNadv_dLF_mp(nordAV,ffx,advffx)


C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                     4-11-2004  MAR |
C |   SubRoutine DYNadv_dLF generates Advection Contribution               |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/           ffx(mx,my,mz): Advected  Variable                   |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   ^^^^^^        uairDY(mx,my,mz): Advection Vector: x-----Direction    |
C |                 vairDY(mx,my,mz): Advection Vector: y-----Direction    |
C |                 wsigDY(mx,my,mz): Advection Vector: sigma-Direction    |
C |                                                                        |
C |   OUTPUT        advffx(mx,my,mz): Advection Contribution               |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   METHOD:  2th order accurate Time       Scheme (leapfrog backw.) .AND.|
C |   ^^^^^^  (2th order accurate Horizontal Scheme on Arakawa A grid .OR. |
C |            4th order accurate Horizontal Scheme on Arakawa A grid     )|
C |            2th order          Vertical   Scheme                        |
C |                                                                        |
C |   REFER.:  Use of  A grid: Purser   & Leslie,   1988, MWR 116, p.2069  |
C |   ^^^^^^   Time    Scheme: Haltiner & Williams, 1980, 5-2,     p.152   |
C |            Spatial Scheme: Haltiner & Williams, 1980, 5-6-5,   p.135   |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_WK.inc'

      integer  nordAV

      real        ffx(mx,my,mz)
      real     advffx(mx,my,mz)


C +--Contribution to Advection
C +  =========================
!$OMP PARALLEL DO private (i,j,k)
        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
            WTxyz8(i,j,k)=     ffx(i,j,k)
          END DO
          END DO
c        END DO


C +--2th centered Differences / x-----Direction
C +  ------------------------------------------

      IF (nordAV.EQ.2)                                              THEN

c       DO    k=1,mz
          DO  i=1,mx
          DO  j=1,my
            WTxyz1(i,j,k)=  uairDY(i,j,k)*dxinv2          *  (
     .                 WTxyz8(im1(i),j,k)-WTxyz8(ip1(i),j,k) )

c #vL     END DO
c #vL     END DO
cc #vL   END DO

C +--2th centered Differences / y-----Direction
C +  ------------------------------------------

cc #vL   DO k=1,mz
c #vL     DO j=1,my
c #vL     DO i=1,mx
            WTxyz2(i,j,k)=  vairDY(i,j,k)*dyinv2          *  (
     .                 WTxyz8(i,jm1(j),k)-WTxyz8(i,jp1(j),k) )
          END DO
          END DO
c        END DO

      ELSE


C +--4th centered Differences / x-----Direction
C +  ------------------------------------------

c        DO    k=1,mz
          DO  i=1,mx
          DO  j=1,my
            WTxyz1(i,j,k)=  uairDY(i,j,k)*dxinv2 * fac43  *  (
     .         0.125 *(WTxyz8(ip2(i),j,k)-WTxyz8(im2(i),j,k))
     .                -WTxyz8(ip1(i),j,k)+WTxyz8(im1(i),j,k) )
c #vL     END DO
c #vL     END DO
cc #vL   END DO


C +--4th centered Differences / y-----Direction
C +  ------------------------------------------

cc #vL   DO k=1,mz
c #vL     DO j=1,my
c #vL     DO i=1,mx
            WTxyz2(i,j,k)=  vairDY(i,j,k)*dyinv2 * fac43  *  (
     .         0.125 *(WTxyz8(i,jp2(j),k)-WTxyz8(i,jm2(j),k))
     .                -WTxyz8(i,jp1(j),k)+WTxyz8(i,jm1(j),k) )
          END DO
          END DO
c        END DO

      ENDIF
      ENDDO
!$OMP END PARALLEL DO

C +--2th centered Differences  / sigma-Direction  / Energy conserving
C +  --- (Haltiner and Williams, 1980, 7.2.2, Eqn. (7-47b) p.220) ---
C +      --------------------------------------------------------

!$OMP PARALLEL DO 
          DO     j=jp11,my1

          DO       k=   1,mz
c            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz6(i,j,k)=      ffx(i,j,k)-        ffx(i,j,kp1(k))
            END DO
c            END DO
         END DO

                   k=   1
c            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz3(i,j,k)=   WTxyz6(i,j,k)     *wsigDY(i,j,k)  
     .                        *0.5               /dsigm1(1)
            END DO
c           END DO
          DO       k=   2,mz
c            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz3(i,j,k)=  (WTxyz6(i,j,k)     *wsigDY(i,j,k)
     .                        +WTxyz6(i,j,km1(k))*wsigDY(i,j,km1(k)))
     .                        *0.5               /dsigm1(k)
            END DO
c            END DO
          END DO


C +--Sum of the Contributions
C +  ========================

          DO     i=ip11,mx1
c          DO     j=jp11,my1
          DO     k=   1,mz
              advffx(i,j,k) = WTxyz1(i,j,k)+WTxyz2(i,j,k)+WTxyz3(i,j,k)
          END DO
          END DO
          END DO
!$OMP END PARALLEL DO

      return
      end


      subroutine DYNdmp

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   FAST                                    17-12-2000  MAR |
C |   SubRoutine DYNdmp provides a Divergence Damper                       |
C |                            for Weakening the Horizontal Acoustic Waves |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^         pstDYn(mx,my)   : Pressure Depth p*(t)           (kPa) |
C |                  pstDY(mx,my)   : Pressure Depth p*(t-dt)              |
C |                                                                        |
C |   INPUT/OUTPUT: uairDY(mx,my,mz): x-Wind Speed                   (m/s) |
C |   ^^^^^^^^^^^^^ vairDY(mx,my,mz): y-Wind Speed                   (m/s) |
C |                                                                        |
C |   REFER. : Damper       : Skamarock & Klemp, MWR 120, 2109--2127, 1992 |
C |   ^^^^^^^^ Use of A grid: Purser and Leslie, MWR 116, 2069--2080, 1988 |
C |            Time Scheme  : Lin    and Rood,   MWR 124, 2046--2070, 1996 |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

      real     damper,damp_x,damp_y

      damper = 0.05d+0 * dtfast
      damp_x = damper           * dxinv2 * fac43
      damp_y = damper           * dyinv2 * fac43


C +--Mass Divergence / x--Direction
C +  ==============================

      do     k=1,mz

          do j=1,my
          do i=1,mx
          WKxyz4(i,j,k)= uairDY(i,j,k)     *pstDYn(i,j)
          end do
          end do

          do j=1,my
          do i=1,mx
          WKxyz1(i,j,k)= damp_x                             *  (
     .                   WKxyz4(ip1(i),j,k)-WKxyz4(im1(i),j,k) 
     .           -0.125*(WKxyz4(ip2(i),j,k)-WKxyz4(im2(i),j,k)))
          end do
          end do


C +--Mass Divergence / y--Direction
C +  ==============================

          do j=1,my
          do i=1,mx
          WKxyz5(i,j,k)= vairDY(i,j,k)     *pstDYn(i,j)
          end do
          end do

          do j=1,my
          do i=1,mx
          WKxyz2(i,j,k)= damp_y                             *  (
     .                   WKxyz5(i,jp1(j),k)-WKxyz5(i,jm1(j),k) 
     .           -0.125*(WKxyz5(i,jp2(j),k)-WKxyz5(i,jm2(j),k)))
          end do
          end do

      end do


C +--Mass Divergence / z--Direction
C +  ==============================

C +--IS   staggered
C +  --------------

      if (.not.staggr)                                        then

C +--Upper Level
C +  ~~~~~~~~~~~
            k = 1
       do   j = 1,my
       do   i = 1,mx
       WKxyz3(i,j,k) =  psigDY(i,j,kp1(k))                    /dsig_2(k)
       end do
       end do

C +--Mid   Levels
C +  ~~~~~~~~~~~~
       do   k = kp1(1),mz1
       do   j = 1,my
       do   i = 1,mx
       WKxyz3(i,j,k) = (psigDY(i,j,kp1(k))-psigDY(i,j,km1(k)))/dsig_2(k)
       end do
       end do
       end do

C +--Lower Level
C +  ~~~~~~~~~~~
            k =   mz
       do   j = 1,my
       do   i = 1,mx
       WKxyz3(i,j,k) =                    -psigDY(i,j,km1(k)) /dsig_2(k)
       end do
       end do


C +--NOT  staggered
C +  --------------

      else

C +--Upper Level
C +  ~~~~~~~~~~~
            k = 1
       do   j = 1,my
       do   i = 1,mx
       WKxyz3(i,j,k) =  psigDY(i,j,k     )                    *qsigm1(k)
       end do
       end do

C +--Lower Levels
C +  ~~~~~~~~~~~~
       do   k = kp1(1),mz
       do   j = 1,my
       do   i = 1,mx
       WKxyz3(i,j,k) = (psigDY(i,j,k     )-psigDY(i,j,km1(k)))*qsigm1(k)
       end do
       end do
       end do

      end if


C +--Mass Divergence / Total
C +  =======================

      do     k=1,mz
          do j=1,my
          do i=1,mx
          WKxyz6(i,j,k)= WKxyz1(i,j,k) + WKxyz2(i,j,k) + WKxyz3(i,j,k)
          end do
          end do


C +--Mass Divergence Damping / x--Direction
C +  ======================================

          do i=1,mx
          do j=1,my
          WKxyz7(i,j,k)=(WKxyz6(ip1(i),j,k)-WKxyz6(im1(i),j,k)) *dxinv2
          end do
          end do

          do j=1,my
          do i=1,mx
          uairDY(i,j,k)=(uairDY(i,j,k)*pstDY(i,j) 
     .                 + WKxyz7(i,j,k)           ) / pstDYn(i,j)
          end do
          end do


C +--Mass Divergence Damping / y--Direction
C +  ======================================

          do j=1,my
          do i=1,mx
          WKxyz7(i,j,k)=(WKxyz6(i,jp1(j),k)-WKxyz6(i,jm1(j),k)) *dyinv2
          end do
          end do

          do j=1,my
          do i=1,mx
          vairDY(i,j,k)=(vairDY(i,j,k)*pstDY(i,j) 
     .                 + WKxyz7(i,j,k)           ) / pstDYn(i,j)
          end do
          end do

      end do


C +--Work Arrays Reset
C +  =================

      do k=1,mz
      do j=1,my
      do i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
        WKxyz3(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
        WKxyz5(i,j,k) = 0.0
        WKxyz7(i,j,k) = 0.0
      end do
      end do
      end do

      return
      end


      subroutine DYN_NH

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   NonHydroStatic / Implicit Part          04-06-2004  MAR |
C |   SubRoutine DYN_NH computes Advection of Non-Hydrostatic Variables    |
C |                         adds Slope    Correction                       |
C |                          and Diabatic Heating    Contributions         |
C |                           to the Non-Hydrostatic Pressure              |
C |                       solves the Divergence/PGF  Interactions          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:        iterun          : Long  Time Step Counter              |
C |   ^^^^^                                                                |
C |                                                                        |
C |   INPUT/OUTPUT: wairNH(mx,my,mz): Vertical Non-Hydrostatic Wind Speed  |
C |   ^^^^^^^^^^^^^ pairNH(mx,my,mz): Normaliz.Non-Hydrostatic Pressure    |
C |                                                                        |
C |   METHODS: Linearization       % Non-Hydrostatic Pressure              |
C |   ^^^^^^^^                                                             |
C |            Advection:        1st Order Upstream                        |
C |                                                                        |
C |            Time      Scheme: Lin    and Rood MWR 124, 2046--2070, 1996 |
C |            Implicit  Scheme: Durran and Klemp                     1983 |
C |                              ADI (Alternate Direction Implicit)        |
C |                                  (e.g., ARPS User Guide, 9.3 p.246)    |
C |                              SOR (Successive OverRelaxation)           |
C |                                  (e.g., Haltiner & Williams 1980,      |
C |                                         5-10-1 p.159            )      |
C |                                                                        |
C |   CAUTION:                                                             |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C | # OPTIONS: #DH  Diabatic    Heating                is included         |
C | # ^^^^^^^^ #WR  Outputs for Verification          are included         |
C | #          #nh  Divergence: Topography Correction  is included         |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_NH.inc'

c #DH include 'MAR_HY.inc'
c #DH include 'MAR_RA.inc'

      include 'MARpen.inc'

      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

      integer              logiIt
      common  /DYNiNH_int/ logiIt
      real                 bet2nh,alphnh,abetnh    ,gam1NH    ,gg1cNH
     .                    ,dtx_bb,gamdtx    ,dtscNH(mz)       ,cgamNH
     .                    ,       ggswNH(mz),dt__NH(mz)
     .                    ,dtb2NH,bgcdNH,bg1dNH,ggsdNH(mz),gs__NH(mz)
     .                    ,AAs_NH(mz),   BBs_NH(mz),CCs_NH(mz)
      common  /DYNiNH_Loc/ bet2nh,alphnh,abetnh    ,gam1NH    ,gg1cNH
     .                    ,dtx_bb,gamdtx    ,dtscNH           ,cgamNH
     .                    ,       ggswNH    ,dt__NH
     .                    ,dtb2NH,bgcdNH,bg1dNH,ggsdNH    ,gs__NH
     .                    ,AAs_NH    ,   BBs_NH    ,CCs_NH
      real                 WK_AAx(mx,my,mz),        WK_CCx(mx,my,mz)
     .                    ,WK_AAy(mx,my,mz),        WK_CCy(mx,my,mz)
      common  /DYNiNH_Wrk/ WK_AAx          ,        WK_CCx
     .                    ,WK_AAy          ,        WK_CCy

      real    GaTerm,GcTerm,G1Term,G3Term,SGTerm,SRes_0,SRes10,SRes_1


C +--Specific SWITCHES
C +  =================

      logical SoundW
      integer nt_Ovr,it_Ovr,i1_dnh,i2_dnh,j1_dnh,j2_dnh,k1_dnh,k2_dnh,kk
      real    betanh,TolOvr,FacOvr,csnd  ,bealnh,ua_Lay,va_Lay

      data    SoundW/.true./
C +...        SoundW=.true. => Vertical Mass Convergence  contributes

      data    betanh/ 0.55/
C +...        betanh: Implicitness: 0.6  (ARPS)
C +                                 0.55 (Juang, 1992, Meteor.and Atmos.Phys.)
      data    nt_Ovr/10     /
C +...        nt_Ovr: Maximum Number of Overrelaxation Iterations

      data    TolOvr/1.00e-3/
C +...        TolOvr:                   Overrelaxation Precision

      data    FacOvr/1.50e+0/
C +...        FacOvr:                   Overrelaxation Factor


C +--Initialization
C +  ==============

      IF   (itexpe.eq.0)                                          THEN
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
            ua0_NH(i,j,k) = uairDY(i,j,k)
            va0_NH(i,j,k) = vairDY(i,j,k)
            wa0_NH(i,j,k) = wairNH(i,j,k)
        END DO
        END DO
        END DO

      END IF
      IF   (logiIt.eq.0)                                          THEN
            logiIt =  1


C +--Thermodynamical Parameters
C +  --------------------------

            gamaNH    = cp    / (cp-RDryAi)

            csnd      = 2.0d+2
C +...      csnd      : Prescribed Sound Speed (m/s)

            c2NH      = csnd * csnd


C +--Slopes of the sigma surfaces
C +  ----------------------------

C +     ***********
        call INIpen
C +     ***********


C +--Time Discretization
C +  -------------------

            dt_ONH    = dt                                       !
            dtxONH    = dt_ONH /dx                               !
            dtyONH    = dt_ONH /dy                               !
                                                                 !
            bet2nh    =         betanh *betanh                   !
            alphnh    = 1.d+0  -betanh                           !
            bealnh    =         alphnh *betanh                   !
            abetnh    =         alphnh /betanh                   !
                                                                 !
                                                                 !
C +--Spatial Discretisation                                      !
C +  ----------------------                                      !
                                                                 !
            gam1NH    =              gamaNH-1.                   !
            cgamNH    =   c2NH                  / gamaNH         !
            gg1cNH    = gamaNH     * gam1NH     /   c2NH         ! G  Factor
            dtb2NH    = bet2nh     * dt_ONH     * dt_ONH         !
            bgcdNH    = gam1NH     * dtb2NH     *   c2NH         !
     .                /(gamaNH     * dx         * dx    )        !
            bg1dNH    = gam1NH     * betanh     /(dx +dx)        !
                                                                 !
C +--Implicit Horizontal Scheme                                  !
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~                                  !
            gamdtx    = 0.5        *(gamaNH-1.) * dtxONH         !
                                                                 !
        DO k=1,mz                                                !
            gs__NH(k) = gg1cNH     * gravi2                      ! Gk Factor
     .                *  sigma(k)  * qsigm1(k)  * dtb2NH         !
            ggswNH(k) = gg1cNH     * gravit                      !
     .                *  sigma(k)  * qsigm1(k)  * dt_ONH         !
                                                                 !
C +--Explicit Horizontal Scheme                                  !
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~                                  !
            ggsdNH(k) = gg1cNH     * gravit                      !
     .                *  sigma(k)  * qsig_1(k)  * dt_ONH         !
                                                                 !
C +--Implicit Vertical   Scheme                                  !
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~                                  !
            dt__NH(k) = qsig_1(k)  * gravit     * dt_ONH         !
                                                                 !
            AAs_NH(k) =-qsig_1(k)     *sigma(kp1(k)) * gs__NH(k) !
            CCs_NH(k) =-qsig_1(km1(k))*sigma(km1(k)) * gs__NH(k) !
        END DO                                                   !
            AAs_NH(mz)= 0.0                                      !
            CCs_NH(1) = 0.0                                      !
        DO k=1,mz                                                !
            BBs_NH(k) =-AAs_NH(k)     *sigma(k) / sigma(kp1(k))  !
     .                 -CCs_NH(k)     *sigma(k) / sigma(km1(k))  !
        END DO                                                   !
                                                                 !
C +--Work Area                                                   !
C +  ~~~~~~~~~                                                   !
        DO k=1,mz                                                !
        DO j=1,my                                                !
        DO i=1,mx                                                !
            WK_AAx(i,j,k) = 0.0                                  !
            WK_CCx(i,j,k) = 0.0                                  !
            WK_AAy(i,j,k) = 0.0                                  !
            WK_CCy(i,j,k) = 0.0                                  !
        END DO                                                   !
        END DO                                                   !
        END DO                                                   !

      END IF


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  HORIZONTAL/VERTICAL ADVECTION / FIRST ORDER UPSTREAM   (BEGIN)  +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Horizontal Advection
C +  ====================


C +--Advection / x-Direction
C +  -----------------------

C +--Courant Number / Non-Hydrostatic Vertical Wind Component (Layer k)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO  k=1,mz
        DO  i=1,mx
        DO  j=1,my
          ua_Lay        = 0.5d+0*(uairDY(i,j,k)+uairDY(i,j,kp1(k)))
          WKxyz1(i,j,k) = dtxONH*      max(zero,ua_Lay)
          WKxyz2(i,j,k) = dtxONH*      min(zero,ua_Lay)

C +--Courant Number / Non-Hydrostatic Pressure Perturbation   (Level k)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          WKxyz4(i,j,k) = dtxONH*      max(zero,uairDY(i,j,k))
          WKxyz5(i,j,k) = dtxONH*      min(zero,uairDY(i,j,k))

C +--Horizontal Differences
C +  ~~~~~~~~~~~~~~~~~~~~~~
          WKxyz3(i,j,k) = wairNH(i,j,k) - wairNH(im1(i),j,k)
          WKxyz6(i,j,k) = pairNH(i,j,k) - pairNH(im1(i),j,k)
        END DO
        END DO
        END DO

C +--Advection
C +  ~~~~~~~~~
        DO  k=1,mz
        DO  i=1,mx
        DO  j=1,my
          wairNH(i,j,k) = wairNH(i,j,k)
     .                  - WKxyz1(i,j,k)*WKxyz3(i     ,j,k)
     .                  - WKxyz2(i,j,k)*WKxyz3(ip1(i),j,k)
          pairNH(i,j,k) = pairNH(i,j,k)
     .                  - WKxyz4(i,j,k)*WKxyz6(i     ,j,k)
     .                  - WKxyz5(i,j,k)*WKxyz6(ip1(i),j,k)
        END DO
        END DO
        END DO


C +--Advection / y-Direction
C +  -----------------------

      IF (mmy.gt.1)                                               THEN

C +--Courant Number / Non-Hydrostatic Vertical Wind Component (Layer k)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO  k=1,mz
        DO  j=1,my
        DO  i=1,mx
          va_Lay        = 0.5d+0*(vairDY(i,j,k)+vairDY(i,j,kp1(k)))
          WKxyz1(i,j,k) = dtxONH*      max(zero,va_Lay)
          WKxyz2(i,j,k) = dtxONH*      min(zero,va_Lay)

C +--Courant Number / Non-Hydrostatic Pressure Perturbation   (Level k)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          WKxyz4(i,j,k) = dtxONH*      max(zero,vairDY(i,j,k))
          WKxyz5(i,j,k) = dtxONH*      min(zero,vairDY(i,j,k))

C +--Horizontal Differences
C +  ~~~~~~~~~~~~~~~~~~~~~~
          WKxyz3(i,j,k) = wairNH(i,j,k) - wairNH(i,jm1(j),k)
          WKxyz6(i,j,k) = pairNH(i,j,k) - pairNH(i,jm1(j),k)
        END DO
        END DO
        END DO

C +--Advection
C +  ~~~~~~~~~
        DO  k=1,mz
        DO  j=1,my
        DO  i=1,mx
          wairNH(i,j,k) = wairNH(i,j,k)
     .                  - WKxyz1(i,j,k)*WKxyz3(i,j     ,k)
     .                  - WKxyz2(i,j,k)*WKxyz3(i,jp1(j),k)
          pairNH(i,j,k) = pairNH(i,j,k)
     .                  - WKxyz4(i,j,k)*WKxyz6(i,j     ,k)
     .                  - WKxyz5(i,j,k)*WKxyz6(i,jp1(j),k)
        END DO
        END DO
        END DO


C +--Work Arrays Reset
C +  -----------------

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz1(i,j,k) = 0.0
          WKxyz2(i,j,k) = 0.0
          WKxyz3(i,j,k) = 0.0
          WKxyz4(i,j,k) = 0.0
          WKxyz5(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
        END DO
        END DO
        END DO

      END IF


C +--Vertical   Advection
C +  ====================

C +--Advection   Velocity / Non-staggered Grid
C +  -----------------------------------------

        IF (.not.staggr)                                          THEN

C +--Velocity in Layers
C +  ~~~~~~~~~~~~~~~~~~
             k= mz
          DO j=jp11,my1
          DO i=ip11,mx1
            WKxyz1(i,j,k)= psigDY(i,j,k)      *0.5
          END DO
          END DO

          DO k=1,mz1
          DO j=jp11,my1
          DO i=ip11,mx1
            WKxyz1(i,j,k)=(psigDY(i,j,kp1(k)) *dsigm1(kp1(k))
     .                    +psigDY(i,j,k)      *dsigm1(k)     )
     .                   /(dsigm1(    kp1(k)) +dsigm1(k)     )

C +--Velocity on Levels
C +  ~~~~~~~~~~~~~~~~~~
            WKxyz2(i,j,k)= psigDY(i,j,k)
          END DO
          END DO
          END DO


C +--Advection   Velocity /     staggered Grid
C +  -----------------------------------------

        ELSE

C +--Velocity in Layers
C +  ~~~~~~~~~~~~~~~~~~
          DO k=2,mz
          DO j=jp11,my1
          DO i=ip11,mx1
            WKxyz1(i,j,k)= psigDY(i,j,k)

C +--Velocity on Levels
C +  ~~~~~~~~~~~~~~~~~~
            WKxyz2(i,j,k)=(psigDY(i,j,km1(k)) *dsig_1(km1(k))
     .                    +psigDY(i,j,k)      *dsig_1(k)     )
     .                   /(dsig_1(    km1(k)) +dsig_1(k)     )
          END DO
          END DO
          END DO

             k=1
          DO j=jp11,my1
          DO i=ip11,mx1
            WKxyz1(i,j,k)= psigDY(i,j,k)
            WKxyz2(i,j,k)= psigDY(i,j,k)      *0.50
          END DO
          END DO

        END IF


C +--Vertical Advection of wairNH in Layers (1st order upstream)
C +  -----------------------------------------------------------

C +--Courant Number
C +  ~~~~~~~~~~~~~~
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz3(i,j,k) = dt_ONH*max(zero,WKxyz1(i,j,k))/pstDYn(i,j)
          WKxyz4(i,j,k) = dt_ONH*min(zero,WKxyz1(i,j,k))/pstDYn(i,j)

C +--Vertical Difference
C +  ~~~~~~~~~~~~~~~~~~~
          WKxyz5(i,j,k) = wairNH(i,j,k) - wairNH(i,j,km1(k))
        END DO
        END DO
        END DO

C +--Advection
C +  ~~~~~~~~~
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          wairNH(i,j,k)= wairNH(i,j,k)
     .                 - WKxyz3(i,j,k)*WKxyz5(i,j,    k )/dsigm1(    k )
     .                 - WKxyz4(i,j,k)*WKxyz5(i,j,kp1(k))/dsigm1(kp1(k))
        END DO
        END DO

C +--LBC
C +  ~~~
        DO j=1,my
          wairNH( 1,j,k)= wairNH(ip11,j,k)
          wairNH(mx,j,k)= wairNH( mx1,j,k)
        END DO
        DO i=1,mx
          wairNH(i, 1,k)= wairNH(i,jp11,k)
          wairNH(i,my,k)= wairNH(i, my1,k)
        END DO
        END DO


C +--Vertical Advection of pairNH on Levels (1st order upstream)
C +  -----------------------------------------------------------

C +--Courant Number
C +  ~~~~~~~~~~~~~~
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz3(i,j,k) = dt_ONH*max(zero,WKxyz2(i,j,k))/pstDYn(i,j)
          WKxyz4(i,j,k) = dt_ONH*min(zero,WKxyz2(i,j,k))/pstDYn(i,j)

C +--Vertical Difference
C +  ~~~~~~~~~~~~~~~~~~~
          WKxyz5(i,j,k) = pairNH(i,j,k) - pairNH(i,j,km1(k))
        END DO
        END DO
        END DO

C +--Advection
C +  ~~~~~~~~~
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          pairNH(i,j,k)= pairNH(i,j,k)
     .                 - WKxyz3(i,j,k)*WKxyz5(i,j,    k )*qsig_1(km1(k))
     .                 - WKxyz4(i,j,k)*WKxyz5(i,j,kp1(k))*qsig_1(    k )
        END DO
        END DO

C +--LBC
C +  ~~~
          DO j=1,my
            pairNH( 1,j,k)= pairNH(ip11,j,k)
            pairNH(mx,j,k)= pairNH( mx1,j,k)
          END DO
          DO i=1,mx
            pairNH(i, 1,k)= pairNH(i,jp11,k)
            pairNH(i,my,k)= pairNH(i, my1,k)
          END DO
        END DO


C +--Work Arrays Reset
C +  =================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz1(i,j,k) = 0.0
          WKxyz2(i,j,k) = 0.0
          WKxyz3(i,j,k) = 0.0
          WKxyz4(i,j,k) = 0.0
          WKxyz5(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
        END DO
        END DO
        END DO


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  HORIZONTAL/VERTICAL ADVECTION / FIRST ORDER UPSTREAM     (END)  +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  DIVERGENCE TOPOGRAPHIC CORRECTION    / EXPLICIT SCHEME (BEGIN)  +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


c #nh DO   k = 1,mz
c #nh DO   j = 1,my
c #nh DO   i = 1,mx
c #nh   pairNH(i,j,k)  = pairNH(i,j,k)     -ggsdNH(k)
c #nh.  *(slopex(i,j,k)*(uairDY(i,j,kp1(k))-uairDY(i,j,k))
c #nh.   +slopey(i,j,k)*(vairDY(i,j,kp1(k))-vairDY(i,j,k)))
c #nh END DO
c #nh END DO
c #nh END DO
C +...REMARK: must it be modified for large slopes 
C +                               by solving implicitly the Acoustic Mode
C +                        and/or by including a Divergence Damper?
C +               (cfr. Purser and Leslie, 199.)


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  DIVERGENCE TOPOGRAPHIC CORRECTION    / EXPLICIT SCHEME   (END)  +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  DIABATIC   HEATING     CONTRIBUTION  / EXPLICIT SCHEME (BEGIN)  +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Sponge                Levels
C +  ============================

c #DH DO   k =        1,mzabso
c #DH DO   j =        1,my
c #DH DO   i =        1,mx
c #DH   WKxyz1(i,j,k) = racv *pktRAd(i,j,k)/ dt
c #DH END DO
c #DH END DO
c #DH END DO


C +--Hydrologically Active Levels
C +  ============================

c #DH DO   k = mzabso+1,mz                                      !
c #DH DO   j =        1,my                                      !
c #DH DO   i =        1,mx                                      !
c #DH   WKxyz1(i,j,k) = racv *pktRAd(i,j,k)/ dt + hlatHY(i,j,k) ! K/s (Q/Cv)
c #DH END DO                                                    !
c #DH END DO                                                    !
c #DH END DO                                                    !


C +--Include the Diabatic Heating Contribution
C +  =========================================

c #DH   DO   k = 1,mz
c #DH   DO   j = jp11,my1
c #DH   DO   i = ip11,mx1
c #DH     pairNH(i,j,k) = pairNH(i,j,k)
c #DH.   +dt_ONH        * WKxyz1(i,j,k) / TairDY(i,j,k)
c #DH     WKxyz1(i,j,k) = 0.0d+0
c #DH   END DO
c #DH   END DO
c #DH   END DO


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  DIABATIC   HEATING     CONTRIBUTION  / EXPLICIT SCHEME   (END)  +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  HORIZONTAL/VERTICAL MASS CONVERGENCE / IMPLICIT SCHEME (BEGIN)  +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


C +--Horizontal Convergence               / x-Direction
C +  ==================================================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx


C +--HYDROSTATIC  Speed Variation in Time / x-Direction
C +  --------------------------------------------------

          WKxyz6(i,j,k) = uairDY(i,j,k)   -  ua0_NH(i,j,k)
        END DO
        END DO
        END DO


C +--Inverse Model Thickness
C +  -----------------------

        DO i=1,mx
        DO j=1,my
	   WKxy1(i,j)   = 2.0 / (pstDYn(ip1(i),j)+pstDYn(i,j))
        END DO
        END DO


C +--Tridiagonal Matrix Coefficients      / x-Direction
C +  --------------------------------------------------

        DO k=   1,mz
        DO j=jp11,my1
        DO i=ip11,mx1
          GaTerm        = bgcdNH            * WKxy1(i  ,j)
          GcTerm        =         bgcdNH    * WKxy1(i-1,j)
          G1Term        = GaTerm            *pstDYn(i+1,j)
          G3Term        =         GcTerm    *pstDYn(i-1,j)

          SGTerm        =(GaTerm +GcTerm)   *pstDYn(i  ,j)

          WK_AAx(i,j,k) =        -G1Term
          WKxyz2(i,j,k) = 1.0d+0 +SGTerm
          WK_CCx(i,j,k) =        -G3Term


C +--x-Contribution to the Independant Term
C +  --------------------------------------

          WKxyz4(i,j,k) = (1.0 -SGTerm        *abetnh) *pairNH(i  ,j,k)
     .                         -WK_AAx(i,j,k) *abetnh  *pairNH(i+1,j,k)
     .                         -WK_CCx(i,j,k) *abetnh  *pairNH(i-1,j,k)

C +--Horizontal Wind Speed Contribution (explicit Part)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     .          -gamdtx *( uairDY(i+1,j,k)-uairDY(i-1,j,k) )
     .          -bg1dNH *( WKxyz6(i+1,j,k)-WKxyz6(i-1,j,k) )
        END DO
        END DO
        END DO


C +--Lateral Boundary Conditions (Dirichlet, x-Direction)
C +  ----------------------------------------------------

           i=     mx1
        DO k=   1,mz
        DO j=jp11,my1
          WKxyz4(i,j,k) = WKxyz4(i,j,k)
     .                   -WK_AAx(i,j,k) * pairNH(ip1(i),j,k)
          WK_AAx(i,j,k) = 0.0
        END DO
        END DO

           i=ip11
        DO k=   1,mz
        DO j=jp11,my1
          WKxyz4(i,j,k) = WKxyz4(i,j,k)
     .                   -WK_CCx(i,j,k) * pairNH(im1(i),j,k)
          WK_CCx(i,j,k) = 0.0
        END DO
        END DO


C +--Horizontal Convergence               / y-Direction
C +  ==================================================

      IF (mmy.gt.1)                                               THEN
        DO k=1,mz
        DO j=1,my
        DO i=1,mx


C +--HYDROSTATIC  Speed Variation in Time / y-Direction
C +  --------------------------------------------------

          WKxyz6(i,j,k) = vairDY(i,j,k)   -  va0_NH(i,j,k)
        END DO
        END DO
        END DO


C +--Inverse Model Thickness
C +  -----------------------

        DO j=1,my
        DO i=1,mx
           WKxy2(i,j)   = 2.0 / (pstDYn(i,jp1(j))+pstDYn(i,j))
        END DO
        END DO


C +--Tridiagonal Matrix Coefficients      / y-Direction
C +  --------------------------------------------------

        DO k=   1,mz
        DO j=jp11,my1
        DO i=ip11,mx1
          GaTerm        = bgcdNH            * WKxy2(i,j  )
          GcTerm        =         bgcdNH    * WKxy2(i,j-1)
          G1Term        = GaTerm            *pstDYn(i,j+1)
          G3Term        =         GcTerm    *pstDYn(i,j-1)

          SGTerm        =(GaTerm +GcTerm)   *pstDYn(i,j  )

          WK_AAy(i,j,k) =               -G1Term
          WKxyz2(i,j,k) = WKxyz2(i,j,k) +SGTerm
          WK_CCy(i,j,k) =               -G3Term


C +--y-Contribution to the Independant Term
C +  --------------------------------------

          WKxyz4(i,j,k) = 
     .    WKxyz4(i,j,k)   -SGTerm         * abetnh * pairNH(i,j  ,k)
     .                    -WK_AAy(i,j,k)  * abetnh * pairNH(i,j+1,k)
     .                    -WK_CCy(i,j,k)  * abetnh * pairNH(i,j-1,k)

C +--Horizontal Wind Speed Contribution (explicit Part)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     .          -gamdtx *( vairDY(i,j+1,k)-vairDY(i,j-1,k) )
     .          -bg1dNH *( WKxyz6(i,j+1,k)-WKxyz6(i,j-1,k) )
        END DO
        END DO
        END DO 


C +--Lateral Boundary Conditions (Dirichlet, y-Direction)
C +  ----------------------------------------------------

           j=     my1
        DO k=   1,mz
        DO i=ip11,mx1
          WKxyz4(i,j,k) = WKxyz4(i,j,k)
     .                   -WK_AAy(i,j,k) * pairNH(i,jp1(j),k)
          WK_AAy(i,j,k) = 0.0
        END DO
        END DO

           j=jp11
        DO k=   1,mz
        DO i=ip11,mx1
          WKxyz4(i,j,k) = WKxyz4(i,j,k)
     .                   -WK_CCy(i,j,k) * pairNH(i,jm1(j),k)
          WK_CCy(i,j,k) = 0.0
        END DO
        END DO 
      END IF


C +--Vertical   Convergence
C +  ======================

      IF (SoundW)                                                 THEN


C +--HYDROSTATIC  Speed Variation in Time / s-Direction
C +  --------------------------------------------------

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz6(i,j,k) =  wairNH(i,j,k)-wa0_NH(i,j,k)
        END DO
        END DO
        END DO 


C +--z-Contribution to the central Diagonal
C +  --------------------------------------

        DO  k =    1,mz
        DO  j = jp11,my1
        DO  i = ip11,mx1
          WKxyz2(i,j,k)=  WKxyz2(i,j,k)+BBs_NH(k)


C +--z-Contribution to the Independant Term
C +  --------------------------------------

          WKxyz4(i,j,k)=  WKxyz4(i,j,k)
     .   -AAs_NH(    k)*  abetnh *pairNH(i,j,kp1(k))
     .   -BBs_NH(    k)*  abetnh *pairNH(i,j,k)
     .   -CCs_NH(    k)*  abetnh *pairNH(i,j,km1(k))
        END DO
        END DO
        END DO

           k=1
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz4(i,j,k)=  WKxyz4(i,j,k)
     .   +ggswNH(    k)*( wairNH(i,j,k)
     .                  + WKxyz6(i,j,k)                     * betaNH)
        END DO
        END DO

        DO k=2,mz
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz4(i,j,k)=  WKxyz4(i,j,k)
     .   +ggswNH(    k)*( wairNH(i,j,k)-wairNH(i,j,km1(k))
     .                  +(WKxyz6(i,j,k)-WKxyz6(i,j,km1(k))) * betaNH)
        END DO
        END DO
        END DO

      END IF


C +--Working Area: partial reset
C +  ===========================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz5(i,j,k) = 0.0d+0
          WKxyz6(i,j,k) = 0.0d+0
        END DO
        END DO
        END DO


C +--Overrelaxation Starting Block
C +  =============================

C +--First Estimate
C +  --------------

      DO  k =     1 ,    mz
      DO  j = jp11,my1
      DO  i = ip11,mx1
        WKxyz7(i,j,k) = pairNH(i,j,k)


C +--Non Variable Part of the Independant Term
C +  -----------------------------------------

        WKxyz8(i,j,k) = WKxyz4(i,j,k)
      END DO
      END DO
      END DO


C +--First Residual
C +  --------------

      DO  k =    1,mz
      DO  i = ip11,mx1
      DO  j = jp11,my1
        WKxyz6(i,j,k) = WK_AAx(i,j,k) * WKxyz7(ip1(i),j,k)
     .                + AAs_NH(    k) * WKxyz7(i,j,kp1(k))
     .                + WK_CCx(i,j,k) * WKxyz7(im1(i),j,k)
c #vL END DO
c #vL END DO

c #vL DO  j = jp11,my1
c #vL DO  i = ip11,mx1
c #vL   WKxyz6(i,j,k) = WKxyz6(i,j,k)
     .                + CCs_NH(    k) * WKxyz7(i,j,km1(k))
     .                + WK_AAy(i,j,k) * WKxyz7(i,jp1(j),k)
     .                + WK_CCy(i,j,k) * WKxyz7(i,jm1(j),k)
     .                + WKxyz2(i,j,k) * WKxyz7(i,j,k)
     .                - WKxyz8(i,j,k)
      END DO
      END DO
      END DO

        SRes_0        =  0.0
      DO  k =    1,mz
      DO  j = jp11,my1
      DO  i = ip11,mx1
        SRes_0        =  SRes_0   +     WKxyz6(i,j,k)
      END DO
      END DO
      END DO


C +--Recurrence
C +  ----------

      it_Ovr= 0
      SRes10= 1.0d+0
c #WR write(6,1001) iterun,it_Ovr,SRes_0,SRes10
 1001 format(2i6,2f18.9)
 1000 CONTINUE
      it_Ovr= it_Ovr + 1


C +--Resolution along the x-Direction
C +  ================================

C +--Tridiagonal Matrix Coefficients
C +  -------------------------------

          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz1(i,j,k) = WK_AAx(i,j,k)
            WKxyz3(i,j,k) = WK_CCx(i,j,k)
          END DO
          END DO
          END DO


C +--Independant Term
C +  ----------------

          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz4(i,j,k) = WKxyz8(i,j,k)
          END DO
          END DO
          END DO

        IF (mmy.gt.1)                                             THEN
          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz4(i,j,k) =     WKxyz4(i,j,k)
     .          - WK_AAy(i,j,k)*WKxyz7(i,jp1(j),k)
     .          - WK_CCy(i,j,k)*WKxyz7(i,jm1(j),k)
          END DO
          END DO
          END DO
        END IF

        IF (SoundW)                                               THEN
          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz4(i,j,k) =     WKxyz4(i,j,k)
     .          - AAs_NH(    k)*WKxyz7(i,j,kp1(k))
     .          - CCs_NH(    k)*WKxyz7(i,j,km1(k))
          END DO
          END DO
          END DO
        END IF


C +--Tridiagonal Matrix Inversion
C +  ----------------------------

          i1_dnh = ip11
          i2_dnh = mx1
          j1_dnh = jp11
          j2_dnh = my1
          k1_dnh =      1
          k2_dnh =     mz

C +       *************
          call MARgau_x(i1_dnh,i2_dnh,j1_dnh,j2_dnh,k1_dnh,k2_dnh)
C +       *************


C +--Resolution along the y-Direction
C +  ================================

        IF (mmy.gt.1)                                             THEN


C +--Tridiagonal Matrix Coefficients
C +  -------------------------------

          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz1(i,j,k) = WK_AAy(i,j,k)
            WKxyz3(i,j,k) = WK_CCy(i,j,k)
          END DO
          END DO
          END DO


C +--Independant Term
C +  ----------------

          DO  k =    1,mz
          DO  i = ip11,mx1
          DO  j = jp11,my1
            WKxyz4(i,j,k) =     WKxyz8(i,j,k)
     .          - WK_AAx(i,j,k)*WKxyz7(ip1(i),j,k)
     .          - WK_CCx(i,j,k)*WKxyz7(im1(i),j,k)
          END DO
          END DO
          END DO
        IF (SoundW)                                               THEN
          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz4(i,j,k) =     WKxyz4(i,j,k)
     .          - AAs_NH(    k)*WKxyz7(i,j,kp1(k))
     .          - CCs_NH(    k)*WKxyz7(i,j,km1(k))
          END DO
          END DO
          END DO
        END IF


C +--Tridiagonal Matrix Inversion
C +  ----------------------------

          i1_dnh = ip11
          i2_dnh = mx1
          j1_dnh = jp11
          j2_dnh = my1
          k1_dnh =      1
          k2_dnh =     mz

C +       *************
          call MARgau_y(i1_dnh,i2_dnh,j1_dnh,j2_dnh,k1_dnh,k2_dnh)
C +       *************

        END IF


C +--Resolution along the z-Direction
C +  ================================

        IF (SoundW)                                               THEN


C +--Tridiagonal Matrix Coefficients
C +  -------------------------------

            DO  k =    1,mz
            DO  j = jp11,my1
            DO  i = ip11,mx1
              WKxyz1(i,j,k) = AAs_NH(    k)
              WKxyz3(i,j,k) = CCs_NH(    k)
            END DO
            END DO
            END DO


C +--Independant Term
C +  ----------------

            DO  k =    1,mz
            DO  i = ip11,mx1
            DO  j = jp11,my1
              WKxyz4(i,j,k) = WKxyz8(i,j,k)
     .            - WK_AAx(i,j,k)*WKxyz7(ip1(i),j,k)
     .            - WK_CCx(i,j,k)*WKxyz7(im1(i),j,k)
            END DO
            END DO
            END DO

          IF (mmy.gt.1)                                           THEN
            DO  k =    1,mz
            DO  j = jp11,my1
            DO  i = ip11,mx1
              WKxyz4(i,j,k) = WKxyz4(i,j,k)
     .          - WK_AAy(i,j,k)*WKxyz7(i,jp1(j),k)
     .          - WK_CCy(i,j,k)*WKxyz7(i,jm1(j),k)
            END DO
            END DO
            END DO
          END IF


C +--Tridiagonal Matrix Inversion
C +  ----------------------------

          k1_dnh =      1
          k2_dnh =     mz

C +            ************
          call MARgz_2mx1y1(k1_dnh,k2_dnh)
C +            ************

        ELSE


C +--Tridiagonal Matrix Coefficients
C +  -------------------------------

          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz1(i,j,k) = 0.0d+0
            WKxyz3(i,j,k) = 0.0d+0
          END DO
          END DO
          END DO


        END IF


C +--Residual: substracts next from former estimated Equation
C +  ========================================================

          DO  k =    1,mz
          DO  i = ip11,mx1
          DO  j = jp11,my1
            WKxyz6(i,j,k) = WK_AAx(i,j,k) * WKxyz7(ip1(i),j,k)
     .                    + WKxyz1(i,j,k) * WKxyz7(i,j,kp1(k))
     .                    + WK_CCx(i,j,k) * WKxyz7(im1(i),j,k)
     .                    + WKxyz3(i,j,k) * WKxyz7(i,j,km1(k))
c #vL     END DO
c #vL     END DO

c #vL     DO  j = jp11,my1
c #vL     DO  i = ip11,mx1
c #vL       WKxyz6(i,j,k) = WKxyz6(i,j,k)
     .                    + WK_AAy(i,j,k) * WKxyz7(i,jp1(j),k)
     .                    + WK_CCy(i,j,k) * WKxyz7(i,jm1(j),k)
     .                    + WKxyz2(i,j,k) * WKxyz7(i,j,k)
     .                    - WKxyz8(i,j,k)
          END DO
          END DO
          END DO

            SRes_1        =  0.0
          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            SRes_1        =  SRes_1   +     WKxyz6(i,j,k) 
          END DO
          END DO
          END DO
            SRes10        =  SRes_1 / SRes_0
            SRes_1        =  SRes_1 /(mx*my*mz)

c #WR     write(6,1001) iterun,it_Ovr,SRes_1,SRes10


C +--New Estimate
C +  ------------

        IF (abs(SRes10).gt.TolOvr.and.it_Ovr.lt.nt_Ovr)           THEN
          DO  k =    1,mz
          DO  j = jp11,my1
          DO  i = ip11,mx1
            WKxyz7(i,j,k) = WKxyz7(i,j,k)
     .            + FacOvr* WKxyz6(i,j,k)/WKxyz2(i,j,k)
          END DO
          END DO
          END DO
        END IF

      IF   (abs(SRes10).gt.TolOvr.and.it_Ovr.lt.nt_Ovr)     GO TO 1000


C +--pairNH Time Increment
C +  =====================

        DO kk= 1,mz
          DO j=jp11,my1
          DO i=ip11,mx1
            WKxyz7(i,j,kk)=betanh* WKxyz7(i,j,kk)+alphnh*pairNH(i,j,kk)
          END DO
          END DO
        END DO


C +--Vertical   Wind Speed: Time Increment
C +  =====================================

        DO   k=    1 ,    mz
          DO j=jp11,my1
          DO i=ip11,mx1
            WKxyz3(i,j,k) =(sigma(kp1(k))*WKxyz7(i,j,kp1(k))
     .                     -sigma(    k )*WKxyz7(i,j,    k ))*dt__NH(k)
          END DO
          END DO
        END DO


C +--Horizontal Wind Speed: Time Increment
C +  =====================================

        DO  kk=    1 ,    mz
          DO i=ip11,mx1
          DO j=jp11,my1

            WKxyz1(i,j,kk) =                             dxinv2*dt_ONH
     .    *(WKxyz7(im1(i),j,kk)*pstDYn(im1(i),j)
     .     -WKxyz7(ip1(i),j,kk)*pstDYn(ip1(i),j))*cgamNH/pstDYn(i,j)

c #vL     END DO
c #vL     END DO

c #vL     DO j=jp11,my1
c #vL     DO i=ip11,mx1

            WKxyz2(i,j,kk) =                             dxinv2*dt_ONH
     .    *(WKxyz7(i,jm1(j),kk)*pstDYn(i,jm1(j))
     .     -WKxyz7(i,jp1(j),kk)*pstDYn(i,jp1(j)))*cgamNH/pstDYn(i,j)

          END DO
          END DO
        END DO


C +--Step NH Variables Forward in Time
C +  =================================

        DO  kk=    1 ,    mz

          DO j=jp11,my1
          DO i=ip11,mx1
            pairNH(i,j,kk) = WKxyz7(i,j,kk)
            wairNH(i,j,kk) = wairNH(i,j,kk)+WKxyz3(i,j,kk)
            uairDY(i,j,kk) = uairDY(i,j,kk)+WKxyz1(i,j,kk)
            vairDY(i,j,kk) = vairDY(i,j,kk)+WKxyz2(i,j,kk)


C +--Memorize uairDY, vairDY into "Previous Time Step Values"
C +  ========================================================

            ua0_NH(i,j,kk) = uairDY(i,j,kk)
            va0_NH(i,j,kk) = vairDY(i,j,kk)
            wa0_NH(i,j,kk) = wairNH(i,j,kk)


C +--Work Arrays Reset
C +  =================

            WKxyz1(i,j,kk) = 0.0
            WKxyz2(i,j,kk) = 0.0
            WKxyz3(i,j,kk) = 0.0
            WKxyz4(i,j,kk) = 0.0
            WKxyz5(i,j,kk) = 0.0
            WKxyz6(i,j,kk) = 0.0
            WKxyz7(i,j,kk) = 0.0
            WKxyz8(i,j,kk) = 0.0
          END DO
          END DO


C +--LBC
C +  ===

          DO j=1,my
            pairNH( 1,j,kk)= pairNH(ip11,j,kk)
            wairNH( 1,j,kk)= wairNH(ip11,j,kk)
            pairNH(mx,j,kk)= pairNH( mx1,j,kk)
            wairNH(mx,j,kk)= wairNH( mx1,j,kk)
          END DO
          DO i=1,mx
            pairNH(i, 1,kk)= pairNH(i,jp11,kk)
            wairNH(i, 1,kk)= wairNH(i,jp11,kk)
            pairNH(i,my,kk)= pairNH(i, my1,kk)
            wairNH(i,my,kk)= wairNH(i, my1,kk)
          END DO
        END DO

        DO j=1,my
        DO i=1,mx
          WKxy1(i,j) = 0.0
          WKxy2(i,j) = 0.0
          WKxy3(i,j) = 0.0
          WKxy4(i,j) = 0.0
          WKxy5(i,j) = 0.0
        END DO
        END DO


C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +  MASS CONVERGENCE   (END)                                        +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      return
      end


      subroutine MARgx11mx1my

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           05-07-2004  MAR |
C |   SubRoutine MARgx11mx1my performs Gaussian Elimination along x-Dir    |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:                                                               |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer  ix

      data ix /0/

      k    =   1


C +--Forward  Sweep
C +  ==============

      IF (ix.ne.1)                                                  THEN
          DO j= 1,my
            WKxyz5(1,j,k)= WKxyz2(1,j,k)
            WKxyz6(1,j,k)=-WKxyz1(1,j,k)/WKxyz5(1,j,k)
          END DO
          DO i=ip11,mx
          DO j=   1,my
            WKxyz5(i,j,k)= WKxyz3(i,j,k)*WKxyz6(i-1,j,k)+WKxyz2(i,j,k)
            WKxyz6(i,j,k)=-WKxyz1(i,j,k)/WKxyz5(i  ,j,k)
          END DO
          END DO
      END IF

          DO j= 1,my
            WKxyz7(1,j,k)= WKxyz4(1,j,k)/WKxyz5(1,j,k)
          END DO

          DO i=ip11,mx
          DO j=   1,my
            WKxyz7(i,j,k)=(WKxyz4(i,j,k)-WKxyz3(i,j,k)*WKxyz7(i-1,j,k))
     .                    /WKxyz5(i,j,k)
          END DO
          END DO


C +--Backward Sweep
C +  ==============

          DO i=mx1,1,-1
          DO j=  1,my
            WKxyz7(i,j,k)=WKxyz6(i,j,k)*WKxyz7(i+1,j,k)+WKxyz7(i,j,k)
          END DO
          END DO

      return
      end


      subroutine MARgy11mx1my

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           05-07-2004  MAR |
C |   SubRoutine MARgy11mx1my performs Gaussian Elimination along y-Dir.   |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:                                                               |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer  ix

      data ix /0/

      k    =   1


C +--Forward  Sweep
C +  ==============

      IF (ix.ne.1)                                                  THEN
          DO i= 1,mx
            WKxyz5(i,1,k)= WKxyz2(i,1,k)
            WKxyz6(i,1,k)=-WKxyz1(i,1,k)/WKxyz5(i,1,k)
          END DO
          DO j=jp11,my
          DO i=   1,mx
            WKxyz5(i,j,k)= WKxyz3(i,j,k)*WKxyz6(i,j-1,k)+WKxyz2(i,j,k)
            WKxyz6(i,j,k)=-WKxyz1(i,j,k)/WKxyz5(i,j  ,k)
          END DO
          END DO
      END IF

          DO i= 1,mx
            WKxyz7(i,1,k)= WKxyz4(i,1,k)/WKxyz5(i,1,k)
          END DO

          DO j=jp11,my
          DO i=   1,mx
            WKxyz7(i,j,k)=(WKxyz4(i,j,k)-WKxyz3(i,j,k)*WKxyz7(i,j-1,k))
     .                    /WKxyz5(i,j,k)
          END DO
          END DO


C +--Backward Sweep
C +  ==============

          DO j=my1,1,-1
          DO i=  1,mx
            WKxyz7(i,j,k)=WKxyz6(i,j,k)*WKxyz7(i,j+1,k)+WKxyz7(i,j,k)
          END DO
          END DO

      return
      end


      subroutine MARgx_1mx1my

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           05-07-2004  MAR |
C |   SubRoutine MARgx_1mx1my performs Gaussian Elimination along x-Dir    |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:                                                               |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer  ix

      data ix /0/


C +--Forward  Sweep
C +  ==============

      IF (ix.ne.1)                                                  THEN
          DO k= 1,mz
          DO j= 1,my
            WKxyz5(1,j,k)= WKxyz2(1,j,k)
            WKxyz6(1,j,k)=-WKxyz1(1,j,k)/WKxyz5(1,j,k)
          END DO
          END DO
        DO   i=ip11,mx
          DO k=   1,mz
          DO j=   1,my
            WKxyz5(i,j,k)= WKxyz3(i,j,k)*WKxyz6(i-1,j,k)+WKxyz2(i,j,k)
            WKxyz6(i,j,k)=-WKxyz1(i,j,k)/WKxyz5(i  ,j,k)
          END DO
          END DO
        END DO
      END IF

          DO k= 1,mz
          DO j= 1,my
            WKxyz7(1,j,k)= WKxyz4(1,j,k)/WKxyz5(1,j,k)
          END DO
          END DO

        DO   i=ip11,mx
          DO k=   1,mz
          DO j=   1,my
            WKxyz7(i,j,k)=(WKxyz4(i,j,k)-WKxyz3(i,j,k)*WKxyz7(i-1,j,k))
     .                    /WKxyz5(i,j,k)
          END DO
          END DO
        END DO


C +--Backward Sweep
C +  ==============

        DO   i=mx1,1,-1
          DO k=  1,mz
          DO j=  1,my
            WKxyz7(i,j,k)=WKxyz6(i,j,k)*WKxyz7(i+1,j,k)+WKxyz7(i,j,k)
          END DO
          END DO
        END DO

      return
      end


      subroutine MARgy_1mx1my

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           05-07-2004  MAR |
C |   SubRoutine MARgy_1mx1my performs Gaussian Elimination along y-Dir.   |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:                                                               |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer  ix

      data ix /0/


C +--Forward  Sweep
C +  ==============

      IF (ix.ne.1)                                                  THEN
        DO   k= 1,mz
          DO i= 1,mx
            WKxyz5(i,1,k)= WKxyz2(i,1,k)
            WKxyz6(i,1,k)=-WKxyz1(i,1,k)/WKxyz5(i,1,k)
          END DO
        END DO
        DO   j=jp11,my
          DO k=   1,mz
          DO i=   1,mx
            WKxyz5(i,j,k)= WKxyz3(i,j,k)*WKxyz6(i,j-1,k)+WKxyz2(i,j,k)
            WKxyz6(i,j,k)=-WKxyz1(i,j,k)/WKxyz5(i,j  ,k)
          END DO
          END DO
        END DO
      END IF

          DO k= 1,mz
          DO i= 1,mx
            WKxyz7(i,1,k)= WKxyz4(i,1,k)/WKxyz5(i,1,k)
          END DO
          END DO

        DO   j=jp11,my
          DO k=   1,mz
          DO i=   1,mx
            WKxyz7(i,j,k)=(WKxyz4(i,j,k)-WKxyz3(i,j,k)*WKxyz7(i,j-1,k))
     .                    /WKxyz5(i,j,k)
          END DO
          END DO
        END DO


C +--Backward Sweep
C +  ==============

        DO j=my1,1,-1
          DO k=  1,mz
          DO i=  1,mx
            WKxyz7(i,j,k)=WKxyz6(i,j,k)*WKxyz7(i,j+1,k)+WKxyz7(i,j,k)
          END DO
          END DO
        END DO

      return
      end


      subroutine MARgz_1mx1my(k1,k2)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           02-07-2004  MAR |
C |   SubRoutine MARgz_1mx1my performs Gaussian Elimination along s-Dir.   |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:                      k1,k2: k Loops Limits                    |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer  k1,k2


C +--Forward  Sweep
C +  ==============

        DO j=1,my
        DO i=1,mx
          WKxyz5(i,j,k1) = WKxyz2(i,j,k1)
          WKxyz6(i,j,k1) =-WKxyz1(i,j,k1) /WKxyz5(i,j,k1)
        END DO
        END DO
      DO   k=kp1(k1),k2
        DO j=1,my
        DO i=1,mx
          WKxyz5(i,j,k) = WKxyz3(i,j,k)   *WKxyz6(i,j,k-1)+WKxyz2(i,j,k)
          WKxyz6(i,j,k) =-WKxyz1(i,j,k)   /WKxyz5(i,j,k)
        END DO
        END DO
      END DO
        DO j=1,my
        DO i=1,mx
          WKxyz7(i,j,k1)= WKxyz4(i,j,k1)  /WKxyz5(i,j,k1)
        END DO
        END DO
      DO   k=kp1(k1),k2
        DO j=1,my
        DO i=1,mx
          WKxyz7(i,j,k) =(WKxyz4(i,j,k)   -WKxyz3(i,j,k) 
     .                   *WKxyz7(i,j,k-1))/WKxyz5(i,j,k)
        END DO
        END DO
      END DO


C +--Backward Sweep
C +  ==============

      DO k=km1(k2),k1,-1
        DO j=1,my
        DO i=1,mx
          WKxyz7(i,j,k) =  WKxyz6(i,j,k) *WKxyz7(i,j,k+1) +WKxyz7(i,j,k)
        END DO
        END DO
      END DO

      return
      end


      subroutine MARgz_2mx1y1(k1,k2)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           03-07-2004  MAR |
C |   SubRoutine MARgz_2mx1y1 performs Gaussian Elimination along s-Dir.   |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:                      k1,k2: k Loops Limits                    |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer  k1,k2


C +--Forward  Sweep
C +  ==============

        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz5(i,j,k1) = WKxyz2(i,j,k1)
          WKxyz6(i,j,k1) =-WKxyz1(i,j,k1) /WKxyz5(i,j,k1)
        END DO
        END DO
      DO   k=kp1(k1),k2
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz5(i,j,k) = WKxyz3(i,j,k)   *WKxyz6(i,j,k-1)+WKxyz2(i,j,k)
          WKxyz6(i,j,k) =-WKxyz1(i,j,k)   /WKxyz5(i,j,k)
        END DO
        END DO
      END DO
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz7(i,j,k1)= WKxyz4(i,j,k1)  /WKxyz5(i,j,k1)
        END DO
        END DO
      DO   k=kp1(k1),k2
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz7(i,j,k) =(WKxyz4(i,j,k)   -WKxyz3(i,j,k) 
     .                   *WKxyz7(i,j,k-1))/WKxyz5(i,j,k)
        END DO
        END DO
      END DO


C +--Backward Sweep
C +  ==============

      DO k=km1(k2),k1,-1
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz7(i,j,k) =  WKxyz6(i,j,k) *WKxyz7(i,j,k+1) +WKxyz7(i,j,k)
        END DO
        END DO
      END DO

      return
      end


      subroutine MARgau_x(i1,i2,j1,j2,k1,k2)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           17-12-2000  MAR |
C |   SubRoutine MARgau_x performs Gaussian Elimination Algorithm along x  |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:              i1,i2,j1,j2,k1,k2: i,j,k Loops Limits            |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer i1,i2,j1,j2,k1,k2,ix

      data ix /0/


C +--Forward  Sweep
C +  ==============

      IF (ix.ne.1)                                                THEN
          DO k=k1,k2
          DO j=j1,j2
            WKxyz5(i1,j,k)= WKxyz2(i1,j,k)
            WKxyz6(i1,j,k)=-WKxyz1(i1,j,k)/WKxyz5(i1,j,k)
          END DO
          END DO
        DO i=ip1(i1),i2
          DO k=k1,k2
          DO j=j1,j2
            WKxyz5(i,j,k)= WKxyz3(i,j,k)*WKxyz6(i-1,j,k)+WKxyz2(i,j,k)
            WKxyz6(i,j,k)=-WKxyz1(i,j,k)/WKxyz5(i  ,j,k)
          END DO
          END DO
        END DO
      END IF

          DO k=k1,k2
          DO j=j1,j2
            WKxyz7(i1,j,k)= WKxyz4(i1,j,k)/WKxyz5(i1,j,k)
          END DO
          END DO

        DO i=ip1(i1),i2
          DO k=k1,k2
          DO j=j1,j2
            WKxyz7(i,j,k)=(WKxyz4(i,j,k)-WKxyz3(i,j,k)*WKxyz7(i-1,j,k))
     .                    /WKxyz5(i,j,k)
          END DO
          END DO
        END DO


C +--Backward Sweep
C +  ==============

        DO i=im1(i2),i1,-1
          DO k=k1,k2
          DO j=j1,j2
            WKxyz7(i,j,k)=WKxyz6(i,j,k)*WKxyz7(i+1,j,k)+WKxyz7(i,j,k)
          END DO
          END DO
        END DO

      return
      end


      subroutine MARgau_y(i1,i2,j1,j2,k1,k2)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           17-12-2000  MAR |
C |   SubRoutine MARgau_y performs Gaussian Elimination Algorithm along y  |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:              i1,i2,j1,j2,k1,k2: i,j,k Loops Limits            |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer i1,i2,j1,j2,k1,k2,ix

      data ix /0/


C +--Forward  Sweep
C +  ==============

      IF (ix.ne.1)                                                THEN
          DO k=k1,k2
          DO i=i1,i2
            WKxyz5(i,j1,k)= WKxyz2(i,j1,k)
            WKxyz6(i,j1,k)=-WKxyz1(i,j1,k)/WKxyz5(i,j1,k)
          END DO
          END DO
        DO j=jp1(j1),j2
          DO k=k1,k2
          DO i=i1,i2
            WKxyz5(i,j,k)= WKxyz3(i,j,k)*WKxyz6(i,j-1,k)+WKxyz2(i,j,k)
            WKxyz6(i,j,k)=-WKxyz1(i,j,k)/WKxyz5(i,j  ,k)
          END DO
          END DO
        END DO
      END IF

          DO k=k1,k2
          DO i=i1,i2
            WKxyz7(i,j1,k)= WKxyz4(i,j1,k)/WKxyz5(i,j1,k)
          END DO
          END DO

        DO j=jp1(j1),j2
          DO k=k1,k2
          DO i=i1,i2
            WKxyz7(i,j,k)=(WKxyz4(i,j,k)-WKxyz3(i,j,k)*WKxyz7(i,j-1,k))
     .                    /WKxyz5(i,j,k)
          END DO
          END DO
        END DO


C +--Backward Sweep
C +  ==============

        DO j=jm1(j2),j1,-1
          DO k=k1,k2
          DO i=i1,i2
            WKxyz7(i,j,k)=WKxyz6(i,j,k)*WKxyz7(i,j+1,k)+WKxyz7(i,j,k)
          END DO
          END DO
        END DO

      return
      end


      subroutine MARgau_z(i1,i2,j1,j2,k1,k2)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                           17-12-2000  MAR |
C |   SubRoutine MARgau_z performs Gaussian Elimination Algorithm along x  |
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:              i1,i2,j1,j2,k1,k2: i,j,k Loops Limits            |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      integer i1,i2,j1,j2,k1,k2


C +--Forward  Sweep
C +  ==============

        DO j=j1,j2
        DO i=i1,i2
          WKxyz5(i,j,k1) =  WKxyz2(i,j,k1)
          WKxyz6(i,j,k1) = -WKxyz1(i,j,k1) /WKxyz5(i,j,k1)
        END DO
        END DO
      DO   k=kp1(k1),k2
        DO j=j1,j2
        DO i=i1,i2
          WKxyz5(i,j,k) =  WKxyz3(i,j,k) *WKxyz6(i,j,k-1) +WKxyz2(i,j,k)
          WKxyz6(i,j,k) = -WKxyz1(i,j,k) /WKxyz5(i,j,k)
        END DO
        END DO
      END DO
        DO j=j1,j2
        DO i=i1,i2
          WKxyz7(i,j,k1) =  WKxyz4(i,j,k1) /WKxyz5(i,j,k1)
        END DO
        END DO
      DO   k=kp1(k1),k2
        DO j=j1,j2
        DO i=i1,i2
          WKxyz7(i,j,k) = (WKxyz4(i,j,k)   -WKxyz3(i,j,k) 
     .                    *WKxyz7(i,j,k-1))/WKxyz5(i,j,k)
        END DO
        END DO
      END DO


C +--Backward Sweep
C +  ==============

      DO k=km1(k2),k1,-1
        DO j=j1,j2
        DO i=i1,i2
          WKxyz7(i,j,k) =  WKxyz6(i,j,k) *WKxyz7(i,j,k+1) +WKxyz7(i,j,k)
        END DO
        END DO
      END DO

      return
      end


      subroutine DYNfil_NH

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   NonHydroStatic                          14-11-2002  MAR |
C |   SubRoutine DYNfil_NH controls Filtering of Non-Hydrostatic Variables |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^         openLB          : Open LBC Switch                      |
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^         FIslou          : Filter Parameter (wind)              |
C |                 FIslop          :                  (pressure)          |
C |                                                                        |
C |   INPUT/OUTPUT: wairNH(mx,my,mz): Vertical Non-Hydrostatic Wind Speed  |
C |   ^^^^^^^^^^^^^ pairNH(mx,my,mz): Normaliz.Non-Hydrostatic Pressure    |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_NH.inc'
      include 'MAR_FI.inc'

      include 'MAR_TU.inc'

      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

c #BV include 'MARvec.inc'
      integer  kdim

      real     dumeps(mz)
      real     dumy3D(mx,my,mz)


C +--Filtering of Vertical Wind Speed
C +  ================================

      kdim = mz

      DO k=1,mz
         dumeps(k)  = FIk_fu(k) * dt_ONH / dtfast
C +...   dumeps(k)  : Filter Parameter for wairNH
C +
      END DO

      DO     k=1,mz
        DO   j=1,my
        DO   i=1,mx
          dumy3D(i,j,k) = wairNH(i,j,k)
        END DO
        END DO
      END DO


C +--Filtering
C +  ---------

      IF (mmy.le.1)                                               THEN 

        DO k=1,mz

c #OB     IF (openLB)                                             THEN

C +         ***************
c #OB       call DYNfil_1D0(dumy3D,dumeps,kdim)
C +         ***************

c #OB     ELSE

C +         **************
            call DYNfil_1D (dumy3D,dumeps,kdim)
C +         **************

c #OB     END IF

        END DO

      ELSE 
c #OB   IF (openLB)                                               THEN

C +         ***************
c #OB       call DYNfil_3D0(dumy3D,dumeps,kdim)
C +         ***************

c #OB   ELSE

c #NV     IF (no_vec)                                             THEN

c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif

c #NV     ELSE

C +         **************
            call DYNfilv3D (dumy3D,dumeps,kdim)
C +         **************

c #NV     END IF

c #OB   END IF
      END IF 


C +--Update
C +  ------

      DO       k=1,mz
        DO     j=1,my
        DO     i=1,mx
          wairNH(i,j,k) = dumy3D(i,j,k)
        END DO
        END DO
      END DO


C +--Filtering of Non-Hydrostatic Pressure
C +  =====================================

      DO k=1,mz
         dumeps(k)  = FIk_fp(k) * dt_ONH / dtfast
C +...   dumeps(k)  : Upper Sponge Parameter  for  pairNH

      END DO

      DO     k=1,mz
        DO   j=1,my
        DO   i=1,mx
          dumy3D(i,j,k) = pairNH(i,j,k)
        END DO
        END DO
      END DO


C +--Filtering
C +  ---------

      IF (mmy.le.1)                                               THEN 
C +
        DO k=1,mz
C +
c #OB     IF (openLB)                                             THEN
C +
C +         ***************
c #OB       call DYNfil_1D0(dumy3D,dumeps,kdim)
C +         ***************
C +
c #OB     ELSE
C +
C +         **************
            call DYNfil_1D (dumy3D,dumeps,kdim)
C +         **************
C +
c #OB     END IF
C +
        END DO
C +
      ELSE 
c #OB   IF (openLB)                                               THEN
C +
C +         ***************
c #OB       call DYNfil_3D0(dumy3D,dumeps,kdim)
C +         ***************
C +
c #OB   ELSE
C +
c #NV     IF (no_vec)                                             THEN
C +
c #NV               if(openmp) then
C +                      **********
c #NV               call DYNfil_3D_mp (dumy3D,dumeps,kdim)
C +                      **********
c #NV               else
C +                      **********
c #NV               call DYNfil_3D (dumy3D,dumeps,kdim)
C +                      **********
c #NV               endif
C +
c #NV     ELSE
C +
C +         **************
            call DYNfilv3D (dumy3D,dumeps,kdim)
C +         **************
C +
c #NV     END IF
C +
c #OB   END IF
      END IF 
C +
C +
C +--Update
C +  ------
C +
      DO       k=1,mz
        DO     j=1,my
        DO     i=1,mx
          pairNH(i,j,k) = dumy3D(i,j,k)
        END DO
        END DO
      END DO
C +
      return
      end
      subroutine TURvNH
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (NH)                                    19-09-2001  MAR |
C |   SubRoutine TURvNH includes contribution of vertical Diffusion        |
C |      to NonHydrostatic vertical velocity  and pressure                 |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT (via common block)                                              |
C |  ^^^^^  dt_Loc: Vertical Diffusion Time Step                      [s]  |
C |         TUkvm(mx,my,mz): Vertical Turbulent Coeffic.(momentum) [m2/s2] |
C |                                                                        |
C |  INPUT / OUTPUT: The Vertical Turbulent Fluxes are included for:       |
C |  ^^^^^^^^^^^^^^                                                        |
C |       a) NonHydrostatic vertical velocity     wairNH(mx,my,mz) [m/s]   |
C |       b) NonHydrostatic pressure (normaliz.)  pairNH(mx,my,mz) [kPa]   |
C |                                                                        |
C | #OPTIONS: #De: Dirichlet Type Top Boundary Condit. for wairNH & wairNH |
C | #^^^^^^^^ _PE: Diffusion on Sigma Surfaces (%Grad.) /Vertical Correct. |
C | #         #PE: Diffusion on Sigma Surfaces (%Strain)/Vertical Correct. |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_SL.inc'
c #De include 'MAR_DI.inc'
C +
      include 'MAR_NH.inc'
      include 'MAR_TU.inc'
c _PE include 'MARpen.inc'
c #PE include 'MARpen.inc'
C +
      include 'MAR_WK.inc'
C +
C +
C +--Parameters
C +  ==========
C +
      integer  k1
      real     alpha ,beta  ,ab    ,FactK
C +
C +
C +--For the Numerical Scheme of Vertical Turbulent Transport
C +  --------------------------------------------------------
C +
      alpha = 0.25
      beta  = 1.00-alpha
      ab    = alpha/beta
C +...For the implicit scheme
C +
C +
C +--Work Arrays Reset
C +  =================
C +
      DO k=1,mz
      DO i=1,mx
        WKxza(i,k) =0.0
        WKxzb(i,k) =0.0
        WKxzc(i,k) =0.0
      END DO
      END DO
C +
C +
C +--Vertical Diffusion of Non Hydrostatic Pressure Perturbation
C +  ===========================================================
C +
C +
C +--Tridiagonal Matrix Coefficients - pairNH 
C +  ----------------------------------------
C +
      DO   j=1,my
C +
        DO k=mmz2,1,-1
C +
        DO i=1,mx
          WKxza(i,k)=-gravi2*(TUkvm (i,j,k)
c _PE.                       +pente3(i,j,k)
c #PE.                       +pente3(i,j,k)
     .                       )*beta
     .                      * romiDY(i,j,k)*rolvDY(i,j,k) 
     .                      /(pstDY2(i,j)  *dsigm1(k) *dsig_1(k))
        END DO
C +
        DO i=1,mx
          WKxzc(i,kp1(k)) = WKxza(i,k) *dsigm1(k)/dsigm1(kp1(k))   
     .                               /rolvDY(i,j,k)*rolvDY(i,j,k+1) 
        END DO
C +
        END DO
C +
        DO k=1,mmz
        DO i=1,mx
          WKxza(i,k) =      WKxza(i,k) * dt_Loc
          WKxzc(i,k) =      WKxzc(i,k) * dt_Loc
          WKxzb(i,k) = 1.0 -WKxzc(i,k) -WKxza(i,k) 
        END DO
        END DO
C +
C +
C +--Second Member of the Tridiagonal System - pairNH
C +  ------------------------------------------------
C +
        DO i=1,mx
          WKxzd(i,1) = WKxza(i,1) *ab*(pairNH(i,j,1)-pairNH(i,j,kp1(1)))
c #De     WKxza(i,1) = 0.0
c #De     WKxzb(i,1) = 1.0
c #De     WKxzd(i,1) = 0.0
        END DO
C +
        DO k=kp1(1),mmz
        DO i=1,mx
          WKxzd(i,k) = WKxza(i,k) *ab*(pairNH(i,j,k)-pairNH(i,j,kp1(k)))
     .                -WKxzc(i,k) *ab*(pairNH(i,j,km1(k))-pairNH(i,j,k))
        END DO
        END DO
C +
C +
C +--Tridiagonal Matrix Inversion - pairNH 
C +  -------------------------------------
C +
             k1= 1
c #De        k1= 2
        DO k=k1,mz
        DO i= 1,mx
          WKxzd(i,k)    = WKxzd(i,k) + pairNH(i,j,k)
        END DO
        END DO
C +
C +    *************
       call TURgau_v(1,mx,mmz)
C +    *************
C +
        DO k=1,mmz1
        DO i=1,mx
          pairNH(i,j,k) = WKxzx(i,k)
        END DO
        END DO
C +
C +
C +--Vertical Diffusion of Non Hydrostatic Vertical Wind Speed
C +  ==========================================================
C +
C +
C +--Tridiagonal Matrix Coefficients - wairNH 
C +  ----------------------------------------
C +
        DO k=1,mmz1
        DO i=1,mx
          FactK     =-beta  *gravi2 *0.5  /(pstDY2(i,j)    *dsig_1(k))
          WKxza(i,k)= FactK *(TUkvm (i,j,k)+TUkvm (i,j,kp1(k))
c _PE.                       +pente3(i,j,k)+pente3(i,j,kp1(k))
c #PE.                       +pente3(i,j,k)+pente3(i,j,kp1(k))
     .                     )* rolvDY(i,j,k)*romiDY(i,j,kp1(k))
     .                      * qsigm1(kp1(k))
          WKxzc(i,k)= FactK *(TUkvm (i,j,k)+TUkvm (i,j,km1(k))
c _PE.                       +pente3(i,j,k)+pente3(i,j,km1(k))
c #PE.                       +pente3(i,j,k)+pente3(i,j,km1(k))
     .                     )* rolvDY(i,j,k)*romiDY(i,j,km1(k))
     .                      * qsigm1(k)
        END DO
        END DO
C +
        DO i=1,mx
          WKxy1(i,j )=   sqrt(wairNH(i,j,mz)*wairNH(i,j,mz)
     .                       + ssvSL(i,j,mz)* ssvSL(i,j,mz))
          WKxy2(i,j )=         SLuus(i,j)   * SLuus(i,j)  /  WKxy1(i,j)
        END DO
C +
           k=  mmz
        DO i=1,mx
          WKxza(i,k)=(beta  *gravit       /(pstDY( i,j)    *dsig_1(k)))
     .                      * romiDY(i,j,k)*WKxy2( i,j)
c _PE     WKxza(i,k)= WKxza(i,k)
c _PE.              + FactK * rolvDY(i,j,k)*romiDY(i,j,k+1)*qsigm1(k+1)  
c _PE.                      *(pente3(i,j,k)+pente3(i,j,k+1))*0.5
c #PE     WKxza(i,k)= WKxza(i,k)
c #PE.              + FactK * rolvDY(i,j,k)*romiDY(i,j,k+1)*qsigm1(k+1)  
c #PE.                      *(pente3(i,j,k)+pente3(i,j,k+1))*0.5
          FactK     =-beta  *gravi2 *0.50 /(pstDY2(i,j)    *dsig_1(k))
          WKxzc(i,k)= FactK *(TUkvm (i,j,k)+TUkvm (i,j,k-1)
c _PE.                       +pente3(i,j,k)+pente3(i,j,k-1)
c #PE.                       +pente3(i,j,k)+pente3(i,j,k-1)
     .                     )* rolvDY(i,j,k)*romiDY(i,j,k-1)*qsigm1(k)
        END DO
C +
        DO k=1,mmz
        DO i=1,mx
          WKxza(i,k) =      WKxza(i,k) * dt_Loc
          WKxzc(i,k) =      WKxzc(i,k) * dt_Loc
          WKxzb(i,k) = 1.0 -WKxzc(i,k) -WKxza(i,k) 
        END DO
        END DO
C +
C +
C +--Second Member of the Tridiagonal System - wairNH
C +  ------------------------------------------------
C +
        DO i=1,mx
          WKxzd(i,1) = WKxza(i,1) *ab*(wairNH(i,j,1)-wairNH(i,j,kp1(1)))
c #De     WKxza(i,1) = 0.0
c #De     WKxzb(i,1) = 1.0
c #De     WKxzd(i,1) = 0.0
        END DO
C +
        DO k=1,mmz1
        DO i=1,mx
          WKxzd(i,k) = WKxza(i,k) *ab*(wairNH(i,j,k)-wairNH(i,j,kp1(k)))
     .                -WKxzc(i,k) *ab*(wairNH(i,j,km1(k))-wairNH(i,j,k))
        END DO
        END DO
C +
           k=  mmz
        DO i=1,mx
          WKxzd(i,k) = WKxza(i,k) *ab* wairNH(i,j,k)
     .                -WKxzc(i,k) *ab*(wairNH(i,j,km1(k))-wairNH(i,j,k))
        END DO
C +
C +
C +--Tridiagonal Matrix Inversion - wairNH 
C +  -------------------------------------
C +
             k1= 1
c #De        k1= 2
        DO k=k1,mz
        DO i=1 ,mx
          WKxzd(i,k)    = WKxzd(i,k) + wairNH(i,j,k)
        END DO
        END DO
C +
C +     *************
        call TURgau_v(1,mx,mmz)
C +     *************
C +
        DO k=1,mmz1
        DO i=1,mx
          wairNH(i,j,k) = WKxzx(i,k)
        END DO
        END DO
C +
      END DO
C +
C +
C +--Work Arrays Reset
C +  =================
C +
      DO k=1,mz
      DO i=1,mx
        WKxza(i,k) = 0.0
        WKxzb(i,k) = 0.0
        WKxzc(i,k) = 0.0
        WKxzd(i,k) = 0.0
        WKxzx(i,k) = 0.0
      END DO
      END DO
C +
      return
      end


      subroutine LBCnud_000(f_LBC0,iv_nu0,kd_nu0)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS LBC                                   Thu  3-12-2009  MAR |
C |   SubRoutine LBCnud_000 computes the Lateral Boundary Conditions       | 
C |              following the Davies (1976) scheme                        |
C |              assuming  zero Outer Fields                               |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT / OUTPUT : f_LBC0, i.e. w,pairNH, ccniHY, qi,qs,qr,qwHY        |
C |   ^^^^^^^^     for iv_nu0 =            3,      3,  3, 3, 3,   3)       |
C |                    f_LBC0 reevalued on a 5-points width boundary zone  |
C |                                                                        |
C |   INPUT:   iv_nu0: Index of the Variable to relax to Outer Conditions  |
C |   ^^^^^^   kd_nu0: Maximum Value of the k (vertical) Index             |
C |                                                                        |
C |   INPUT (via common block)                                             |
C |   ^^^^^    reaLBC: Input INI: Previous Dyn.Simulation (MAR .or. GCM)   |
C |            rxfact: Lateral Sponge Coefficient         (A89)            |
C |            rxLB,ryLB: Nudging Coefficient                              |
C |            Independant Term  used in the Implicit Scheme               |
C |                                                                        |
C |   REFER. : Davies, QJRMS 102, pp.405--418, 1976  (relation 11 p.409)   |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


!    Global Variables
!    ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_LB.inc'
      include 'MAR_WK.inc'

      real     f_LBC0(mx,my,mz)
      integer  iv_nu0,kd_nu0


!    Local  Variables
!    ================

      logical  relaxg

      real     fmag0g(6),fmag0d(6),fmag0b(6),fmag0h(6)
      data fmag0g/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
      data fmag0d/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
      data fmag0b/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
      data fmag0h/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
C +...     fmag0X:magnification factor (=>nudging selectively modified)

c #OG data relaxg/.false./
C +...     relaxg=.false.==> NO nudging  at the left boundary. 


!    x Boundaries
!    ============

      IF (mmx.gt.1)                                               THEN

c #OG   IF (relaxg)                                               THEN
          DO i=ip11,n6-1
          DO k=  1 ,kd_nu0
          DO j=jp11,my1
              f_LBC0(i,j,k) =  f_LBC0(i,j,k)
     .         /(1.0     +     fmag0g(iv_nu0)*rxLB(i))
          END DO
          END DO
          END DO
c #OG   END IF

          DO i=mx-n6+2,mx1
          DO k=  1    ,kd_nu0
          DO j=jp11   ,my1
              f_LBC0(i,j,k) =  f_LBC0(i,j,k)
     .         /(1.0     +     fmag0d(iv_nu0)*rxLB(i))
          END DO
          END DO
          END DO


!    Zero Gradient at x LBC if fmag0g,d = 0
!    --------------------------------------

          DO k=  1 ,kd_nu0
          DO j=jp11,my1
              f_LBC0( 1,j,k) = (1.-fmag0g(iv_nu0))*f_LBC0(ip11,j,k) ! 0-grad.
!    .                       +     fmag0g(iv_nu0) *f_LBC0(   1,j,k) ! 0 at x-LB
              f_LBC0(mx,j,k) = (1.-fmag0d(iv_nu0))*f_LBC0( mx1,j,k) ! 0-grad.
!    .                       +     fmag0d(iv_nu0) *f_LBC0( mx ,j,k) ! 0 at x-LB
          END DO
          END DO


!    Nudging to zero in in the lateral Sponge
!    ----------------------------------------

          DO i=ip11,n6-1
          DO k=  1 ,kd_nu0
          DO j=jp11,my1
            WKxyz1(i  ,j,k)  = f_LBC0(  i,j,k) + rxfact*rxLB(i) 
     .    *(f_LBC0(i+1,j,k)  + f_LBC0(i-1,j,k)     
     .     -f_LBC0(i  ,j,k)  - f_LBC0(i  ,j,k))
          END DO
          END DO
          END DO

          DO i=ip11,n6-1
          DO k=  1 ,kd_nu0
          DO j=jp11,my1
            f_LBC0(i  ,j,k)  = WKxyz1(i  ,j,k)
          END DO
          END DO
          END DO

          DO i=mx-n6+2,mx1
          DO k=  1    ,kd_nu0
          DO j=jp11   ,my1
            WKxyz1(i  ,j,k)  = f_LBC0(  i,j,k) + rxfact*rxLB(i) 
     .    *(f_LBC0(i+1,j,k)  + f_LBC0(i-1,j,k)     
     .     -f_LBC0(i  ,j,k)  - f_LBC0(i  ,j,k))
          END DO
          END DO
          END DO

          DO i=mx-n6+2,mx1
          DO k=  1    ,kd_nu0
          DO j=jp11   ,my1
            f_LBC0(i  ,j,k)  = WKxyz1(i  ,j,k)
          END DO
          END DO
          END DO


!    Zero Gradient at x LBC if fmag0g,d = 0
!    --------------------------------------

          DO k=  1 ,kd_nu0
          DO j=jp11,my1
              f_LBC0( 1,j,k) = (1.-fmag0g(iv_nu0))*f_LBC0(ip11,j,k) ! 0-grad.
!    .                       +     fmag0g(iv_nu0) *f_LBC0(   1,j,k) ! 0 at x-LB
              f_LBC0(mx,j,k) = (1.-fmag0d(iv_nu0))*f_LBC0( mx1,j,k) ! 0-grad.
!    .                       +     fmag0d(iv_nu0) *f_LBC0( mx ,j,k) ! 0 at x-LB
          END DO
          END DO

      END IF


!    y Boundaries
!    ============

      IF (mmy.gt.1)                                               THEN

          DO j=jp11,n6-1
          DO k=  1 ,kd_nu0
          DO i=  1 ,mx
            f_LBC0(i,j,k) = f_LBC0(i,j,k)
     .      /(1.0     +     fmag0b(iv_nu0)*ryLB(j))
          END DO
          END DO
          END DO

          DO j=my-n6+2,my1
          DO k=  1    ,kd_nu0
          DO i=  1    ,mx
            f_LBC0(i,j,k) = f_LBC0(i,j,k)
     .      /(1.0     +     fmag0h(iv_nu0)*ryLB(j))
          END DO
          END DO
          END DO


!    Zero Gradient at y LBC if fmag0b,h = 0
!    --------------------------------------

          DO k=  1 ,kd_nu0
          DO i=  1 ,mx
            f_LBC0(i, 1,k) = (1.-fmag0b(iv_nu0))*f_LBC0(i,jp11,k) ! 0-grad.
!    .                     +     fmag0b(iv_nu0) *f_LBC0(i,   1,k) ! 0 at y-LB
            f_LBC0(i,my,k) = (1.-fmag0h(iv_nu0))*f_LBC0(i, my1,k) ! 0-grad.
!    .                     +     fmag0h(iv_nu0) *f_LBC0(i, my ,k) ! 0 at y-LB
          END DO
          END DO


!    Nudging to zero in in the lateral Sponge
!    ----------------------------------------

          DO j=  2 ,n6-1
          DO k=  1 ,kd_nu0
          DO i=ip11,mx1
            WKxyz2(i,j,k) =f_LBC0(  i,j,k) + rxfact*ryLB(j) 
     .                  *( f_LBC0(i,j+1,k)  +f_LBC0(i,j-1,k)     
     .                   - f_LBC0(i,j  ,k)  -f_LBC0(i,j  ,k))
          END DO
          END DO
          END DO

          DO j=  2 ,n6-1
          DO k=  1 ,kd_nu0
          DO i=ip11,mx1
                f_LBC0(i,j,k) = WKxyz2(i,j,k)
          END DO
          END DO
          END DO

          DO j=my-n6+2,my1
          DO k=  1    ,kd_nu0
          DO i=ip11   ,mx1
            WKxyz2(i,j,k) =f_LBC0(  i,j,k) + rxfact*ryLB(j) 
     .                  *( f_LBC0(i,j+1,k)  +f_LBC0(i,j-1,k)     
     .                   - f_LBC0(i,j  ,k)  -f_LBC0(i,j  ,k))
          END DO
          END DO
          END DO

          DO j=my-n6+2,my1
          DO k=  1    ,kd_nu0
          DO i=ip11   ,mx1
            f_LBC0( i, j,k) = WKxyz2(i,j,k)
          END DO
          END DO
          END DO


!    Zero Gradient at y LBC if fmag0b,h = 0
!    --------------------------------------

          DO k=  1 ,kd_nu0
          DO j=jp11,my1
            f_LBC0(i, 1,k) = (1.-fmag0b(iv_nu0))*f_LBC0(i,jp11,k) ! 0-grad.
!    .                     +     fmag0b(iv_nu0) *f_LBC0(i,   1,k) ! 0 at y-LB
            f_LBC0(i,my,k) = (1.-fmag0h(iv_nu0))*f_LBC0(i, my1,k) ! 0-grad.
!    .                     +     fmag0h(iv_nu0) *f_LBC0(i, my ,k) ! 0 at y-LB
          END DO
          END DO

c #OB     DO k=  1 ,kd_nu0
c #OB       f_LBC0( 1, 1,k) = (f_LBC0( 1,jp11,k)+f_LBC0(ip11, 1,k))*0.5
c #OB       f_LBC0(mx, 1,k) = (f_LBC0(mx,jp11,k)+f_LBC0( mx1, 1,k))*0.5
c #OB       f_LBC0( 1,my,k) = (f_LBC0( 1, my1,k)+f_LBC0(ip11,my,k))*0.5
c #OB       f_LBC0(mx,my,k) = (f_LBC0(mx, my1,k)+f_LBC0( mx1,my,k))*0.5
c #OB     END DO

      END IF


C +--Work Arrays Reset
C +  =================

          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k) = 0.0
            WKxyz2(i,j,k) = 0.0
          END DO
          END DO
          END DO

      return
      end


      subroutine DYNwww 

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   DIAGNOSTICS                             16-07-2004  MAR |
C |   SubRoutine DYNwww computes Vertical Wind Speed wairDY (z Coordinate) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT  (via common block)                                            |
C |   ^^^^^   psigDY(i,j,k): Vertical Wind Speed (Sigma Coordinate system) |
C |                          on Level k                                    |
C |           uairDY(i,j,k): k Sigma Level Wind (x-direction)        [m/s] |
C |           vairDY(i,j,k): k Sigma Level Wind (y-direction)        [m/s] |
C |           gplvDY(i,j,k): k Sigma Level Geopotential            [m2/s2] |
C |           tairDY(i,j,k): k Sigma Level Temperature                 [K] |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^  wairDY(i,j,k)= -(R T /p) g dSigma /dt + (u dz /dx +v dz /dy) |
C |                                                                 [cm/s] |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_WK.inc'


C +--local   Variables
C +  =================

      include 'MARvec.inc'

      DO  k=1,mz


C +--u d(phi)/d(x)
C +  =============

        DO i=1,mx
        DO j=1,my
              WKxy1(i,j)  =
     .        fac43 *(gplvDY(ip1(i),j,k)-gplvDY(im1(i),j,k)
     .       -0.125 *(gplvDY(im2(i),j,k)-gplvDY(im2(i),j,k)))*dyinv2
c #vL   END DO
c #vL   END DO

c #vL   DO i=1,mx
c #vL   DO j=1,my
             WKxyz1(i,j,k)=  WKxy1(i,j) *uairDY(i,j,k)
        END DO
        END DO


C +--v d(phi)/d(y)
C +  =============

        IF (mmy.gt.1)                                             THEN
          DO j=1,my
          DO i=1,mx
              WKxy1(i,j)  =
     .        fac43 *(gplvDY(i,jp1(j),k)-gplvDY(i,jm1(j),k)
     .       -0.125 *(gplvDY(i,jp2(j),k)-gplvDY(i,jm2(j),k)))*dyinv2
c #vL     END DO
c #vL     END DO

c #vL     DO i=1,mx
c #vL     DO j=1,my
             WKxyz1(i,j,k)= WKxyz1(i,j,k) 
     .                    +  WKxy1(i,j) *vairDY(i,j,k)
          END DO
          END DO
        END IF

      END DO


C +--Vertical Wind Speed (cm/s)
C +  ==========================

      DO i=1,mx
      DO j=1,my
      DO k=1,mz
        wairDY(i,j,k)=-RDryAi*tairDY(i,j,k)*psigDY(i,j,k)*grvinv
     .               / (pstDY(i,j)*sigma(k)+ptopDY)             *100.
     .               + WKxyz1(i,j,k)                     *grvinv*100.
c #vL END DO
c #vL END DO
c #vL END DO

c #vL DO j=1,my
c #vL DO i=1,mx
c #vL DO k=1,mz
         WKxy1(i,j)  = 0.0
        WKxyz1(i,j,k)= 0.0
      END DO
      END DO
      END DO

      return
      end


      subroutine DYNadv_LFB(norder)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                     4-11-2004  MAR |
C |   SubRoutine DYNadv_LFB manages Leap-Frog Backward   Advection Scheme  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   ^^^^^^        iterun          : Long Time Step Counter               |
C |                 ntFast          : Time      Step Counter Maximum Value |
C |                 micphy          : Hydrometeors   Switch                |
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   OUTPUT        pktaDY(mx,my,mzz) Potent. Temperat. / p_0**kappa       |
C |   ^^^^^^          qvDY(mx,my,mz): Water Vapor  Concentration   [kg/kg] |
C |                 ccniHY(mx,my,mz): Ice crystals Number              [-] |
C |                   qiHY(mx,my,mz): Ice crystals Concentration   [kg/kg] |
C |                   qsHY(mx,my,mz): Snow  Flakes Concentration   [kg/kg] |
C |                   qwHY(mx,my,mz): Cloud Dropl. Concentration   [kg/kg] |
C |                   qrHY(mx,my,mz): Rain  Drops  Concentration   [kg/kg] |
C |   SEE DYNdgz:   uairDY(mx,my,mz): Wind  Speed  x-Direction       [m/s] |
C |                 vairDY(mx,my,mz): Wind  Speed  y-Direction       [m/s] |
C |                                                                        |
C |   METHOD:  2th order accurate Time       Scheme (leapfrog backw.) .AND.|
C |   ^^^^^^  (2th order accurate Horizontal Scheme on Arakawa A grid .OR. |
C |            4th order accurate Horizontal Scheme on Arakawa A grid     )|
C |            2th order          Vertical   Scheme                        |
C |                                                                        |
C |   CAUTION: This routine must be used                                   |
C |   ^^^^^^^  with a positive  definite restoring Procedure               |
C |            for    positive  definite Variables                         |
C |           (Such a Procedure is set up after digital filtering in MAR)  |
C |                                                                        |
C |   REFER.:  Use of  A grid: Purser   & Leslie,   1988, MWR 116, p.2069  |
C |   ^^^^^^   Time    Scheme: Haltiner & Williams, 1980, 5-2,     p.152   |
C |            Spatial Scheme: Haltiner & Williams, 1980, 5-6-5,   p.135   |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'

      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_SL.inc'
c #HY include 'MAR_HY.inc'
c #TC include 'MAR_TC.inc'

      integer  norder


C +--Local  Variables
C +  ================

      real         ff(mx,my,mzz)     ! Advected  Variable
      integer  ntSlow                ! Time      Step Counter Maximum Value
      integer  n


C +--DATA
C +  ====

               ntSlow = ntFast


C +--Advection of x-Momentum (uairDY)
C +  ================================

      qqmass = .FALSE.

!      DO   k=1,mz
!        DO j=1,my
!        DO i=1,mx
!            ff(i,j,k) =  uairDY(i,j,k)
!        END DO
!        END DO
!      END DO
!           k=  mzz
!        DO j=1,my
!        DO i=1,mx
!            ff(i,j,k) =  0.
!        END DO
!        END DO

!c #NV IF (no_vec)                                                  THEN
!C +                *************
!c #NV   call       DYNadv_LFB_2s(ntSlow,norder,ff)
!C +                *************
!c #NV ELSE

!C +                *************
!        call       DYNadv_LFB_2v(ntSlow,norder,ff)
!C +                *************

!c #NV END IF

!      DO   k=1,mz
!        DO j=1,my
!        DO i=1,mx
!          uairDY(i,j,k) =   ff(i,j,k)
!        END DO
!        END DO
!      END DO


!C +--Advection of y-Momentum (vairDY)
!C +  ================================

!      DO   k=1,mz
!        DO j=1,my
!        DO i=1,mx
!            ff(i,j,k) =  vairDY(i,j,k)
!        END DO
!        END DO
!      END DO
!           k=  mzz
!        DO j=1,my
!        DO i=1,mx
!            ff(i,j,k) =  0.
!        END DO
!        END DO

!c #NV IF (no_vec)                                                  THEN

!C +                *************
!c #NV   call       DYNadv_LFB_2s(ntSlow,norder,ff)
!C +                *************

!c #NV ELSE

!C +                *************
!        call       DYNadv_LFB_2v(ntSlow,norder,ff)
!C +                *************

!c #NV END IF

!      DO   k=1,mz
!        DO j=1,my
!        DO i=1,mx
!          vairDY(i,j,k) =   ff(i,j,k)
!        END DO
!        END DO
!      END DO


C +--Advection of Heat (pktaDY)
C +  ==========================

      qqmass = .FALSE.
      norder =  4

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
            ff(i,j,k) =  pktaDY(i,j,k)
        END DO
        END DO
      END DO
           k=  mzz
        DO j=1,my
        DO i=1,mx
            ff(i,j,k) =  pktaDY(i,j,k)
        END DO
        END DO

c #NV IF (no_vec)                                                  THEN
c #NV    if(openmp) then
C +                ****************
c #NV     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #NV    else
C +                *************
c #NV     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #NV    endif
c #NV ELSE

C +                *************
        call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                *************

c #NV END IF

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
          pktaDY(i,j,k) =   ff(i,j,k)
        END DO
        END DO
      END DO


C +--Advection of Water Vapor (qvDY)
C +  ===============================

      qqmass = .TRUE.

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
            ff(i,j,k) =    qvDY(i,j,k)
        END DO
        END DO
      END DO
           k=  mzz
        DO j=1,my
        DO i=1,mx
            ff(i,j,k) =  qvapSL(i,j)
        END DO
        END DO

c #NV IF (no_vec)                                                  THEN

c #NV    if(openmp) then
C +                ****************
c #NV     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #NV    else
C +                *************
c #NV     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #NV    endif

c #NV ELSE

C +                *************
        call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                *************

c #NV END IF

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
            qvDY(i,j,k) =   ff(i,j,k)
        END DO
        END DO
      END DO


C +--Advection of Ice Crystals Nb (ccniHY)
C +  =====================================

c #HY IF (micphy)                                                 THEN
c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =  ccniHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO
c #HY        k=  mzz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =       0.
c #HY     END DO
c #HY     END DO

c #hy   IF (no_vec)                                               THEN

c #hy    if(openmp) then
C +                ****************
c #hy     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #hy    else
C +                *************
c #hy     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #hy    endif

c #hy   ELSE

C +                  *************
c #HY     call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                  *************

c #hy   END IF

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       ccniHY(i,j,k) =   ff(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Advection of Cloud Crystals  (qiHY)
C +  ===================================

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =    qiHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO
c #HY        k=  mzz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =       0.
c #HY     END DO
c #HY     END DO

c #hy   IF (no_vec)                                               THEN

c #hy    if(openmp) then
C +                ****************
c #hy     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #hy    else
C +                *************
c #hy     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #hy    endif

c #hy   ELSE

C +                  *************
c #HY     call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                  *************

c #hy   END IF

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         qiHY(i,j,k) =   ff(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Advection of Snow  Flakes    (qsHY)
C +  ===================================

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =    qsHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO
c #HY        k=  mzz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =  qsrfHY(i,j)
c #HY     END DO
c #HY     END DO

c #hy   IF (no_vec)                                               THEN

c #hy    if(openmp) then
C +                ****************
c #hy     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #hy    else
C +                *************
c #hy     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #hy    endif

c #hy   ELSE

C +                  *************
c #HY     call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                  *************

c #hy   END IF

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         qsHY(i,j,k) =   ff(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Advection of Cloud Dropplets (qwHY)
C +  ===================================

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =    qwHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO
c #HY        k=  mzz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =       0.
c #HY     END DO
c #HY     END DO

c #hy   IF (no_vec)                                               THEN

c #hy    if(openmp) then
C +                ****************
c #hy     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #hy    else
C +                *************
c #hy     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #hy    endif

c #hy   ELSE

C +                  *************
c #HY     call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                  *************

c #hy   END IF

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         qwHY(i,j,k) =   ff(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Advection of Rain  Drops     (qrHY)
C +  ===================================

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =    qrHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO
c #HY        k=  mzz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         ff(i,j,k) =       0.
c #HY     END DO
c #HY     END DO

c #hy   IF (no_vec)                                               THEN

c #hy    if(openmp) then
C +                ****************
c #hy     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #hy    else
C +                *************
c #hy     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #hy    endif

c #hy   ELSE

C +                  *************
c #HY     call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                  *************

c #hy   END IF

c #HY   DO   k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY         qrHY(i,j,k) =   ff(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY END IF


C +--Advection of Tracers         (qxTC)
C +  ===================================

c #TC DO     n=1,ntrac
c #TC   DO   k=1,mz
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC         ff(i,j,k) =    qxTC(i,j,k,n)
c #TC     END DO
c #TC     END DO
c #TC   END DO
c #TC        k=  mzz
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC         ff(i,j,k) =       0.
c #TC     END DO
c #TC     END DO

c #tc   IF (no_vec)                                               THEN

c #tc    if(openmp) then
C +                ****************
c #tc     call     DYNadv_LFB_2p(ntSlow,norder,ff)
C +                ****************
c #tc    else
C +                *************
c #tc     call     DYNadv_LFB_2s   (ntSlow,norder,ff)
C +                *************
c #tc    endif

c #tc   ELSE

C +                  *************
c #TC     call       DYNadv_LFB_2v(ntSlow,norder,ff)
C +                  *************

c #tc   END IF

c #TC   DO   k=1,mz
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC         qxTC(i,j,k,n) =   ff(i,j,k)
c #TC     END DO
c #TC     END DO
c #TC   END DO
c #TC END DO

      return
      end


      subroutine DYNadv_LFB_2s(niSlow,nordAV,ffx)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    22-11-2006  MAR |
C |   SubRoutine DYNadv_LFB_2s solves Advection (LeapFrog Backward Scheme) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/        nnSlow          : Time      Step Counter Maximum Value |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   INPUT/   (via common block)                                          |
C |   ^^^^^^        qqmass          : Mass Conservation Switch (+def.var.) |
C |                 iterun          : Long Time Step Counter               |
C |                 dt              : Time Step                            |
C |                 opstDY(mx,my)   : MASS, Time Step n                    |
C |                 pstDYn(mx,my)   : MASS, Time Step n+1                  |
C |                 uairDY(mx,my,mz): Advection Vector: x-----Direction    |
C |                 vairDY(mx,my,mz): Advection Vector: y-----Direction    |
C |                 psigDY(mx,my,mz): Advection Vector: sigma-Direction    |
C |                                                                        |
C |   INPUT/            ff(mx,my,mz): Advected  Variable                   |
C |   OUTPUT                                                               |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   METHOD:  2th order accurate Time       Scheme (leapfrog backw.) .AND.|
C |   ^^^^^^  (2th order accurate Horizontal Scheme on Arakawa A grid .OR. |
C |            4th order accurate Horizontal Scheme on Arakawa A grid     )|
C |            2th order          Vertical   Scheme                        |
C |                                                                        |
C |            Robert Time Filter (for minimizing the computational mode)  |
C |                                                                        |
C |   CAUTION: This routine must be used                                   |
C |   ^^^^^^^  with a positive  definite restoring Procedure               |
C |            for    positive  definite Variables                         |
C |           (Such a Procedure is set up after digital filtering in MAR)  |
C |                                                                        |
C |   REFER.:  Use of  A grid: Purser   & Leslie,   1988, MWR 116, p.2069  |
C |   ^^^^^^   Time    Scheme: Haltiner & Williams, 1980, 5-2,     p.152   |
C |            Spatial Scheme: Haltiner & Williams, 1980, 5-6-5,   p.135   |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MARqqm.inc'

      include 'MAR_WK.inc'

      integer  niSlow                   ! Time      Step Counter Initial Value
      real        ffx(mx,my,mzz)        ! Advected  Variable (t=n)

      integer  nordAV


C +--Local  Variables
C +  ================

      logical                    daSlow ! Initialization Switch
      common  /DYNadv_LFB_2s_log/daSlow !
      real                       dtSlow ! Time Step
      common  /DYNadv_LFB_2s_rea/dtSlow !
      real     rtSlow                   !
      integer  itSlow                   ! Time Step Counter
      integer  nnSlow,n0Slow            !
      common  /DYNadv_LFB_2s_int/nnSlow !
      real        ffm1                  ! Advected  Variable (t=n-1)
      real        ffp1(mx,my,mzz)       ! Advected  Variable (t=n+1)
      real       dff                    ! Variable  Increment

      integer   kk
      real      summ,sumn

      logical   LFBord , FLhost

      data      LFBord /.FALSE./
      data      FLhost /.TRUE./


C +--Start the Leapfrog Backward Scheme
C +  ==================================

      IF (.NOT.daSlow)                                              THEN
               daSlow =.true.
               n0Slow = niSlow  ! previous           Nb of  Time Steps
      ELSE
               n0Slow = nnSlow  ! previous           Nb of  Time Steps
      END IF
               rtSlow = CFLzDY  ! minimum acceptable Nb of  Time Steps
                                ! in the leap-frog Backward Scheme

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
               rtSlow = max(rtSlow ,abs(uairDY(i,j,k))*2.0*dt/dx       )
               rtSlow = max(rtSlow ,abs(vairDY(i,j,k))*2.0*dt/dx       )
        END DO
        END DO
      END DO
               nnSlow =          rtSlow + 0.5
               nnSlow =      max(nnSlow , ntFast)
      IF  (mod(nnSlow,2).EQ.0)   nnSlow = nnSlow + 1
               dtSlow =  dt   / (nnSlow+1)

      IF (nnSlow.NE.n0Slow)                                         THEN
          write(6,6000)  nnSlow,dtSlow
 6000     format(/,'Advection Leap-Frog Backward Properties',
     .           /,' ntSlow = ',i6,
     .           /,' dtSlow = ',f9.2,/,1x)
      END IF


C +--Mass Conservation
C +  =================

      IF   (qqmass)                                                 THEN

            summ = 0.

       IF  (LFBord)                                                 THEN

        IF (nordAV.EQ.2)                                            THEN

         DO  k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k)*dtx
     .           *(uairDY(lgx ,j,k)
     .                     *(       ffx(lgx1,j,k)*opstDY(lgx1,j)
     .                             -ffx(lgx ,j,k)*opstDY(lgx ,j) )
     .            -uairDY(ldx ,j,k)
     .                     *(       ffx(ldx1,j,k)*opstDY(ldx1,j)
     .                             -ffx(ldx ,j,k)*opstDY(ldx ,j) ) )
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k)*dtx
     .           *(vairDY(i,lgy ,k)
     .                     *(       ffx(i,lgy1,k)*opstDY(i,lgy1)
     .                             -ffx(i,lgy ,k)*opstDY(i,lgy ) )
     .            -vairDY(i,ldy ,k)
     .                     *(       ffx(i,ldy1,k)*opstDY(i,ldy1)
     .                             -ffx(i,ldy ,k)*opstDY(i,ldy ) ) )
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

         END DO

        ELSE

         DO k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k)*dtx
     .           *(uairDY(lgx ,j,k)
     .                *f2_3*(      (ffx(lgx1,j,k)*opstDY(lgx1,j)
     .                             -ffx(lgx ,j,k)*opstDY(lgx ,j))
     .                      +0.125*(ffx(lgx ,j,k)*opstDY(lgx ,j)
     .                             -ffx(lgx2,j,k)*opstDY(lgx2,j)))
     .            +uairDY(lgxx,j,k)
     .                *f2_3* 0.125*(ffx(lgx ,j,k)*opstDY(lgx ,j)
     .                             -ffx(lgx1,j,k)*opstDY(lgx1,j))
     .            -uairDY(ldx ,j,k)
     .                *f2_3*(      (ffx(ldx1,j,k)*opstDY(ldx1,j)
     .                             -ffx(ldx ,j,k)*opstDY(ldx ,j))
     .                      +0.125*(ffx(ldx ,j,k)*opstDY(ldx ,j)
     .                             -ffx(ldx2,j,k)*opstDY(ldx2,j)))
     .            -uairDY(ldxx,j,k)
     .                *f2_3* 0.125*(ffx(ldx ,j,k)*opstDY(ldx ,j)
     .                             -ffx(ldx1,j,k)*opstDY(ldx1,j)))
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k)*dtx
     .           *(vairDY(i,lgy ,k)
     .                *f2_3*(      (ffx(i,lgy1,k)*opstDY(i,lgy1)
     .                             -ffx(i,lgy ,k)*opstDY(i,lgy ))
     .                      +0.125*(ffx(i,lgy ,k)*opstDY(i,lgy )
     .                             -ffx(i,lgy2,k)*opstDY(i,lgy2)))
     .            +vairDY(i,lgyy,k)
     .                *f2_3* 0.125*(ffx(i,lgy ,k)*opstDY(i,lgy )
     .                             -ffx(i,lgy1,k)*opstDY(i,lgy1))
     .            -vairDY(i,ldy ,k)
     .                *f2_3*(      (ffx(i,ldy1,k)*opstDY(i,ldy1)
     .                             -ffx(i,ldy ,k)*opstDY(i,ldy ))
     .                      +0.125*(ffx(i,ldy ,k)*opstDY(i,ldy )
     .                             -ffx(i,ldy2,k)*opstDY(i,ldy2)))
     .            -vairDY(i,ldyy,k)
     .                *f2_3* 0.125*(ffx(i,ldy ,k)*opstDY(i,ldy )
     .                             -ffx(i,ldy1,k)*opstDY(i,ldy1)))
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

         END DO

        ENDIF

       ELSE IF (FLhost)                                            THEN

        DO   k=1,mz
          DO j=1,my
            summ = summ + dsigm1(k) * dtx             *dsigm1(       k)
     .                  *(opstDY(1   ,j)*ffx(1   ,j,k)*uairDY(1   ,j,k)
     .                   -opstDY(mx  ,j)*ffx(mx  ,j,k)*uairDY(mx  ,j,k))
          END DO

          DO i=1,mx
            summ = summ + dsigm1(k) * dtx             *dsigm1(       k)
     .                  *(opstDY(i,1   )*ffx(i,1   ,k)*vairDY(i,1   ,k)
     .                   -opstDY(i,my  )*ffx(i,my  ,k)*vairDY(i,my  ,k))
          END DO

          DO j=1,my
          DO i=1,mx
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

        END DO

       ELSE

        DO   k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k) * dtx
     .                  *(opstDY(lgx ,j)*ffx(lgx ,j,k)*uairDY(lgx ,j,k)
     .                   -opstDY(ldx ,j)*ffx(ldx ,j,k)*uairDY(ldx ,j,k))
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k) * dtx
     .                  *(opstDY(i,lgy )*ffx(i,lgy ,k)*vairDY(i,lgy ,k)
     .                   -opstDY(i,ldy )*ffx(i,ldy ,k)*vairDY(i,ldy ,k))
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

        END DO

       END IF

      END IF


C +--Start Leap-Frog Backward
C +  ========================

      DO  itSlow =  1 ,  nnSlow+1


C +--Mass Divergence
C +  ===============

C +--2th centered Differences  / sigma-Direction  / Energy conserving
C +  --- (Haltiner and Williams, 1980, 7.2.2, Eqn. (7-47b) p.220) ---
C +      --------------------------------------------------------

C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~
          DO       k=   1,mz
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz6(i,j,k)=      ffx(i,j,k)-        ffx(i,j,kp1(k))
            END DO
            END DO
          END DO

          DO       k=   2,mz
                   kk=km1(k)
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz7(i,j,k)=   wsigDY(i,j,kk)
              WKxyz8(i,j,k)=   WKxyz6(i,j,kk)
            END DO
            END DO
          END DO

                   k=   1
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz3(i,j,k)=   WKxyz6(i,j,k)     *wsigDY(i,j,k)  
     .                        *0.5               /dsigm1(1)
            END DO
            END DO
          DO       k=   2,mz
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz3(i,j,k)=  (WKxyz6(i,j,k)     *wsigDY(i,j,k)
     .                        +WKxyz8(i,j,k)     *WKxyz7(i,j,k))
     .                        *0.5               /dsigm1(k)
            END DO
            END DO
          END DO


C +--Mass Update (Leapfrog-Backward)
C +  ===============================

        IF  (itSlow.eq.1)                                           THEN
          IF(nordAV.EQ.2)                                           THEN
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2          *  (
     .                 ffx(im1(i),j,k)-ffx(ip1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2          *  (
     .                 ffx(i,jm1(j),k)-ffx(i,jp1(j),k)       )
     .                     +WKxyz3(i,j,k)                     )
     .                      *dtSlow
               ffx(i,j,k)  =     ffx(i,j,k) + dff
              ffp1(i,j,k)  =     ffx(i,j,k) + dff + dff
            END DO
            END DO
            END DO
          ELSE
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2 * fac43  *  (
     .          0.125*(ffx(ip2(i),j,k)-ffx(im2(i),j,k))
     .                -ffx(ip1(i),j,k)+ffx(im1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2 * fac43  *  (
     .          0.125*(ffx(i,jp2(j),k)-ffx(i,jm2(j),k))
     .                -ffx(i,jp1(j),k)+ffx(i,jm1(j),k)       )
     .                     +WKxyz3(i,j,k)                     )
     .                      *dtSlow
               ffx(i,j,k)  =     ffx(i,j,k) + dff
              ffp1(i,j,k)  =     ffx(i,j,k) + dff + dff
            END DO
            END DO
            END DO
          ENDIF
        ELSE
          IF (itSlow.LE.nnSlow)                                     THEN
           IF(nordAV.EQ.2)                                          THEN
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2          *  (
     .                 ffx(im1(i),j,k)-ffx(ip1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2          *  (
     .                 ffx(i,jp1(j),k)-ffx(i,jp1(j),k)       )
     .                     +WKxyz3(i,j,k)                     )
     .                      *dtSlow
              ffm1         =    ffx(i,j,k)
               ffx(i,j,k)  =   ffp1(i,j,k)
              ffp1(i,j,k)  =   ffm1        + dff + dff

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt          ffx(i,j,k)  =    ffx(i,j,k)+ 
c #rt.            Robert*(0.5*(ffp1(i,j,k)+ffm1)-ffx(i,j,k))
            END DO
            END DO
            END DO
           ELSE
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2 * fac43  *  (
     .          0.125*(ffx(ip2(i),j,k)-ffx(im2(i),j,k))
     .                -ffx(ip1(i),j,k)+ffx(im1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2 * fac43  *  (
     .          0.125*(ffx(i,jp2(j),k)-ffx(i,jm2(j),k))
     .                -ffx(i,jp1(j),k)+ffx(i,jm1(j),k)       )
     .                     +WKxyz3(i,j,k)                     )
     .                      *dtSlow
              ffm1         =    ffx(i,j,k)
               ffx(i,j,k)  =   ffp1(i,j,k)
              ffp1(i,j,k)  =   ffm1        + dff + dff

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt          ffx(i,j,k)  =    ffx(i,j,k)+ 
c #rt.            Robert*(0.5*(ffp1(i,j,k)+ffm1)-ffx(i,j,k))
            END DO
            END DO
            END DO
           ENDIF
          ELSE
           IF(nordAV.EQ.2)                                          THEN
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2          *  (
     .                 ffx(im1(i),j,k)-ffx(ip1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2          *  (
     .                 ffx(i,jm1(j),k)-ffx(i,jp1(j),k)       )
     .                     +WKxyz3(i,j,k)                     )
     .                      *dtSlow
                ffx(i,j,k)  =     ffx(i,j,k) + dff
            END DO
            END DO
            END DO
           ELSE
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2 * fac43  *  (
     .          0.125*(ffx(ip2(i),j,k)-ffx(im2(i),j,k))
     .                -ffx(ip1(i),j,k)+ffx(im1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2 * fac43  *  (
     .          0.125*(ffx(i,jp2(j),k)-ffx(i,jm2(j),k))
     .                -ffx(i,jp1(j),k)+ffx(i,jm1(j),k)       )
     .                     +WKxyz3(i,j,k)                     )
     .                      *dtSlow
                ffx(i,j,k)  =     ffx(i,j,k) + dff
            END DO
            END DO
            END DO
           ENDIF
C +***     Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

          END IF
        END IF

      END DO


C +--Work Arrays Reset
C +  =================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz3(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
        END DO
        END DO
        END DO


C +--Mass Conservation
C +  =================

      IF (qqmass)                                                   THEN
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            ffx(i,j,k) = max(zero,                         ffx(i,j,k))
          END DO
          END DO
          END DO

            sumn = 0.
        IF (FLhost)                                                 THEN
          DO k=1,mz
          DO j=1   ,my  
          DO i=1   ,mx  
            sumn       =     sumn +pstDYn(i,j) *dsigm1(k) *ffx(i,j,k)
          END DO
          END DO
          END DO
        ELSE  
          DO k=1,mz
          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            sumn       =     sumn +pstDYn(i,j) *dsigm1(k) *ffx(i,j,k)
          END DO
          END DO
          END DO
        END IF
        IF (sumn.gt.zero)                                           THEN
            summ  =  summ  / sumn
c           summ  =  summ / min(1., summ + 0.001) ! for increasing precipitation
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            ffx(i,j,k) =     summ                         *ffx(i,j,k)
          END DO
          END DO
          END DO
        END IF

      END IF

      return
      end


      subroutine DYNadv_LFB_2p(niSlow,nordAV,ffx)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    22-11-2006  MAR |
C |   SubRoutine DYNadv_LFB_2s solves Advection (LeapFrog Backward Scheme) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/        nnSlow          : Time      Step Counter Maximum Value |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   INPUT/   (via common block)                                          |
C |   ^^^^^^        qqmass          : Mass Conservation Switch (+def.var.) |
C |                 iterun          : Long Time Step Counter               |
C |                 dt              : Time Step                            |
C |                 opstDY(mx,my)   : MASS, Time Step n                    |
C |                 pstDYn(mx,my)   : MASS, Time Step n+1                  |
C |                 uairDY(mx,my,mz): Advection Vector: x-----Direction    |
C |                 vairDY(mx,my,mz): Advection Vector: y-----Direction    |
C |                 psigDY(mx,my,mz): Advection Vector: sigma-Direction    |
C |                                                                        |
C |   INPUT/            ff(mx,my,mz): Advected  Variable                   |
C |   OUTPUT                                                               |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   METHOD:  2th order accurate Time       Scheme (leapfrog backw.) .AND.|
C |   ^^^^^^  (2th order accurate Horizontal Scheme on Arakawa A grid .OR. |
C |            4th order accurate Horizontal Scheme on Arakawa A grid     )|
C |            2th order          Vertical   Scheme                        |
C |                                                                        |
C |            Robert Time Filter (for minimizing the computational mode)  |
C |                                                                        |
C |   CAUTION: This routine must be used                                   |
C |   ^^^^^^^  with a positive  definite restoring Procedure               |
C |            for    positive  definite Variables                         |
C |           (Such a Procedure is set up after digital filtering in MAR)  |
C |                                                                        |
C |   REFER.:  Use of  A grid: Purser   & Leslie,   1988, MWR 116, p.2069  |
C |   ^^^^^^   Time    Scheme: Haltiner & Williams, 1980, 5-2,     p.152   |
C |            Spatial Scheme: Haltiner & Williams, 1980, 5-6-5,   p.135   |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MARqqm.inc'

      include 'MAR_WK.inc'

      integer  niSlow                   ! Time      Step Counter Initial Value
      real        ffx(mx,my,mzz)        ! Advected  Variable (t=n)

      integer  nordAV


C +--Local  Variables
C +  ================

      logical                    daSlow ! Initialization Switch
      common  /DYNadv_LFB_2s_log/daSlow !
      real                       dtSlow ! Time Step
      common  /DYNadv_LFB_2s_rea/dtSlow !
      real     rtSlow                   !
      integer  itSlow                   ! Time Step Counter
      integer  nnSlow,n0Slow            !
      common  /DYNadv_LFB_2s_int/nnSlow !
      real        ffm1                  ! Advected  Variable (t=n-1)
      real        ffp1(mx,my,mzz)       ! Advected  Variable (t=n+1)
      real       dff                    ! Variable  Increment

      integer   kk
      real      summ,sumn

      logical   LFBord , FLhost

      data      LFBord /.FALSE./
      data      FLhost /.TRUE./


C +--Start the Leapfrog Backward Scheme
C +  ==================================

      IF   (.not.qqmass)                                            THEN

      IF (.NOT.daSlow)                                              THEN
               daSlow =.true.
               n0Slow = niSlow  ! previous           Nb of  Time Steps
      ELSE
               n0Slow = nnSlow  ! previous           Nb of  Time Steps
      END IF
               rtSlow = CFLzDY  ! minimum acceptable Nb of  Time Steps
                                ! in the leap-frog Backward Scheme

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
               rtSlow = max(rtSlow ,abs(uairDY(i,j,k))*2.0*dt/dx       )
               rtSlow = max(rtSlow ,abs(vairDY(i,j,k))*2.0*dt/dx       )
        END DO
        END DO
      END DO
               nnSlow =          rtSlow + 0.5
               nnSlow =      max(nnSlow , ntFast)
      IF  (mod(nnSlow,2).EQ.0)   nnSlow = nnSlow + 1
               dtSlow =  dt   / (nnSlow+1)

      IF (nnSlow.NE.n0Slow)                                         THEN
          write(6,6000)  nnSlow,dtSlow
 6000     format(/,'Advection Leap-Frog Backward Properties',
     .           /,' ntSlow = ',i6,
     .           /,' dtSlow = ',f9.2,/,1x)
      END IF

      ENDIF

C +--Mass Conservation
C +  =================

      IF   (qqmass)                                                 THEN

            summ = 0.
!$OMP PARALLEL DO REDUCTION(+: summ) private(i,j,k)
      DO  k=1,mz

       IF  (LFBord)                                                 THEN

        IF (nordAV.EQ.2)                                            THEN

c         DO  k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k)*dtx
     .           *(uairDY(lgx ,j,k)
     .                     *(       ffx(lgx1,j,k)*opstDY(lgx1,j)
     .                             -ffx(lgx ,j,k)*opstDY(lgx ,j) )
     .            -uairDY(ldx ,j,k)
     .                     *(       ffx(ldx1,j,k)*opstDY(ldx1,j)
     .                             -ffx(ldx ,j,k)*opstDY(ldx ,j) ) )
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k)*dtx
     .           *(vairDY(i,lgy ,k)
     .                     *(       ffx(i,lgy1,k)*opstDY(i,lgy1)
     .                             -ffx(i,lgy ,k)*opstDY(i,lgy ) )
     .            -vairDY(i,ldy ,k)
     .                     *(       ffx(i,ldy1,k)*opstDY(i,ldy1)
     .                             -ffx(i,ldy ,k)*opstDY(i,ldy ) ) )
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

c         END DO

        ELSE

c         DO k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k)*dtx
     .           *(uairDY(lgx ,j,k)
     .                *f2_3*(      (ffx(lgx1,j,k)*opstDY(lgx1,j)
     .                             -ffx(lgx ,j,k)*opstDY(lgx ,j))
     .                      +0.125*(ffx(lgx ,j,k)*opstDY(lgx ,j)
     .                             -ffx(lgx2,j,k)*opstDY(lgx2,j)))
     .            +uairDY(lgxx,j,k)
     .                *f2_3* 0.125*(ffx(lgx ,j,k)*opstDY(lgx ,j)
     .                             -ffx(lgx1,j,k)*opstDY(lgx1,j))
     .            -uairDY(ldx ,j,k)
     .                *f2_3*(      (ffx(ldx1,j,k)*opstDY(ldx1,j)
     .                             -ffx(ldx ,j,k)*opstDY(ldx ,j))
     .                      +0.125*(ffx(ldx ,j,k)*opstDY(ldx ,j)
     .                             -ffx(ldx2,j,k)*opstDY(ldx2,j)))
     .            -uairDY(ldxx,j,k)
     .                *f2_3* 0.125*(ffx(ldx ,j,k)*opstDY(ldx ,j)
     .                             -ffx(ldx1,j,k)*opstDY(ldx1,j)))
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k)*dtx
     .           *(vairDY(i,lgy ,k)
     .                *f2_3*(      (ffx(i,lgy1,k)*opstDY(i,lgy1)
     .                             -ffx(i,lgy ,k)*opstDY(i,lgy ))
     .                      +0.125*(ffx(i,lgy ,k)*opstDY(i,lgy )
     .                             -ffx(i,lgy2,k)*opstDY(i,lgy2)))
     .            +vairDY(i,lgyy,k)
     .                *f2_3* 0.125*(ffx(i,lgy ,k)*opstDY(i,lgy )
     .                             -ffx(i,lgy1,k)*opstDY(i,lgy1))
     .            -vairDY(i,ldy ,k)
     .                *f2_3*(      (ffx(i,ldy1,k)*opstDY(i,ldy1)
     .                             -ffx(i,ldy ,k)*opstDY(i,ldy ))
     .                      +0.125*(ffx(i,ldy ,k)*opstDY(i,ldy )
     .                             -ffx(i,ldy2,k)*opstDY(i,ldy2)))
     .            -vairDY(i,ldyy,k)
     .                *f2_3* 0.125*(ffx(i,ldy ,k)*opstDY(i,ldy )
     .                             -ffx(i,ldy1,k)*opstDY(i,ldy1)))
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

c         END DO

        ENDIF

       ELSE IF (FLhost)                                            THEN

c        DO   k=1,mz
          DO j=1,my
            summ = summ + dsigm1(k) * dtx             *dsigm1(       k)
     .                  *(opstDY(1   ,j)*ffx(1   ,j,k)*uairDY(1   ,j,k)
     .                   -opstDY(mx  ,j)*ffx(mx  ,j,k)*uairDY(mx  ,j,k))
          END DO

          DO i=1,mx
            summ = summ + dsigm1(k) * dtx             *dsigm1(       k)
     .                  *(opstDY(i,1   )*ffx(i,1   ,k)*vairDY(i,1   ,k)
     .                   -opstDY(i,my  )*ffx(i,my  ,k)*vairDY(i,my  ,k))
          END DO

          DO j=1,my
          DO i=1,mx
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

c        END DO

       ELSE

c        DO   k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k) * dtx
     .                  *(opstDY(lgx ,j)*ffx(lgx ,j,k)*uairDY(lgx ,j,k)
     .                   -opstDY(ldx ,j)*ffx(ldx ,j,k)*uairDY(ldx ,j,k))
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k) * dtx
     .                  *(opstDY(i,lgy )*ffx(i,lgy ,k)*vairDY(i,lgy ,k)
     .                   -opstDY(i,ldy )*ffx(i,ldy ,k)*vairDY(i,ldy ,k))
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

c        END DO

       END IF

       ENDDO
!$OMP END PARALLEL DO

      END IF


C +--Start Leap-Frog Backward
C +  ========================

      DO  itSlow =  1 ,  nnSlow+1


C +--Mass Divergence
C +  ===============

C +--2th centered Differences  / sigma-Direction  / Energy conserving
C +  --- (Haltiner and Williams, 1980, 7.2.2, Eqn. (7-47b) p.220) ---
C +      --------------------------------------------------------

C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~

!$OMP PARALLEL DO private (i,j,k)
            DO     j=jp11,my1
          DO       k=   1,mz
c            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz6(i,j,k)=      ffx(i,j,k)-        ffx(i,j,kp1(k))
            END DO
c            END DO
          END DO

          DO       k=   2,mz
                   kk=km1(k)
c            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz7(i,j,k)=   wsigDY(i,j,kk)
              WTxyz8(i,j,k)=   WTxyz6(i,j,kk)
            END DO
c            END DO
          END DO

                   k=   1
c            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz3(i,j,k)=   WTxyz6(i,j,k)     *wsigDY(i,j,k)  
     .                        *0.5               /dsigm1(1)
c            END DO
            END DO
          DO       k=   2,mz
c            DO     j=jp11,my1
            DO     i=ip11,mx1
              WTxyz3(i,j,k)=  (WTxyz6(i,j,k)     *wsigDY(i,j,k)
     .                        +WTxyz8(i,j,k)     *WTxyz7(i,j,k))
     .                        *0.5               /dsigm1(k)
            END DO
            END DO
          END DO
!$OMP END PARALLEL DO


C +--Mass Update (Leapfrog-Backward)
C +  ===============================

!$OMP PARALLEL DO private(i,j,k,dff,ffm1)
            DO k=   1,mz
        IF  (itSlow.eq.1)                                           THEN
          IF(nordAV.EQ.2)                                           THEN
c            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2          *  (
     .                 ffx(im1(i),j,k)-ffx(ip1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2          *  (
     .                 ffx(i,jm1(j),k)-ffx(i,jp1(j),k)       )
     .                     +WTxyz3(i,j,k)                     )
     .                      *dtSlow
               ffx(i,j,k)  =     ffx(i,j,k) + dff
              ffp1(i,j,k)  =     ffx(i,j,k) + dff + dff
            END DO
            END DO
c            END DO
          ELSE
c            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2 * fac43  *  (
     .          0.125*(ffx(ip2(i),j,k)-ffx(im2(i),j,k))
     .                -ffx(ip1(i),j,k)+ffx(im1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2 * fac43  *  (
     .          0.125*(ffx(i,jp2(j),k)-ffx(i,jm2(j),k))
     .                -ffx(i,jp1(j),k)+ffx(i,jm1(j),k)       )
     .                     +WTxyz3(i,j,k)                     )
     .                      *dtSlow
               ffx(i,j,k)  =     ffx(i,j,k) + dff
              ffp1(i,j,k)  =     ffx(i,j,k) + dff + dff
            END DO
            END DO
c            END DO
          ENDIF
        ELSE
          IF (itSlow.LE.nnSlow)                                     THEN
           IF(nordAV.EQ.2)                                          THEN
c            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2          *  (
     .                 ffx(im1(i),j,k)-ffx(ip1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2          *  (
     .                 ffx(i,jp1(j),k)-ffx(i,jp1(j),k)       )
     .                     +WTxyz3(i,j,k)                     )
     .                      *dtSlow
              ffm1         =    ffx(i,j,k)
               ffx(i,j,k)  =   ffp1(i,j,k)
              ffp1(i,j,k)  =   ffm1        + dff + dff

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt          ffx(i,j,k)  =    ffx(i,j,k)+ 
c #rt.            Robert*(0.5*(ffp1(i,j,k)+ffm1)-ffx(i,j,k))
            END DO
            END DO
c            END DO
           ELSE
c            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2 * fac43  *  (
     .          0.125*(ffx(ip2(i),j,k)-ffx(im2(i),j,k))
     .                -ffx(ip1(i),j,k)+ffx(im1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2 * fac43  *  (
     .          0.125*(ffx(i,jp2(j),k)-ffx(i,jm2(j),k))
     .                -ffx(i,jp1(j),k)+ffx(i,jm1(j),k)       )
     .                     +WTxyz3(i,j,k)                     )
     .                      *dtSlow
              ffm1         =    ffx(i,j,k)
               ffx(i,j,k)  =   ffp1(i,j,k)
              ffp1(i,j,k)  =   ffm1        + dff + dff

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt          ffx(i,j,k)  =    ffx(i,j,k)+ 
c #rt.            Robert*(0.5*(ffp1(i,j,k)+ffm1)-ffx(i,j,k))
            END DO
            END DO
c            END DO
           ENDIF
          ELSE
           IF(nordAV.EQ.2)                                          THEN
c            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2          *  (
     .                 ffx(im1(i),j,k)-ffx(ip1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2          *  (
     .                 ffx(i,jm1(j),k)-ffx(i,jp1(j),k)       )
     .                     +WTxyz3(i,j,k)                     )
     .                      *dtSlow
                ffx(i,j,k)  =     ffx(i,j,k) + dff
            END DO
            END DO
c            END DO
           ELSE
c            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(
     .                      uairDY(i,j,k)*dxinv2 * fac43  *  (
     .          0.125*(ffx(ip2(i),j,k)-ffx(im2(i),j,k))
     .                -ffx(ip1(i),j,k)+ffx(im1(i),j,k)       )
     .                     +vairDY(i,j,k)*dyinv2 * fac43  *  (
     .          0.125*(ffx(i,jp2(j),k)-ffx(i,jm2(j),k))
     .                -ffx(i,jp1(j),k)+ffx(i,jm1(j),k)       )
     .                     +WTxyz3(i,j,k)                     )
     .                      *dtSlow
                ffx(i,j,k)  =     ffx(i,j,k) + dff
            END DO
            END DO
c            END DO
           ENDIF
C +***     Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

          END IF
        END IF
        END DO
!$OMP END PARALLEL DO

      END DO

C +--Mass Conservation
C +  =================

      IF (qqmass)                                                   THEN

            sumn = 0.

!$OMP PARALLEL DO REDUCTION(+: sumn) private(i,j,k)
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            ffx(i,j,k) = max(zero,                         ffx(i,j,k))
          END DO
          END DO
c          END DO

        IF (FLhost)                                                 THEN
c          DO k=1,mz
          DO j=1   ,my  
          DO i=1   ,mx  
            sumn       =     sumn +pstDYn(i,j) *dsigm1(k) *ffx(i,j,k)
          END DO
          END DO
c          END DO
        ELSE  
c          DO k=1,mz
          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            sumn       =     sumn +pstDYn(i,j) *dsigm1(k) *ffx(i,j,k)
          END DO
          END DO
c          END DO
        END IF
       ENDDO
!$OMP END PARALLEL DO

        IF (sumn.gt.zero)                                           THEN
            summ  =  summ  / sumn
c           summ  =  summ / min(1., summ + 0.001) ! for increasing precipitation
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            ffx(i,j,k) =     summ                         *ffx(i,j,k)
          END DO
          END DO
          END DO
        END IF

      END IF

      return
      end


      subroutine DYNadv_LFB_2v(niSlow,nordAV,ffx)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    22-11-2006  MAR |
C |   SubRoutine DYNadv_LFB_2v solves Advection (LeapFrog Backward Scheme) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT/        qqmass          : Mass Conservation Switch (+def.var.) |
C |   ^^^^^^        iterun          : Long Time Step Counter               |
C |                 nnSlow          : Time      Step Counter Maximum Value |
C |                                                                        |
C |   INPUT/  (via common block)                                           |
C |   ^^^^^^        dt              : Time Step                            |
C |                 opstDY(mx,my)   : MASS, Time Step n                    |
C |                 pstDYn(mx,my)   : MASS, Time Step n+1                  |
C |                 uairDY(mx,my,mz): Advection Vector: x-----Direction    |
C |                 vairDY(mx,my,mz): Advection Vector: y-----Direction    |
C |                 psigDY(mx,my,mz): Advection Vector: sigma-Direction    |
C |                                                                        |
C |   INPUT/           ffx(mx,my,mz): Advected  Variable                   |
C |   OUTPUT                                                               |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   METHOD:  2th order accurate Time       Scheme (leapfrog backw.) .AND.|
C |   ^^^^^^  (2th order accurate Horizontal Scheme on Arakawa A grid .OR. |
C |            4th order accurate Horizontal Scheme on Arakawa A grid     )|
C |            2th order          Vertical   Scheme                        |
C |                                                                        |
C |            Robert Time Filter (for minimizing the computational mode)  |
C |                                                                        |
C |   CAUTION: This routine must be used                                   |
C |   ^^^^^^^  with a positive  definite restoring Procedure               |
C |            for    positive  definite Variables                         |
C |           (Such a Procedure is set up after digital filtering in MAR)  |
C |                                                                        |
C |   REFER.:  Use of  A grid: Purser   & Leslie,   1988, MWR 116, p.2069  |
C |   ^^^^^^   Time    Scheme: Haltiner & Williams, 1980, 5-2,     p.152   |
C |            Spatial Scheme: Haltiner & Williams, 1980, 5-6-5,   p.135   |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MARqqm.inc'

      include 'MAR_WK.inc'

      integer  niSlow                   ! Time      Step Counter Maximum Value
      real        ffx(mx,my,mzz)        ! Advected  Variable (t=n)

      integer  nordAV


C +--Local  Variables
C +  ================

      logical                    daSlow ! Initialization Switch
      common  /DYNadv_LFB_2v_log/daSlow !
      real                       dtSlow ! Time Step
      common  /DYNadv_LFB_2v_rea/dtSlow !
      real     rtSlow                   !
      integer  itSlow                   ! Time Step Counter
      integer  nnSlow,n0Slow            !
      common  /DYNadv_LFB_2v_int/nnSlow !

      real        ffm1                  ! Advected  Variable (t=n-1)
      real        ffp1(mx,my,mzz)       ! Advected  Variable (t=n+1)
      real       dff                    ! Variable  Increment

      integer   kk  ,ip2s,ip1s,im1s,im2s,jp2s,jp1s,jm1s,jm2s

      real      summ,sumn

      logical   LFBord , FLhost

      data      LFBord /.FALSE./
      data      FLhost /.TRUE./


C +--Start the Leapfrog Backward Scheme
C +  ==================================

      IF (.NOT.daSlow)                                              THEN
               daSlow =.true.
               n0Slow = niSlow  ! previous           Nb of  Time Steps
      ELSE
               n0Slow = nnSlow  ! previous           Nb of  Time Steps
      END IF
               rtSlow = CFLzDY  ! minimum acceptable Nb of  Time Steps
                                ! in the leap-frog Backward Scheme

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
               rtSlow = max(rtSlow ,abs(uairDY(i,j,k))*2.0*dt/dx       )
               rtSlow = max(rtSlow ,abs(vairDY(i,j,k))*2.0*dt/dx       )
        END DO
        END DO
      END DO
               nnSlow =          rtSlow + 0.5
               nnSlow =      max(nnSlow , ntFast)
      IF  (mod(nnSlow,2).EQ.0)   nnSlow = nnSlow + 1
               dtSlow =  dt   / (nnSlow+1)

      IF (nnSlow.NE.n0Slow)                                         THEN
          write(6,6000)  nnSlow,dtSlow
 6000     format(/,'Advection Leap-Frog Backward Properties',
     .           /,' ntSlow = ',i6,
     .           /,' dtSlow = ',f9.2,/,1x)
      END IF


C +--Mass Conservation
C +  =================

      IF (qqmass)                                                   THEN
            summ = 0.
       IF(LFBord)                                                   THEN
        DO   k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k)*dtx
     .           *(uairDY(lgx ,j,k)
     .                *f2_3*(      (ffx(lgx1,j,k)*opstDY(lgx1,j)
     .                             -ffx(lgx ,j,k)*opstDY(lgx ,j))
     .                      +0.125*(ffx(lgx ,j,k)*opstDY(lgx ,j)
     .                             -ffx(lgx2,j,k)*opstDY(lgx2,j)))
     .            +uairDY(lgxx,j,k)
     .                *f2_3* 0.125*(ffx(lgx ,j,k)*opstDY(lgx ,j)
     .                             -ffx(lgx1,j,k)*opstDY(lgx1,j))
     .            -uairDY(ldx ,j,k)
     .                *f2_3*(      (ffx(ldx1,j,k)*opstDY(ldx1,j)
     .                             -ffx(ldx ,j,k)*opstDY(ldx ,j))
     .                      +0.125*(ffx(ldx ,j,k)*opstDY(ldx ,j)
     .                             -ffx(ldx2,j,k)*opstDY(ldx2,j)))
     .            -uairDY(ldxx,j,k)
     .                *f2_3* 0.125*(ffx(ldx ,j,k)*opstDY(ldx ,j)
     .                             -ffx(ldx1,j,k)*opstDY(ldx1,j)))
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k)*dtx
     .           *(vairDY(i,lgy ,k)
     .                *f2_3*(      (ffx(i,lgy1,k)*opstDY(i,lgy1)
     .                             -ffx(i,lgy ,k)*opstDY(i,lgy ))
     .                      +0.125*(ffx(i,lgy ,k)*opstDY(i,lgy )
     .                             -ffx(i,lgy2,k)*opstDY(i,lgy2)))
     .            +vairDY(i,lgyy,k)
     .                *f2_3* 0.125*(ffx(i,lgy ,k)*opstDY(i,lgy )
     .                             -ffx(i,lgy1,k)*opstDY(i,lgy1))
     .            -vairDY(i,ldy ,k)
     .                *f2_3*(      (ffx(i,ldy1,k)*opstDY(i,ldy1)
     .                             -ffx(i,ldy ,k)*opstDY(i,ldy ))
     .                      +0.125*(ffx(i,ldy ,k)*opstDY(i,ldy )
     .                             -ffx(i,ldy2,k)*opstDY(i,ldy2)))
     .            -vairDY(i,ldyy,k)
     .                *f2_3* 0.125*(ffx(i,ldy ,k)*opstDY(i,ldy )
     .                             -ffx(i,ldy1,k)*opstDY(i,ldy1)))
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO
        END DO

       ELSE IF (FLhost)                                            THEN
        DO   k=1,mz
          DO j=1,my
            summ = summ + dsigm1(k) * dtx             *dsigm1(       k)
     .                  *(opstDY(1   ,j)*ffx(1   ,j,k)*uairDY(1   ,j,k)
     .                   -opstDY(mx  ,j)*ffx(mx  ,j,k)*uairDY(mx  ,j,k))
          END DO

          DO i=1,mx
            summ = summ + dsigm1(k) * dtx             *dsigm1(       k)
     .                  *(opstDY(i,1   )*ffx(i,1   ,k)*vairDY(i,1   ,k)
     .                   -opstDY(i,my  )*ffx(i,my  ,k)*vairDY(i,my  ,k))
          END DO

          DO j=1,my
          DO i=1,mx
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO

        END DO

       ELSE
        DO   k=1,mz

          DO j=lgy ,ldy 
            summ = summ + dsigm1(k) * dtx
     .                  *(opstDY(lgx ,j)*ffx(lgx ,j,k)*uairDY(lgx ,j,k)
     .                   -opstDY(ldx ,j)*ffx(ldx ,j,k)*uairDY(ldx ,j,k))
          ENDDO

          DO i=lgx ,ldx 
            summ = summ + dsigm1(k) * dtx
     .                  *(opstDY(i,lgy )*ffx(i,lgy ,k)*vairDY(i,lgy ,k)
     .                   -opstDY(i,ldy )*ffx(i,ldy ,k)*vairDY(i,ldy ,k))
          ENDDO

          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            summ = summ + opstDY(i,j)   *ffx(i,j,k)   *dsigm1(k) 
          END DO
          END DO
        END DO
       END IF
      END IF


C +--Start Leap-Frog Backward
C +  ========================

      DO  itSlow =  1 ,  nnSlow+1


C +--Mass Divergence
C +  ===============

C +--4th centered Differences / x-----Direction
C +  ------------------------------------------

        DO    k=1,mz
          DO  i=1,mx
            ip2s=ip2(i)
            ip1s=ip1(i)
            im1s=im1(i)
            im2s=im2(i)
          DO  j=1,my
            WKxyz1(i,j,k)=  uairDY(i   ,j,k)*dxinv2 * fac43
     .             * ( 0.125 *(ffx(ip2s,j,k)-ffx(im2s,j,k))
     .                        -ffx(ip1s,j,k)+ffx(im1s,j,k) )
          END DO
          END DO
        END DO


C +--4th centered Differences / y-----Direction
C +  ------------------------------------------

        DO k=1,mz
          DO j=1,my
            jp2s=jp2(j)
            jp1s=jp1(j)
            jm1s=jm1(j)
            jm2s=jm2(j)
          DO i=1,mx
            WKxyz2(i,j,k)=  vairDY(i,j   ,k)*dyinv2 * fac43
     .             * ( 0.125 *(ffx(i,jp2s,k)-ffx(i,jm2s,k))
     .                        -ffx(i,jp1s,k)+ffx(i,jm1s,k) )
          END DO
          END DO
        END DO


C +--2th centered Differences  / sigma-Direction  / Energy conserving
C +  --- (Haltiner and Williams, 1980, 7.2.2, Eqn. (7-47b) p.220) ---
C +      --------------------------------------------------------

C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~
          DO       k=   1,mz
                   kk=kp1(k)
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz6(i,j,k)=   ffx(i,j,k)   -ffx(i,j,kk)
            END DO
            END DO
          END DO

          DO       k=   2,mz
                   kk=km1(k)
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz7(i,j,k)=   wsigDY(i,j,kk)
              WKxyz8(i,j,k)=   WKxyz6(i,j,kk)
            END DO
            END DO
          END DO

                   k=   1
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz3(i,j,k)=   WKxyz6(i,j,k) * wsigDY(i,j,k)  
     .                        *0.5           / dsigm1(1)
            END DO
            END DO
          DO       k=   2,mz
            DO     j=jp11,my1
            DO     i=ip11,mx1
              WKxyz3(i,j,k)=  (WKxyz6(i,j,k) * wsigDY(i,j,k)
     .                        +WKxyz8(i,j,k) * WKxyz7(i,j,k))
     .                        *0.5            /dsigm1(k)
            END DO
            END DO
          END DO


C +--Mass Update (Leapfrog-Backward)
C +  ===============================

        IF  (itSlow.eq.1)                                           THEN
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(WKxyz1(i,j,k)+WKxyz2(i,j,k)+WKxyz3(i,j,k))
     .                      *dtSlow
               ffx(i,j,k)  =    ffx(i,j,k) + dff
              ffp1(i,j,k)  =    ffx(i,j,k) + dff + dff
            END DO
            END DO
            END DO
        ELSE
          IF (itSlow.le.nnSlow)                                     THEN
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(WKxyz1(i,j,k)+WKxyz2(i,j,k)+WKxyz3(i,j,k))
     .                      *dtSlow
              ffm1         =    ffx(i,j,k)
               ffx(i,j,k)  =   ffp1(i,j,k)
              ffp1(i,j,k)  =   ffm1        + dff + dff

C +--Robert Time Filter
C +  ~~~~~~~~~~~~~~~~~~
c #rt          ffx(i,j,k)  =    ffx(i,j,k)+ 
c #rt.            Robert*(0.5*(ffp1(i,j,k)+ffm1)-ffx(i,j,k))
            END DO
            END DO
            END DO
          ELSE
            DO k=   1,mz
            DO j=jp11,my1
            DO i=ip11,mx1
               dff         =(WKxyz1(i,j,k)+WKxyz2(i,j,k)+WKxyz3(i,j,k))
     .                      *dtSlow
               ffx(i,j,k)  =    ffx(i,j,k) + dff
            END DO
            END DO
            END DO
C +***      Leapfrog-Backward (e.g. Haltiner and Williams, p.152)

          END IF
        END IF

      END DO


C +--Work Arrays Reset
C +  =================

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz1(i,j,k) = 0.0
          WKxyz2(i,j,k) = 0.0
          WKxyz3(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
          WKxyz7(i,j,k) = 0.0
          WKxyz8(i,j,k) = 0.0
        END DO
        END DO
        END DO


C +--Mass Conservation
C +  =================

      IF (qqmass)                                                   THEN
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            ffx(i,j,k) = max(zero,                         ffx(i,j,k))
          END DO
          END DO
          END DO

            sumn = 0.
        IF (FLhost)                                                 THEN
          DO k=1,mz
          DO j=1   ,my  
          DO i=1   ,mx  
            sumn       =     sumn +pstDYn(i,j) *dsigm1(k) *ffx(i,j,k)
          END DO
          END DO
          END DO
        ELSE  
          DO k=1,mz
          DO j=lgy ,ldy 
          DO i=lgx ,ldx 
            sumn       =     sumn +pstDYn(i,j) *dsigm1(k) *ffx(i,j,k)
          END DO
          END DO
          END DO
        END IF
        IF (sumn.gt.zero)                                           THEN
            summ  =  summ  / sumn
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            ffx(i,j,k) =     summ                         *ffx(i,j,k)
          END DO
          END DO
          END DO
        END IF

      END IF

      return
      end


      subroutine DYNadv_hor(ff,fp0,fp1,fu,fv)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    27-09-2001  MAR |
C |   SubRoutine DYNadv_hor includes the Horizontal Advection Contribution |
C |              solved by using a Cubic Spline Technique                  |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   fp0: mass                                                   |
C |   ^^^^^    fu:  advection velocity, x-direction, (e.g., uairDY)        |
C |            fv:  advection velocity, y-direction, (e.g., vairDY)        |
C |                                                                        |
C |            iterun: Iteration            Index                          |
C |            openLB: Zero-Gradient  LBC   Switch                         |
C |            FirstC: First Call at time=t Switch                         |
C |            qqmass: Mass  Conservation   Switch                         |
C |                                                                        |
C |   INPUT &/ ff: advected  variable, which may be:                       |
C |   OUTPUT : uairDY,vairDY, pktaDY, qvDY, qwHY,qrHY, qiHY,ccniHY,qsHY    |
C |   ^^^^^^^^ uairDY  : x-wind speed component                     (m/s)  |
C |            vairDY  : y-wind speed component                     (m/s)  |
C |            pktaDY: Potential Temperature divided by 100.[kPa]**(R/Cp)  |
C |              qvDY: Air specific Humidity                      (kg/kg)  |
C |            ****HY: Hydrometeor  Concentration                 (kg/kg)  |
C |                                                                        |
C |   METHOD : The following Contributions may be taken into account:      |
C |   ^^^^^^^^     du/dt:=-udu/dx -vdu/dy                                  |
C |                dv/dt:=-udv/dx -vdv/dy                                  |
C |                dP/dt:=-udP/dx -vdP/dy  (Potential Temperature)         |
C |                dq/dt:=-udq/dx -vdq/dy  (Water     Species)             |
C |            Correction for Mass Conservation  (qqmass = .true.)         |
C |            is based on the assumption that the meteorological fields   |
C |            at Lateral Boundaries (LB) change only through relaxation   |
C |            of MAR Fields towards Large Scale Meteorological Fields,    |
C |            ==> Total Mass remains constant during "inner" Advection    |
C |                (i1,i2) = (1,mx)   ==>    correction operated at LB's   |
C |                          (   correction slightly inconsistent     )    |
C |                (i1,i2) = (2,mx-1) ==> no correction operated at LB's   |
C |                          (LB relaxation slightly badly conditioned)    |
C |            Inclusion of Mass Flux at the LB's causes a conflict        |
C |                                                      with LBC scheme   |
C |            This is verified by the onset of spurious waves   at LB's   |
C |                                                                        |
C |   REFER. : Alpert, thesis, 1980                                        |
C |   ^^^^^^^^ Pielke, Mesoscale Meteorological Modeling, 297--307, 1984   |
C |           (Seibert and Morariu, JAM, p.118, 1991)                      |
C |                                                                        |
C | # OPTIONS: #MC (Mass   Correction)             performed               |
C | # ^^^^^^^^ #MD (Mass   Difference) Correction  preferred               |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
c #HY include 'MAR_HY.inc'
      include 'MAR_CU.inc'
C +
      include 'MAR_LB.inc'
      include 'MAR_WK.inc'
C +
      real      fp0(mx,my)
      real      fp1(mx,my)
      real       ff(mx,my,mz)
      real       fu(mx,my,mz)
      real       fv(mx,my,mz)
C +
C +
C +--Local  Variables
C +  ================
C +
      integer iunPos,junPos,iindex,jindex
C +
      integer               i1_adh  ,i2_adh   ,j1_adh  ,j2_adh   ,k_pdim
      parameter            (i1_adh=1,i2_adh=mx,j1_adh=1,j2_adh=my)
      parameter            (k_pdim=mz)
c #QB common/DYNadv_hor_loc/i1_adh  ,i2_adh   ,j1_adh  ,j2_adh
C +
c #MC real                  sumMav
      real                  sumMx    
      common/DYNadv_horrloc/sumMx(mz)          
C +
      real                    dff
      real                     f0(mx,my,mz)
      real                  sumM0(mz),sumM1(mz)
      real                  sumP0(mz),sumP1(mz)
      real                  sumF0(mz)
      real                 rsum,rsumd,rsumds,rsumda,FlwPos
C +
c #SP logical               log_xx,log_yy
C +
      logical               qqflux
      logical               NestOK
C +
C +
C +--DATA
C +  ====
C +
      data                  qqflux/.false./
      data                  NestOK/.true./
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +--Conservation: Mass
C +  ==================
C +
      IF   (qqmass)                                               THEN
        IF (FirstC)                                               THEN
C +
C +
C +--Interior of the Model Domain 
C +  ----------------------------
C +
c #MC     IF (qqflux)                                             THEN
c #MC       DO   k=1,k_pdim
c #MC           sumM0(k)= 0.0
c #MC           sumM1(k)= 0.0
c #MC         DO j=j1_adh,j2_adh
c #MC         DO i=i1_adh,i2_adh
c #MC           sumM0(k)= sumM0(k)+ fp0(i,j)
c #MC           sumM1(k)= sumM1(k)+ fp1(i,j)
c #MC         END DO
c #MC         END DO
c #MC       END DO
c #MC     ELSE
c #MC       DO   k=1,k_pdim
c #MC           sumM0(k)= 0.0
c #MC           sumM1(k)= 0.0
c #MC         DO j=1,my
c #MC         DO i=1,mx
c #MC           sumM0(k)= sumM0(k)+ fp0(i,j)
c #MC           sumM1(k)= sumM1(k)+ fp1(i,j)
c #MC         END DO
c #MC         END DO
c #MC       END DO
c #MC     END IF
C +
C +
C +--Mass Inflow / x-Lateral Boundaries
C +  ----------------------------------
C +
c #MC     IF (mmx.gt.1.and.qqflux)                                THEN
C +
C +--"x-small" Boundary
C +  ~~~~~~~~~~~~~~~~~~
c #MC            i=i1_adh
c #MC       DO   k=     1,k_pdim
c #MC         DO j=j1_adh,j2_adh
c #MC           sumM0(k)= sumM0(k)+ fp0(i,j)*fu(i,j,k)*dtx
c #MC         END DO
C +
C +--"x-large" Boundary
C +  ~~~~~~~~~~~~~~~~~~
c #MC            i=i2_adh
c #MC         DO j=j1_adh,j2_adh
c #MC           sumM0(k)= sumM0(k)- fp0(i,j)*fu(i,j,k)*dtx
c #MC         END DO
c #MC       END DO
c #MC     END IF
C +
C +
C +--Mass Inflow / y-Lateral Boundaries
C +  ----------------------------------
C +
c #MC     IF (mmy.gt.1.and.qqflux)                                THEN
C +
C +--"y-small" Boundary
C +  ~~~~~~~~~~~~~~~~~~
c #MC            j=j1_adh
c #MC       DO   k=     1,k_pdim
c #MC         DO i=i1_adh,i2_adh
c #MC           sumM0(k)= sumM0(k)+ fp0(i,j)*fv(i,j,k)*dtx
c #MC         END DO
C +
C +--"y-large" Boundary
C +  ~~~~~~~~~~~~~~~~~~
c #MC            j=j2_adh
c #MC         DO i=i1_adh,i2_adh
c #MC           sumM0(k)= sumM0(k)- fp0(i,j)*fv(i,j,k)*dtx
c #MC         END DO
c #MC       END DO
c #MC     END IF
c #MC           sumMav  = 0.
            DO   k= 1,k_pdim
                sumMx(k)= 1.
c #MC           sumMx(k)= sumM0(k)/ sumM1(k)
c #MC           sumMav  = sumMav  + sumMx(k) *dsigm1(k)
            END DO
c #MC         DO j=j1_adh,j2_adh
c #MC         DO i=i1_adh,i2_adh
c #MC           fp1(i,j)= fp1(i,j)* sumMav
c #MC         END DO
c #MC         END DO
        END IF
C +
C +
C +--Conservation: Property
C +  ======================
C +
C +--Interior of the Model Domain 
C +  ----------------------------
C +
          IF (qqflux)                                             THEN
            DO   k=     1,k_pdim
                sumP0(k) = 0.0
                sumF0(k) = 0.0
              DO j=j1_adh,j2_adh
              DO i=i1_adh,i2_adh
                f0(i,j,k) = ff(i,j,k) *fp0(i,j)
                 sumP0(k) =  sumP0(k) + f0(i,j,k)
              END DO
              END DO
            END DO
          ELSE
            DO   k=     1,k_pdim
                sumP0(k)= 0.0
              DO j=     1,my
              DO i=     1,mx
                f0(i,j,k) = ff(i,j,k) *fp0(i,j)
                 sumP0(k) =  sumP0(k) + f0(i,j,k)
              END DO
              END DO
            END DO
          END IF
C +
C +
C +--Mass Inflow / x-Lateral Boundaries
C +  ----------------------------------
C +
          IF (mmx.gt.1.and.qqflux)                                THEN
            DO   k=     1,k_pdim
                 i=i1_adh
              DO j=j1_adh,j2_adh
                sumF0(k) = sumF0(k) 
     .                  + ff(i,j,k)*fp0(i,j)*fu(i,j,k)*dtx
              END DO
                 i=i2_adh
              DO j=j1_adh,j2_adh
                sumF0(k) = sumF0(k) 
     .                  - ff(i,j,k)*fp0(i,j)*fu(i,j,k)*dtx
              END DO
            END DO
          END IF
C +
C +
C +--Mass Inflow / y-Lateral Boundaries
C +  ----------------------------------
C +
          IF (mmy.gt.1.and.qqflux)                                THEN
            DO   k=     1,k_pdim
                 j=j1_adh
              DO i=i1_adh,i2_adh
                sumF0(k) = sumF0(k) 
     .                  + ff(i,j,k)*fp0(i,j)*fv(i,j,k)*dtx
              END DO
                 j=j2_adh
              DO i=i1_adh,i2_adh
                sumF0(k) = sumF0(k) 
     .                  - ff(i,j,k)*fp0(i,j)*fv(i,j,k)*dtx
              END DO
            END DO
          END IF
          IF (             qqflux)                                THEN
            DO   k=     1,k_pdim
                sumP0(k) = sumP0(k) + sumF0(k)
            END DO
          END IF
C +
C +
C +--Positive Definiteness Condition
C +  -------------------------------
C +
            DO   k=     1,k_pdim
                sumP0(k) = max(sumP0(k),zero)
            END DO
C +
      END IF
C +
C +
C +--Time Splitting (Alternate Direction)
C +  ====================================
C +
c #SP log_xx = .false.
c #SP log_yy = .false.
C +
 300  CONTINUE
c #SP IF (mod(itexpe,2).eq.0.and..not.log_yy)                GO TO 301
C +
C +
C +--Advection Contribution following x
C +  ==================================
C +
        IF (mmx.gt.1)                                             THEN 
C +
          DO i=1,mx
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz1(i,j,k)=fu(i,j,k) *dtx
            END DO
            END DO
          END DO
C +
C +
C +--First Order Derivative, LBC
C +  ---------------------------
C +
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz2( 1,j,k) = 0.0
              WKxyz2(mx,j,k) = 0.0
            END DO
            END DO
C +
C +
C +--First Order Derivative, Forward  Sweep
C +  --------------------------------------
C +
          DO i=ip11,mx1
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz2(i,j,k)=(3.0*(ff(i+1,j,k)-ff(i-1,j,k))/dx
     .                       -WKxyz2(i-1,j,k)                )/CUspxh(i)
            END DO
            END DO
          END DO
C +
C +
C +--First Order Derivative, Backward Sweep
C +  --------------------------------------
C +
          DO i=mx2,ip11,-1
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz2(i,j,k)=CUspxb(i)*WKxyz2(i+1,j,k)+WKxyz2(i,j,k)
            END DO
            END DO
          END DO
C +
C +
C +--First Order Difference
C +  ----------------------
C +
          DO i=1,mx
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz2(i,j,k)= WKxyz2(i,j,k)*dx
            END DO
            END DO
          END DO
C +
C +
C +--Interpolated Variable
C +  ---------------------
C +
          DO i=1,mx
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz3(i,j,k)= WKxyz1(i,j,k)*WKxyz1(i,j,k)
            END DO
            END DO
          END DO
C +
C +
C +--Direction of Advection
C +  ----------------------
C +
          DO i=1,mx
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz4(i,j,k) =  sign(unun,WKxyz1(i     ,j,k))
              iunPos        =            WKxyz4(i     ,j,k)
              iindex        =   max(   1,i-iunPos)
              iindex        =   min(  mx,  iindex)
              WKxyz5(i,j,k) =            WKxyz2(iindex,j,k)
              WKxyz6(i,j,k) = WKxyz4(i,j,k)*(ff(iindex,j,k)-ff(i,j,k))
            END DO
            END DO
          END DO
C +
C +
C +--Advection
C +  ---------
C +
          DO i=1,mx
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz7(i,j,k)=WKxyz6(i,j,k)+WKxyz6(i,j,k)+WKxyz2(i,j,k)
              WKxyz8(i,j,k)=WKxyz7(i,j,k)+WKxyz6(i,j,k)+WKxyz2(i,j,k)
              WKxyz6(i,j,k)=    ff(i,j,k)-WKxyz1(i,j,k)*WKxyz2(i,j,k)
            END DO
            END DO
          END DO
C +
C +
          DO i=1,mx
            DO k=   1,k_pdim
            DO j=jp11,my1
              WKxyz6(i,j,k)=    ff(i,j,k)- WKxyz1(i,j,k)*WKxyz2(i,j,k)
     .       +WKxyz4(i,j,k)*WKxyz3(i,j,k)*(WKxyz8(i,j,k)+WKxyz5(i,j,k))
     .       -WKxyz1(i,j,k)*WKxyz3(i,j,k)*(WKxyz7(i,j,k)+WKxyz5(i,j,k))
            END DO
            END DO
          END DO
C +
C +
C +--Inflow LBC
C +  ----------
C +
          IF   (qqflux)                                           THEN
C +
C +--Large Scale Contribution over dt (dff, to be implemented)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            IF (NestOK)                                           THEN
                dff = 0.
C +
C +--Host Model Solution is preferred ("outer" solution if inflow included)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
              DO k=   1,k_pdim
              DO j=   1,my
                WKxyz6( 1,j,k) =         ff( 1,j,k) + dff
                WKxyz6(mx,j,k) =         ff(mx,j,k) + dff
              END DO
              END DO
C +
C +--MAR        Solution is preferred ("inner" solution if inflow included)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ELSE
              DO k=   1,k_pdim
              DO j=   1,my
                FlwPos         = max(zero, sign(unun,WKxyz4( 1,j,k)))
                WKxyz6( 1,j,k) =     WKxyz6( 1,j,k) * (unun - FlwPos)
     .                         +         ff( 1,j,k) *         FlwPos
                FlwPos         = max(zero, sign(unun,WKxyz4(mx,j,k)))
                WKxyz6(mx,j,k) =     WKxyz6(mx,j,k) *         FlwPos
     .                         +         ff(mx,j,k) * (unun - FlwPos)
              END DO
              END DO
            END IF
C +
C +--Host Model Solution is preferred
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          ELSE
              DO k=   1,k_pdim
              DO j=   1,my
                WKxyz6( 1,j,k) =         ff( 1,j,k)
                WKxyz6(mx,j,k) =         ff(mx,j,k)
              END DO
              END DO
          END IF
C +
C +
C +--Finalisation
C +  ------------
C +
          DO i=1,mx
            DO k=   1,k_pdim
            DO j=jp11,my1
                  ff( i,j,k) = WKxyz6(i,j,k)
              WKxyz1( i,j,k) = 0.0
              WKxyz2( i,j,k) = 0.0
              WKxyz3( i,j,k) = 0.0
              WKxyz4( i,j,k) = 0.0
              WKxyz5( i,j,k) = 0.0
              WKxyz6( i,j,k) = 0.0
              WKxyz7( i,j,k) = 0.0
              WKxyz8( i,j,k) = 0.0
            END DO
            END DO
          END DO
        END IF
C +
c #SP log_xx = .true.
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +--Time Splitting (Alternate Direction)
C +  ====================================
C +
 301  CONTINUE
c #SP IF (                            log_yy)                GO TO 302
C +
C +
C +--Advection Contribution following y 
C +  ==================================
C +
        IF (mmy.gt.1)                                             THEN 
C +
          DO j=1,my
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz1(i,j,k)=fv(i,j,k) *dtx
            END DO
            END DO
          END DO
C +
C +
C +--First Order Derivative, LBC
C +  ---------------------------
C +
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz2(1, 1,k) = 0.0
              WKxyz2(1,my,k) = 0.0
            END DO
            END DO
C +
C +
C +--First Order Derivative, Forward  Sweep
C +  --------------------------------------
C +
          DO j=jp11,my1
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz2(i,j,k)=(3.0*(ff(i,j+1,k)-ff(i,j-1,k))/dx
     .                       -WKxyz2(i,j-1,k)                )/CUspyh(j)
            END DO
            END DO
          END DO
C +
C +
C +--First Order Derivative, Backward Sweep
C +  --------------------------------------
C +
          DO j=my2,jp11,-1
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz2(i,j,k)=CUspyb(j)*WKxyz2(i,j+1,k)+WKxyz2(i,j,k)
            END DO
            END DO
          END DO
C +
C +
C +--First Order Difference
C +  ----------------------
C +
          DO j=1,my
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz2(i,j,k)= WKxyz2(i,j,k)*dx
            END DO
            END DO
          END DO
C +
C +
C +--Interpolated Variable
C +  ---------------------
C +
          DO j=1,my
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz3(i,j,k)= WKxyz1(i,j,k)*WKxyz1(i,j,k)
            END DO
            END DO
          END DO
C +
C +
C +--Direction of Advection
C +  ----------------------
C +
          DO j=1,my
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz4(i,j,k) =  sign(unun,WKxyz1(i,j     ,k))
              junPos        =            WKxyz4(i,j     ,k)
              jindex        =   max(   1,j-junPos)
              jindex        =   min(  my,  jindex)
              WKxyz5(i,j,k) =            WKxyz2(i,jindex,k)
              WKxyz6(i,j,k) = WKxyz4(i,j,k)*(ff(i,jindex,k)-ff(i,j,k))
            END DO
            END DO
          END DO
C +
C +
C +--Advection
C +  ---------
C +
          DO j=1,my
            DO k=   1,k_pdim
            DO i=ip11,mx1
              WKxyz7(i,j,k)=WKxyz6(i,j,k)+WKxyz6(i,j,k)+WKxyz2(i,j,k)
              WKxyz8(i,j,k)=WKxyz7(i,j,k)+WKxyz6(i,j,k)+WKxyz2(i,j,k)
              WKxyz6(i,j,k)=    ff(i,j,k)-WKxyz1(i,j,k)*WKxyz2(i,j,k)
            END DO
            END DO
          END DO
C +
C +
          DO j=1,my
            DO k=   1,k_pdim
            DO i=ip11,mx1
                  ff(i,j,k)=    ff(i,j,k)- WKxyz1(i,j,k)*WKxyz2(i,j,k)
     .       +WKxyz4(i,j,k)*WKxyz3(i,j,k)*(WKxyz8(i,j,k)+WKxyz5(i,j,k))
     .       -WKxyz1(i,j,k)*WKxyz3(i,j,k)*(WKxyz7(i,j,k)+WKxyz5(i,j,k))
            END DO
            END DO
          END DO
C +
C +
C +--Inflow LBC
C +  ----------
C +
          IF   (qqflux)                                           THEN
C +
C +--Large Scale Contribution over dt (dff, to be implemented)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            IF (NestOK)                                           THEN
                dff = 0.
C +
C +--Host Model Solution is preferred ("outer" solution if inflow included)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
              DO k=   1,k_pdim
              DO i=   1,mx
                WKxyz6(i, 1,k) =         ff(i, 1,k)
                WKxyz6(i,my,k) =         ff(i,my,k)
              END DO
              END DO
C +
C +--Nested Model Solution is preferred
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C +
C +--MAR        Solution is preferred ("inner" solution if inflow included)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            ELSE
              DO k=   1,k_pdim
              DO i=   1,mx
                FlwPos         = max(zero, sign(unun,WKxyz4(i, 1,k)))
                WKxyz6(i, 1,k) =     WKxyz6(i, 1,k) * (unun - FlwPos)
     .                         +         ff(i, 1,k) *         FlwPos
                FlwPos         = max(zero, sign(unun,WKxyz4(i,my,k)))
                WKxyz6(i,my,k) =     WKxyz6(i,my,k) *         FlwPos
     .                         +         ff(i,my,k) * (unun - FlwPos)
              END DO
              END DO
            END IF
C +
C +--Host Model Solution is preferred
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          ELSE
              DO k=   1,k_pdim
              DO i=   1,mx
                WKxyz6(i, 1,k) =         ff(i, 1,k)
                WKxyz6(i,my,k) =         ff(i,my,k)
              END DO
              END DO
          END IF
C +
C +
C +--Finalisation
C +  ------------
C +
          DO j=1,my
            DO k=   1,k_pdim
            DO i=ip11,mx1
                  ff(i, j,k) = WKxyz6(i,j,k)
              WKxyz1(i, j,k) = 0.0
              WKxyz2(i, j,k) = 0.0
              WKxyz3(i, j,k) = 0.0
              WKxyz4(i, j,k) = 0.0
              WKxyz5(i, j,k) = 0.0
              WKxyz6(i, j,k) = 0.0
              WKxyz7(i, j,k) = 0.0
              WKxyz8(i, j,k) = 0.0
            END DO
            END DO
          END DO
        END IF
C +
c #SP log_yy = .true.
C +
c #SP IF (                       .not.log_xx)                GO TO 300
 302  CONTINUE
C +
C +
C +--Conservation
C +  ============
C +
        IF   (qqmass)                                             THEN
C +
C +
C +--Fluxes at the Lateral Boundaries      through Advection
C +  -------------------------------------------------------
C +
          IF (qqflux)                                             THEN
            DO k=1,k_pdim
                     sumP1(k)     = 0.0
                  DO     j=j1_adh,j2_adh
                  DO     i=i1_adh,i2_adh
                     WKxy1(i,j) = ff(i,j,k) *    fp1(i,j)
                     sumP1(k)   =  sumP1(k) +  WKxy1(i,j)
                  END DO
                  END DO
C +
                    rsumd     = sumP1(k)
c #MD               rsumd     = sumP1(k)-sumP0(k)
                    rsumds    = sign(unun,rsumd)
                    rsumda    =  abs(     rsumd)
                    rsumd     =  max(eps9,rsumda)       *rsumds
                    rsum      = sumP0(k) /rsumd
c #MD               rsum      = sumF0(k) /rsumd
                  DO     j=j1_adh,j2_adh
                  DO     i=i1_adh,i2_adh
                    ff(i,j,k) =     ff(i,j,k)           *rsum
c #MD               ff(i,j,k) =(    f0(i,j,k)
c #MD.                         +(WKxy1(i,j)  -f0(i,j,k))*rsum)
c #MD.                        /    fp1(i,j)
                  END DO
                  END DO
C +
            END DO
C +
                  DO     j=1,my
                  DO     i=1,mx
                    WKxy1(i,j) = 0.0
                  END DO
                  END DO
C +
C +
C +--Fluxes at the Lateral Boundaries only through the nudging Procedure
C +  -------------------------------------------------------------------
C +
          ELSE
C +
            DO k=1,k_pdim
                     sumP1(k) = 0.0
                  DO     j=1,my
                  DO     i=1,mx
                     sumP1(k) = sumP1(k) + ff(i,j,k) * fp1(i,j)
                  END DO
                  END DO
C +
                    rsumd     = sumP1(k) * sumMx(k)
                    rsumds    = sign(unun,rsumd)
                    rsumda    =  abs(     rsumd)
                    rsumd     =  max(eps9,rsumda)    * rsumds
                    rsum      = sumP0(k) /rsumd
                  DO     j=1,my
                  DO     i=1,mx
                    ff(i,j,k) =            ff(i,j,k) * rsum
                  END DO
                  END DO
C +
            END DO
          END IF
C +
        END IF
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
      return
      end
      subroutine DYNadv_sal

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                               Tue 10-Jan-2012  MAR |
C |   SubRoutine DYNadv_sal includes the Horizontal Advection Contribution |
C |                                  of Saltating Snow                     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    iterun: Run   Iteration                        Counter      |
C |            micphy: Cloud Microphysics                     Switch       |
C |            openLB: Open  Lateral Boundary Condition (LBC) Switch       |
C |                                                                        |
C |   INPUT  / uairDY,vairDY, qsHY, uss_HY                                 |
C |   OUTPUT : snobSL  : snow eroded        thickness            [m w.e.]  |
C |   ^^^^^^^^ snohSL  : snow precipitation thickness            [m w.e.]  |
C |                                                                        |
C |   METHOD : The following Contributions are taken into account:         |
C |   ^^^^^^^^     dq/dt:=-(ud(qp*)/dx -vd(qp*)/dy)/p*                     |
C |                                                                        |
C |   REFER. : Alpert, thesis, 1980                                        |
C |   ^^^^^^^^ Pielke, Mesoscale Meteorological Modeling, 297--307, 1984   |
C |            Seibert and Morariu, JAM, p.118, 1991                       |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_HY.inc'
      include 'MAR_BS.inc'

      include 'MAR_SL.inc'

      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

      real                   facFLX
      common  /DYNadv_sal_r/ facFLX 


      IF (iterun.LE.1)                                              THEN
!         IF (zsigma(mz).LT.1.5) 
!    .    STOP ' in DYNadv_sal: z_sbl inacceptable'
!         facFLX=0.1+0.8*exp(-(zsigma(mz)-0.5)*0.15)
          facFLX=2.0+6.0*exp(-(zsigma(mz)-0.4)*1.50) - 1.
      END IF



!  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


!  Additional Snow Particles Horizontal Flux
!  =========================================

         k = mz
!        k = mz (i.e., Consider SBL only)

      DO j=1,my
      DO i=1,mx
        WKxy0(i,j) = pstDY(i,j)
     . *facFLX     *  qsHY(i,j,k)*min(unun,sign(unun,zero-uss_HY(i,j)))
      END DO
      END DO


      DO j=1,my
      DO i=1,mx
        WKxy1(i,j) = WKxy0(i,j)*uairDY(i,j,k)
        WKxy2(i,j) = WKxy0(i,j)*vairDY(i,j,k)
      END DO
      END DO


!  Flux Convergence
!  ================

      DO j=jp11,my1
      DO i=ip11,mx1
        qsHY(i,j,k) = qsHY(i,j,k) 
     .        +(dtx*(WKxy1(im1(i),    j )-WKxy1(ip1(i),    j ))
     .         +dty*(WKxy2(    i ,jm1(j))-WKxy2(    i ,jp1(j))))
     .        /(2.0* pstDY(    i,     j))
      END DO
      END DO


      DO j=1,my
      DO i=1,mx
        WKxy0(i,j) = 0.
        WKxy1(i,j) = 0.
        WKxy2(i,j) = 0.
      END DO
      END DO


!  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


      return
      end


      subroutine DYNadv_cubh(fc,h,b,mm,pc,ec,gc,wka,wkb,wkc,wkd,wke,wkf,
     .                       m,m1,m2,dx)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    14-12-2000  MAR |
C |   SubRoutine DYNadv_cubh computes Horizontal Advection                 |
C |              using a Cubic Spline Interpolation Technique              |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT  : fc  : Value of the Variable to be advected                   |
C |  ^^^^^^^^ ec  : Advection Speed, times 2dt / dx                        |
C |           h,b : Cubic Spline       Auxiliary Variables                 |
C |           mm  : Backward Sweep               Switch                    |
C |           wka,wkb,wkc,wkd,wke,wkf: Work Area Variables                 |
C |           m,m1,m2:                 Axis      Dimensions                |
C |           dx  :                    Grid      Size                      |
C |                                                                        |
C |  OUTPUT : gc  : New Value of the Variable after Advection              |
C |  ^^^^^^^^                                                              |
C |                                                                        |
C |  REFER. : Alpert, thesis, 1980                                         |
C |  ^^^^^^^^ Pielke, Mesoscale Meteorological Modeling, 297--307, 1984    |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      integer    mm   ,  m   , m1   , m2   , i
      real       pc(m), ec(m), fc(m), gc(m)
      real        h(m),  b(m)
      real      wka(m),wkb(m),wkc(m),wkd(m),wke(m),wkf(m)
      real       dx
C +
      m1    = m -1
      m2    = m -2
C +
C +
C +--First Order Derivative, LBC
C +  ---------------------------
C +
      pc(1) = 0.0
      pc(m) = 0.0
C +
C +
C +--First Order Derivative, Forward  Sweep
C +  --------------------------------------
C +
      DO i=2,m1
        pc(i)=(3.0*(fc(i+1)-fc(i-1))/dx-pc(i-1))/h(i)
      END DO
C +
C +
C +--First Order Derivative, Backward Sweep
C +  --------------------------------------
C +
      DO i=m2,2,-1
        pc(i)=b(i)*pc(i+1)+pc(i)
      END DO
C +
      IF(mm.eq.0)                                               RETURN
C +
C +
C +--First Order Difference
C +  ----------------------
C +
      DO i=1,m
       pc(i)= pc(i)*dx
      END DO
C +
C +
C +--Interpolated Variable
C +  ---------------------
C +
      DO i=1,m
        wkc(i)= ec(i)*ec(i)
      END DO
C +
      DO i=1,m
        IF (ec(i).lt.0.0)                                         THEN
            wka(i)=        -1.0
          IF (i.lt.m)                                             THEN 
            wkb(i)=      pc(i+1)
            wkd(i)=fc(i)-fc(i+1)
          END IF
        ELSE
            wka(i)=         1.0
          IF (i.gt.1)                                             THEN
            wkb(i)=pc(i-1)
            wkd(i)=fc(i-1)-fc(i)
          END IF
        END IF
      END DO
C +
      DO i=1,m
         wke(i)=wkd(i)+wkd(i)+pc(i)
         wkf(i)=wke(i)+wkd(i)+pc(i)
         wkd(i)= fc(i)- ec(i)*pc(i)
      END DO
C +
      DO i=1,m
         gc(i)=fc(i)-ec(i)*pc(i)
     .       +wka(i)*wkc(i)*(wkf(i)+wkb(i))
     .        -ec(i)*wkc(i)*(wke(i)+wkb(i))
      END DO
C +
      IF (ec(1).gt.0.0) gc(1)=fc(1)
      IF (ec(m).lt.0.0) gc(m)=fc(m)
C +
      return
      end
      subroutine TRCadv_hor
C +
C +------------------------------------------------------------------------+
C | MAR TRACERS                                            27-09-2001  MAR |
C |   SubRoutine TRCadv_hor includes the Horizontal Advection Contribution |
C |              solved by using a Cubic Spline Technique (see DYNadv_cubh)|
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    iterun: Run   Iteration                        Counter      |
C |            openLB: Open  Lateral Boundary Condition (LBC) Switch       |
C |                                                                        |
C |   INPUT /  uairDY,vairDY,         qxTC                                 |
C |   OUTPUT:    qxTC: Tracer Concentration                       (kg/kg)  |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   METHOD:  The following Contributions are taken into account:         |
C |   ^^^^^^       dq/dt:=-udq/dx -vdq/dy                                  |
C |                                                                        |
C |   REFER.:  Alpert, thesis, 1980                                        |
C |   ^^^^^^^  Pielke, Mesoscale Meteorological Modeling, 297--307, 1984   |
C |            Seibert and Morariu, JAM, p.118, 1991                       |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
      include 'MAR_TC.inc'
      include 'MAR_CU.inc'
C +
      include 'MAR_LB.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      integer icub  ,i1_ath,i2_ath,j1_ath,j2_ath,n
      real    sump  ,sumpn ,sumx  ,dudx
      real    sumv  ,sumvn ,rsum  ,dvdy
C +
      real    vecxa (mx),vecxb (mx),vecxc (mx),vecxd (mx)
      real    vecxe (mx),vecxf (mx)
      real    vecx4 (mx)
      real    vecx40(mx)
      real    vecx5 (mx),vecx6 (mx)
      real    vecya (my),vecyb (my),vecyc (my),vecyd (my)
      real    vecye (my),vecyf (my)
      real    vecy4 (my)
      real    vecy40(my)
      real    vecy5 (my),vecy6 (my)
C +
c #SP logical log_xx,log_yy
      logical qqflux
C +
C +
C +--DATA
C +  ====
C +
      data        icub/1/
      data      qqflux/.false./
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +--Mass Flux: horizontal Limits
C +  ============================
C +
      IF (qqflux)                                                 THEN
          i1_ath = min(   n7+1,mx)
          i2_ath = max(mx-n6-1, 1)
          j1_ath = min(   n7+1,my)
          j2_ath = max(my-n6-1, 1)
      ELSE
          i1_ath =              1
          i2_ath =             mx
          j1_ath =              1
          j2_ath =             my
      END IF
C +
C +
C +--Conservation  (IN)
C +  ==================
C +
        IF (qqmass)                                               THEN
C +
              sump = 0.0
              sumpn= 0.0
            DO     j=j1_ath,j2_ath
            DO     i=i1_ath,i2_ath
              sump = sump +               opstDY (i,j)
              sumpn= sumpn+                pstDYn(i,j)
            END DO
            END DO
C +
          IF (mmx.gt.1.and.qqflux)                                THEN
                   i=i1_ath
            DO     j=j1_ath,j2_ath
              sump = sump +               opstDY (i,j)*uairDY(i,j,k)*dtx
            END DO
                   i=i2_ath
            DO     j=j1_ath,j2_ath
              sump = sump -               opstDY (i,j)*uairDY(i,j,k)*dtx
            END DO
          END IF
C +
          IF (mmy.gt.1.and.qqflux)                                THEN
                   j=j1_ath
            DO     i=i1_ath,i2_ath
              sump = sump +               opstDY (i,j)*vairDY(i,j,k)*dtx
            END DO
                   j=j2_ath
            DO     i=i1_ath,i2_ath
              sump = sump -               opstDY (i,j)*vairDY(i,j,k)*dtx
            END DO
          END IF
              sumx = sump / sumpn
C +
        END IF
C +
C +
C +--Loop on    the Tracers:  BEGIN
C +  ==============================
C +
      DO  n=1,ntrac 
C +
C +
C +--Loop along the Vertical: BEGIN
C +  ==============================
C +
      DO  k=1,mz 
C +
C +
C +--Conservation  (IN)
C +  ==================
C +
        IF (qqmass)                                               THEN
C +
              sumv = 0.0
            DO     j=j1_ath,j2_ath
            DO     i=i1_ath,i2_ath
              sumv = sumv + qxTC(i,j,k,n)*opstDY (i,j)
            END DO
            END DO
C +
          IF (mmx.gt.1.and.qqflux)                                THEN
                   i=i1_ath
            DO     j=j1_ath,j2_ath
              sumv = sumv + qxTC(i,j,k,n)*opstDY (i,j)*uairDY(i,j,k)*dtx
            END DO
                   i=i2_ath
            DO     j=j1_ath,j2_ath
              sumv = sumv - qxTC(i,j,k,n)*opstDY (i,j)*uairDY(i,j,k)*dtx
            END DO
          END IF
C +
          IF (mmy.gt.1.and.qqflux)                                THEN
                   j=j1_ath
            DO     i=i1_ath,i2_ath
              sumv = sumv + qxTC(i,j,k,n)*opstDY (i,j)*vairDY(i,j,k)*dtx
            END DO
                   j=j2_ath
            DO     i=i1_ath,i2_ath
              sumv = sumv - qxTC(i,j,k,n)*opstDY (i,j)*vairDY(i,j,k)*dtx
            END DO
          END IF
              sumv = max(sumv,zero)
C +
        END IF
C +
C +
C +--Time Splitting (Alternate Direction)
C +  ====================================
C +
c #SP   log_xx = .false.
c #SP   log_yy = .false.
C +
 300    CONTINUE
c #SP   IF (mod(iterun,2).eq.0.and..not.log_yy)              GO TO 301
C +
C +
C +--Advection Contribution following x
C +  ==================================
C +
          DO j=jp11,my1
            DO i=1,mx
              vecx5(i)=uairDY(i,j,k) *dtx *jtAdvH
            END DO
C +
            DO i=1,mx
              IF (i.gt.1.and.i.lt.mx)                             THEN
                IF      (uairDY(i,j,k).le.0.0)                    THEN
                  dudx= (uairDY(ip1(i),j,k)-uairDY(i,j,k))/dx
                ELSE
                  dudx=-(uairDY(i,j,k)-uairDY(im1(i),j,k))/dx
                END IF
                IF  (abs(dudx).gt.0.00001)                        THEN
                  vecx5(i)=vecx5(i) *dt *jtAdvH
     .                                  *dudx /(1.0-exp(-dt*jtAdvH
     .                                                     *dudx))
C +...            Correction of Seibert et Morariu, JAM, p.118, 1991
C +
                END IF
              END IF
            END DO
C +
C +
C +--Tracers
C +  -------
C +
              DO i=1,mx
                vecx4(i)=  qxTC(i,j,k,n)
              END DO
C +
C +           ******************************************************
              call DYNadv_cubh(vecx4,CUspxh,CUspxb,icub,vecx6,vecx5,
     .                  vecx40,vecxa,vecxb,vecxc,vecxd,vecxe,vecxf,
     .                  mmx,mmx1,mmx2,dx)
C +           ******************************************************
C +
              DO i=ip11,mx1
                  qxTC(i,j,k,n)=max(vecx40(i),zero)
              END DO
C +
          END DO
C +
c #SP   log_xx = .true.
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +--Time Splitting (Alternate Direction)
C +  ====================================
C +
 301    CONTINUE
c #SP   IF (                            log_yy)              GO TO 302
C +
C +
C +--Advection Contribution following y 
C +  ==================================
C +
          IF (mmy.gt.1) then 
C +
            DO i=ip11,mx1
              DO j=1,my
                vecy5(j)=vairDY(i,j,k) *dty *jtAdvH
              END DO
C +
              DO j=1,my
                IF (j.gt.1.and.j.lt.my)                           THEN
                  IF      (vairDY(i,j,k).le.0.0)                  THEN
                    dvdy= (vairDY(i,j+1,k)-vairDY(i,j,k))/dy
                  ELSE
                    dvdy=-(vairDY(i,j,k)-vairDY(i,j-1,k))/dy
                  END IF
                  IF (abs(dvdy).gt.0.00001)                       THEN
                    vecy5(j)=vecy5(j) *dt *jtAdvH
     .                                    *dvdy /(1.0-exp(-dt*jtAdvH
     .                                                       *dvdy))
C +...              Correction of Seibert et Morariu, JAM, p.118, 1991
C +
                  END IF
                END IF
              END DO
C +
C +
C +--Tracers
C +  -------
C +
                DO j=1,my
                  vecy4(j)=  qxTC(i,j,k,n)
                END DO
C +
C +             ******************************************************
                call DYNadv_cubh(vecy4,CUspyh,CUspyb,icub,vecy6,vecy5,
     .                    vecy40,vecya,vecyb,vecyc,vecyd,vecye,vecyf,
     .                    mmy,mmy1,mmy2,dy)
C +             ******************************************************
C +
                DO j=jp11,my1
                    qxTC(i,j,k,n)=max(vecy40(j),zero)
                END DO
C +
            END DO
C +
          END IF 
C +
c #SP   log_yy = .true.
C +
c #SP   IF (                       .not.log_xx)              GO TO 300
 302    CONTINUE
C +
C +
C +--Conservation (OUT)
C +  ==================
C +
        IF (qqmass)                                               THEN
C +
                  sumvn= 0.0
                DO     j=j1_ath,j2_ath
                DO     i=i1_ath,i2_ath
                  sumvn= sumvn     +     qxTC(i,j,k,n)*pstDYn(i,j)
                END DO
                END DO
C +
              IF (sumvn.gt.0.0)                                   THEN
                  rsum = sumv / (sumvn*sumx)
                DO     j=1,my
                DO     i=1,mx
                  qxTC(i,j,k,n) =        qxTC(i,j,k,n)*rsum
                END DO
                END DO
              END IF
C +
        END IF
C +
C +
C +--Loop along the Vertical: END
C +  ============================
C +
      END DO
C +
C +
C +--Loop on    the Tracers:  END
C +  ============================
C +
      END DO
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
      return
      end


      subroutine DYNadv_ver

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    18-09-2001  MAR |
C |   SubRoutine DYNadv_ver  includes the Vertical  Advection Contribution |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    iterun: Run   Iteration                        Counter      |
C |            uairDY, vairDY, pktaDY Values    / Time Step n              |
C |            uairDY  : x-wind speed component                     (m/s)  |
C |            vairDY  : y-wind speed component                     (m/s)  |
C |            pktaDY: potential temperature divided by 100.[kPa]**(R/Cp)  |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^   uairDY, vairDY, pktaDY Values    / Time Step n+1            |
C |                                                                        |
C |   METHOD:  Unstaggered Grid: 1st Accurate in Space Upstream Scheme     |
C |   ^^^^^^^^   Staggered Grid: 2nd Accurate in Space                     |
C |                                                                        |
C | # OPTIONS: #VA: Vertical Average preferred in Centered Conserv Scheme  |
C | # ^^^^^^^^ #NS: NO   Slip Surface BC used  in Centered Conserv Scheme  |
C | #          #UR: Upper Radiating Condition (to be corrected, DO'NT USE) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
c #cA include 'MAR_CA.inc'

      include 'MAR_WK.inc'

c #UR real     uairUP, vairUP, pktaUP
c #UR common  /DYNadv_ver_var/ uairUP(mx,my,0:2),
c #UR.                         vairUP(mx,my,0:2),
c #UR.                         pktaUP(mx,my,0:2)
c #WA integer                  nadvrd
c #WA common  /DYNadv_ver_loc/ nadvrd

      logical centrL
c #ZU logical adv3rd
c #ZU real    gat(mx,my,mz),ga0(mx,my)


C +--Local  Variables
C +  ================

      integer itimax,ntimax,       nt__UP,nt    ,kk
      real    cflmax,cflsig,faccfl,dt__UP,dt_sig,dsgm
      real    uair_0,uair_c,uair_1,uair_2,uair_d
      real    vair_0,vair_c,vair_1,vair_2,vair_d
      real    pkta_0,pkta_c,pkta_1,pkta_2,pkta_d
      real    old__u,old__v,old__t


C +--DATA
C +  ====

c #ZU data adv3rd/ .true./

      data centrL/ .true./
c #UP      centrL=.false.


C +--Initialization of the Upper Radiating Boundary Condition
C +  ========================================================

c #UR IF (iterun.eq.1)                                            THEN
c #UR   DO       k=    0 ,     2
c #UR           kk=max(1 ,     k)
c #UR   DO       j=jp11,my1
c #UR   DO       i=ip11,mx1
c #UR     uairUP(i,j,k) = uairDY(i,j,kk)
c #UR     vairUP(i,j,k) = vairDY(i,j,kk)
c #UR     pktaUP(i,j,k) = pktaDY(i,j,kk)
c #UR   END DO
c #UR   END DO
c #UR   END DO
c #UR END IF


C +--Slip condition for Mountain Wave Experiments
C +  ============================================

c #OM   DO       j=jp11,my1
c #OM   DO       i=ip11,mx1
c #OM     psigDY(i,j,mz)=0.0
c #OM   END DO
c #OM   END DO


C +--First and Second Order Schemes
C +  ==============================

c #ZU IF (.not.adv3rd)                                            THEN 


C +--Courant Number
C +  --------------

           cflmax     = 0.0

C +--Centered second Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       IF (centrL.and.staggr)                                     THEN

c #WA     write(6,6001)iterun
 6001     format(i6,' 6001       centrL .and.       staggr /CFL Number')

          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*psigDY(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.0)
            cflsig     = abs(WKxyz7(i,j,k)+WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO

          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)=                 0.00
c #UR       WKxyz8(i,j,1)=dt*psigDY(i,j,1)*0.33
c #UR.                     /(pstDYn(i,j)*dsigm1(1)*2.)
C +...      WKxyz8(i,j,1)<--"psigDY(i,j,0)"

c #UR       cflsig     = abs(WKxyz8(i,j,k)+WKxyz8(i,j,k))
c #UR       cflmax     = max(cflsig,cflmax)
          END DO
          END DO

          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=dt*psigDY(i,j,km1(k))
     .                     /(pstDYn(i,j)*dsigm1(k)*2.)
            cflsig     = abs(WKxyz8(i,j,k)+WKxyz8(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO

       ELSE

C +--Upstream first  Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF           (staggr)                                     THEN

c #WA     write(6,6002)iterun
 6002     format(i6,' 6002 .not. centrL .and.       staggr /Wind Speed')

          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=(psigDY(i,j,k-1)*dsig_1(k-1)
     .                    +psigDY(i,j,k)  *dsig_1(k))
     .                   /(dsig_1    (k-1)+dsig_1(k))
          END DO
          END DO
          END DO

          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)= psigDY(i,j,1)  *dsig_1(1)
     .                   /(dsig_1    (0)  +dsig_1(1))
          END DO
          END DO

C +--Upstream first  Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE

c #WA     write(6,6003)iterun
 6003     format(i6,' 6003 (.not.)centrL.and. .not. staggr /Wind Speed')

          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)= psigDY(i,j,k)
          END DO
          END DO
          END DO

        END IF

C +--Centered second Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF(centrL)                                                THEN

c #WA     write(6,6004)iterun
 6004     format(i6,' 6004        centrL.and. .not. staggr /CFL Number')

          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*WKxyz8(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.)
            cflsig     = abs(WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO

C +--Upstream first  Order Scheme on a (non) staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE

c #WA     write(6,6005)iterun
 6005     format(i6,' 6005  .not. centrL.and.(.not.)staggr /CFL Number')

          DO          k=    1 ,mmz1
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.0)                              THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO
          END DO

                      k=  mz
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.0)                              THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO

          DO          j=1,my
          DO          i=1,mx
               WKxyz7(i,j,1)= 0.0
          END DO
          END DO

C +--Work Array Reset
C +  ~~~~~~~~~~~~~~~~
          DO          k=1,mz
          DO          j=1,my
          DO          i=1,mx
               WKxyz8(i,j,k)= 0.0
          END DO
          END DO
          END DO

        END IF

       END IF


C +--Set Up    of the Local Split Time Differencing
C +  ----------------------------------------------

            cflmax    = 2.0  *cflmax
C +...      restricted CFL Criterion

            ntimax    =       cflmax
       IF  (centrL)                                               THEN
            ntimax    = max(2,ntimax)
c #WA     write(6,6006)ntimax
 6006     format(i6,' 6006        centrL.and.(.not.)staggr /Nb Iterat.')
       ELSE
            ntimax    = max(1,ntimax)
c #WA     write(6,6007)ntimax
 6007     format(i6,' 6007  .not. centrL.and.(.not.)staggr /Nb Iterat.')
       END IF

C +--Update of CFL Number
C +  ~~~~~~~~~~~~~~~~~~~~
       IF  (ntimax.gt.1)                                          THEN
            faccfl       = 1.0           / ntimax    
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)= WKxyz7(i,j,k) * faccfl 
            WKxyz8(i,j,k)= WKxyz8(i,j,k) * faccfl 
          END DO
          END DO
          END DO
       END IF

C +--OUTPUT for Verification
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #WA  nadvrd      = nadvrd                 + 1
c #WA  write(6,6000) nadvrd,cflmax,ntimax
 6000  format(i6,' CFLmax ',3x,' ',3x,'  =',f7.4,
     .        6x,' ntimax ',8x,  '   =',i4)


C +--2nd Order Centered Energy conserving:  Local Split Time Differencing
C +  --------- (Haltiner & Williams 1980 7.2.2, (7-47b) p.220) ----------
C +            -----------------------------------------------

       IF   (centrL)                                              THEN

        IF  (staggr)                                              THEN

c #WA     write(6,6008)
 6008     format(6x,' 6008        centrL.and.       staggr /A Contrib.')

         DO  itimax=    1,ntimax

C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN

            DO       j=jp11,my1

C +--Vertical Differences

                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = uairDY(i,j,k)
                WKxzq(i,k)   = vairDY(i,j,k)
                WKxzx(i,k)   = pktaDY(i,j,k)

c #VA           WKxzp(i,k)   =(uairDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +uairDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(vairDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +vairDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(pktaDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +pktaDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO

              DO      i=ip11,mx1
                uair_0       =                  WKxzp(i,  k)
c #UR           uair_0       =                 uairUP(i,j,0)
                WKxza(i,k)   =( WKxzp(i,  k)  -uair_0)
                vair_0       =                  WKxzq(i,  k)
c #UR           vair_0       =                 vairUP(i,j,0)
                WKxzb(i,k)   =( WKxzq(i,  k)  -vair_0)
                pkta_0       =                  WKxzx(i,  k)
c #UR           pkta_0       =                 pktaUP(i,j,0)
                WKxzc(i,k)   =( WKxzx(i,  k)  -pkta_0)
              END DO

              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = uairDY(i,j,k)  
                WKxzq(i,k)   = vairDY(i,j,k)
                WKxzx(i,k)   = pktaDY(i,j,k)

c #VA           WKxzp(i,k)   =(uairDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +uairDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +uairDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(vairDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +vairDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +vairDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(pktaDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +pktaDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +pktaDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO

                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   = uairDY(i,j,k)  
                WKxzq(i,k)   = vairDY(i,j,k)
                WKxzx(i,k)   = pktaDY(i,j,k)

c #VA           WKxzp(i,k)   =(uairDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +uairDY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(vairDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +vairDY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(pktaDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +pktaDY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO

              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO

                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0d+0
                WKxy2(i,j)   = 0.0d+0
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(pktaDY(i,j,k)  - WKxzx(i,  k-1)) 
              END DO

C +--Advection Contribution

              DO       k=    1 ,mmz1
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                WKxyz1(i,j,k)= uairDY(i,j,k)  -WKxzd(i,k)
                WKxyz4(i,j,k)= uairDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                WKxyz2(i,j,k)= vairDY(i,j,k)  -WKxzd(i,k)
                WKxyz5(i,j,k)= vairDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)= pktaDY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)= pktaDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO

                       k=       mmz
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                WKxyz1(i,j,k)= uairDY(i,j,k)  -WKxzd(i,k)
                WKxyz4(i,j,k)= uairDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                WKxyz2(i,j,k)= vairDY(i,j,k)  -WKxzd(i,k)
                WKxyz5(i,j,k)= vairDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)= pktaDY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)= pktaDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO

            END DO

C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN

C +--Vertical Differences

            DO       j=jp11,my1

                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO

              DO      i=ip11,mx1
                uair_0       =                  WKxzp(i,  k)
c #UR           uair_0       =                 uairUP(i,j,0)
                WKxza(i,k)   =( WKxzp(i,  k)  -uair_0)
                vair_0       =                  WKxzq(i,  k)
c #UR           vair_0       =                 vairUP(i,j,0)
                WKxzb(i,k)   =( WKxzq(i,  k)  -vair_0)
                pkta_0       =                  WKxzx(i,  k)
c #UR           pkta_0       =                 pktaUP(i,j,0)
                WKxzc(i,k)   =( WKxzx(i,  k)  -pkta_0)
              END DO

              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO

                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO

              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO

                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0
                WKxy2(i,j)   = 0.0
                WKxy3(i,j)   = 0.0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(pktaDY(i,j,k)  - WKxzx(i,  k-1))
              END DO

C +--Advection Contribution

              DO      k=    1 ,mmz1
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO

                      k=       mmz
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO

            END DO

C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE

            DO       j=jp11,my1

C +--Vertical Differences

                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO

              DO      i=ip11,mx1
                uair_0       =                  WKxzp(i,  k)
c #UR           uair_0       =                 uairUP(i,j,0)
                WKxza(i,k)   =( WKxzp(i,  k)  -uair_0)
                vair_0       =                  WKxzq(i,  k)
c #UR           vair_0       =                 vairUP(i,j,0)
                WKxzb(i,k)   =( WKxzq(i,  k)  -vair_0)
                pkta_0       =                  WKxzx(i,  k)
c #UR           pkta_0       =                 pktaUP(i,j,0)
                WKxzc(i,k)   =( WKxzx(i,  k)  -pkta_0)
              END DO

              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO

                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO

              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO

                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0d+0
                WKxy2(i,j)   = 0.0d+0
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(pktaDY(i,j,k)  - WKxzx(i,  k-1))
              END DO

C +--Wind     Advection

              DO             k=    1 ,mmz1
              DO           i=ip11,mx1
                    uairDY(i,j,k) = WKxyz1(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxza(i,k  ))
                    vairDY(i,j,k) = WKxyz2(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxzb(i,k  ))
              END DO
              END DO

                             k=       mmz
              DO           i=ip11,mx1
                    uairDY(i,j,k) = WKxyz1(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy1(i,j)
     .                             +WKxyz8(i,j,k)  *WKxza(i,k))
                    vairDY(i,j,k) = WKxyz2(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy2(i,j)
     .                             +WKxyz8(i,j,k)  *WKxzb(i,k))
              END DO

C +--Pot.Temp.Advect.avoids double Counting in case of convective Adjustment

              DO             k=    1 ,mmz1
              DO           i=ip11,mx1
c #cA           IF (adj_CA(i,j).eq.0)                             THEN
                    pktaDY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k  ))
c #cA           END IF
              END DO
              END DO

                             k=       mmz
              DO           i=ip11,mx1
c #cA           IF (adj_CA(i,j).eq.0)                             THEN
                    pktaDY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy3(i,j)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k))
c #cA           END IF
              END DO

            END DO

          END IF


C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------

         END DO


C +--2nd Order Centered Leap-Frog Backward: Local Split Time Differencing
C +  --------------------------------------------------------------------

        ELSE

c #WA     write(6,6009)
 6009     format(6x,' 6009        centrL.and. .not. staggr /A Contrib.')

         DO  itimax=    1,ntimax

C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN

            DO       j=jp11,my1

C +--Advection Increment

                     k=    1
              DO     i=ip11,mx1
                uair_0       =                 uairDY(i,j,k)
c #UR           uair_0       =                 uairUP(i,j,0)
                WKxza(i,k)   =(uairDY(i,j,k+1)-uair_0)
     .                        *WKxyz7(i,j,k)
                vair_0       =                 vairDY(i,j,k)
c #UR           vair_0       =                 vairUP(i,j,0)
                WKxzb(i,k)   =(vairDY(i,j,k+1)-vairDY(i,j,k  ))
     .                        *WKxyz7(i,j,k)
                pkta_0       =                 pktaDY(i,j,k)
c #UR           pkta_0       =                 pktaUP(i,j,0)
                WKxzc(i,k)   =(pktaDY(i,j,k+1)-pktaDY(i,j,k  )) 
     .                        *WKxyz7(i,j,k)
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(uairDY(i,j,k+1)-uairDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(vairDY(i,j,k+1)-vairDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(pktaDY(i,j,k+1)-pktaDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO

                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -uairDY(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -vairDY(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(pktaDY(i,j,k+1)-pktaDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO

C +--Advection Contribution

              DO       k=    1 ,mmz
              DO       i=ip11,mx1
                WKxyz1(i,j,k)= uairDY(i,j,k)  -WKxza(i,k)
                WKxyz4(i,j,k)= uairDY(i,j,k) -(WKxza(i,k)+WKxza(i,k))
                WKxyz2(i,j,k)= vairDY(i,j,k)  -WKxzb(i,k)
                WKxyz5(i,j,k)= vairDY(i,j,k) -(WKxzb(i,k)+WKxzb(i,k))
                WKxyz3(i,j,k)= pktaDY(i,j,k)  -WKxzc(i,k)
                WKxyz6(i,j,k)= pktaDY(i,j,k) -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
            END DO

C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN

C +--Advection Increment

            DO       j=jp11,my1

                     k=    1
              DO     i=ip11,mx1
                uair_0       =                 WKxyz4(i,j,k)
c #UR           uair_0       =                 uairUP(i,j,0)
                vair_0       =                 WKxyz5(i,j,k)
c #UR           vair_0       =                 vairUP(i,j,0)
                pkta_0       =                 WKxyz6(i,j,k)
c #UR           pkta_0       =                 pktaUP(i,j,0)

                WKxza(i,k)   =(WKxyz4(i,j,k+1)-uair_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-vair_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-pkta_0)
     .                        *WKxyz7(i,j,k)
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO

                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(pktaDY(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO

C +--Advection Contribution

              DO      k=    1 ,mmz
              DO      i=ip11,mx1
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxza(i,k)+WKxza(i,k))
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzb(i,k)+WKxzb(i,k))
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO

            END DO

C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE

            DO       j=jp11,my1

C +--Advection Increment

                      k=    1
              DO      i=ip11,mx1
                uair_0       =                 WKxyz4(i,j,k)
c #UR           uair_0       =                 uairUP(i,j,0)
                vair_0       =                 WKxyz5(i,j,k)
c #UR           vair_0       =                 vairUP(i,j,0)
                pkta_0       =                 WKxyz6(i,j,k)
c #UR           pkta_0       =                 pktaUP(i,j,0)

                WKxza(i,k)   =(WKxyz4(i,j,k+1)-uair_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-vair_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-pkta_0)
     .                        *WKxyz7(i,j,k)
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO

                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(pktaDY(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO

C +--Wind     Advection

              DO             k=    1 ,mmz
                DO           i=ip11,mx1
                      uairDY(i,j,k) = WKxyz1(i,j,k) -WKxza(i,k)        
                      vairDY(i,j,k) = WKxyz2(i,j,k) -WKxzb(i,k)        
                END DO

C +--Pot.Temp.Advect.avoids double Counting in case of convective Adjustment

                DO           i=ip11,mx1
c #cA             IF (adj_CA(i,j).eq.0)                           THEN
                      pktaDY(i,j,k) = WKxyz3(i,j,k) -WKxzc(i,k)
c #cA             END IF
                END DO
              END DO

            END DO

          END IF


C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------

         END DO

        END IF


C +--First  Order Upstream Scheme:          Local Split Time Differencing
C +  --------------------------------------------------------------------

       ELSE

c #WA     write(6,6010)
 6010     format(6x,' 6010  .not. centrL.and.(.not.)staggr /A Contrib.')

         DO  itimax=    1,ntimax

C +--Auxiliary Variables
C +  ~~~~~~~~~~~~~~~~~~~
c #WA     write(6,6011)itimax,WKxyz1(imez,jmez,mz1),WKxyz1(imez,jmez,mz)
c #WA.                       ,uairDY(imez,jmez,mz1),uairDY(imez,jmez,mz)
 6011     format(6x,' 6011  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)

             DO       k=1,mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)= uairDY(i,j,k)
               WKxyz2(i,j,k)= vairDY(i,j,k)
               WKxyz3(i,j,k)= pktaDY(i,j,k)
             END DO
             END DO
             END DO

C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~
                      k=1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = 0.0d+0
               WKxyz5(i,j,k) = 0.0d+0
               WKxyz6(i,j,k) = 0.0d+0
c #UR          WKxyz4(i,j,k) = WKxyz1(i,j,k)-uairUP(i,j,0)
c #UR          WKxyz5(i,j,k) = WKxyz2(i,j,k)-vairUP(i,j,0)
c #UR          WKxyz6(i,j,k) = WKxyz3(i,j,k)-pktaUP(i,j,0)
             END DO
             END DO

             DO       k=kp1(1),mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = WKxyz1(i,j,k)-WKxyz1(i,j,k-1)
               WKxyz5(i,j,k) = WKxyz2(i,j,k)-WKxyz2(i,j,k-1)
               WKxyz6(i,j,k) = WKxyz3(i,j,k)-WKxyz3(i,j,k-1)
             END DO
             END DO
             END DO

                      k=  mzz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxy1 (i,j)   =              -WKxyz1(i,j,k-1)
               WKxy2 (i,j)   =              -WKxyz2(i,j,k-1)
               WKxy3 (i,j)   = pktaDY(i,j,k)-WKxyz3(i,j,k-1)
             END DO
             END DO
C +
C +--Advection Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~
             DO       k=    1 ,mmz1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=uairDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k+1)
               WKxyz2(i,j,k)=vairDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k+1)
               WKxyz3(i,j,k)=pktaDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k+1)
             END DO
             END DO
             END DO

                      k=mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=uairDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy1( i,j)
               WKxyz2(i,j,k)=vairDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy2( i,j)
               WKxyz3(i,j,k)=pktaDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy3( i,j)
             END DO
             END DO

C +--Wind    Update
C +  ~~~~~~~~~~~~~~
             DO             k=1,mz
             DO             j=jp11,my1
               DO           i=ip11,mx1
                     uairDY(i,j,k) = WKxyz1(i,j,k)
                     vairDY(i,j,k) = WKxyz2(i,j,k)
               END DO

C +--Pot.Temp.Update avoids double Counting in case of convective Adjustment
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               DO           i=ip11,mx1
c #cA            IF (adj_CA(i,j).eq.0)                            THEN
                     pktaDY(i,j,k) = WKxyz3(i,j,k)
c #cA            END IF
               END DO
             END DO
             END DO


C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------

c #WA     write(6,6012)itimax,WKxyz1(imez,jmez,mz1),WKxyz1(imez,jmez,mz)
c #WA.                       ,uairDY(imez,jmez,mz1),uairDY(imez,jmez,mz)
 6012     format(6x,' 6012  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)
         END DO

       END IF


C +--Upper Radiating Boundary Condition
C +  ----------------------------------

c #UR   DO           j=jp11,my1
c #UR   DO           i=ip11,mx1
c #UR       uair_c =  zero
c #UR       uair_1 = (uairDY(i,j,1)+uairUP(i,j,1)) * 0.5
c #UR       uair_2 = (uairDY(i,j,2)+uairUP(i,j,2)) * 0.5
c #UR       uair_d =  uair_2       -uair_1
c #UR    IF(uair_d.ne.zero)
c #UR.      uair_c =-(uairDY(i,j,1)-uairUP(i,j,1))*dsig_1(1)/(dt*uair_d)
c #UR    IF(uair_c.lt.zero)                                         THEN
c #UR       dt__UP = -sigma(1) / uair_c
c #UR       nt__UP =  dt       / dt__UP
c #UR       nt__UP =       max(1,nt__UP)
c #UR       dt__UP =  dt       / nt__UP
c #UR       dt_sig =  dt__UP   * uair_c / sigma(1)
c #UR       DO  nt =           1,nt__UP
c #UR                 uairUP(i,j,0)=uairUP(i,j,0)
c #UR.              -(uair_1       -uairUP(i,j,0))*dt_sig
c #UR       END DO
c #UR    END IF
c #UR    DO  k = 1,2
c #UR                 uairUP(i,j,k)=uairDY(i,j,k)
c #UR    END DO

c #UR       vair_c =  zero
c #UR       vair_1 = (vairDY(i,j,1)+vairUP(i,j,1)) * 0.5
c #UR       vair_2 = (vairDY(i,j,2)+vairUP(i,j,2)) * 0.5
c #UR       vair_d =  vair_2       -vair_1
c #UR    IF(vair_d.ne.zero)
c #UR.      vair_c =-(vairDY(i,j,1)-vairUP(i,j,1))*dsig_1(1)/(dt*vair_d)
c #UR    IF(vair_c.lt.zero)                                         THEN
c #UR       dt__UP = -sigma(1) / vair_c
c #UR       nt__UP =  dt       / dt__UP
c #UR       nt__UP =       max(1,nt__UP)
c #UR       dt__UP =  dt       / nt__UP
c #UR       dt_sig =  dt__UP   * vair_c / sigma(1)
c #UR       DO  nt =           1,nt__UP
c #UR                 vairUP(i,j,0)=vairUP(i,j,0)
c #UR.              -(vair_1       -vairUP(i,j,0))*dt_sig
c #UR       END DO
c #UR    END IF
c #UR    DO  k = 1,2
c #UR                 vairUP(i,j,k)=vairDY(i,j,k)
c #UR    END DO

c #UR       pkta_c =  zero
c #UR       pkta_1 = (pktaDY(i,j,1)+pktaUP(i,j,1)) * 0.5
c #UR       pkta_2 = (pktaDY(i,j,2)+pktaUP(i,j,2)) * 0.5
c #UR       pkta_d =  pkta_2       -pkta_1
c #UR    IF(pkta_d.ne.zero)
c #UR.      pkta_c =-(pktaDY(i,j,1)-pktaUP(i,j,1))*dsig_1(1)/(dt*pkta_d)
c #UR    IF(pkta_c.lt.zero)                                         THEN
c #UR       dt__UP = -sigma(1) / pkta_c
c #UR       nt__UP =  dt       / dt__UP
c #UR       nt__UP =       max(1,nt__UP)
c #UR       dt__UP =  dt       / nt__UP
c #UR       dt_sig =  dt__UP   * pkta_c / sigma(1)
c #UR       DO  nt =           1,nt__UP
c #UR                 pktaUP(i,j,0)=pktaUP(i,j,0)
c #UR.              -(pkta_1       -pktaUP(i,j,0))*dt_sig
c #UR       END DO
c #UR    END IF
c #UR    DO  k = 1,2
c #UR                 pktaUP(i,j,k)=pktaDY(i,j,k)
c #UR    END DO

c #UR   END DO
c #UR   END DO


C +--Work Arrays Reset
C +  -----------------

        DO       j=1,my
        DO       i=1,mx
          WKxy1( i,j)   = 0.0
          WKxy2( i,j)   = 0.0
          WKxy3( i,j)   = 0.0
        END DO
        END DO

        DO       k=1,mz
        DO       i=1,mx
          WKxza( i,  k) = 0.0
          WKxzb( i,  k) = 0.0
          WKxzc( i,  k) = 0.0
          WKxzd( i,  k) = 0.0
          WKxzp( i,  k) = 0.0
          WKxzq( i,  k) = 0.0
          WKxzx( i,  k) = 0.0
        END DO
        END DO

        DO       k=1,mz
        DO       j=1,my
        DO       i=1,mx
          WKxyz1(i,j,k) = 0.0
          WKxyz2(i,j,k) = 0.0
          WKxyz3(i,j,k) = 0.0
          WKxyz4(i,j,k) = 0.0
          WKxyz5(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
          WKxyz7(i,j,k) = 0.0
          WKxyz8(i,j,k) = 0.0
        END DO
        END DO
        END DO


C +--Third Order Vertical Scheme
C +  ===========================

c #ZU ELSE 

c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      = 0.0
c #ZO  ga0(i,j)      = uairDY(i,j,mz)
c #ZU  END DO
c #ZU  END DO

c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    = uairDY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO

C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************

c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU  uairDY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO

c #ZO  DO  j=jp11,my1
c #ZO  DO  i=ip11,mx1
c #ZO  ga0(i,j)      = vairDY(i,j,mz)
c #ZU  END DO
c #ZU  END DO

c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    = vairDY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO

C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************

c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU  vairDY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO

c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      = pktaDY(i,j,mzz)
c #ZO  ga0(i,j)      = pktaDY(i,j,mz)
c #ZU  END DO
c #ZU  END DO

c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    = pktaDY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO

C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************

c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU  pktaDY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO

c #ZU end if 

      return
      end


      subroutine DYNadv_cubv(gat,ga0)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    11-03-1996  MAR |
C |   SubRoutine DYNadv_cubv  computes vertical Advection                  |
C |              using a Cubic Spline Interpolation Technique              |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | INPUT:  gat       : each of the following variables at Time Step n     |
C | ^^^^^       uairDY: x-wind speed component                      (m/s)  |
C |             vairDY: y-wind speed component                      (m/s)  |
C |             pktaDY: potential temperature divided by 100.[kPa]**(R/Cp) |
C |         ga0       : Surface Bound. Condit. of uairDY, vairDY or pktaDY |
C |                                                                        |
C | OUTPUT: gat         ,                               at Time Step n+1   |
C | ^^^^^^                                                                 |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_CU.inc'

      include 'MAR_WK.inc'

      real     gat(mx,my,mz),ga0(mx,my)


C +--Local  Variables
C +  ================

      integer  kk
      real     al,al2,al3,y


C +--Cubic Spline
C +  ============

      DO j=jp11,my1
      DO i=ip11,mx1
        WKxyz2(i,j, 1)=2.0- 0.5 *CUspzh(2)
C +...  P_1           (Pielke, p.302)
        WKxyz3(i,j, 1)=3.0*(gat(i,j,2)-gat(i,j,1))/dsig_1(1)
     .                /WKxyz2(i,j,1)
C +***  R_1           (Pielke, p.304)
      END DO
      END DO

      DO k=kp1(1),mmz1
      DO j=jp11,my1
      DO i=ip11,mx1
        WKxyz2(i,j, k)=2.0-(CUspzb(k-1)*CUspzh(k))/WKxyz2(i,j,k-1)
C +...  P_k, k=kp1(1),mmz1 (Pielke, p.303)
        WKxyz3(i,j, k)=
     . (3.0*((gat(i,j,k+1)-gat(i,j,k))*CUspzb(k)/dsig_1(k)
     .      +(gat(i,j,k)-gat(i,j,k-1))*CUspzh(k)/dsig_1(k-1))
     . -WKxyz3(i,j,k-1) *CUspzh( k)) / WKxyz2(i,j,k)
C +***  R_k, k=kp1(1),mmz1  (Pielke, p.304)
      END DO
      END DO
      END DO

      DO j=jp11,my1
      DO i=ip11,mx1
        WKxyz2(i,j,mz)=2.0-(CUspzb(mmz1)*CUspzh(mz))/WKxyz2(i,j,mmz1)
C +***  P_k, k=kp1(1),mmz1  (Pielke, p.303)
        WKxyz3(i,j,mz)=
     . (3.0*((ga0(i,j   )-gat(i,j,mz )) *CUspzb(mz) /dsig_1(mz)
     .      +(gat(i,j,mz)-gat(i,j,mmz1))*CUspzh(mz) /dsig_1(mmz1))
     . -WKxyz3(i,j,mmz1) *CUspzh(mz)) / WKxyz2(i,j,mz)
C +***  R_mz         (Pielke, p.304)
      END DO
      END DO

      DO j=jp11,my1
      DO i=ip11,mx1
        WKxyz4(i,j,mz)=WKxyz3(i,j,mz)-CUspzb(mz)
     .    *(3.0*(ga0(i,j)-gat(i,j,mz))/dsig_1(mz)-0.50*WKxyz3(i,j,mz))
     .    /(2.0                      - 0.50*CUspzb(mz)/WKxyz2(i,j,mz))
     .    / WKxyz2(i,j,mz)
C +***    N_mz         (Pielke, p.303)
      END DO
      END DO

      DO kk=1,mmz1
         k =mz-kk
      DO j=jp11,my1
      DO i=ip11,mx1
          WKxyz4(i,j, k)=WKxyz3(i,j, k)-CUspzb(k)
     .     * WKxyz4(i,j,k+1)
     .     / WKxyz2(i,j,k)
C +***    N_k, k=mmz1,1 (Pielke, p.303)
      END DO
      END DO
      END DO

      DO k=1,mz
      DO j=jp11,my1
      DO i=ip11,mx1
          al =psigDY(i,j,k)*dt/pstDYn(i,j)/dsig_1(k-1)
          al2=al*al
          al3=al2*al
        IF (al.lt.0.0)                                         GO TO 5
        IF (k .eq.1  )                                         GO TO 3
          y=gat(i,j,k-1)-gat(i,j,k)
          gat(i,j,k)=gat(i,j,k)
     .     -al *           WKxyz4(i,j,k)  *dsig_1(k-1)
     .     +al2*(3.0*y+2.0*WKxyz4(i,j,k)  *dsig_1(k-1) 
     .                    +WKxyz4(i,j,k-1)*dsig_1(k-1))
     .     -al3*(2.0*y+    WKxyz4(i,j,k)  *dsig_1(k-1) 
     .                    +WKxyz4(i,j,k-1)*dsig_1(k-1))
        GO TO  3
 5      CONTINUE
        IF (k .eq.mz)                                          GO TO 3
          y=gat(i,j,k)-gat(i,j,k+1)
          gat(i,j,k)=gat(i,j,k)
     .     -al * WKxyz4(i,j,k)*dsig_1(k)
     .     -al2*(3.0*y+2.0*WKxyz4(i,j,k)  *dsig_1(k) 
     .                    +WKxyz4(i,j,k+1)*dsig_1(k))
     .     -al3*(2.0*y+    WKxyz4(i,j,k)  *dsig_1(k) 
     .                    +WKxyz4(i,j,k+1)*dsig_1(k))
 3      CONTINUE
      END DO
      END DO
      END DO


C +--Work Arrays Reset
C +  =================

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz2(i,j,k) = 0.0
        WKxyz3(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
      END DO
      END DO
      END DO

      return
      end


      subroutine DYNadv_verq

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    18-09-2001  MAR |
C |   SubRoutine DYNadv_verq includes the Vertical  Advection Contribution |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^      iterun,            Run Iteration  Counter                 |
C |                qvDY,            Air Vap. Water Values / Time Step n    |
C |              qvapSL,            SBC Vap. Water Values / Time Step n    |
C |                                                                        |
C |   OUTPUT  (via common block)                                           |
C |   ^^^^^^       qvDY,            Air Vap. Water Values / Time Step n+1  |
C |                                                                        |
C |   METHOD:  Unstaggered Grid: 1st Accurate in Space Upstream Scheme     |
C |   ^^^^^^^^   Staggered Grid: 2nd Accurate in Space                     |
C |                                                                        |
C | # OPTIONS: #VA: Vertical Average preferred in Centered Conserv Scheme  |
C | # ^^^^^^^^ #NS: NO   Slip Surface BC used  in Centered Conserv Scheme  |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
c #cA include 'MAR_CA.inc'
      include 'MAR_SL.inc'
C +
      include 'MAR_WK.inc'
C +
c #WA integer                  nadvrd
c #WA common  /DYNadv_ver_loc/ nadvrd
C +
      logical  centrL
c #ZU logical  adv3rd
c #ZU real     gat(mx,my,mz),ga0(mx,my)
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  itimax,ntimax
      real     cflmax,cflsig,faccfl,dsgm,qv_0
      real     old__u,old__v,old__t,qw_0,qr_0
C +
C +
C +--DATA
C +  ====
C +
c #ZU data adv3rd/ .true./
C +
      data centrL/ .true./
c #UP      centrL=.false.
C +
C +
C +--Slip condition for Mountain Wave Experiments
C +  ============================================
C +
c #OM   DO       j=jp11,my1
c #OM   DO       i=ip11,mx1
c #OM     psigDY(i,j,mz)=0.0
c #OM   END DO
c #OM   END DO
C +
C +
C +--First and Second Order Schemes
C +  ==============================
C +
c #ZU IF (.not.adv3rd)                                            THEN 
C +
C +
C +--Courant Number
C +  --------------
C +
           cflmax     = 0.0
C +
C +--Centered second Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       IF (centrL.and.staggr)                                     THEN
C +
c #WA     write(6,6001)iterun
 6001     format(i6,' 6001       centrL .and.       staggr /CFL Number')
C +
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*psigDY(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.0)
            cflsig     = abs(WKxyz7(i,j,k)+WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)=   0.0
          END DO
          END DO
C +
          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=dt*psigDY(i,j,km1(k))
     .                     /(pstDYn(i,j)*dsigm1(k)*2.0)
            cflsig     = abs(WKxyz8(i,j,k)+WKxyz8(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
       ELSE
C +
C +--Upstream first  Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF           (staggr)                                     THEN
C +
c #WA     write(6,6002)iterun
 6002     format(i6,' 6002 .not. centrL .and.       staggr /Wind Speed')
C +
          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=(psigDY(i,j,k-1)*dsig_1(k-1)
     .                    +psigDY(i,j,k)  *dsig_1(k))
     .                   /(dsig_1    (k-1)+dsig_1(k))
          END DO
          END DO
          END DO
C +
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)= psigDY(i,j,1)  *dsig_1(1)
     .                   /(dsig_1    (0)  +dsig_1(1))
          END DO
          END DO
C +
C +--Upstream first  Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE
C +
c #WA     write(6,6003)iterun
 6003     format(i6,' 6003 (.not.)centrL.and. .not. staggr /Wind Speed')
C +
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)= psigDY(i,j,k)
          END DO
          END DO
          END DO
C +
        END IF
C +
C +--Centered second Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF(centrL)                                                THEN
C +
c #WA     write(6,6004)iterun
 6004     format(i6,' 6004        centrL.and. .not. staggr /CFL Number')
C +
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*WKxyz8(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.0)
            cflsig     = abs(WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
C +--Upstream first  Order Scheme on a (non) staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE
C +
c #WA     write(6,6005)iterun
 6005     format(i6,' 6005  .not. centrL.and.(.not.)staggr /CFL Number')
C +
          DO          k=    1 ,mmz1
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.0)                              THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
                      k=  mz
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.0)                              THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO
C +
          DO          j=1,my
          DO          i=1,mx
               WKxyz7(i,j,1)= 0.0
          END DO
          END DO
C +
C +--Work Array Reset
C +  ~~~~~~~~~~~~~~~~
          DO          k=1,mz
          DO          j=1,my
          DO          i=1,mx
               WKxyz8(i,j,k)= 0.0
          END DO
          END DO
          END DO
C +
        END IF
C +
       END IF
C +
C +
C +--Set Up    of the Local Split Time Differencing
C +  ----------------------------------------------
C +
            cflmax    = 2.0 *cflmax
C +...      restricted CFL Criterion
C +
            ntimax    =       cflmax
       IF  (centrL)                                               THEN
            ntimax    = max(2,ntimax)
c #WA     write(6,6006)ntimax
 6006     format(i6,' 6006        centrL.and.(.not.)staggr /Nb Iterat.')
       ELSE
            ntimax    = max(1,ntimax)
c #WA     write(6,6007)ntimax
 6007     format(i6,' 6007  .not. centrL.and.(.not.)staggr /Nb Iterat.')
       END IF
C +
C +--Update of CFL Number
C +  ~~~~~~~~~~~~~~~~~~~~
       IF  (ntimax.gt.1)                                          THEN
            faccfl       = 1.0d+0        / ntimax    
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)= WKxyz7(i,j,k) * faccfl 
            WKxyz8(i,j,k)= WKxyz8(i,j,k) * faccfl 
          END DO
          END DO
          END DO
       END IF
C +
C +--OUTPUT for Verification
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #WA  nadvrd      = nadvrd                 + 1
c #WA  write(6,6000) nadvrd,cflmax,ntimax
 6000  format(i6,' CFLmax ',3x,' ',3x,'  =',f7.4,
     .        6x,' ntimax ',8x,  '   =',i4)
C +
C +
C +--2nd Order Centered Energy conserving:  Local Split Time Differencing
C +  --------- (Haltiner & Williams 1980 7.2.2, (7-47b) p.220) ----------
C +            -----------------------------------------------
C +
       IF   (centrL)                                              THEN
C +
        IF  (staggr)                                              THEN
C +
c #WA     write(6,6008)
 6008     format(6x,' 6008        centrL.and.       staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN
C +
            DO       j=jp11,my1
C +
C +--Vertical Differences
C +  
                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzx(i,k)   =   qvDY(i,j,k)
C +
c #VA           WKxzx(i,k)   =(  qvDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qvDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
C +
              DO      i=ip11,mx1
                  qv_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qv_0)
              END DO
C +
              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzx(i,k)   =   qvDY(i,j,k)
C +
c #VA           WKxzx(i,k)   =(  qvDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qvDY(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +  qvDY(i,j,k+1)*dsigm1(k+1)        )/dsgm
              END DO
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO
C +
                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzx(i,k)   =   qvDY(i,j,k)
C +
c #VA           WKxzx(i,k)   =(  qvDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qvDY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO
C +
              DO      i=ip11,mx1
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy3(i,j)   = 0.0
c #NS           WKxy3(i,j)   =(qvapSL(i,j)    - WKxzx(i,  k-1)) 
              END DO
C +
C +--Advection Contribution
C +  
              DO       k=    1 ,mmz1
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)=   qvDY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)=   qvDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO
C +
                       k=       mmz
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)=   qvDY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)=   qvDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO
C +
            END DO
C +
C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN
C +
C +--Vertical Differences
C +
            DO       j=jp11,my1
C +
                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
C +
              DO      i=ip11,mx1
                  qv_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qv_0)
              END DO
C +
              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)        )/dsgm
              END DO
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO
C +
                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO
C +
              DO      i=ip11,mx1
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy3(i,j)   =(qvapSL(i,j)    - WKxzx(i,  k-1)) 
              END DO
C +
C +--Advection Contribution
C +  
              DO      k=    1 ,mmz1
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
C +
            END DO
C +
C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE
C +
            DO       j=jp11,my1
C +
C +--Vertical Differences
C +
                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
C +
              DO      i=ip11,mx1
                  qv_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qv_0)
              END DO
C +
              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO
C +
                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO
C +
              DO      i=ip11,mx1
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy3(i,j)   =(qvapSL(i,j)    - WKxzx(i,  k-1))
              END DO
C +
C +--Wat.Vapr.Advect.avoids double Counting in case of convective Adjustment
C +
              DO             k=    1 ,mmz1
              DO           i=ip11,mx1
c #cA           IF (adj_CA(i,j).eq.0)                             THEN
                      qvDY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k  ))
c #cA           END IF
              END DO
              END DO
C +
                             k=       mmz
              DO           i=ip11,mx1
c #cA           IF (adj_CA(i,j).eq.0)                             THEN
                      qvDY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy3(i,j)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k))
c #cA           END IF
              END DO
C +
            END DO
C +
          END IF
C +
C +
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
C +
C +--2nd Order Centered Leap-Frog Backward: Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
        ELSE
C +
c #WA     write(6,6009)
 6009     format(6x,' 6009        centrL.and. .not. staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +  
                     k=    1
              DO     i=ip11,mx1
                  qv_0       =                   qvDY(i,j,k)
                WKxzc(i,k)   =(  qvDY(i,j,k+1)-  qvDY(i,j,k  )) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxzc(i,k)   =(  qvDY(i,j,k+1)-  qvDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxzc(i,k)   =(qvapSL(i,j)    -  qvDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO       k=    1 ,mmz
              DO       i=ip11,mx1
                WKxyz3(i,j,k)=   qvDY(i,j,k)  -WKxzc(i,k)
                WKxyz6(i,j,k)=   qvDY(i,j,k) -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
            END DO
C +
C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN
C +
C +--Advection Increment
C +
            DO       j=jp11,my1
C +
                     k=    1
              DO     i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qw_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-  qr_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qvapSL(i,j)    -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO      k=    1 ,mmz
              DO      i=ip11,mx1
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxza(i,k)+WKxza(i,k))
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzb(i,k)+WKxzb(i,k))
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
C +
            END DO
C +
C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +
                      k=    1
              DO      i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qw_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-  qr_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qvapSL(i,j)    -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Wat.Vapr.Advect.avoids double Counting in case of convective Adjustment
C +
              DO             k=    1 ,mmz
                DO           i=ip11,mx1
c #cA             IF (adj_CA(i,j).eq.0)                           THEN
                        qvDY(i,j,k) = WKxyz3(i,j,k) -WKxzc(i,k)
c #cA             END IF
                END DO
              END DO
C +
            END DO
C +
          END IF
C +
C +
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
        END IF
C +
C +
C +--First  Order Upstream Scheme:          Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
       ELSE
C +
c #WA     write(6,6010)
 6010     format(6x,' 6010  .not. centrL.and.(.not.)staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--Auxiliary Variables
C +  ~~~~~~~~~~~~~~~~~~~
c #WA     write(6,6011)itimax,WKxyz1(imez,jmez,mz1),WKxyz1(imez,jmez,mz)
c #WA.                       ,  qvDY(imez,jmez,mz1),  qvDY(imez,jmez,mz)
 6011     format(6x,' 6011  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)
C +
             DO       k=1,mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz3(i,j,k)=   qvDY(i,j,k)
             END DO
             END DO
             END DO
C +
C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~
                      k=1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = 0.0d+0
               WKxyz5(i,j,k) = 0.0d+0
               WKxyz6(i,j,k) = 0.0d+0
             END DO
             END DO
C +
             DO       k=kp1(1),mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = WKxyz1(i,j,k)-WKxyz1(i,j,k-1)
               WKxyz5(i,j,k) = WKxyz2(i,j,k)-WKxyz2(i,j,k-1)
               WKxyz6(i,j,k) = WKxyz3(i,j,k)-WKxyz3(i,j,k-1)
             END DO
             END DO
             END DO
C +
                      k=  mzz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxy1 (i,j)   =              -WKxyz1(i,j,k-1)
               WKxy2 (i,j)   =              -WKxyz2(i,j,k-1)
               WKxy3 (i,j)   = qvapSL(i,j)  -WKxyz3(i,j,k-1)
             END DO
             END DO
C +
C +--Advection Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~
             DO       k=    1 ,mmz1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz3(i,j,k)=  qvDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k+1)
             END DO
             END DO
             END DO
C +
                      k=mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz3(i,j,k)=  qvDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy3( i,j)
             END DO
             END DO
C +
C +--Wat.Vapr.Update avoids double Counting in case of convective Adjustment
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             DO             k=1,mz
             DO             j=jp11,my1
               DO           i=ip11,mx1
c #cA            IF (adj_CA(i,j).eq.0)                            THEN
                       qvDY(i,j,k) = WKxyz3(i,j,k)
c #cA            END IF
               END DO
             END DO
             END DO
C +
C +
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
c #WA     write(6,6012)itimax,WKxyz1(imez,jmez,mz1),WKxyz1(imez,jmez,mz)
c #WA.                       ,  qvDY(imez,jmez,mz1),  qvDY(imez,jmez,mz)
 6012     format(6x,' 6012  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)
         END DO
C +
       END IF
C +
C +
C +--Work Arrays Reset
C +  -----------------
C +
        DO       j=1,my
        DO       i=1,mx
          WKxy1( i,j)   = 0.0
          WKxy2( i,j)   = 0.0
          WKxy3( i,j)   = 0.0
        END DO
        END DO
C +
        DO       k=1,mz
        DO       i=1,mx
          WKxza( i,  k) = 0.0
          WKxzb( i,  k) = 0.0
          WKxzc( i,  k) = 0.0
          WKxzd( i,  k) = 0.0
        END DO
        END DO
C +
        DO       k=1,mz
        DO       j=1,my
        DO       i=1,mx
          WKxyz1(i,j,k) = 0.0
          WKxyz2(i,j,k) = 0.0
          WKxyz3(i,j,k) = 0.0
          WKxyz4(i,j,k) = 0.0
          WKxyz5(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
          WKxyz7(i,j,k) = 0.0
          WKxyz8(i,j,k) = 0.0
        END DO
        END DO
        END DO
C +
C +
C +--Third Order Vertical Scheme
C +  ===========================
C +
c #ZU ELSE 
C +
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      = qvapSL(i,j)    
c #ZO  ga0(i,j)      =   qvDY(i,j,mz)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    =   qvDY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU    qvDY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZU end if 
C +
      return
      end


      subroutine HYDadv_ver

C +------------------------------------------------------------------------+
C | MAR DYNAMICS   SLOW                                    18-09-2001  MAR |
C |   SubRoutine HYDadv_ver  includes the Vertical  Advection Contribution |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT   (via common block)                                           |
C |   ^^^^^    iterun  : Run   Iteration Counter                           |
C |              qvDY, qwHY, qrHY, qiHY, ccniHY, qsHY / Time Step n        |
C |              qwHY  : Cloud Droplets Concentration             (kg/kg)  |
C |              qrHY  : Rain  Drops    Concentration             (kg/kg)  |
C |              qvDY  : Water Vapor    Concentration             (kg/kg)  |
C |              qiHY  : Ice   Crystals Concentration             (kg/kg)  |
C |            ccniHY  : Ice   Crystals Number                             |
C |              qsHY  : Snow  Flakes   Concentration             (kg/kg)  |
C |                                                                        |
C |   OUTPUT :   qvDY, qwHY, qrHY, qiHY, ccniHY, qsHY / Time Step n+1      |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   METHOD:  Unstaggered Grid: 1st Accurate in Space Upstream Scheme     |
C |   ^^^^^^^^   Staggered Grid: 2nd Accurate in Space                     |
C |                                                                        |
C | # OPTIONS: #VA: Vertical Average preferred in Centered Conserv Scheme  |
C | # ^^^^^^^^ #NS: NO   Slip Surface BC used  in Centered Conserv Scheme  |
C | #          #WF: Water Conservation  along the Vertical                 |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
c #cA include 'MAR_CA.inc'
c #HY include 'MAR_HY.inc'
      include 'MAR_SL.inc'

      include 'MAR_WK.inc'

c #WA integer                  nadvrd
c #WA common  /DYNadv_ver_loc/ nadvrd

      logical  centrL
c #ZU logical  adv3rd
c #ZU real     gat(mx,my,mz),ga0(mx,my)


C +--Local  Variables
C +  ================

      integer  ntimax,itimax

      real     cflmax,cflsig,faccfl,dsgm 
      real     old__u,old__v,old__t
      real     qw_0  ,qr_0  ,qv_0  ,qi_0  ,ccni_0,qs_0
c #WF real     qwVC  ,qrVC  ,qvVC  ,qiVC  ,ciVC  ,qsVC
c #BS real     dh_sno


C +--DATA
C +  ====

c #ZU data adv3rd/ .true./

      data centrL/ .true./
c #UP      centrL=.false.


C +--Slip condition for Mountain Wave Experiments
C +  ============================================

c #OM   DO       j=jp11,my1
c #OM   DO       i=ip11,mx1
c #OM     psigDY(i,j,mz)=0.0
c #OM   END DO
c #OM   END DO


C +--First and Second Order Schemes
C +  ==============================

c #ZU IF (.not.adv3rd)                                            THEN 


C +--Courant Number
C +  --------------

           cflmax     = 0.0

C +--Centered second Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       IF (centrL.and.staggr)                                     THEN

c #WA     write(6,6001)iterun
 6001     format(i6,' 6001       centrL .and.       staggr /CFL Number')

          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*psigDY(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.0)
            cflsig     = abs(WKxyz7(i,j,k)+WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO

          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)=                 0.00
          END DO
          END DO

          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=dt*psigDY(i,j,km1(k))
     .                     /(pstDYn(i,j)*dsigm1(k)*2.0)
            cflsig     = abs(WKxyz8(i,j,k)+WKxyz8(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO

       ELSE

C +--Upstream first  Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF           (staggr)                                     THEN

c #WA     write(6,6002)iterun
 6002     format(i6,' 6002 .not. centrL .and.       staggr /Wind Speed')

          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=(psigDY(i,j,k-1)*dsig_1(k-1)
     .                    +psigDY(i,j,k)  *dsig_1(k))
     .                   /(dsig_1    (k-1)+dsig_1(k))
          END DO
          END DO
          END DO

          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)= psigDY(i,j,1)  *dsig_1(1)
     .                   /(dsig_1    (0)  +dsig_1(1))
          END DO
          END DO

C +--Upstream first  Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE

c #WA     write(6,6003)iterun
 6003     format(i6,' 6003 (.not.)centrL.and. .not. staggr /Wind Speed')

          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)= psigDY(i,j,k)
          END DO
          END DO
          END DO

        END IF

C +--Centered second Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF(centrL)                                                THEN

c #WA     write(6,6004)iterun
 6004     format(i6,' 6004        centrL.and. .not. staggr /CFL Number')

          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*WKxyz8(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.0)
            cflsig     = abs(WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO

C +--Upstream first  Order Scheme on a (non) staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE

c #WA     write(6,6005)iterun
 6005     format(i6,' 6005  .not. centrL.and.(.not.)staggr /CFL Number')

          DO          k=    1 ,mmz1
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.0)                              THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO
          END DO

                      k=  mz
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.0)                              THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO

          DO          j=1,my
          DO          i=1,mx
               WKxyz7(i,j,1)= 0.0
          END DO
          END DO

C +--Work Array Reset
C +  ~~~~~~~~~~~~~~~~
          DO          k=1,mz
          DO          j=1,my
          DO          i=1,mx
               WKxyz8(i,j,k)= 0.0
          END DO
          END DO
          END DO

        END IF

       END IF


C +--Set Up    of the Local Split Time Differencing
C +  ----------------------------------------------

            cflmax    = 2.0  *cflmax
C +...      restricted CFL Criterion

            ntimax    =       cflmax
       IF  (centrL)                                               THEN
            ntimax    = max(2,ntimax)
c #WA     write(6,6006)ntimax
 6006     format(i6,' 6006        centrL.and.(.not.)staggr /Nb Iterat.')
       ELSE
            ntimax    = max(1,ntimax)
c #WA     write(6,6007)ntimax
 6007     format(i6,' 6007  .not. centrL.and.(.not.)staggr /Nb Iterat.')
       END IF

C +--Update of CFL Number
C +  ~~~~~~~~~~~~~~~~~~~~
       IF  (ntimax.gt.1)                                          THEN
            faccfl       = 1.0d+0        / ntimax    
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)= WKxyz7(i,j,k) * faccfl 
            WKxyz8(i,j,k)= WKxyz8(i,j,k) * faccfl 
          END DO
          END DO
          END DO
       END IF

C +--OUTPUT for Verification
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #WA  nadvrd      = nadvrd                 + 1
c #WA  write(6,6000) nadvrd,cflmax,ntimax
 6000  format(i6,' CFLmax ',3x,' ',3x,'  =',f7.4,
     .        6x,' ntimax ',8x,  '   =',i4)


C +--Warm Water Conservation
C +  -----------------------

c #WF  DO j=1,my
c #WF  DO i=1,mx
c #WF      WKxy4(i,j) = 0.0d+0
c #WF      WKxy5(i,j) = 0.0d+0
c #WF      WKxy6(i,j) = 0.0d+0
c #WF      WKxy7(i,j) = 0.0d+0
c #WF      WKxy8(i,j) = 0.0d+0
c #WF      WKxy9(i,j) = 0.0d+0
c #WF    DO k=1,mz
c #WF      WKxy4(i,j) = WKxy4(i,j) + dsigm1(k)*qvDY(i,j,k)
c #WF      WKxy5(i,j) = WKxy5(i,j) + dsigm1(k)*qwHY(i,j,k)
c #WF      WKxy6(i,j) = WKxy6(i,j) + dsigm1(k)*qrHY(i,j,k)
c #WF      WKxy7(i,j) =         max(WKxy7(i,j),qvDY(i,j,k))
c #WF      WKxy8(i,j) =         max(WKxy8(i,j),qwHY(i,j,k))
c #WF      WKxy9(i,j) =         max(WKxy9(i,j),qrHY(i,j,k))
c #WF    END DO
c #WF  END DO
c #WF  END DO


C +--Warm Water
C +--Start Vertical Advection
C +  ------------------------

       IF   (centrL)                                              THEN

        IF  (staggr)                                              THEN

c #WA     write(6,6008)
 6008     format(6x,' 6008        centrL.and.       staggr /A Contrib.')

C +--2nd Order Centered Energy conserving:  Local Split Time Differencing
C +  ~~~~~~~~~ (Haltiner & Williams 1980 7.2.2, (7-47b) p.220) ~~~~~~~~~~
C +            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         DO  itimax=    1,ntimax

C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN

            DO       j=jp11,my1

C +--Vertical Differences

                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   =   qwHY(i,j,k)
                WKxzq(i,k)   =   qrHY(i,j,k)
                WKxzx(i,k)   =   qvDY(i,j,k)

c #VA           WKxzp(i,k)   =(  qwHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qwHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(  qrHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qrHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(  qvDY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qvDY(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO

              DO      i=ip11,mx1
                  qw_0       =                  WKxzp(i,  k)
                WKxza(i,k)   =( WKxzp(i,  k)  -  qw_0)
                  qr_0       =                  WKxzq(i,  k)
                WKxzb(i,k)   =( WKxzq(i,  k)  -  qr_0)
                  qv_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qv_0)
              END DO

              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   =   qwHY(i,j,k)  
                WKxzq(i,k)   =   qrHY(i,j,k)
                WKxzx(i,k)   =   qvDY(i,j,k)

c #VA           WKxzp(i,k)   =(  qwHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qwHY(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +  qwHY(i,j,k+1)*dsigm1(k+1)        )/dsgm
c #VA           WKxzq(i,k)   =(  qrHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qrHY(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +  qrHY(i,j,k+1)*dsigm1(k+1)        )/dsgm
c #VA           WKxzx(i,k)   =(  qvDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qvDY(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +  qvDY(i,j,k+1)*dsigm1(k+1)        )/dsgm
              END DO
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO

                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   =   qwHY(i,j,k)  
                WKxzq(i,k)   =   qrHY(i,j,k)
                WKxzx(i,k)   =   qvDY(i,j,k)

c #VA           WKxzp(i,k)   =(  qwHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qwHY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(  qrHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qrHY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(  qvDY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qvDY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO

              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO

                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0d+0
                WKxy2(i,j)   = 0.0d+0
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(qvapSL(i,j)    - WKxzx(i,  k-1)) 
              END DO

C +--Advection Contribution

              DO       k=    1 ,mmz1
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                WKxyz1(i,j,k)=   qwHY(i,j,k)  -WKxzd(i,k)
                WKxyz4(i,j,k)=   qwHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                WKxyz2(i,j,k)=   qrHY(i,j,k)  -WKxzd(i,k)
                WKxyz5(i,j,k)=   qrHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)=   qvDY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)=   qvDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO

                       k=       mmz
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                WKxyz1(i,j,k)=   qwHY(i,j,k)  -WKxzd(i,k)
                WKxyz4(i,j,k)=   qwHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                WKxyz2(i,j,k)=   qrHY(i,j,k)  -WKxzd(i,k)
                WKxyz5(i,j,k)=   qrHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)=   qvDY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)=   qvDY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO

            END DO

C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN

C +--Vertical Differences

            DO       j=jp11,my1

                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO

              DO      i=ip11,mx1
                  qw_0       =                  WKxzp(i,  k)
                WKxza(i,k)   =( WKxzp(i,  k)  -  qw_0)
                  qr_0       =                  WKxzq(i,  k)
                WKxzb(i,k)   =( WKxzq(i,  k)  -  qr_0)
                  qv_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qv_0)
              END DO

              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO

                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO

              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO

                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0d+0
                WKxy2(i,j)   = 0.0d+0
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(qvapSL(i,j)    - WKxzx(i,  k-1))
              END DO

C +--Advection Contribution

              DO      k=    1 ,mmz1
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO

                      k=       mmz
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))

                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO

            END DO

C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE

            DO       j=jp11,my1

C +--Vertical Differences

                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO

              DO      i=ip11,mx1
                  qw_0       =                  WKxzp(i,  k)
                WKxza(i,k)   =( WKxzp(i,  k)  -  qw_0)
                  qr_0       =                  WKxzq(i,  k)
                WKxzb(i,k)   =( WKxzq(i,  k)  -  qr_0)
                  qv_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qv_0)
              END DO

              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)        )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)        )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0d+0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)        )/dsgm
              END DO
              END DO

              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO

                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)

c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0d+0)/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0d+0)/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0d+0)/dsgm
              END DO

              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO

                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0d+0
                WKxy2(i,j)   = 0.0d+0
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(qvapSL(i,j)    - WKxzx(i,  k-1))
              END DO

C +--Hydromet.Advection

              DO             k=    1 ,mmz1
              DO           i=ip11,mx1
                      qwHY(i,j,k) = WKxyz1(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxza(i,k  ))
                      qrHY(i,j,k) = WKxyz2(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxzb(i,k  ))
              END DO
              END DO

                             k=       mmz
              DO           i=ip11,mx1
                      qwHY(i,j,k) = WKxyz1(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy1(i,j)
     .                             +WKxyz8(i,j,k)  *WKxza(i,k))
                      qrHY(i,j,k) = WKxyz2(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy2(i,j)
     .                             +WKxyz8(i,j,k)  *WKxzb(i,k))
              END DO

C +--Wat.Vapr.Advect.avoids double Counting in case of convective Adjustment

              DO             k=    1 ,mmz1
              DO           i=ip11,mx1
c #cA           IF (adj_CA(i,j).eq.0)                             THEN
                      qvDY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k  ))
c #cA           END IF
              END DO
              END DO

                             k=       mmz
              DO           i=ip11,mx1
c #cA           IF (adj_CA(i,j).eq.0)                             THEN
                      qvDY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy3(i,j)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k))
c #cA           END IF
              END DO
C +
            END DO
C +
          END IF


C +--Warm Water
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------

         END DO


C +--Warm Water
C +--2nd Order Centered Leap-Frog Backward: Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
        ELSE
C +
c #WA     write(6,6009)
 6009     format(6x,' 6009        centrL.and. .not. staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +  
                     k=    1
              DO     i=ip11,mx1
                  qw_0       =                   qwHY(i,j,k)
                WKxza(i,k)   =(  qwHY(i,j,k+1)-  qw_0)
     .                        *WKxyz7(i,j,k)
                  qr_0       =                   qrHY(i,j,k)
                WKxzb(i,k)   =(  qrHY(i,j,k+1)-  qrHY(i,j,k  ))
     .                        *WKxyz7(i,j,k)
                  qv_0       =                   qvDY(i,j,k)
                WKxzc(i,k)   =(  qvDY(i,j,k+1)-  qvDY(i,j,k  )) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(  qwHY(i,j,k+1)-  qwHY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(  qrHY(i,j,k+1)-  qrHY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(  qvDY(i,j,k+1)-  qvDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -  qwHY(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -  qrHY(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qvapSL(i,j)    -  qvDY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO       k=    1 ,mmz
              DO       i=ip11,mx1
                WKxyz1(i,j,k)=   qwHY(i,j,k)  -WKxza(i,k)
                WKxyz4(i,j,k)=   qwHY(i,j,k) -(WKxza(i,k)+WKxza(i,k))
                WKxyz2(i,j,k)=   qrHY(i,j,k)  -WKxzb(i,k)
                WKxyz5(i,j,k)=   qrHY(i,j,k) -(WKxzb(i,k)+WKxzb(i,k))
                WKxyz3(i,j,k)=   qvDY(i,j,k)  -WKxzc(i,k)
                WKxyz6(i,j,k)=   qvDY(i,j,k) -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
            END DO
C +
C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN
C +
C +--Advection Increment
C +
            DO       j=jp11,my1
C +
                     k=    1
              DO     i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qw_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-  qr_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qvapSL(i,j)    -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO      k=    1 ,mmz
              DO      i=ip11,mx1
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxza(i,k)+WKxza(i,k))
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzb(i,k)+WKxzb(i,k))
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
C +
            END DO
C +
C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +
                      k=    1
              DO      i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qw_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-  qr_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qvapSL(i,j)    -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Hydromet.Advection
C +  
              DO             k=    1 ,mmz
                DO           i=ip11,mx1
                        qwHY(i,j,k) = WKxyz1(i,j,k) -WKxza(i,k)        
                        qrHY(i,j,k) = WKxyz2(i,j,k) -WKxzb(i,k)        
                END DO
C +
C +--Wat.Vapr.Advect.avoids double Counting in case of convective Adjustment
C +
                DO           i=ip11,mx1
c #cA             IF (adj_CA(i,j).eq.0)                           THEN
                        qvDY(i,j,k) = WKxyz3(i,j,k) -WKxzc(i,k)
c #cA             END IF
                END DO
              END DO
C +
            END DO
C +
          END IF
C +
C +
C +--Warm Water
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
        END IF
C +
C +
C +--Warm Water
C +--First  Order Upstream Scheme:          Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
       ELSE
C +
c #WA     write(6,6010)
 6010     format(6x,' 6010  .not. centrL.and.(.not.)staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--Auxiliary Variables
C +  ~~~~~~~~~~~~~~~~~~~
c #WA     write(6,6011)itimax,WKxyz1(imez,jmez,mz1),WKxyz1(imez,jmez,mz)
c #WA.                       ,  qwHY(imez,jmez,mz1),  qwHY(imez,jmez,mz)
 6011     format(6x,' 6011  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)
C +
             DO       k=1,mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=   qwHY(i,j,k)
               WKxyz2(i,j,k)=   qrHY(i,j,k)
               WKxyz3(i,j,k)=   qvDY(i,j,k)
             END DO
             END DO
             END DO
C +
C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~
                      k=1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = 0.0d+0
               WKxyz5(i,j,k) = 0.0d+0
               WKxyz6(i,j,k) = 0.0d+0
             END DO
             END DO
C +
             DO       k=kp1(1),mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = WKxyz1(i,j,k)-WKxyz1(i,j,k-1)
               WKxyz5(i,j,k) = WKxyz2(i,j,k)-WKxyz2(i,j,k-1)
               WKxyz6(i,j,k) = WKxyz3(i,j,k)-WKxyz3(i,j,k-1)
             END DO
             END DO
             END DO
C +
                      k=  mzz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxy1 (i,j)   =              -WKxyz1(i,j,k-1)
               WKxy2 (i,j)   =              -WKxyz2(i,j,k-1)
               WKxy3 (i,j)   = qvapSL(i,j)  -WKxyz3(i,j,k-1)
             END DO
             END DO
C +
C +--Advection Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~
             DO       k=    1 ,mmz1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=  qwHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k+1)
               WKxyz2(i,j,k)=  qrHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k+1)
               WKxyz3(i,j,k)=  qvDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k+1)
             END DO
             END DO
             END DO
C +
                      k=mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=  qwHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy1( i,j)
               WKxyz2(i,j,k)=  qrHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy2( i,j)
               WKxyz3(i,j,k)=  qvDY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy3( i,j)
             END DO
             END DO
C +
C +--Wind    Update
C +  ~~~~~~~~~~~~~~
             DO             k=1,mz
             DO             j=jp11,my1
               DO           i=ip11,mx1
                       qwHY(i,j,k) = WKxyz1(i,j,k)
                       qrHY(i,j,k) = WKxyz2(i,j,k)
               END DO
C +
C +--Pot.Temp.Update avoids double Counting in case of convective Adjustment
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               DO           i=ip11,mx1
c #cA            IF (adj_CA(i,j).eq.0)                            THEN
                       qvDY(i,j,k) = WKxyz3(i,j,k)
c #cA            END IF
               END DO
             END DO
             END DO
C +
C +
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
c #WA     write(6,6012)itimax,WKxyz1(imez,jmez,mz1),WKxyz1(imez,jmez,mz)
c #WA.                       ,  qwHY(imez,jmez,mz1),  qwHY(imez,jmez,mz)
 6012     format(6x,' 6012  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)
         END DO
C +
       END IF
C +
C +
C +--Warm Water Conservation
C +  -----------------------
C +
c #WF  DO j=1,my
c #WF  DO i=1,mx
c #WF      qvVC      = 0.0d+0
c #WF      qwVC      = 0.0d+0
c #WF      qrVC      = 0.0d+0
c #WF    DO k=1,mz
C +
C +--Flux Limitor
C +  ~~~~~~~~~~~~
c #WF      qvDY(i,j,k) =      max( eps9     ,qvDY(i,j,k))
c #WF      qvDY(i,j,k) =      min(WKxy7(i,j),qvDY(i,j,k))
c #WF      qwHY(i,j,k) =      max( zero     ,qwHY(i,j,k))
c #WF      qwHY(i,j,k) =      min(WKxy8(i,j),qwHY(i,j,k))
c #WF      qrHY(i,j,k) =      max( zero     ,qrHY(i,j,k))
c #WF      qrHY(i,j,k) =      min(WKxy9(i,j),qrHY(i,j,k))
C +
C +--Column Average
C +  ~~~~~~~~~~~~~~
c #WF      qvVC      = qvVC      + dsigm1(k)*qvDY(i,j,k)
c #WF      qwVC      = qwVC      + dsigm1(k)*qwHY(i,j,k)
c #WF      qrVC      = qrVC      + dsigm1(k)*qrHY(i,j,k)
c #WF    END DO
C +
C +--Surface Boundary Flux
C +  ~~~~~~~~~~~~~~~~~~~~~
c #WF      qvVC      = qvVC - psigDY(i,j,mz)
c #WF.                        *(qvDY(i,j,mz)-qvapSL(i,j))*dt/pstDYn(i,j)
c #WF      qwVC      = qwVC - psigDY(i,j,mz)
c #WF.                        * qwHY(i,j,mz)             *dt/pstDYn(i,j)
c #WF      qrVC      = qrVC - psigDY(i,j,mz)
c #WF.                        * qrHY(i,j,mz)             *dt/pstDYn(i,j)
C +
C +--Mass Restore
C +  ~~~~~~~~~~~~
c #WF    DO k=1,mz
c #WF      qvDY(i,j,k) = qvDY(i,j,k) * WKxy4(i,j)/max(eps12,qvVC)
c #WF      qwHY(i,j,k) = qwHY(i,j,k) * WKxy5(i,j)/max(eps12,qwVC)
c #WF      qrHY(i,j,k) = qrHY(i,j,k) * WKxy6(i,j)/max(eps12,qrVC)
c #WF    END DO
c #WF  END DO
c #WF  END DO
C +
C +
C +--Warm Water
C +--Work Arrays Reset
C +  -----------------
C +
       DO       j=1,my
       DO       i=1,mx
         WKxy1( i,j)   = 0.0
         WKxy2( i,j)   = 0.0
         WKxy3( i,j)   = 0.0
         WKxy4( i,j)   = 0.0
         WKxy5( i,j)   = 0.0
         WKxy6( i,j)   = 0.0
       END DO
       END DO
C +
       DO       k=1,mz
       DO       i=1,mx
         WKxza( i,  k) = 0.0
         WKxzb( i,  k) = 0.0
         WKxzc( i,  k) = 0.0
         WKxzd( i,  k) = 0.0
       END DO
       END DO
C +
       DO       k=1,mz
       DO       j=1,my
       DO       i=1,mx
         WKxyz1(i,j,k) = 0.0
         WKxyz2(i,j,k) = 0.0
         WKxyz3(i,j,k) = 0.0
         WKxyz4(i,j,k) = 0.0
         WKxyz5(i,j,k) = 0.0
         WKxyz6(i,j,k) = 0.0
       END DO
       END DO
       END DO
C +
C +
C +--Ice  Water Conservation
C +  -----------------------
C +
c #WF  DO j=1,my
c #WF  DO i=1,mx
c #WF      WKxy4(i,j) = 0.0d+0
c #WF      WKxy5(i,j) = 0.0d+0
c #WF      WKxy6(i,j) = 0.0d+0
c #WF      WKxy7(i,j) = 0.0d+0
c #WF      WKxy8(i,j) = 0.0d+0
c #WF      WKxy9(i,j) = 0.0d+0
c #WF    DO k=1,mz
c #WF      WKxy4(i,j) = WKxy4(i,j) + dsigm1(k)*ccniHY(i,j,k)
c #WF      WKxy5(i,j) = WKxy5(i,j) + dsigm1(k)*  qiHY(i,j,k)
c #WF      WKxy6(i,j) = WKxy6(i,j) + dsigm1(k)*  qsHY(i,j,k)
c #WF      WKxy7(i,j) =         max(WKxy7(i,j),ccniHY(i,j,k))
c #WF      WKxy8(i,j) =         max(WKxy8(i,j),  qiHY(i,j,k))
c #WF      WKxy9(i,j) =         max(WKxy9(i,j),  qsHY(i,j,k))
c #WF    END DO
c #WF  END DO
c #WF  END DO
C +
C +
C +--Ice  Water
C +--Start Vertical Advection
C +  ------------------------
C +
       IF   (centrL)                                              THEN
C +
        IF  (staggr)                                              THEN
C +
C +--2nd Order Centered Energy conserving:  Local Split Time Differencing
C +  ~~~~~~~~~ (Haltiner & Williams 1980 7.2.2, (7-47b) p.220) ~~~~~~~~~~
C +            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         DO  itimax=    1,ntimax
C +
C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN
C +
            DO       j=jp11,my1
C +
C +--Vertical Differences
C +  
                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   =   qiHY(i,j,k)
                WKxzq(i,k)   = ccniHY(i,j,k)
                WKxzx(i,k)   =   qsHY(i,j,k)
C +
c #VA           WKxzp(i,k)   =(  qiHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qiHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(ccniHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +ccniHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(  qsHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qsHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
C +
              DO      i=ip11,mx1
                  qi_0       =                  WKxzp(i,  k)
                WKxza(i,k)   =( WKxzp(i,  k)  -  qi_0)
                ccni_0       =                  WKxzq(i,  k)
                WKxzb(i,k)   =( WKxzq(i,  k)  -ccni_0)
                  qs_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qs_0)
              END DO
C +
              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   =   qiHY(i,j,k)  
                WKxzq(i,k)   = ccniHY(i,j,k)
                WKxzx(i,k)   =   qsHY(i,j,k)
C +
c #VA           WKxzp(i,k)   =(  qiHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qiHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qiHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(ccniHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +ccniHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +ccniHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(  qsHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qsHY(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +  qsHY(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO
C +
                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   =   qiHY(i,j,k)  
                WKxzq(i,k)   = ccniHY(i,j,k)
                WKxzx(i,k)   =   qsHY(i,j,k)
C +
c #VA           WKxzp(i,k)   =(  qiHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qiHY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(ccniHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +ccniHY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(  qsHY(i,j,k-1)*dsigm1(k-1)
c #VA.                        +  qsHY(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO
C +
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0d+0
                WKxy2(i,j)   = 0.0d+0
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(qsrfHY(i,j)    - WKxzx(i,  k-1)) 
              END DO
C +  
C +--Advection Contribution
C +  
              DO       k=    1 ,mmz1
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                WKxyz1(i,j,k)=   qiHY(i,j,k)  -WKxzd(i,k)
                WKxyz4(i,j,k)=   qiHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                WKxyz2(i,j,k)= ccniHY(i,j,k)  -WKxzd(i,k)
                WKxyz5(i,j,k)= ccniHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)=   qsHY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)=   qsHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO
C +
                       k=       mmz
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                WKxyz1(i,j,k)=   qiHY(i,j,k)  -WKxzd(i,k)
                WKxyz4(i,j,k)=   qiHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                WKxyz2(i,j,k)= ccniHY(i,j,k)  -WKxzd(i,k)
                WKxyz5(i,j,k)= ccniHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                WKxyz3(i,j,k)=   qsHY(i,j,k)  -WKxzd(i,k)
                WKxyz6(i,j,k)=   qsHY(i,j,k) -(WKxzd(i,k)+WKxzd(i,k))
              END DO
C +
            END DO
C +
C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN
C +
C +--Vertical Differences
C +
            DO       j=jp11,my1
C +
                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
C +
              DO      i=ip11,mx1
                  qi_0       =                  WKxzp(i,  k)
                WKxza(i,k)   =( WKxzp(i,  k)  -  qi_0)
                ccni_0       =                  WKxzq(i,  k)
                WKxzb(i,k)   =( WKxzq(i,  k)  -ccni_0)
                  qs_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qs_0)
              END DO
C +
              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO
C +
                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO
C +
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0d+0
                WKxy2(i,j)   = 0.0d+0
                WKxy3(i,j)   = 0.0d+0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(qsrfHY(i,j)    - WKxzx(i,  k-1))
              END DO
C +
C +--Advection Contribution
C +  
              DO      k=    1 ,mmz1
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
C +
            END DO
C +
C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE
C +
            DO       j=jp11,my1
C +
C +--Vertical Differences
C +
                      k=    1
                dsgm         =             2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
C +
              DO      i=ip11,mx1
                  qi_0       =                  WKxzp(i,  k)
                WKxza(i,k)   =( WKxzp(i,  k)  -  qi_0)
                ccni_0       =                  WKxzq(i,  k)
                WKxzb(i,k)   =( WKxzq(i,  k)  -ccni_0)
                  qs_0       =                  WKxzx(i,  k)
                WKxzc(i,k)   =( WKxzx(i,  k)  -  qs_0)
              END DO
C +
              DO      k=kp1(1),mmz1
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)+dsigm1(k+1)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz4(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz5(i,j,k+1)*dsigm1(k+1)     )/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0
c #VA.                        +WKxyz6(i,j,k+1)*dsigm1(k+1)     )/dsgm
              END DO
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
              END DO
C +
                      k=       mmz
                dsgm         = dsigm1(k-1)+2.0*dsigm1(k)
              DO      i=ip11,mx1
                WKxzp(i,k)   = WKxyz4(i,j,k)  
                WKxzq(i,k)   = WKxyz5(i,j,k)
                WKxzx(i,k)   = WKxyz6(i,j,k)
C +
c #VA           WKxzp(i,k)   =(WKxyz4(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz4(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzq(i,k)   =(WKxyz5(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz5(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
c #VA           WKxzx(i,k)   =(WKxyz6(i,j,k-1)*dsigm1(k-1)
c #VA.                        +WKxyz6(i,j,k  )*dsigm1(k  ) *2.0)/dsgm
              END DO
C +
              DO      i=ip11,mx1
                WKxza(i,k)   =( WKxzp(i,  k)  - WKxzp(i,  k-1)) 
                WKxzb(i,k)   =( WKxzq(i,  k)  - WKxzq(i,  k-1)) 
                WKxzc(i,k)   =( WKxzx(i,  k)  - WKxzx(i,  k-1)) 
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   = 0.0
                WKxy2(i,j)   = 0.0
                WKxy3(i,j)   = 0.0
c #NS           WKxy1(i,j)   =                - WKxzp(i,  k-1)
c #NS           WKxy2(i,j)   =                - WKxzq(i,  k-1)
c #NS           WKxy3(i,j)   =(qsrfHY(i,j)    - WKxzx(i,  k-1))
              END DO
C +
C +--Hydromet.Advection
C +  
              DO             k=    1 ,mmz1
              DO           i=ip11,mx1
                      qiHY(i,j,k) = WKxyz1(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxza(i,k  ))
                    ccniHY(i,j,k) = WKxyz2(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxzb(i,k  ))
                      qsHY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k  ))
              END DO
              END DO
C +
                             k=       mmz
              DO           i=ip11,mx1
                      qiHY(i,j,k) = WKxyz1(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy1(i,j)
     .                             +WKxyz8(i,j,k)  *WKxza(i,k))
                    ccniHY(i,j,k) = WKxyz2(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy2(i,j)
     .                             +WKxyz8(i,j,k)  *WKxzb(i,k))
                      qsHY(i,j,k) = WKxyz3(i,j,k)
     .                            -(WKxyz7(i,j,k)  *WKxy3(i,j)
     .                             +WKxyz8(i,j,k)  *WKxzc(i,k))
              END DO
C +
            END DO
C +
          END IF
C +
C +
C +--Ice  Water
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
C +
C +--Ice  Water
C +--2nd Order Centered Leap-Frog Backward: Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
        ELSE
C +
         DO  itimax=    1,ntimax
C +
C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +  
                     k=    1
              DO     i=ip11,mx1
                  qi_0       =                   qiHY(i,j,k)
                WKxza(i,k)   =(  qiHY(i,j,k+1)-  qi_0)
     .                        *WKxyz7(i,j,k)
                ccni_0       =                 ccniHY(i,j,k)
                WKxzb(i,k)   =(ccniHY(i,j,k+1)-ccniHY(i,j,k  ))
     .                        *WKxyz7(i,j,k)
                  qv_0       =                   qsHY(i,j,k)
                WKxzc(i,k)   =(  qsHY(i,j,k+1)-  qsHY(i,j,k  )) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(  qiHY(i,j,k+1)-  qiHY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(ccniHY(i,j,k+1)-ccniHY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(  qsHY(i,j,k+1)-  qsHY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -  qiHY(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -ccniHY(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qsrfHY(i,j)    -  qsHY(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO       k=    1 ,mmz
              DO       i=ip11,mx1
                WKxyz1(i,j,k)=   qiHY(i,j,k)  -WKxza(i,k)
                WKxyz4(i,j,k)=   qiHY(i,j,k) -(WKxza(i,k)+WKxza(i,k))
                WKxyz2(i,j,k)= ccniHY(i,j,k)  -WKxzb(i,k)
                WKxyz5(i,j,k)= ccniHY(i,j,k) -(WKxzb(i,k)+WKxzb(i,k))
                WKxyz3(i,j,k)=   qsHY(i,j,k)  -WKxzc(i,k)
                WKxyz6(i,j,k)=   qsHY(i,j,k) -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
            END DO
C +
C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN
C +
C +--Advection Increment
C +
            DO       j=jp11,my1
C +
                     k=    1
              DO     i=ip11,mx1
                  qi_0       =                 WKxyz4(i,j,k)
                ccni_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qi_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-ccni_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qsrfHY(i,j)    -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO      k=    1 ,mmz
              DO      i=ip11,mx1
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxza(i,k)+WKxza(i,k))
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzb(i,k)+WKxzb(i,k))
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
C +
            END DO
C +
C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +
                      k=    1
              DO      i=ip11,mx1
                  qi_0       =                 WKxyz4(i,j,k)
                ccni_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qi_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-ccni_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(qsrfHY(i,j)    -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Hydromet.Advection
C +  
              DO             k=    1 ,mmz
                DO           i=ip11,mx1
                        qiHY(i,j,k) = WKxyz1(i,j,k) -WKxza(i,k)        
                      ccniHY(i,j,k) = WKxyz2(i,j,k) -WKxzb(i,k)        
                        qsHY(i,j,k) = WKxyz3(i,j,k) -WKxzc(i,k)
                END DO
              END DO
C +
            END DO
C +
          END IF
C +
C +
C +--Ice  Water
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
        END IF
C +
C +
C +--Ice  Water
C +--First  Order Upstream Scheme:          Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
       ELSE
C +
         DO  itimax=    1,ntimax
C +
C +--Auxiliary Variables
C +  ~~~~~~~~~~~~~~~~~~~
             DO       k=1,mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=   qiHY(i,j,k)
               WKxyz2(i,j,k)= ccniHY(i,j,k)
               WKxyz3(i,j,k)=   qsHY(i,j,k)
             END DO
             END DO
             END DO
C +
C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~
                      k=1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = 0.0d+0
               WKxyz5(i,j,k) = 0.0d+0
               WKxyz6(i,j,k) = 0.0d+0
             END DO
             END DO
C +
             DO       k=kp1(1),mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = WKxyz1(i,j,k)-WKxyz1(i,j,k-1)
               WKxyz5(i,j,k) = WKxyz2(i,j,k)-WKxyz2(i,j,k-1)
               WKxyz6(i,j,k) = WKxyz3(i,j,k)-WKxyz3(i,j,k-1)
             END DO
             END DO
             END DO
C +
                      k=  mzz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxy1 (i,j)   =              -WKxyz1(i,j,k-1)
               WKxy2 (i,j)   =              -WKxyz2(i,j,k-1)
               WKxy3 (i,j)   = qsrfHY(i,j)  -WKxyz3(i,j,k-1)
             END DO
             END DO
C +
C +--Advection Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~
             DO       k=    1 ,mmz1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=  qiHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k+1)
               WKxyz2(i,j,k)=ccniHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k+1)
               WKxyz3(i,j,k)=  qsHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k+1)
             END DO
             END DO
             END DO
C +
                      k=mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz1(i,j,k)=  qiHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz4(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy1( i,j)
               WKxyz2(i,j,k)=ccniHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz5(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy2( i,j)
               WKxyz3(i,j,k)=  qsHY(i,j,k)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy3( i,j)
             END DO
             END DO
C +
C +--Hydrom. Update
C +  ~~~~~~~~~~~~~~
             DO             k=1,mz
             DO             j=jp11,my1
               DO           i=ip11,mx1
                       qiHY(i,j,k) = WKxyz1(i,j,k)
                     ccniHY(i,j,k) = WKxyz2(i,j,k)
                       qsHY(i,j,k) = WKxyz3(i,j,k)
               END DO
             END DO
             END DO
C +
C +
C +--Ice  Water
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
       END IF
C +
C +
C +--Ice  Water Conservation
C +  -----------------------
C +
c #WF  DO j=1,my
c #WF  DO i=1,mx
c #WF      ciVC      = 0.0d+0
c #WF      qiVC      = 0.0d+0
c #WF      qsVC      = 0.0d+0
c #WF    DO k=1,mz
C +
C +--Flux Limitor
C +  ~~~~~~~~~~~~
c #WF      ccniHY(i,j,k) =      max( zero     ,ccniHY(i,j,k))
c #WF      ccniHY(i,j,k) =      min(WKxy7(i,j),ccniHY(i,j,k))
c #WF        qiHY(i,j,k) =      max( zero     ,  qiHY(i,j,k))
c #WF        qiHY(i,j,k) =      min(WKxy8(i,j),  qiHY(i,j,k))
c #WF        qsHY(i,j,k) =      max( zero     ,  qsHY(i,j,k))
c #WF        qsHY(i,j,k) =      min(WKxy9(i,j),  qsHY(i,j,k))
C +
C +--Column Average
C +  ~~~~~~~~~~~~~~
c #WF      ciVC      = ciVC      + dsigm1(k)  *ccniHY(i,j,k)
c #WF      qiVC      = qiVC      + dsigm1(k)  *  qiHY(i,j,k)
c #WF      qsVC      = qsVC      + dsigm1(k)  *  qsHY(i,j,k)
c #WF    END DO
C +
C +--Surface Boundary Flux
C +  ~~~~~~~~~~~~~~~~~~~~~
c #WF      ciVC      = ciVC - psigDY(i,j,mz)
c #WF.                       *ccniHY(i,j,mz)             *dt/pstDYn(i,j)
c #WF      qiVC      = qiVC - psigDY(i,j,mz)
c #WF.                        * qiHY(i,j,mz)             *dt/pstDYn(i,j)
c #WF      qsVC      = qsVC - psigDY(i,j,mz)
c #WF.                        *(qsHY(i,j,mz)-qsrfHY(i,j))*dt/pstDYn(i,j)
C +
C +--Mass Restore
C +  ~~~~~~~~~~~~
c #WF    DO k=1,mz
c #WF      ccniHY(i,j,k) = ccniHY(i,j,k) *(WKxy4(i,j)/max(eps12,ciVC))
c #WF        qiHY(i,j,k) =   qiHY(i,j,k) * WKxy5(i,j)/max(eps12,qiVC)
c #WF        qsHY(i,j,k) =   qsHY(i,j,k) * WKxy6(i,j)/max(eps12,qsVC)
c #WF    END DO
c #WF  END DO
c #WF  END DO
C +
C +
C +--Work Arrays Reset
C +  -----------------
C +
       DO       j=1,my
       DO       i=1,mx
         WKxy1( i,j)   = 0.0
         WKxy2( i,j)   = 0.0
         WKxy3( i,j)   = 0.0
         WKxy4( i,j)   = 0.0
         WKxy5( i,j)   = 0.0
         WKxy6( i,j)   = 0.0
       END DO
       END DO
C +
       DO       k=1,mz
       DO       i=1,mx
         WKxza( i,  k) = 0.0
         WKxzb( i,  k) = 0.0
         WKxzc( i,  k) = 0.0
         WKxzd( i,  k) = 0.0
       END DO
       END DO
C +
       DO       k=1,mz
       DO       j=1,my
       DO       i=1,mx
         WKxyz1(i,j,k) = 0.0
         WKxyz2(i,j,k) = 0.0
         WKxyz3(i,j,k) = 0.0
         WKxyz4(i,j,k) = 0.0
         WKxyz5(i,j,k) = 0.0
         WKxyz6(i,j,k) = 0.0
       END DO
       END DO
       END DO
C +
C +
C +--Courant Number
C +--Work Arrays Reset
C +  -----------------
C +
       DO       k=1,mz
       DO       j=1,my
       DO       i=1,mx
         WKxyz7(i,j,k) = 0.0
         WKxyz8(i,j,k) = 0.0
       END DO
       END DO
       END DO
C +
C +
C +--Third Order Vertical Scheme
C +  ===========================
C +
c #ZU ELSE 
C +
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      = 0.
c #ZO  ga0(i,j)      =   qwHY(i,j,mz)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    =   qwHY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU    qwHY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZO  DO  j=jp11,my1
c #ZO  DO  i=ip11,mx1
c #ZO  ga0(i,j)      =   qrHY(i,j,mz)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    =   qrHY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU    qrHY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      = qvapSL(i,j)    
c #ZO  ga0(i,j)      =   qvDY(i,j,mz)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    =   qvDY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU    qvDY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      = 0.0
c #ZO  ga0(i,j)      =   qiHY(i,j,mz)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    =   qiHY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU    qiHY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZO  DO  j=jp11,my1
c #ZO  DO  i=ip11,mx1
c #ZO  ga0(i,j)      = ccniHY(i,j,mz)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    = ccniHY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU  ccniHY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      = qsrfHY(i,j)    
c #ZO  ga0(i,j)      =   qsHY(i,j,mz)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    =   qsHY(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU    qsHY(i,j,k) = gat(i,j,k)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZU end if 
C +
C +
C +--Impact on Snow Erosion/Deposition
C +  =================================
C +
c #BS DO     j=jp11,my1
c #BS DO     i=ip11,mx1
c #BS   dh_sno = psigDY(i,j,mz)*(qsHY(i,j,mz)-qsrfHY(i,j))*dt*grvinv
C +...  dh_sno contains an implicit factor 1.d3[kPa-->Pa]/ro_Wat[kg/m2-->mWE]
C +            > 0 ==> Atmospheric Loss ==> Surface Gain
C +
c #BS   snohSL(i,j) = snohSL(i,j) + max(zero,dh_sno) 
c #BS   snobSL(i,j) = snobSL(i,j) + min(zero,dh_sno) 
c #BS   snowHY(i,j) = snowHY(i,j) +          dh_sno
c #BS END DO
c #BS END DO
C +
      return
      end
      subroutine DYNfil_1D(f1_fil,e1_fil,k1_fil)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (1-D)                              24-09-2001  MAR |
C |   SubRoutine DYNfil_1D  is used to Filter Horizontal Fields in 2D Code |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  f1_fil   : filtered variable                                 |
C |   ^^^^^   e1_fil   : value of the selectivity parameter                |
C |           k1_fil   : vertical dimension of the problem                 |
C |                                                                        |
C |   OUTPUT:(via common block)                                            |
C |   ^^^^^^  f1_fil                                                       |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The value    of the variable is fixed at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER. : Alpert (1981), J.Comput.Phys. 44, pp.212--219               |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
      include 'MARdim.inc'
C +
      real     f1_fil(mx,my,mz),e1_fil(mz)
      integer  k1_fil
C +
C +
C +--Local  Variables
C +  ================
C +
      include 'MARvec.inc'
C +
      integer  kindex
      integer  m , i
      integer  m1,m2
c #EP integer  m3,m4
      real     aa,bb
c #EP real     delt2,delt3,delt4
C +
C +
C +--Initialisation of the Gaussian Elimination Algorithm
C +  ====================================================
C +
        m  = mx
        m1 = m-1
        m2 = m-2
c #EP   m3 = m-3
c #EP   m4 = m-4
C +
      DO kindex=1,k1_fil
C +
        vecx1(1) = 0.0
        vecx2(1) = 1.0
        vecx1(m) = 0.0
        vecx2(m) = 1.0
        vecx4(1) = f1_fil(1,1,kindex)
        vecx4(m) = f1_fil(m,1,kindex)
C +
        delta =    e1_fil(    kindex)
C +
c #EP   delt4 =        delta+delta
c #EP   delt3 =        delt4+delt4
c #EP   delt2 =        delt3+delt3
C +..   Filter Selectivity Parameter Increase near the Boundaries 
C +
        aa    =     1.0-delta
        bb    =2.0*(1.0+delta)
C +
        DO i=2,m1
          vecx1(i)  = aa
          vecx2(i)  = bb
          vecx4(i)  = f1_fil(i-1,1,kindex)+2.0*f1_fil(i,1,kindex)
     .               +f1_fil(i+1,1,kindex)
        END DO
C +
c #EP     vecx1(2)  =      1.0-delt2
c #EP     vecx1(3)  =      1.0-delt3
c #EP     vecx1(4)  =      1.0-delt4
c #EP     vecx2(2)  = 2.0*(1.0+delt2)
c #EP     vecx2(3)  = 2.0*(1.0+delt3)
c #EP     vecx2(4)  = 2.0*(1.0+delt4)
C +
c #EP     vecx1(m2) = vecx1(2)
c #EP     vecx1(m3) = vecx1(3)
c #EP     vecx1(m4) = vecx1(4)
c #EP     vecx2(m2) = vecx2(2)
c #EP     vecx2(m3) = vecx2(3)
c #EP     vecx2(m4) = vecx2(4)
C +
        DO i=1,m
          vecxa(i)  = f1_fil(i,1,kindex)
          vecx5(i)  = 0.
          vecx6(i)  = 0.
        END DO
C +
C +
C +--Gaussian Elimination Algorithm
C +  ==============================
C +
C +     *********
        call tlat(vecx1,vecx2,vecx1,vecx4,vecx5,vecx6,m ,m ,vecxa)
C +     *********
C +
        DO i=1,m
          f1_fil(i,1,kindex)= vecxa(i)
        END DO
C +
      END DO
C +
      return
      end
      subroutine DYNfil_1D0(f1_fi0,e1_fi0,k1_fi0)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (1-D)                              16-11-2002  MAR |
C |   SubRoutine DYNfil_1D0 is used to Filter Horizontal Fields in 2D Code |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  f1_fi0   : filtered variable                                 |
C |   ^^^^^   e1_fi0   : value of the selectivity parameter                |
C |           k1_fi0   : vertical dimension of the problem                 |
C |                                                                        |
C |   OUTPUT:(via common block)                                            |
C |   ^^^^^^  f1_fi0                                                       |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The gradient of the variable is  zero at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER. : Alpert (1981), J.Comput.Phys. 44, pp.212--219               |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Clobal Variables
C +  ================
C +
      include 'MARphy.inc'
      include 'MARdim.inc'
C +
      real     f1_fi0(mx,my,mz),e1_fi0(mz)
      integer  k1_fi0
C +
C +
C +--Local  Variables
C +  ================
C +
      include 'MARvec.inc'
C +
      integer  kindex
      integer  m , i
      integer  m1,m2
c #EP integer  m3,m4
      real     aa,bb
c #EP real     delt2,delt3,delt4
C +
C +
C +--Initialisation of the Gaussian Elimination Algorithm
C +  ====================================================
C +
        m  = mx
        m1 = m-1
        m2 = m-2
c #EP   m3 = m-3
c #EP   m4 = m-4
C +
      DO kindex=1,k1_fi0
C +
        f1_fi0(1,1,1)=f1_fi0(  2,1,kindex)
        f1_fi0(m,1,1)=f1_fi0(m-1,1,kindex)
C +
        delta =       e1_fi0(      kindex)
C +
c #EP   delt4 =       delta+delta
c #EP   delt3 =       delt4+delt4
c #EP   delt2 =       delt3+delt3
C +..   Filter Selectivity Parameter Increase near the Boundaries 
C +
        aa    =     1.0-delta
        bb    =2.0*(1.0+delta)
C +
        DO i=1,m2
          vecx1(i)  = aa
          vecx2(i)  = bb
          vecx4(i)  = f1_fi0(i,1,kindex)+2.0*f1_fi0(i+1,1,kindex)
     .                                      +f1_fi0(i+2,1,kindex)
          vecxa(i)  =                        f1_fi0(i+1,1,kindex)
        END DO
C +
          vecx2(1)  =       3.0+delta
c #EP     vecx2(1)  =       3.0+delt2
          vecx2(m2) = vecx2(1)
C +
c #EP     vecx1(1)  =      1.0-delt2
c #EP     vecx1(2)  =      1.0-delt3
c #EP     vecx1(3)  =      1.0-delt4
c #EP     vecx2(2)  = 2.0*(1.0+delt3)
c #EP     vecx2(3)  = 2.0*(1.0+delt4)
C +
c #EP     vecx1(m2) = vecx1(1)
c #EP     vecx1(m3) = vecx1(2)
c #EP     vecx1(m4) = vecx1(3)
c #EP     vecx2(m3) = vecx2(2)
c #EP     vecx2(m4) = vecx2(3)
C +
C +
        DO i=1,m
          vecx5(i)  = 0.
          vecx6(i)  = 0.
        END DO
C +
C +
C +--Gaussian Elimination Algorithm
C +  ==============================
C +
C +     *********
        call tlat(vecx1,vecx2,vecx1,vecx4,vecx5,vecx6,m ,m2,vecxa)
C +     *********
C +
        DO i=1,m2
          f1_fi0(i+1,1,kindex)= vecxa(  i)
        END DO
C +
          f1_fi0(  1,1,kindex)=f1_fi0(  2,1,kindex)
          f1_fi0(  m,1,kindex)=f1_fi0(m-1,1,kindex)
C +
      END DO
C +
      return
      end
      subroutine tlat(tlat_a,tlat_b,tlat_c,tlat_d,tlat_p,tlat_q,nx,n 
     .               ,tlat_x)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER                                    20-09-2001  MAR |
C |   SubRoutine tlat  uses the Gaussian Elimination Algorithm             | 
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    (needed to solve the implicit scheme developped for filtering)      |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   tlat_a,tlat_b,tlat_c: tri-diagional matrix coefficients     |
C |   ^^^^^    tlat_d              : tri-diagional matrix independent term |
C |            tlat_p,tlat_q       : working          variables            |
C |            n                   : dimension of the variables            |
C |            ix                  : switch                                |
C |            tlat_x              : variable to solve                     |
C |                                                                        |
C |   OUTPUT:  tlat_x                                                      |
C |   ^^^^^^                                                               |
C +------------------------------------------------------------------------+
C +
      IMPLICIT NONE
C +
      integer  nx,n
      real     tlat_a(nx),tlat_b(nx),tlat_c(nx),tlat_d(nx)
      real     tlat_x(nx),tlat_p(nx),tlat_q(nx)
C + 
      integer  k ,l
      integer  ix
C +
      data     ix/0/
C +
C +
C +--Forward  Sweep
C +  ==============
C +
      IF (ix.ne.1)                                                  THEN
          tlat_p(1)= tlat_b(1)
          tlat_q(1)=-tlat_c(1)/tlat_p(1)
        DO k=2,n
          tlat_p(k)= tlat_a(k)*tlat_q(k-1)+tlat_b(k)
          tlat_q(k)=-tlat_c(k)/tlat_p(k)
        END DO
      END IF
C +
          tlat_x(1)= tlat_d(1)/tlat_p(1)
        DO k=2,n
          tlat_x(k)=(tlat_d(k)-tlat_a(k)  *tlat_x(k-1))/tlat_p(k)
        END DO
C +
C +
C +--Backward Sweep
C +  ==============
C +
        DO l=2,n
          k=n-l+1
          tlat_x(k)=tlat_q(k)*tlat_x(k+1)+tlat_x(k)
        END DO
C +
      return
      end
      subroutine DYNfil_2H(f,eps)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (2-D)                               5-02-2002  MAR |
C |   SubRoutine DYNfil_2H  is used to Filter Horizontal Fields in 3D Code |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   f(i,j) : variable to be filtered for a particular Level k   |
C |   ^^^^^    eps    : value of the selectivity parameter                 |
C |                                                                        |
C |   OUTPUT:  f(i,j)                                                      |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The value    of the variable is fixed at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER.:  Raymond and Garder, MWR 116, Jan 1988, p209                 |
C |   ^^^^^^                                                               |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      real    f(mx,my),eps
C +
C +
C +--Local  Variables
C +  ================
C +
      integer ix
      real    aa,bb
c #EP real    eps2,eps3,eps4,eps5
C +
      real    x(mx,my)
      real    a1(1:mx) ,b1(1:mx) ,d1(1:mx) ,p1(mx) ,q1(mx) ,wk1(1:mx) 
      real    a2(1:my) ,b2(1:my) ,d2(1:my) ,p2(my) ,q2(my) ,wk2(1:my) 
C +
C +
C +--Initialisation
C +  ==============
C +
      m  = mx
      m1 = mx1
      m2 = mx2
c #EP m3 = mx-3
c #EP m4 = mx-4
      mn = my
      mn1= my1
      mn2= my2
c #EP mn3= my-3
c #EP mn4= my-4
C +
C +
C +--1st Matrix Initialisation
C +  -------------------------
C +
        a1( 1) = 0.0
        b1( 1) = 1.0
        a1(mx) = 0.0
        b1(mx) = 1.0
C +
c #EP   eps5   =        eps +eps
c #EP   eps4   =        eps5+eps5
c #EP   eps3   =        eps4+eps4
c #EP   eps2   =        eps3+eps3
C +..   Pour diminution de la sectivite du filtre vers les bords
C +       (augmentation --X 2-- parametre selectivite a chaque pas spatial)
C +
        aa     =       1.0-eps
        bb     = 2.0 *(1.0+eps)
C +
      DO i=ip11,mx1
        a1(i)   = aa
        b1(i)   = bb
      END DO
C +
c #EP   a1(2)   =      1.0-eps2
c #EP   a1(3)   =      1.0-eps3
c #EP   a1(4)   =      1.0-eps4
c #EP   a1(5)   =      1.0-eps5
c #EP   b1(2)   = 2.0*(1.0+eps2)
c #EP   b1(3)   = 2.0*(1.0+eps3)
c #EP   b1(4)   = 2.0*(1.0+eps4)
c #EP   b1(5)   = 2.0*(1.0+eps5)
C +
c #EP   a1(m1)  = a1(2)
c #EP   a1(m2)  = a1(3)
c #EP   a1(m3)  = a1(4)
c #EP   a1(m4)  = a1(5)
c #EP   b1(m1)  = b1(2)
c #EP   b1(m2)  = b1(3)
c #EP   b1(m3)  = b1(4)
c #EP   b1(m4)  = b1(5)
C +
C +
C +--2th Matrix Initialisation
C +  -------------------------
C +
        a2( 1) = 0.0
        b2( 1) = 1.0
        a2(my) = 0.0
        b2(my) = 1.0
C +
      DO j=jp11,my1
        a2(j)   = aa
        b2(j)   = bb
      END DO
C +
c #EP   a2(2)   = a1(2)
c #EP   a2(3)   = a1(3)
c #EP   a2(4)   = a1(4)
c #EP   a2(5)   = a1(5)
c #EP   b2(2)   = b1(2)
c #EP   b2(3)   = b1(3)
c #EP   b2(4)   = b1(4)
c #EP   b2(5)   = b1(5)
C +
c #EP   a2(mn1) = a1(2)
c #EP   a2(mn2) = a1(3)
c #EP   a2(mn3) = a1(4)
c #EP   a2(mn4) = a1(5)
c #EP   b2(mn1) = b1(2)
c #EP   b2(mn2) = b1(3)
c #EP   b2(mn3) = b1(4)
c #EP   b2(mn4) = b1(5)
C +
C +
C +--1st Equations System
C +  ====================
C +
      DO j=jp11,my1
C +
        d1( 1) =f( 1,jm1(j))    +2.0*f( 1,j)    +     f( 1,jp1(j))
        d1(mx) =f(mx,jm1(j))    +2.0*f(mx,j)    +     f(mx,jp1(j))
C +
        DO  i=ip11,mx1
        d1(i  )=f(im1(i),jp1(j))+2.0*f(i,jp1(j))+    f(ip1(i),jp1(j))+
     &      2.0*f(im1(i),j)     +4.0*f(i,j)     +2.0*f(ip1(i),j)     +
     &          f(im1(i),jm1(j))+2.0*f(i,jm1(j))+    f(ip1(i),jm1(j))
        END DO
C +
        ix = 0
C +
C +     *********
        call tlat(a1,b1,a1,d1,p1,q1,m  ,m  ,wk1)
C +     *********
C +
        DO i=ip11,mx1
          x(i,j) = wk1(i)
        END DO
C +
      END DO
C +
C +
C +--2th Equations System
C +  ====================
C +
      DO i=ip11,mx1
C +
          d2( 1) = f(i, 1)
          d2(my) = f(i,my)
C +
        DO j=jp11,my1
          d2( j) = x(i,j)
        END DO
C +
        ix = 0
C +
C +     *********
        call tlat(a2,b2,a2,d2,p2,q2,mn ,mn ,wk2)
C +     *********
C +
        DO j=jp11,my1
          f(i,j) = wk2(j)
        END DO
C +
      END DO
C +
      return
      end
      subroutine DYNfil_2H0(f,eps)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (2-D)                               5-02-2002  MAR |
C |   SubRoutine DYNfil_2H0 is used to Filter Horizontal Fields in 3D Code |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   f(i,j) : variable to be filtered for a particular Level k   |
C |   ^^^^^    eps    : value of the selectivity parameter                 |
C |                                                                        |
C |   OUTPUT:  f(i,j)                                                      |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The gradient of the variable is  zero at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER. : Raymond and Garder, MWR 116, Jan 1988, p209                 |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      real     f(mx,my),eps
C +
C +
C +--Local  Variables
C +  ================
C +
      integer ix
      real    aa,bb
c #EP real    eps2,eps3,eps4,eps5
C +
      real    x(mx,my)
      real    a1(i_2:mx1),b1(i_2:mx1),d1(i_2:mx1)
      real    p1(mx2)    ,q1(mx2)   ,wk1(i_2:mx1)
      real    a2(j_2:my1),b2(j_2:my1),d2(j_2:my1)
      real    p2(my2)    ,q2(my2)   ,wk2(j_2:my1)
C +
C +
C +--Initialisation
C +  ==============
C +
      m  = mx
      m1 = mx1
      m2 = mx2
c #EP m3 = mx-3
c #EP m4 = mx-4
      mn = my
      mn1= my1
      mn2= my2
c #EP mn3= my-3
c #EP mn4= my-4
C +
C +
C +--Zero-Gradient Boundary Conditions
C +  ---------------------------------
C +
      DO i=1,mx
        f(i, 1) =     f(i,jp11)
        f(i,my) =     f(i, my1)
      END DO
C +
      DO j=1,my
        f( 1,j) =     f(ip11,j)
        f(mx,j) =     f( mx1,j)
      END DO
C +
C +  Corners v
        f( 1, 1) = 0.5*(f(ip11, 1)+f( 1,jp11))
        f(mx, 1) = 0.5*(f( mx1, 1)+f(mx,jp11))
        f( 1,my) = 0.5*(f(ip11,my)+f( 1, my1))
        f(mx,my) = 0.5*(f( mx1,my)+f(mx, my1))
C +
C +
C +--1st Matrix Initialisation
C +  -------------------------
C +
c #EP   eps5   =        eps +eps
c #EP   eps4   =        eps5+eps5
c #EP   eps3   =        eps4+eps4
c #EP   eps2   =        eps3+eps3
C +..   Pour diminution de la sectivite du filtre vers les bords
C +       (augmentation --X 2-- parametre selectivite a chaque pas spatial)
C +
        aa     =       1.0-eps
        bb     = 2.0 *(1.0+eps)
C +
      DO i=ip11,mx1
        a1(i)   = aa
        b1(i)   = bb
      END DO
C +
c #EP   a1(2)   =      1.0-eps2
c #EP   a1(3)   =      1.0-eps3
c #EP   a1(4)   =      1.0-eps4
c #EP   a1(5)   =      1.0-eps5
c #EP   b1(2)   = 2.0*(1.0+eps2)
c #EP   b1(3)   = 2.0*(1.0+eps3)
c #EP   b1(4)   = 2.0*(1.0+eps4)
c #EP   b1(5)   = 2.0*(1.0+eps5)
C +
c #EP   a1(m1)  = a1(2)
c #EP   a1(m2)  = a1(3)
c #EP   a1(m3)  = a1(4)
c #EP   a1(m4)  = a1(5)
c #EP   b1(m1)  = b1(2)
c #EP   b1(m2)  = b1(3)
c #EP   b1(m3)  = b1(4)
c #EP   b1(m4)  = b1(5)
C +
        b1(2)   =       3.0+eps
c #EP   b1(2)   =       3.0+eps2
        b1(m1)  = b1(2)
C +
C +
C +--2th Matrix Initialisation
C +  -------------------------
C +
      DO j=jp11,my1
        a2(j)   = aa
        b2(j)   = bb
      END DO
C +
c #EP   a2(2)   = a1(2)
c #EP   a2(3)   = a1(3)
c #EP   a2(4)   = a1(4)
c #EP   a2(5)   = a1(5)
c #EP   b2(2)   = b1(2)
c #EP   b2(3)   = b1(3)
c #EP   b2(4)   = b1(4)
c #EP   b2(5)   = b1(5)
C +
c #EP   a2(mn1) = a1(2)
c #EP   a2(mn2) = a1(3)
c #EP   a2(mn3) = a1(4)
c #EP   a2(mn4) = a1(5)
c #EP   b2(mn1) = b1(2)
c #EP   b2(mn2) = b1(3)
c #EP   b2(mn3) = b1(4)
c #EP   b2(mn4) = b1(5)
C +
        b2(jp11) = 3.0+eps
c #EP   b2(jp11) = 3.0+eps2
        b2(mn1)  = b2(jp11)
C +
C +
C +--1st Equations System
C +  ====================
C +
      DO j=jp11,my1
C +
        DO i=ip11,mx1
        d1(i  )=f(im1(i),jp1(j))+2.0*f(i,jp1(j))+    f(ip1(i),jp1(j))+
     &      2.0*f(im1(i),j)     +4.0*f(i,j)     +2.0*f(ip1(i),j)     +
     &          f(im1(i),jm1(j))+2.0*f(i,jm1(j))+    f(ip1(i),jm1(j))
        END DO
C +
        ix = 0
C +
C +     *********
        call tlat(a1,b1,a1,d1,p1,q1,m2 ,m2 ,wk1)
C +     *********
C +
        DO i=ip11,mx1
          x(i,j) = wk1(i)
        END DO
C +
      END DO
C +
C +
C +--2th Equations System
C +  ====================
C +
      DO i=ip11,mx1
C +
        DO j=jp11,my1
          d2(j)   = x(i,j)
        END DO
C +
        ix = 0
C +
C +     *********
        call tlat(a2,b2,a2,d2,p2,q2,mn2,mn2,wk2)
C +     *********
C +
        DO j=jp11,my1
          f(i,j) = wk2(j)
        END DO
C +
      END DO
C +
C +
C +--Zero-Gradient Boundary Conditions
C +  =================================
C +
      DO i=1,mx
        f(i, 1) =                          f(i,jp11)
        f(i,my) =                          f(i,my1)
      END DO
C +
      DO j=1,my
        f( 1,j) =          f(ip11,j)
        f(mx,j) =          f(mx1,j)
      END DO
C +
C +  Corners v
       f( 1, 1) = 0.50 * (f(ip11, 1) + f( 1,jp11))
       f(mx, 1) = 0.50 * (f( mx1, 1) + f(mx,jp11))
       f( 1,my) = 0.50 * (f(ip11,my) + f( 1, my1))
       f(mx,my) = 0.50 * (f( mx1,my) + f(mx, my1))
C +
      return
      end


      subroutine DYNfil_3D_mp(f3_fil,e3_fil,k3_fil)
 
C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (3-D)                           19-11-2012-XF  MAR |
C |   SubRoutine DYNfil_3D_mp is used to Filter Horizontal Fields in 3DCode|
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   f3_fil(i,j,k): variable to be filtered (in surface k)       |
C |   ^^^^^    e3_fil(    k): value of the selectivity parameter           |
C |            k3_fil       : vertical dimension of the variable           |
C |                                                                        |
C |   OUTPUT:  f3_fil(i,j,k)                                               |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The value    of the variable is fixed at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER. : Raymond and Garder, MWR 116, Jan 1988, p209                 |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
 
 
      IMPLICIT NONE
 
 
C +--Global Variables
C +  ================
 
      include 'MARphy.inc'
 
      include 'MARdim.inc'
      include 'MARgrd.inc'
 
      include 'MAR_WK.inc'
 
      real     f3_fil(mx,my,mz),e3_fil(mz)
      integer  k3_fil
 
 
C +--Local  Variables
C +  ================
 
      real     eps2(   mz)
      real     eps3(   mz)
      real     eps4(   mz)
      real     eps5(   mz)
      real     a1_fil(1:mx,mz) ,b1_fil(1:mx,mz) ,aa_fil(mz)
      real     a2_fil(1:my,mz) ,b2_fil(1:my,mz) ,bb_fil(mz)
 
 
C +--Initialisation
C +  ==============
 
      m  = mx
      m1 = mx1
      m2 = mx2
c #EP m3 = mx-3
c #EP m4 = mx-4
      mn = my
      mn1= my1
      mn2= my2
c #EP mn3= my-3
c #EP mn4= my-4
 
 
C +--1st Matrix Initialisation
C +  -------------------------
 
!$OMP PARALLEL DO default(shared)
!$OMP.private(a1_fil,b1_fil,a2_fil,b2_fil,
!$OMP.        WTxy4,WTxy6,WTxy7,i,j,k)
      DO k=1,k3_fil
        a1_fil( 1,k) = 0.0
        b1_fil( 1,k) = 1.0
        a1_fil(mx,k) = 0.0
        b1_fil(mx,k) = 1.0
 
c #EP   eps5( k) =      e3_fil(k)+e3_fil( k)
c #EP   eps4( k) =        eps5(k)+eps5(k)
c #EP   eps3( k) =        eps4(k)+eps4(k)
c #EP   eps2( k) =        eps3(k)+eps3(k)
C +..   Pour diminution de la sectivite du filtre vers les bords
C +       (augmentation --X 2-- parametre selectivite a chaque pas spatial)
 
        aa_fil(   k) =      1.0-e3_fil(k)
        bb_fil(   k) = 2.0*(1.0+e3_fil(k))
 
      DO i=ip11,mx1
        a1_fil(i, k) = aa_fil(k)
        b1_fil(i, k) = bb_fil(k)
      END DO
 
c #EP   a1_fil(2,k) =      1.0-eps2(k)
c #EP   a1_fil(3,k) =      1.0-eps3(k)
c #EP   a1_fil(4,k) =      1.0-eps4(k)
c #EP   a1_fil(5,k) =      1.0-eps5(k)
c #EP   b1_fil(2,k) = 2.0*(1.0+eps2(k))
c #EP   b1_fil(3,k) = 2.0*(1.0+eps3(k))
c #EP   b1_fil(4,k) = 2.0*(1.0+eps4(k))
c #EP   b1_fil(5,k) = 2.0*(1.0+eps5(k))
 
c #EP   a1_fil(m1,k)= a1_fil(2,k)
c #EP   a1_fil(m2,k)= a1_fil(3,k)
c #EP   a1_fil(m3,k)= a1_fil(4,k)
c #EP   a1_fil(m4,k)= a1_fil(5,k)
c #EP   b1_fil(m1,k)= b1_fil(2,k)
c #EP   b1_fil(m2,k)= b1_fil(3,k)
c #EP   b1_fil(m3,k)= b1_fil(4,k)
c #EP   b1_fil(m4,k)= b1_fil(5,k)
 
 
C +--2th Matrix Initialisation
C +  -------------------------
 
        a2_fil( 1,k) = 0.0
        b2_fil( 1,k) = 1.0
        a2_fil(my,k) = 0.0
        b2_fil(my,k) = 1.0
 
      DO j=jp11,my1
        a2_fil(j,k)  = aa_fil(k)
        b2_fil(j,k)  = bb_fil(k)
      END DO
 
c #EP   a2_fil(2,k) = a1_fil(2,k)
c #EP   a2_fil(3,k) = a1_fil(3,k)
c #EP   a2_fil(4,k) = a1_fil(4,k)
c #EP   a2_fil(5,k) = a1_fil(5,k)
c #EP   b2_fil(2,k) = b1_fil(2,k)
c #EP   b2_fil(3,k) = b1_fil(3,k)
c #EP   b2_fil(4,k) = b1_fil(4,k)
c #EP   b2_fil(5,k) = b1_fil(5,k)
 
c #EP   a2_fil(mn1,k) = a1_fil(2,k)
c #EP   a2_fil(mn2,k) = a1_fil(3,k)
c #EP   a2_fil(mn3,k) = a1_fil(4,k)
c #EP   a2_fil(mn4,k) = a1_fil(5,k)
c #EP   b2_fil(mn1,k) = b1_fil(2,k)
c #EP   b2_fil(mn2,k) = b1_fil(3,k)
c #EP   b2_fil(mn3,k) = b1_fil(4,k)
c #EP   b2_fil(mn4,k) = b1_fil(5,k)
 
c      END DO
 
C +--1st Equations System
C +  ====================
 
C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------
 
c      DO k=1,k3_fil
      DO j=jp11,my1
 
        WTxy4(1     ,j) =
     &  f3_fil( 1,jm1(j),k) +2.0*f3_fil( 1,j,k)+f3_fil( 1,jp1(j),k)
        WTxy4(mx    ,j) =
     &  f3_fil(mx,jm1(j),k) +2.0*f3_fil(mx,j,k)+f3_fil(mx,jp1(j),k)
 
        DO i=ip11,mx1
              WTxy4(i     ,j        ) =
     &        f3_fil(im1(i),jp1(j),k)+2.0*f3_fil(i,jp1(j),k)
     &   +    f3_fil(ip1(i),jp1(j),k)+
     &    2.0*f3_fil(im1(i),j     ,k)+4.0*f3_fil(i,j     ,k)
     &   +2.0*f3_fil(ip1(i),j     ,k)+
     &        f3_fil(im1(i),jm1(j),k)+2.0*f3_fil(i,jm1(j),k)
     &   +    f3_fil(ip1(i),jm1(j),k)
        END DO
 
      END DO
c     END DO
 
 
C +--Gaussian Elimination Algorithm: F-B Sweep ==> WTxy7
C +  ----------------------------------------------------
C +
c       DO k=1,k3_fil
        DO j=1,my
 
C +--Forward  Sweep
 
            WTxy6(1,j)=-a1_fil(1,k)/b1_fil(1,k)
            WTxy7(1,j)= WTxy4(1,j)/b1_fil(1,k)
          DO i=ip11,mx
            WTxy6(i,j)=-a1_fil(i,k)
     .                   /(a1_fil(i,k)*WTxy6(i-1,j)+b1_fil(i,k))
            WTxy7(i,j)=(WTxy4(i,j)-a1_fil(i,k)*WTxy7(i-1,j))
     .                   /(a1_fil(i,k)*WTxy6(i-1,j)+b1_fil(i,k))
          END DO
 
C +--Backward Sweep
 
          DO i=mx1,1,-1
            WTxy7(i,j)=WTxy6(i,j)*WTxy7(i+1,j)+WTxy7(i,j)
          END DO
 
        END DO
c       END DO
 
 
C +--2th Equations System
C +  ====================
 
C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------
 
c     DO k=1,k3_fil
      DO i=ip11,mx1
          WTxy4(i, 1) = f3_fil(i, 1, k)
          WTxy4(i,my) = f3_fil(i,my, k)
        DO j=jp11,my1
          WTxy4(i, j) = WTxy7(i, j)
        END DO
      END DO
c     END DO
 
 
C +--Gaussian Elimination Algorithm: F-B Sweep ==> WTxy7
C +  ----------------------------------------------------
 
c       DO k=1,k3_fil
        DO i=1,mx
 
C +--Forward  Sweep
 
            WTxy6(i,1)=-a2_fil(1,  k)/b2_fil(1,k)
            WTxy7(i,1)= WTxy4(i,1)/b2_fil(1,k)
          DO j=jp11,my
            WTxy6(i,j)=-a2_fil(  j,k)
     .                   /(a2_fil(  j,k)*WTxy6(i,j-1)+b2_fil(j,k))
            WTxy7(i,j)=(WTxy4(i,j)-a2_fil(j,k)*WTxy7(i,j-1))
     .                   /(a2_fil(  j,k)*WTxy6(i,j-1)+b2_fil(j,k))
          END DO
 
C +--Backward Sweep
 
          DO j=my1,1,-1
            WTxy7(i,j)=WTxy6(i,j)*WTxy7(i,j+1)+WTxy7(i,j)
          END DO
 
        END DO
c       END DO
 
 
C +--Result
C +  ======
 
c     DO k=1,k3_fil
      DO j=jp11,my1
      DO i=ip11,mx1
        f3_fil(i,j,k) = WTxy7(i,j)
      END DO
      END DO
      END DO
!$OMP END PARALLEL DO

      return
      end

      subroutine DYNfil_3D(f3_fil,e3_fil,k3_fil)
 
C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (3-D)                           19-11-2012-XF  MAR |
C |   SubRoutine DYNfil_3D  is used to Filter Horizontal Fields in 3D Code |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   f3_fil(i,j,k): variable to be filtered (in surface k)       |
C |   ^^^^^    e3_fil(    k): value of the selectivity parameter           |
C |            k3_fil       : vertical dimension of the variable           |
C |                                                                        |
C |   OUTPUT:  f3_fil(i,j,k)                                               |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The value    of the variable is fixed at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER. : Raymond and Garder, MWR 116, Jan 1988, p209                 |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
 
 
      IMPLICIT NONE
 
 
C +--Global Variables
C +  ================
 
      include 'MARphy.inc'
 
      include 'MARdim.inc'
      include 'MARgrd.inc'
 
      include 'MAR_WK.inc'
 
      real     f3_fil(mx,my,mz),e3_fil(mz)
      integer  k3_fil
 
 
C +--Local  Variables
C +  ================
 
      real     eps2(   mz)
      real     eps3(   mz)
      real     eps4(   mz)
      real     eps5(   mz)
      real     a1_fil(1:mx,mz) ,b1_fil(1:mx,mz) ,aa_fil(mz)
      real     a2_fil(1:my,mz) ,b2_fil(1:my,mz) ,bb_fil(mz)
 
 
C +--Initialisation
C +  ==============
 
      m  = mx
      m1 = mx1
      m2 = mx2
c #EP m3 = mx-3
c #EP m4 = mx-4
      mn = my
      mn1= my1
      mn2= my2
c #EP mn3= my-3
c #EP mn4= my-4
 
 
C +--1st Matrix Initialisation
C +  -------------------------
  
      DO k=1,k3_fil
        a1_fil( 1,k) = 0.0
        b1_fil( 1,k) = 1.0
        a1_fil(mx,k) = 0.0
        b1_fil(mx,k) = 1.0
 
c #EP   eps5( k) =      e3_fil(k)+e3_fil( k)
c #EP   eps4( k) =        eps5(k)+eps5(k)
c #EP   eps3( k) =        eps4(k)+eps4(k)
c #EP   eps2( k) =        eps3(k)+eps3(k)
C +..   Pour diminution de la sectivite du filtre vers les bords
C +       (augmentation --X 2-- parametre selectivite a chaque pas spatial)
 
        aa_fil(   k) =      1.0-e3_fil(k)
        bb_fil(   k) = 2.0*(1.0+e3_fil(k))
 
      DO i=ip11,mx1
        a1_fil(i, k) = aa_fil(k)
        b1_fil(i, k) = bb_fil(k)
      END DO
 
c #EP   a1_fil(2,k) =      1.0-eps2(k)
c #EP   a1_fil(3,k) =      1.0-eps3(k)
c #EP   a1_fil(4,k) =      1.0-eps4(k)
c #EP   a1_fil(5,k) =      1.0-eps5(k)
c #EP   b1_fil(2,k) = 2.0*(1.0+eps2(k))
c #EP   b1_fil(3,k) = 2.0*(1.0+eps3(k))
c #EP   b1_fil(4,k) = 2.0*(1.0+eps4(k))
c #EP   b1_fil(5,k) = 2.0*(1.0+eps5(k))
 
c #EP   a1_fil(m1,k)= a1_fil(2,k)
c #EP   a1_fil(m2,k)= a1_fil(3,k)
c #EP   a1_fil(m3,k)= a1_fil(4,k)
c #EP   a1_fil(m4,k)= a1_fil(5,k)
c #EP   b1_fil(m1,k)= b1_fil(2,k)
c #EP   b1_fil(m2,k)= b1_fil(3,k)
c #EP   b1_fil(m3,k)= b1_fil(4,k)
c #EP   b1_fil(m4,k)= b1_fil(5,k)
 
 
C +--2th Matrix Initialisation
C +  -------------------------
 
        a2_fil( 1,k) = 0.0
        b2_fil( 1,k) = 1.0
        a2_fil(my,k) = 0.0
        b2_fil(my,k) = 1.0
 
      DO j=jp11,my1
        a2_fil(j,k)  = aa_fil(k)
        b2_fil(j,k)  = bb_fil(k)
      END DO
 
c #EP   a2_fil(2,k) = a1_fil(2,k)
c #EP   a2_fil(3,k) = a1_fil(3,k)
c #EP   a2_fil(4,k) = a1_fil(4,k)
c #EP   a2_fil(5,k) = a1_fil(5,k)
c #EP   b2_fil(2,k) = b1_fil(2,k)
c #EP   b2_fil(3,k) = b1_fil(3,k)
c #EP   b2_fil(4,k) = b1_fil(4,k)
c #EP   b2_fil(5,k) = b1_fil(5,k)
 
c #EP   a2_fil(mn1,k) = a1_fil(2,k)
c #EP   a2_fil(mn2,k) = a1_fil(3,k)
c #EP   a2_fil(mn3,k) = a1_fil(4,k)
c #EP   a2_fil(mn4,k) = a1_fil(5,k)
c #EP   b2_fil(mn1,k) = b1_fil(2,k)
c #EP   b2_fil(mn2,k) = b1_fil(3,k)
c #EP   b2_fil(mn3,k) = b1_fil(4,k)
c #EP   b2_fil(mn4,k) = b1_fil(5,k)
 
      END DO
 
C +--1st Equations System
C +  ====================
 
C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------
 
      DO k=1,k3_fil
      DO j=jp11,my1
 
        WTxyz4(1     ,j ,k) =
     &  f3_fil( 1,jm1(j),k) +2.0*f3_fil( 1,j,k)+f3_fil( 1,jp1(j),k)
        WTxyz4(mx    ,j ,k) =
     &  f3_fil(mx,jm1(j),k) +2.0*f3_fil(mx,j,k)+f3_fil(mx,jp1(j),k)
 
        DO i=ip11,mx1
              WTxyz4(i     ,j     ,k) =
     &        f3_fil(im1(i),jp1(j),k)+2.0*f3_fil(i,jp1(j),k)
     &   +    f3_fil(ip1(i),jp1(j),k)+
     &    2.0*f3_fil(im1(i),j     ,k)+4.0*f3_fil(i,j     ,k)
     &   +2.0*f3_fil(ip1(i),j     ,k)+
     &        f3_fil(im1(i),jm1(j),k)+2.0*f3_fil(i,jm1(j),k)
     &   +    f3_fil(ip1(i),jm1(j),k)
        END DO
 
      END DO
      END DO
 
 
C +--Gaussian Elimination Algorithm: F-B Sweep ==> WTxyz7
C +  ----------------------------------------------------
C +
        DO k=1,k3_fil
        DO j=1,my
 
C +--Forward  Sweep
 
            WTxyz6(1,j,k)=-a1_fil(1,k)/b1_fil(1,k)
            WTxyz7(1,j,k)= WTxyz4(1,j,k)/b1_fil(1,k)
          DO i=ip11,mx
            WTxyz6(i,j,k)=-a1_fil(i,k)
     .                   /(a1_fil(i,k)*WTxyz6(i-1,j,k)+b1_fil(i,k))
            WTxyz7(i,j,k)=(WTxyz4(i,j,k)-a1_fil(i,k)*WTxyz7(i-1,j,k))
     .                   /(a1_fil(i,k)*WTxyz6(i-1,j,k)+b1_fil(i,k))
          END DO
 
C +--Backward Sweep
 
          DO i=mx1,1,-1
            WTxyz7(i,j,k)=WTxyz6(i,j,k)*WTxyz7(i+1,j,k)+WTxyz7(i,j,k)
          END DO
 
        END DO
        END DO
 
 
C +--2th Equations System
C +  ====================
 
C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------
 
      DO k=1,k3_fil
      DO i=ip11,mx1
          WTxyz4(i, 1,k) = f3_fil(i, 1, k)
          WTxyz4(i,my,k) = f3_fil(i,my, k)
        DO j=jp11,my1
          WTxyz4(i, j,k) = WTxyz7(i, j, k)
        END DO
      END DO
      END DO
 
 
C +--Gaussian Elimination Algorithm: F-B Sweep ==> WTxyz7
C +  ----------------------------------------------------
 
        DO k=1,k3_fil
        DO i=1,mx
 
C +--Forward  Sweep
 
            WTxyz6(i,1,k)=-a2_fil(1,  k)/b2_fil(1,k)
            WTxyz7(i,1,k)= WTxyz4(i,1,k)/b2_fil(1,k)
          DO j=jp11,my
            WTxyz6(i,j,k)=-a2_fil(  j,k)
     .                   /(a2_fil(  j,k)*WTxyz6(i,j-1,k)+b2_fil(j,k))
            WTxyz7(i,j,k)=(WTxyz4(i,j,k)-a2_fil(j,k)*WTxyz7(i,j-1,k))
     .                   /(a2_fil(  j,k)*WTxyz6(i,j-1,k)+b2_fil(j,k))
          END DO
 
C +--Backward Sweep
 
          DO j=my1,1,-1
            WTxyz7(i,j,k)=WTxyz6(i,j,k)*WTxyz7(i,j+1,k)+WTxyz7(i,j,k)
          END DO
 
        END DO
        END DO
 
 
C +--Result
C +  ======
 
      DO k=1,k3_fil
      DO j=jp11,my1
      DO i=ip11,mx1
        f3_fil(i,j,k) = WTxyz7(i,j,k)
      END DO
      END DO
      END DO
 
      return
      end

      subroutine DYNfilv3D(f3_fil,e3_fil,k3_fil)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (3-D)                              24-07-2004  MAR |
C |   SubRoutine DYNfilv3D  is used to Filter Horizontal Fields in 3D Code |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   f3_fil(i,j,k): variable to be filtered (in surface k)       |
C |   ^^^^^    e3_fil(    k): value of the selectivity parameter           |
C |            k3_fil       : vertical dimension of the variable           |
C |                                                                        |
C |   OUTPUT:  f3_fil(i,j,k)                                               |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The value    of the variable is fixed at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER. : Raymond and Garder, MWR 116, Jan 1988, p209                 |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_WK.inc'

      real     f3_fil(mx,my,mz),e3_fil(mz)
      integer  k3_fil


C +--Local  Variables
C +  ================

      real     eps2(   mz)
      real     eps3(   mz)
      real     eps4(   mz)
      real     eps5(   mz)
      real     a1_fil(1:mx,mz) ,b1_fil(1:mx,mz) ,aa_fil(mz)
      real     a2_fil(1:my,mz) ,b2_fil(1:my,mz) ,bb_fil(mz)

      integer  i1_f3D,i2_f3D,j1_f3D,j2_f3D,k1_f3D,k2_f3D


C +--Initialisation
C +  ==============

      m  = mx
      m1 = mx1
      m2 = mx2
c #EP m3 = mx-3
c #EP m4 = mx-4
      mn = my
      mn1= my1
      mn2= my2
c #EP mn3= my-3
c #EP mn4= my-4


      IF    (k3_fil.EQ.1)                                           THEN
             k      =  1


C +--1st Matrix Initialisation,  1 Level
C +  -----------------------------------

          a1_fil( 1,k) = 0.0
          b1_fil( 1,k) = 1.0
          a1_fil(mx,k) = 0.0
          b1_fil(mx,k) = 1.0

c #EP     eps5( k) =      e3_fil(k)+e3_fil( k)
c #EP     eps4( k) =        eps5(k)+eps5(k)
c #EP     eps3( k) =        eps4(k)+eps4(k)
c #EP     eps2( k) =        eps3(k)+eps3(k)
C +...    Pour diminution de la sectivite du filtre vers les bords
C +      (augmentation --X 2-- parametre selectivite a chaque pas spatial)

          aa_fil(   k) =      1.0-e3_fil(k)
          bb_fil(   k) = 2.0*(1.0+e3_fil(k))

        DO i=ip11,mx1
          a1_fil(i, k) = aa_fil(k)
          b1_fil(i, k) = bb_fil(k)
        END DO

c #EP     a1_fil(2,k) =      1.0-eps2(k)
c #EP     a1_fil(3,k) =      1.0-eps3(k)
c #EP     a1_fil(4,k) =      1.0-eps4(k)
c #EP     a1_fil(5,k) =      1.0-eps5(k)
c #EP     b1_fil(2,k) = 2.0*(1.0+eps2(k))
c #EP     b1_fil(3,k) = 2.0*(1.0+eps3(k))
c #EP     b1_fil(4,k) = 2.0*(1.0+eps4(k))
c #EP     b1_fil(5,k) = 2.0*(1.0+eps5(k))

c #EP     a1_fil(m1,k)= a1_fil(2,k)
c #EP     a1_fil(m2,k)= a1_fil(3,k)
c #EP     a1_fil(m3,k)= a1_fil(4,k)
c #EP     a1_fil(m4,k)= a1_fil(5,k)
c #EP     b1_fil(m1,k)= b1_fil(2,k)
c #EP     b1_fil(m2,k)= b1_fil(3,k)
c #EP     b1_fil(m3,k)= b1_fil(4,k)
c #EP     b1_fil(m4,k)= b1_fil(5,k)


C +--2th Matrix Initialisation,  1 Level
C +  -----------------------------------

          a2_fil( 1,k) = 0.0
          b2_fil( 1,k) = 1.0
          a2_fil(my,k) = 0.0
          b2_fil(my,k) = 1.0

        DO j=jp11,my1
          a2_fil(j,k)  = aa_fil(k)
          b2_fil(j,k)  = bb_fil(k)
        END DO

c #EP     a2_fil(2,k) = a1_fil(2,k)
c #EP     a2_fil(3,k) = a1_fil(3,k)
c #EP     a2_fil(4,k) = a1_fil(4,k)
c #EP     a2_fil(5,k) = a1_fil(5,k)
c #EP     b2_fil(2,k) = b1_fil(2,k)
c #EP     b2_fil(3,k) = b1_fil(3,k)
c #EP     b2_fil(4,k) = b1_fil(4,k)
c #EP     b2_fil(5,k) = b1_fil(5,k)

c #EP     a2_fil(mn1,k) = a1_fil(2,k)
c #EP     a2_fil(mn2,k) = a1_fil(3,k)
c #EP     a2_fil(mn3,k) = a1_fil(4,k)
c #EP     a2_fil(mn4,k) = a1_fil(5,k)
c #EP     b2_fil(mn1,k) = b1_fil(2,k)
c #EP     b2_fil(mn2,k) = b1_fil(3,k)
c #EP     b2_fil(mn3,k) = b1_fil(4,k)
c #EP     b2_fil(mn4,k) = b1_fil(5,k)

      ELSE IF (k3_fil.EQ.mz)                                        THEN


C +--All Matrices Initialisation, mz Levels
C +  --------------------------------------

        DO k=1,mz

c #EP     eps5( k) =      e3_fil(k)+e3_fil( k)
c #EP     eps4( k) =        eps5(k)+eps5(k)
c #EP     eps3( k) =        eps4(k)+eps4(k)
c #EP     eps2( k) =        eps3(k)+eps3(k)
C +...    Pour diminution de la sectivite du filtre vers les bords
C +      (augmentation --X 2-- parametre selectivite a chaque pas spatial)

          aa_fil(   k) =      1.0-e3_fil(k)
          bb_fil(   k) = 2.0*(1.0+e3_fil(k))
        END DO


C +--1st Matrix   Initialisation, mz Levels
C +  --------------------------------------

        DO k=1,mz
         DO i=ip11,mx1
          a1_fil(i, k) = aa_fil(k)
          b1_fil(i, k) = bb_fil(k)
         END DO
        END DO

        DO k=1,mz
          a1_fil( 1,k) = 0.0
          b1_fil( 1,k) = 1.0
          a1_fil(mx,k) = 0.0
          b1_fil(mx,k) = 1.0
        END DO

c #EP   DO k=1,mz
c #EP     a1_fil( 2,k) =      1.0-eps2(k)
c #EP     a1_fil( 3,k) =      1.0-eps3(k)
c #EP     a1_fil( 4,k) =      1.0-eps4(k)
c #EP     a1_fil( 5,k) =      1.0-eps5(k)
c #EP     b1_fil( 2,k) = 2.0*(1.0+eps2(k))
c #EP     b1_fil( 3,k) = 2.0*(1.0+eps3(k))
c #EP     b1_fil( 4,k) = 2.0*(1.0+eps4(k))
c #EP     b1_fil( 5,k) = 2.0*(1.0+eps5(k))

c #EP     a1_fil(m1,k) = a1_fil(2,k)
c #EP     a1_fil(m2,k) = a1_fil(3,k)
c #EP     a1_fil(m3,k) = a1_fil(4,k)
c #EP     a1_fil(m4,k) = a1_fil(5,k)
c #EP     b1_fil(m1,k) = b1_fil(2,k)
c #EP     b1_fil(m2,k) = b1_fil(3,k)
c #EP     b1_fil(m3,k) = b1_fil(4,k)
c #EP     b1_fil(m4,k) = b1_fil(5,k)
c #EP   END DO


C +--2th Matrix   Initialisation, mz Levels
C +  --------------------------------------

        DO k=1,mz
         DO j=jp11,my1
          a2_fil(j,k)  = aa_fil(k)
          b2_fil(j,k)  = bb_fil(k)
         END DO
        END DO

        DO k=1,mz
          a2_fil( 1,k) = 0.0
          b2_fil( 1,k) = 1.0
          a2_fil(my,k) = 0.0
          b2_fil(my,k) = 1.0
        END DO

c #EP   DO k=1,mz
c #EP     a2_fil(  2,k) = a1_fil(2,k)
c #EP     a2_fil(  3,k) = a1_fil(3,k)
c #EP     a2_fil(  4,k) = a1_fil(4,k)
c #EP     a2_fil(  5,k) = a1_fil(5,k)
c #EP     b2_fil(  2,k) = b1_fil(2,k)
c #EP     b2_fil(  3,k) = b1_fil(3,k)
c #EP     b2_fil(  4,k) = b1_fil(4,k)
c #EP     b2_fil(  5,k) = b1_fil(5,k)

c #EP     a2_fil(mn1,k) = a1_fil(2,k)
c #EP     a2_fil(mn2,k) = a1_fil(3,k)
c #EP     a2_fil(mn3,k) = a1_fil(4,k)
c #EP     a2_fil(mn4,k) = a1_fil(5,k)
c #EP     b2_fil(mn1,k) = b1_fil(2,k)
c #EP     b2_fil(mn2,k) = b1_fil(3,k)
c #EP     b2_fil(mn3,k) = b1_fil(4,k)
c #EP     b2_fil(mn4,k) = b1_fil(5,k)
c #EP   END DO

      ELSE
        write(6,*) 'k3_fil = ',k3_fil,'! This case is not accounted'
        stop
      END IF


C +--1st Equations System
C +  ====================

C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------

      DO k=1,k3_fil
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = a1_fil(i,k)
        WKxyz2(i,j,k) = b1_fil(i,k)
        WKxyz3(i,j,k) = a1_fil(i,k)
      END DO
      END DO
      END DO

      DO k=1,k3_fil
      DO j=jp11,my1
        WKxyz4(1     ,j ,k) = 
     &  f3_fil( 1,jm1(j),k) +2.0*f3_fil( 1,j,k)+f3_fil( 1,jp1(j),k)
        WKxyz4(mx    ,j ,k) =
     &  f3_fil(mx,jm1(j),k) +2.0*f3_fil(mx,j,k)+f3_fil(mx,jp1(j),k)
      END DO
      END DO

      DO k=1,k3_fil
      DO i=ip11,mx1
      DO j=   1,my
            WKxyz6(i     ,j     ,k) =
     &      f3_fil(im1(i),j     ,k)+2.0*f3_fil(i     ,j     ,k)
     & +    f3_fil(ip1(i),j     ,k)
      ENDDO
      ENDDO

      DO j=jp11,my1
      DO i=ip11,mx1
            WKxyz5(i     ,j     ,k) =   WKxyz6(i     ,jm1(j),k)
            WKxyz7(i     ,j     ,k) =   WKxyz6(i     ,jp1(j),k)
      ENDDO
      ENDDO

      DO j=jp11,my1
      DO i=ip11,mx1
            WKxyz4(i     ,j     ,k) = 
     .      WKxyz7(i     ,j     ,k)
     .    + WKxyz6(i     ,j     ,k) +   WKxyz6(i     ,j     ,k)
     .    + WKxyz5(i     ,j     ,k)

 ! Previous three Loops Stand for the following unvectorized Loop:
 !          WKxyz4(i     ,j     ,k) = 
 !   &      f3_fil(im1(i),jp1(j),k)+2.0*f3_fil(i,jp1(j),k)
 !   & +    f3_fil(ip1(i),jp1(j),k)+
 !   &  2.0*f3_fil(im1(i),j     ,k)+4.0*f3_fil(i     ,j     ,k)
 !   & +2.0*f3_fil(ip1(i),j     ,k)+
 !   &      f3_fil(im1(i),jm1(j),k)+2.0*f3_fil(i     ,jm1(j),k)
 !   & +    f3_fil(ip1(i),jm1(j),k)
      END DO
      END DO
      END DO


C +--Gaussian Elimination Algorithm: F-B Sweep ==> WKxyz7
C +  ----------------------------------------------------

      IF (k3_fil.EQ.1)                                              THEN

C +        ************
      call MARgx11mx1my
C +        ************

      ELSE

C +        ************
      call MARgx_1mx1my
C +        ************

      ENDIF


C +--2th Equations System
C +  ====================

C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------

      DO k=1,k3_fil
      DO j=1,my
      DO i=ip11,mx1
        WKxyz1(i,j,k) = a2_fil(j,k)
        WKxyz2(i,j,k) = b2_fil(j,k)
        WKxyz3(i,j,k) = a2_fil(j,k)
      END DO
      END DO
      END DO

      DO k=1,k3_fil
      DO i=ip11,mx1
        WKxyz4(i, 1,k) = f3_fil(i, 1, k)
        WKxyz4(i,my,k) = f3_fil(i,my, k)
      END DO
      END DO

      DO k=1,k3_fil
      DO j=jp11,my1
      DO i=ip11,mx1
        WKxyz4(i,j,k) = WKxyz7(i,j,k)
      END DO
      END DO
      END DO

      k1_f3D = 1
      k2_f3D = k3_fil


C +--Gaussian Elimination Algorithm: F-B Sweep ==> WKxyz7
C +  ----------------------------------------------------

      IF (k3_fil.EQ.1)                                              THEN

C +        ************
      call MARgy11mx1my
C +        ************

      ELSE

C +        ************
      call MARgy_1mx1my
C +        ************

      ENDIF


C +--Result
C +  ======

      DO k=1,k3_fil
      DO j=jp11,my1
      DO i=ip11,mx1
        f3_fil(i,j,k) = WKxyz7(i,j,k)
      END DO
      END DO
      END DO

      DO k=1,k3_fil
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
        WKxyz3(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
        WKxyz5(i,j,k) = 0.0
        WKxyz6(i,j,k) = 0.0
        WKxyz7(i,j,k) = 0.0
      END DO
      END DO
      END DO

      return
      end


      subroutine DYNfil_3D0(f3_fi0,e3_fi0,k3_fi0)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS FILTER (3-D)                              27-09-2001  MAR |
C |   SubRoutine DYNfil_3D0 is used to Filter Horizontal Fields in 3D Code |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   f3_fi0(i,j,k): variable to be filtered (in surface k)       |
C |   ^^^^^    e3_fi0(    k): value of the selectivity parameter           |
C |            k3_fi0       : vertical dimension of the variable           |
C |                                                                        |
C |   OUTPUT : f3_fi0(i,j,k)                                               |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |   1. The gradient of the variable is  zero at the Boundary             |
C |   2. Filter Selectivity Parameter may be increased near the Boundary   |
C |                                                                (#EP)   |
C |                                                                        |
C |   REFER. : Raymond and Garder, MWR 116, Jan 1988, p209                 |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_WK.inc'
C +
      real     f3_fi0(mx,my,mz),e3_fi0(mz)
      integer  k3_fi0
C +
C +
C +--Local  Variables
C +  ================
C +
      real     aa_fi0( mz)   ,bb_fi0(    mz)
      real     eps2(   mz)
      real     eps3(   mz)
      real     eps4(   mz)
      real     eps5(   mz)
      real     a1_fi0(i_2:mx1,mz),b1_fi0(i_2:mx1,mz)
      real     a2_fi0(j_2:my1,mz),b2_fi0(j_2:my1,mz)
C +
      integer  i1_f30,i2_f30,j1_f30,j2_f30,k1_f30,k2_f30
C +
C +
C +--Initialisation
C +  ==============
C +
      m  = mx
      m1 = mx1
      m2 = mx2
c #EP m3 = mx-3
c #EP m4 = mx-4
      mn = my
      mn1= my1
      mn2= my2
c #EP mn3= my-3
c #EP mn4= my-4
C +
C +
C +--Zero-Gradient Boundary Conditions
C +  ---------------------------------
C +
      DO k=1,k3_fi0
      DO i=1,mx
        f3_fi0( i, 1,k) =        f3_fi0( i,jp11,k)
        f3_fi0( i,my,k) =        f3_fi0( i, my1,k)
      END DO
C +
      DO j=1,my
        f3_fi0( 1, j,k) =        f3_fi0(ip11, j,k)
        f3_fi0(mx, j,k) =        f3_fi0( mx1, j,k)
      END DO
C +
C +  Corners v
        f3_fi0( 1, 1,k) = 0.5*(f3_fi0(ip11, 1,k)+f3_fi0( 1,jp11,k))
        f3_fi0(mx, 1,k) = 0.5*(f3_fi0( mx1, 1,k)+f3_fi0(mx,jp11,k))
        f3_fi0( 1,my,k) = 0.5*(f3_fi0(ip11,my,k)+f3_fi0( 1, my1,k))
        f3_fi0(mx,my,k) = 0.5*(f3_fi0( mx1,my,k)+f3_fi0(mx, my1,k))
      END DO
C +
C +
C +--1st Matrix Initialisation
C +  -------------------------
C +
      DO k=1,k3_fi0
c #EP   eps5(k)   =   e3_fi0( k)+e3_fi0( k)
c #EP   eps4(k)   =   eps5(k)+eps5(k)
c #EP   eps3(k)   =   eps4(k)+eps4(k)
c #EP   eps2(k)   =   eps3(k)+eps3(k)
C +..   Pour diminution de la sectivite du filtre vers les bords
C +       (augmentation --X 2-- parametre selectivite a chaque pas spatial)
C +
        aa_fi0(k)     =      1.0-e3_fi0(k)
        bb_fi0(k)     = 2.0*(1.0+e3_fi0(k))
C +
      DO i=ip11,mx1
        a1_fi0(i,k)   = aa_fi0(k)
        b1_fi0(i,k)   = bb_fi0(k)
      END DO
C +
c #EP   a1_fi0(2,k)   =      1.0-eps2(k)
c #EP   a1_fi0(3,k)   =      1.0-eps3(k)
c #EP   a1_fi0(4,k)   =      1.0-eps4(k)
c #EP   a1_fi0(5,k)   =      1.0-eps5(k)
c #EP   b1_fi0(2,k)   = 2.0*(1.0+eps2(k))
c #EP   b1_fi0(3,k)   = 2.0*(1.0+eps3(k))
c #EP   b1_fi0(4,k)   = 2.0*(1.0+eps4(k))
c #EP   b1_fi0(5,k)   = 2.0*(1.0+eps5(k))
C +
c #EP   a1_fi0(m1,k)  = a1_fi0(2,k)
c #EP   a1_fi0(m2,k)  = a1_fi0(3,k)
c #EP   a1_fi0(m3,k)  = a1_fi0(4,k)
c #EP   a1_fi0(m4,k)  = a1_fi0(5,k)
c #EP   b1_fi0(m1,k)  = b1_fi0(2,k)
c #EP   b1_fi0(m2,k)  = b1_fi0(3,k)
c #EP   b1_fi0(m3,k)  = b1_fi0(4,k)
c #EP   b1_fi0(m4,k)  = b1_fi0(5,k)
C +
        b1_fi0(2,k)   =      3.0+e3_fi0( k)
c #EP   b1_fi0(2,k)   =      3.0+eps2(k)
        b1_fi0(m1,k)  = b1_fi0(2,k)
C +
C +
C +--2th Matrix Initialisation
C +  -------------------------
C +
      DO j=jp11,my1
        a2_fi0(j,k)   = aa_fi0(k)
        b2_fi0(j,k)   = bb_fi0(k)
      END DO
C +
c #EP   a2_fi0(2,k)   = a1_fi0(2,k)
c #EP   a2_fi0(3,k)   = a1_fi0(3,k)
c #EP   a2_fi0(4,k)   = a1_fi0(4,k)
c #EP   a2_fi0(5,k)   = a1_fi0(5,k)
c #EP   b2_fi0(2,k)   = b1_fi0(2,k)
c #EP   b2_fi0(3,k)   = b1_fi0(3,k)
c #EP   b2_fi0(4,k)   = b1_fi0(4,k)
c #EP   b2_fi0(5,k)   = b1_fi0(5,k)
C +
c #EP   a2_fi0(mn1,k) = a1_fi0(2,k)
c #EP   a2_fi0(mn2,k) = a1_fi0(3,k)
c #EP   a2_fi0(mn3,k) = a1_fi0(4,k)
c #EP   a2_fi0(mn4,k) = a1_fi0(5,k)
c #EP   b2_fi0(mn1,k) = b1_fi0(2,k)
c #EP   b2_fi0(mn2,k) = b1_fi0(3,k)
c #EP   b2_fi0(mn3,k) = b1_fi0(4,k)
c #EP   b2_fi0(mn4,k) = b1_fi0(5,k)
C +
        b2_fi0(jp11,k) = 3.0+e3_fi0( k)
c #EP   b2_fi0(jp11,k) = 3.0+eps2(k)
        b2_fi0(mn1 ,k) = b2_fi0(jp11,k)
      END DO
C +
C +
C +--1st Equations System
C +  ====================
C +
C +
C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------
C +
      DO k=1,k3_fi0
      DO j=jp11,my1
      DO i=ip11,mx1
        WKxyz1(i,j,k) = a1_fi0(i,k)
        WKxyz2(i,j,k) = b1_fi0(i,k)
        WKxyz3(i,j,k) = a1_fi0(i,k)
      END DO
      END DO
      END DO
C +
      DO k=1,k3_fi0
      DO j=jp11,my1
      DO i=ip11,mx1
            WKxyz4(i     ,j     ,k) =
     &      f3_fi0(im1(i),jp1(j),k)+2.0*f3_fi0(i,jp1(j),k)
     & +    f3_fi0(ip1(i),jp1(j),k)+
     &  2.0*f3_fi0(im1(i),j     ,k)+4.0*f3_fi0(i,j     ,k)
     & +2.0*f3_fi0(ip1(i),j     ,k)+
     &      f3_fi0(im1(i),jm1(j),k)+2.0*f3_fi0(i,jm1(j),k)
     & +    f3_fi0(ip1(i),jm1(j),k)
      END DO
      END DO
      END DO
C +
      i1_f30 = ip11
      i2_f30 = mx1
      j1_f30 = jp11
      j2_f30 = my1
      k1_f30 = 1
      k2_f30 = k3_fi0
C +
C +
C +--Gaussian Elimination Algorithm: F-B Sweep ==> WKxyz7
C +  ----------------------------------------------------
C +
C +   *************
      call MARgau_x(i1_f30,i2_f30,j1_f30,j2_f30,k1_f30,k2_f30)
C +   *************
C +
C +
C +--2th Equations System
C +  ====================
C +
C +
C +--Gaussian Elimination Algorithm: Set Up
C +  --------------------------------------
C +
      DO k=1,k3_fi0
      DO j=jp11,my1
      DO i=ip11,mx1
        WKxyz1(i,j,k) = a2_fi0(j,k)
        WKxyz2(i,j,k) = b2_fi0(j,k)
        WKxyz3(i,j,k) = a2_fi0(j,k)
        WKxyz4(i,j,k) = WKxyz7(i,j,k)
      END DO
      END DO
      END DO
C +
      i1_f30 = ip11
      i2_f30 = mx1
      j1_f30 = jp11
      j2_f30 = my1
      k1_f30 = 1
      k2_f30 = k3_fi0
C +
C +
C +--Gaussian Elimination Algorithm: F-B Sweep ==> WKxyz7
C +  ----------------------------------------------------
C +
C +   *************
      call MARgau_y(i1_f30,i2_f30,j1_f30,j2_f30,k1_f30,k2_f30)
C +   *************
C +
C +
C +--Result
C +  ======
C +
      DO k=1,k3_fi0
      DO j=jp11,my1
      DO i=ip11,mx1
        f3_fi0(i,j,k) = WKxyz7(i,j,k)
      END DO
      END DO
      END DO
C +
C +
C +--Zero-Gradient Boundary Conditions
C +  =================================
C +
      DO k=1,k3_fi0
      DO i=1,mx
        f3_fi0(i, 1,k) =                             f3_fi0(i,jp11,k)
        f3_fi0(i,my,k) =                             f3_fi0(i, my1,k)
      END DO
      END DO
C +
      DO k=1,k3_fi0
      DO j=1,my
        f3_fi0( 1,j,k) =          f3_fi0(ip11,j,k)
        f3_fi0(mx,j,k) =          f3_fi0( mx1,j,k)
      END DO
      END DO
C +
C +  Corners v
      DO k=1,k3_fi0
        f3_fi0( 1, 1,k) = 0.50 *(f3_fi0(ip11, 1,k) +f3_fi0( 1,jp11,k))
        f3_fi0(mx, 1,k) = 0.50 *(f3_fi0(mx1 , 1,k) +f3_fi0(mx,jp11,k))
        f3_fi0( 1,my,k) = 0.50 *(f3_fi0(ip11,my,k) +f3_fi0( 1, my1,k))
        f3_fi0(mx,my,k) = 0.50 *(f3_fi0(mx1 ,my,k) +f3_fi0(mx, my1,k))
      END DO
C +
      DO k=1,k3_fi0
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
        WKxyz3(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
        WKxyz5(i,j,k) = 0.0
        WKxyz6(i,j,k) = 0.0
        WKxyz7(i,j,k) = 0.0
      END DO
      END DO
      END DO
C +
      return
      end


      subroutine DYNqqm(specQt,eval_s,eval_p)

!--------------------------------------------------------------------------+
!   MAR DYNAMICS   SLOW                                Wed 11-12-2009  MAR |
!                                                                          |
!     subroutine DYNqqm restaures Water Mass                               |
!                                                                          |
!--------------------------------------------------------------------------+

      IMPLICIT  NONE


!  Global Variables
!  ================

      include  "MARphy.inc"
      include  "MARdim.inc"
      include  "MARgrd.inc"
      include  "MAR_GE.inc"
      include  "MAR_DY.inc"
      include  "MAR_FI.inc"
      include  "MARqqm.inc"
      include  "MAR_WK.inc"

      logical           RetroD
      logical           Set_MM
      logical           logqqm
      common/DYNqqm_log/logqqm
      real              specQt(mx,my,mz)
      character*3       eval_s
      character*6       eval_p


!  Local  Variables
!  ================

      character*6       eval0p
      common/DYNqqm_cha/eval0p

      real              fac_mm    ,summmm    ,sum_mm    ,countr
      real              sumnew    ,qqnmin(mz),qqnmax(mz)
      real              sumbak(mz),qqxmin(mz),qqxmax(mz)
     .                 ,qqnFil(mx,my,mz)
      common/DYNqqm_rea/sumbak    ,qqxmin    ,qqxmax
     .                 ,qqnFil

      data              RetroD/.false./
      data              Set_MM/.false./
      data              logqqm/.false./


!  Conservation Constraint Boundary
!  ================================

      IF (.not.logqqm)                                              THEN
               logqqm=.true.
        write(6,6) lb
 6      format(/,'*** DYNqqm: lb =',i3,' ***',/,'    ******',/)
      END IF


!  Retro-diffusion (Before Process)
!  ================================

      IF (RetroD)                                                   THEN
        DO   k=1,mz
        DO   j=1,my
        DO   i=1,mx
          WKxyz1(i,j,k) =           (FIsloQ       /FIslou)
     .   *FIkhmn*(specQt(i-1,j,k)-4.*specQt(i,j,k)+specQt(i+1,j,k)
     .           +specQt(i,j-1,k)                 +specQt(i,j+1,k))
     .   *dtx/dx
        END DO
        END DO
        END DO
        DO   k=1,mz
        DO   j=1,my
        DO   i=1,mx
          specQt(i,j,k) =            specQt(i,j,k)-WKxyz1(i,j,k)
          WKxyz1(i,j,k) =         0.
        END DO
        END DO
        END DO
      END IF


!  Mass Evaluation (Before Process)
!  ================================

      IF   (eval_s.EQ.'BAK')                                        THEN
            eval0p    = eval_p
        DO   k=1,mz
            qqxmax(k) = 0.0
            qqxmin(k) = 1.e20
          DO j=1,my
          DO i=1,mx
            qqnFil(i,j,k) =         specQt(i,j,k)   *pstDYn(i,j)
     .                            /(SFm_DY(i,j)     *SFm_DY(i,j))
            qqxmax(k) =         max(qqxmax(k)       ,qqnFil(i,j,k))
            qqxmin(k) =         min(qqxmin(k)       ,qqnFil(i,j,k))
          END DO
          END DO
        END DO

       IF  (FIBord)                                                 THEN
        DO   k=1,mz
            sumbak(k) = 0.0
          DO j=lgy,ldy
          DO i=lgx,ldx
            sumbak(k) =             sumbak(k)       +qqnFil(i,j,k)
          END DO
          END DO
        END DO

        IF (eval_p(1:3).EQ.'FIL')                                   THEN

          DO k=1,mz
          DO j=lgy ,ldy
            sumbak(k) = sumbak(k) + dtx
     .           *(FIkhmn*FacFIk  *(specQt(lgx1,j,k)*pstDYn(lgx1,j)
     .                             -specQt(lgx ,j,k)*pstDYn(lgx ,j)
     .                             +specQt(ldx1,j,k)*pstDYn(ldx1,j)
     .                             -specQt(ldx ,j,k)*pstDYn(ldx ,j)))/dx
          ENDDO

          DO i=lgx ,ldx
            sumbak(k) = sumbak(k) + dtx
     .           *(FIkhmn*FacFIk  *(specQt(i,lgy1,k)*pstDYn(i,lgy1)
     .                             -specQt(i,lgy ,k)*pstDYn(i,lgy )
     .                             +specQt(i,ldy1,k)*pstDYn(i,ldy1)
     .                             -specQt(i,ldy ,k)*pstDYn(i,ldy )))/dx
          ENDDO
          ENDDO

        END IF

       ELSE

          DO k=1,mz
            sumbak(k) = 0.0
          DO j=1,my
          DO i=1,mx
            sumbak(k) = sumbak(k) + qqnFil(i,j,k)
          END DO
          END DO
          END DO

       END IF


!  Mass Reset      (After  Process)
!  ================================

      ELSE IF (eval_s.EQ.'SET' )                                    THEN
        IF    (eval_p.NE.eval0p)                                    THEN
          write(6,6010) eval_p,eval0p
 6010     format('Problem in Mass Reset, Process',a7,' .NE. ',a6)
          STOP
        END IF

        DO   k=1,mz
            qqnmax(k) = 0.0
            qqnmin(k) = 1.e20
          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k) =         specQt(i,j,k)   *pstDYn(i,j)
     .                            /(SFm_DY(i,j)     *SFm_DY(i,j))
          END DO
          END DO
        END DO

c #VQ       summmm =  0.0
        IF (FIBord)                                                 THEN
          DO k=1,mz
            sumnew  = 0.0
          DO j=lgy,ldy
          DO i=lgx,ldx
            sumnew = WKxyz1(i,j,k)               +           sumnew
          END DO
          END DO
            sumnew =                                max(eps9,sumnew)
            countr =                         (ldx-lgx+1)*(ldy-lgy+1)
            fac_mm =                               sumbak(k)/sumnew
c #VQ       summmm = summmm       +dsigm1(k)     * fac_mm
          DO j=1,my
          DO i=1,mx
            specQt(i,j,k) =        specQt(i,j,k) * fac_mm
            WKxyz1(i,j,k) =        WKxyz1(i,j,k) * fac_mm
            qqnmax(k) =        max(WKxyz1(i,j,k) , qqnmax(k))
            qqnmin(k) =        min(WKxyz1(i,j,k) , qqnmin(k))
          END DO
          END DO
            sumbak(k) = sumbak(k) / countr
          END DO
        ELSE
          DO k=1,mz
            sumnew  = 0.0
          DO j=1,my
          DO i=1,mx
            sumnew = WKxyz1(i,j,k)               +           sumnew
          END DO
          END DO
            sumnew =                                max(eps9,sumnew)
            countr =                                 mx *        my
            fac_mm =                               sumbak(k)/sumnew
c #VQ       summmm = summmm       +dsigm1(k)     * fac_mm
          DO j=1,my
          DO i=1,mx
            specQt(i,j,k) =        specQt(i,j,k) * fac_mm
            WKxyz1(i,j,k) =        WKxyz1(i,j,k) * fac_mm
            qqnmax(k) =        max(WKxyz1(i,j,k) , qqnmax(k))
            qqnmin(k) =        min(WKxyz1(i,j,k) , qqnmin(k))
          END DO
          END DO
            sumbak(k) = sumbak(k) / countr
          END DO
        ENDIF


!  Maximorum/Minimorum RESET (water vapor only)
!  ============================================

        IF (eval_p.EQ.'FIL_Qv'.AND.Set_MM)                          THEN
c #VQ       sum_mm = 0.
          DO k=1,mz
            fac_mm =     (qqxmax(k)-sumbak(k))
     .         /(max(epsi,qqnmax(k)-sumbak(k)))
            fac_mm = min((sumbak(k)- sigma(k) *103.5*epsq)
     .                  /(sumbak(k)-qqnmin(k)),fac_mm)
            fac_mm = max( 1.0                 ,fac_mm)

c #VQ       sum_mm = sum_mm       + dsigm1(k) *fac_mm

          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k)=sumbak(k)+fac_mm*(WKxyz1(i,j,k)-sumbak(k))
            specQt(i,j,k)=WKxyz1(i,j,k)   * SFm_DY(i,j)  *SFm_DY(i,j) 
     .                                    / pstDYn(i,j)
          END DO
          END DO
          END DO


!  Output of Statistics
!  ====================

c #VQ         IF (mod(jhurGE,3).EQ.0.AND.minuGE.EQ.0.AND.jsecGE.EQ.0)
c #VQ.          write(24,240)
 240            format(21x, 'RESTORE MASS ... EXTREMA')
c #VQ           write(24,241)jdarGE,labmGE(mmarGE),iyrrGE
c #VQ.                      ,jhurGE,minuGE,jsecGE 
c #VQ.                      ,summmm,sum_mm
 241            format(i3,'-',a3,'-',i4,i3,'h',i2,':',i2,2f12.6)

        END IF


!  Work Array(s) reset
!  ===================

        DO   k=1,mz
          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k) = 0.
          END DO
          END DO
        END DO

      ELSE
          write(6,6020) eval_s
 6020     format('Problem in Mass Reset, Type   ',a4)
          STOP
      END if

      return
      end


      subroutine TURhor_kh 

C +------------------------------------------------------------------------+
C | MAR TURBULENCE HORIZONTAL                              30-12-2000  MAR |
C |   SubRoutine TURhor_kh computes the Horizontal Diffusion Coefficient   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT  (via common block)                                            |
C |   ^^^^^   uairDY(i,j,k): Horizontal Wind Speed (x-Direction)     (m/s) |
C |           vairDY(i,j,k): Horizontal Wind Speed (y-Direction)     (m/s) |
C |                                                                        |
C |   OUTPUT (via common block)                                            |
C |   ^^^^^^   TUkhx(i,j,k): Horizont.Diff.Coefficient (i+1/2,j,k)  (m2/s) |
C |            TUkhy(i,j,k): Horizont.Diff.Coefficient (i,j+1/2,k)  (m2/s) |
C |                                                                        |
C |   REFER.: Tag et al., JAM 18, 1429--1441, 1979                         |
C |   ^^^^^^^                                                              |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_TU.inc'

      include 'MAR_WK.inc'


C +--Reset of the Horizontal Diffusion Coefficient
C +  =============================================

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        TUkhx(i,j,k) = 0.0
        TUkhy(i,j,k) = 0.0
      END DO
      END DO
      END DO


C +--2D Model Version
C +  ================

      IF (mmy.eq.1)                                               THEN

           j=1
        DO k=1,mz
        DO i=1,mx
          WKxza(i,k)=uairDY(ip1(i),j,k)-uairDY(i,j,k)
          WKxzb(i,k)=vairDY(ip1(i),j,k)-vairDY(i,j,k)
        END DO
        END DO

        DO k=1,mz
          DO i=1,mx
            TUkhx( i,j,k) = TUkhff*dx
     .          *(sqrt(0.5*(WKxzb(i,k)  *WKxzb(i,k) ) 
     .                     +WKxza(i,k)  *WKxza(i,k)  ))
            WKxza( i,  k) = 0.0
            WKxzb( i,  k) = 0.0
          END DO
            TUkhx(mx,j,k) = 0.0
        END DO


C +--Upper Absorbing Layer
C +  ---------------------

        IF (TUkhmx.gt.0.0)                                        THEN
          DO k=1,mzabso
          DO j=1,my
          DO i=1,mx
            TUkhx(i,j,k) = TUkhx(i,j,k) + TUspon(k)
          END DO
          END DO
          END DO
        END IF


C +--3D Model Version
C +  ================

      ELSE

        DO k=1,mz


C +--x Direction
C +  -----------

          DO i=1,mx
          DO j=jp11,my1
           WKxyz1(i,j,k) =
     .               vairDY(ip1(i),    j ,k)-vairDY(i,    j ,k)
           WKxyz3(i,j,k) =
     .               uairDY(ip1(i),    j ,k)-uairDY(i,    j ,k)
c #vL     ENDDO
c #vL     ENDDO

c #vL     DO j=jp11,my1
c #vL     DO i=1,mx
           WKxyz2(i,j,k) =
     .               uairDY(    i ,jp1(j),k)-uairDY(i,jm1(j),k)
           WKxyz4(i,j,k) =
     .               vairDY(    i ,jp1(j),k)-vairDY(i,jm1(j),k)
           WKxyz5(i,j,k) =
     .               vairDY(    i ,jp1(j),k)
           WKxyz6(i,j,k) =
     .               vairDY(    i ,jm1(j),k)
c #vL     ENDDO
c #vL     ENDDO

c #vL     DO i=1,mx
c #vL     DO j=jp11,my1
            TUkhx(i,j,k) = TUkhff *dx *(sqrt(
     .         0.5*((WKxyz1(    i ,    j ,k)
     .       + 0.5* (WKxyz2(    i ,    j ,k)))**2)
     .       +      (WKxyz3(    i ,    j ,k)) **2 
     .       +(0.25*(WKxyz4(    i ,    j ,k)
     .              +WKxyz5(ip1(i),    j ,k)
     .              -WKxyz6(ip1(i),    j ,k)))**2)) 

 ! The 3 previous Loops Stand for the following non-vectorized Loop:
 !          TUkhx(i,j,k) = TUkhff *dx *(sqrt(
 !   .         0.5*((vairDY(ip1(i),    j ,k)-vairDY(i,    j ,k)
 !   .       + 0.5* (uairDY(i     ,jp1(j),k)-uairDY(i,jm1(j),k)))**2)
 !   .       +      (uairDY(ip1(i),    j ,k)-uairDY(i,    j ,k)) **2 
 !   .       +(0.25*(vairDY(i     ,jp1(j),k)-vairDY(i,jm1(j),k)
 !   .              +vairDY(ip1(i),jp1(j),k)
 !   .              -vairDY(ip1(i),jm1(j),k)))**2)) 
          END DO
          END DO


C +--y Direction
C +  -----------

          DO j=1,my
          DO i=ip11,mx1
           WKxyz1(i,j,k) =
     .               vairDY(    i ,jp1(j),k)-vairDY(    i ,j,k)
           WKxyz3(i,j,k) =
     .               uairDY(    i ,jp1(j),k)-uairDY(    i ,j,k)
c #vL     ENDDO
c #vL     ENDDO

c #vL     DO i=ip11,mx1
c #vL     DO j=1,my
           WKxyz2(i,j,k) =
     .               uairDY(ip1(i),    j ,k)-uairDY(im1(i),j,k)
           WKxyz4(i,j,k) =
     .               vairDY(ip1(i),    j ,k)-vairDY(im1(i),j,k)
           WKxyz5(i,j,k) =
     .               vairDY(ip1(i),    j ,k)
           WKxyz6(i,j,k) =
     .               vairDY(im1(i),    j ,k)
c #vL     ENDDO
c #vL     ENDDO

c #vL     DO j=1,my
c #vL     DO i=ip11,mx1
            TUkhy(i,j,k) = TUkhff *dx *(sqrt(
     .         0.5*((WKxyz1(    i ,    j ,k)
     .       + 0.5* (WKxyz2(    i ,    j ,k)))**2)
     .       +      (WKxyz3(    i ,    j ,k)) **2 
     .       +(0.25*(WKxyz4(    i ,    j ,k)
     .              +WKxyz5(    i ,jp1(j),k)
     .              -WKxyz6(    i ,jp1(j),k)))**2)) 

 ! The 3 previous Loops Stand for the following non-vectorized Loop:
 !          TUkhy(i,j,k) = TUkhff *dx *(sqrt(
 !   .         0.5*((vairDY(    i ,jp1(j),k)-vairDY(    i ,j,k)
 !   .       + 0.5* (uairDY(ip1(i),    j ,k)-uairDY(im1(i),j,k)))**2)
 !   .       +      (uairDY(    i ,jp1(j),k)-uairDY(    i ,j,k)) **2 
 !   .       +(0.25*(vairDY(ip1(i),    j ,k)-vairDY(im1(i),j,k)
 !   .              +vairDY(ip1(i),jp1(j),k)
 !   .              -vairDY(im1(i),jp1(j),k)))**2)) 
c #vL     ENDDO
c #vL     ENDDO

c #vL     DO i=1,mx
c #vL     DO j=jp11,my1
            WKxyz1(i,j,k) = 0.
            WKxyz2(i,j,k) = 0.
            WKxyz3(i,j,k) = 0.
            WKxyz4(i,j,k) = 0.
            WKxyz5(i,j,k) = 0.
            WKxyz6(i,j,k) = 0.
          END DO
          END DO

        END DO


C +--Upper Absorbing Layer
C +  ---------------------

        IF (TUkhmx.gt.0.0)                                        THEN

          DO k=1,mzabso
          DO j=1,my
          DO i=1,mx
            TUkhx(i,j,k) = TUkhx(i,j,k) + TUspon(k)
            TUkhy(i,j,k) = TUkhy(i,j,k) + TUspon(k)
          END DO
          END DO
          END DO

        END IF

      END IF


C +--Lateral Boundary Values
C +  -----------------------

c #OB IF (mmx.gt.1)                                               THEN
c #OB   DO k=1,mz
c #OB   DO j=1,my
c #OB     TUkhx( 1, j,k) = 0.0
c #OB     TUkhx(mx, j,k) = 0.0
c #OB     TUkhy( 1, j,k) = 0.0
c #OB     TUkhy(mx, j,k) = 0.0
c #OB   END DO
c #OB   END DO
c #OB END IF

c #OB IF (mmy.gt.1)                                               THEN
c #OB   DO k=1,mz
c #OB   DO i=1,mx
c #OB     TUkhx( i, 1,k) = 0.0
c #OB     TUkhx( i,my,k) = 0.0
c #OB     TUkhy( i, 1,k) = 0.0
c #OB     TUkhy( i,my,k) = 0.0
c #OB   END DO
c #OB   END DO
c #OB END IF


      return
      end


      subroutine TURhor_dyn(dtHDif) 

C +------------------------------------------------------------------------+
C | MAR TURBULENCE HORIZONTAL                          Sat 05-12-2009  MAR |
C |   SubRoutine TURhor_dyn computes Horizontal Diffusion                  |
C |                              and Correction Terms                      |
C |                         using an Explicit Scheme                       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | INPUT: dt_Loc: Time Step between two CaLLs of Horiz. Diffusion Routine |
C | ^^^^^  dtHDif: Time Step between two run   of Horiz. Diffusion Scheme  |
C |               (dt_Loc = n X dtHDif, n = 1,2,...)                       |
C |        micphy: Cloud Microphysical Scheme Switch                       |
C |                                                                        |
C | INPUT (via common block)                                               |
C | ^^^^^  TUkhx(mx,my,mz): Horizontal Diffusion Coefficient (x-Direction) |
C |        TUkhy(mx,my,mz): Horizontal Diffusion Coefficient (y-Direction) |
C |                                                                        |
C | INPUT / OUTPUT                                                         |
C | ^^^^^^^^^^^^^^                                                         |
C |      The Horizontal Diffusion and Correction Terms are included for :  |
C |       1) The Horizontal     x-Wind Component uairDY(mx,my,mz)    [m/s] |
C |       2) The Horizontal     y-Wind Component vairDY(mx,my,mz)    [m/s] |
C |                                                                        |
C |  #NH  3) The Vertical       z-Wind Component wairNH(mx,my,mz)    [m/s] |
C |                                                                        |
C |       4) The Potential      Temperature      pktaDY(mx,my,mzz)         |
C |       5) The Air Specific   Humidity           qvDY(mx,my,mz)  [kg/kg] |
C |                                                                        |
C |  #HY  6) The Ice Crystals   Concentration      qiHY(mx,my,mz)  [kg/kg] |
C |       7) The Ice Crystals   Number           ccniHY(mx,my,mz)  [Nb/m3] |
C |       8) The Cloud Droplets Concentration      qwHY(mx,my,mz)  [kg/kg] |
C |       9) The Snow Flakes    Concentration      qsHY(mx,my,mz)  [kg/kg] |
C |      10) The Rain Drops     Concentration      qrHY(mx,my,mz)  [kg/kg] |
C |                                                                        |
C |  #TC 11) The Tracer         Concentration      qxTC(mx,my,mz,ntrac)    |
C |                                                                        |
C |  REMARK:                                                               |
C |  ^^^^^^^                                                               |
C |  !. `Standard' Horizontal Diffusion is performed on Sigma Surfaces     |
C |  !.  Smagorinski Relation (see Tag et al. 1979, JAM 18, 1429--1441)    |
C |  !.  CAUTION: Horizontal Diffusion is switched on with turhor = .true. |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
c #NH include 'MAR_NH.inc'

c #Di include 'MAR_DI.inc'

      include 'MAR_TU.inc'
c _PE include 'MARpen.inc'
c #PE include 'MARpen.inc'
      include 'MAR_FI.inc'

c #HY include 'MAR_HY.inc'
c #TC include 'MAR_TC.inc'

      include 'MAR_WK.inc'

      real     dtHDif


C +--Local  Variables
C +  ================

      integer  nntrac,ntDifH,iter  ,n_kq  ,ivar ,itrac
      real     akhsta,akhloc,cflakh,dx2inv,gdx2
      real      facxx, facxy, facyy, alph2,beta2,akhm2,alph22,beta22

c #DC real     rhox  (mx,my,mz)
c _PE real     rikx  (mx,my,mzz)
c #PE real     rikx  (mx,my,mzz)
c _PE real     riky  (mx,my,mzz)
c #PE real     riky  (mx,my,mzz)

      real     vartop(mx,my),varbot(mx,my)
c #DC real                   varbou(mx,my)


C +--DATA
C +  ====

      data nntrac/0/
c #TC      nntrac=ntrac


C +--Reset of the Local Variables
C +  ============================

c _PE DO k=1,mzz
c _PE DO j=1,my
c _PE DO i=1,mx
c _PE   rikx(i,j,k) = 0.0
c _PE   riky(i,j,k) = 0.0
c _PE END DO
c _PE END DO
c _PE END DO

c #PE DO k=1,mzz
c #PE DO j=1,my
c #PE DO i=1,mx
c #PE   rikx(i,j,k) = 0.0
c #PE   riky(i,j,k) = 0.0
c #PE END DO
c #PE END DO
c #PE END DO

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
c _PE     akhm(i,j,k) = 0.0
c _PE   pente1(i,j,k) = 0.0
c _PE   pente2(i,j,k) = 0.0
c _PE   pente3(i,j,k) = 0.0
c #PE     akhm(i,j,k) = 0.0
c #PE   pente1(i,j,k) = 0.0
c #PE   pente2(i,j,k) = 0.0
c #PE   pente3(i,j,k) = 0.0
        WKxyz3(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
        WKxyz5(i,j,k) = 0.0
      END DO
      END DO
      END DO


C +--Update of Local Variables and 
C +            Mesh Averaged Horizontal Diffusion Coefficient akhm
C +  =============================================================

        akhsta        = 0.0
      DO k=1,mz
      DO i=ip11,mx1
      DO j=jp11,my1
        WKxyz1(i,j,k) = FIkhmn+0.25*(TUkhx(i,j,k)+TUkhx(im1(i),j,k))
c #vL END DO
c #vL END DO

c #vL DO j=jp11,my1
c #vL DO i=ip11,mx1
c #vL   WKxyz1(i,j,k) =     WKxyz1(i,j,k) 
     .                        +0.25*(TUkhy(i,j,k)+TUkhy(i,jm1(j),k))
        akhsta        = max(WKxyz1(i,j,k),akhsta)
c #PE     akhm(i,j,k) =     WKxyz1(i,j,k)
c #PE     rikx(i,j,k) =     rolvDY(i,j,k) * slopex(i,j,k) *akhm(i,j,k)
c #PE     riky(i,j,k) =     rolvDY(i,j,k) * slopey(i,j,k) *akhm(i,j,k)
c _PE     akhm(i,j,k) =     WKxyz1(i,j,k)
c _PE     rikx(i,j,k) =     rolvDY(i,j,k) * slopex(i,j,k) *akhm(i,j,k)
c _PE     riky(i,j,k) =     rolvDY(i,j,k) * slopey(i,j,k) *akhm(i,j,k)
      END DO
      END DO
      END DO


C +--Local Time step
C +  ===============

      cflakh       = dt_Loc *akhsta / dx / dx
      ntDifH       = 3      *cflakh
      ntDifH       = max(iun,ntDifH)
      dtHDif       = dt_Loc /ntDifH


C +--Update of Local Coefficients  
C +  ============================

c _PE IF (mmy.gt.2)                                               THEN
c _PE   DO k=1,mmz1
c _PE   DO j=jp11,my1
c _PE   DO i=ip11,mx1
c _PE     WKxyz1(i,j,k)= rikx(i,j,k) *riky(i,j,k) *gravi2 *0.5 
c _PE.                  /max(epsi,akhm(i,j,k))
c _PE.                  /(sigma(k+1)-sigma(k))
c _PE   END DO
c _PE   END DO
c _PE   END DO
c _PE END IF

c #PE IF (mmy.gt.2)                                               THEN
c #PE   DO k=1,mmz1
c #PE   DO j=jp11,my1
c #PE   DO i=ip11,mx1
c #PE     WKxyz1(i,j,k)= rikx(i,j,k) *riky(i,j,k) *gravi2 *0.5 
c #PE.                  /max(epsi,akhm(i,j,k))
c #PE.                  /(sigma(k+1)-sigma(k))
c #PE   END DO
c #PE   END DO
c #PE   END DO
c #PE END IF

         dx2inv = 1.0/dx/dx

        DO j=1,my
        DO i=1,mx
c _PE     akhm(i,j,mz) = 0.0
c #PE     akhm(i,j,mz) = 0.0
C +...    The vertical correction to horizontal diffusion is assumed 
C +       to be equal to zero in the surface boundary layer

          WKxy1(i,j)   = 0.0
          WKxy2(i,j)   = 0.0
          WKxy3(i,j)   = dx2inv / pstDY(i,j)
          WKxy4(i,j)   = 1.0    /(pstDY(i,j)*pstDY(i,j))
c #DC     rhox (i,j,mz)= 0.0
        END DO
        END DO

        DO i=1,mx1
        DO j=1,my
          WKxy1(i,j) = 0.5*(pstDY(i,j)+pstDY(ip1(i),j))
        END DO
        END DO

      IF (mmy.gt.1)                                               THEN
        DO j=1,my1
        DO i=1,mx
          WKxy2(i,j) = 0.5*(pstDY(i,j)+pstDY(i,jp1(j)))
        END DO
        END DO
      END IF

                          gdx2  =  0.5        *gravit / dx
        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz3(i,j,k) = gdx2  / (pstDY(i,j) *dsig_2(k))
        END DO
        END DO
        END DO

c #DC   DO k=1,mmz1
c #DC   DO j=1,my
c #DC   DO i=1,mx
c #DC     rhox  (i,j,k)  = 0.5 *WKxy4(i,j) 
c #DC.                        *(WKxyz1(i,j,k+1) +WKxyz1(i,j,k))
c #DC   END DO
c #DC   END DO
c #DC   END DO

        DO j=1,my
        DO i=1,mx
          WKxy4(i,j)     = 0.0
        END DO
        END DO


C +--Global Variables Loop
C +  =====================

             n_kq =   5    ! Nombre de variables Ã  diffuser: u,v,(w),T,q
c #KT        n_kq =   4    !                                 u,v,(w),T
c #KQ        n_kq =  10+nntrac
      DO     iter =1,   ntDifH
      DO     ivar =1,   n_kq

c #TC   IF    (ivar.gt.10)                                  GO TO  341

        GO TO (331,332,333,334,335,336,337,338,339,340) ivar


C +--u Wind Speed Component
C +  ----------------------

 331    CONTINUE

c #DF     facxx = 1.0
c #DF     facxy = 0.5
c #DF     facyy = 0.5
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k) = uairDY(i,j,k)
c #DF       WKxyz2(i,j,k) = vairDY(i,j,k)
          END DO
          END DO
          END DO

          DO j=1,my
          DO i=1,mx
            vartop(i,j)   = ugeoDY(i,j,1)
c #Di       vartop(i,j)   = uairDI(i,j)
            varbot(i,j)   = uairDY(i,j,mz)
c #DC       varbou(i,j)   = vairDY(i,j,mz)
          END DO
          END DO

        GO TO 330


C +--v Wind Speed Component
C +  ----------------------

 332    CONTINUE

c #DF     facxx = 0.5
c #DF     facxy = 0.5
c #DF     facyy = 1.0
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k) = vairDY(i,j,k)
c #DF       WKxyz2(i,j,k) = uairDY(i,j,k)
          END DO
          END DO
          END DO

          DO j=1,my
          DO i=1,mx
            vartop(i,j)   = vgeoDY(i,j,1)
c #Di       vartop(i,j)   = vairDI(i,j)
            varbot(i,j)   = vairDY(i,j,mz)
c #DC       varbou(i,j)   = uairDY(i,j,mz)
          END DO
          END DO

        GO TO 330


C +--w Wind Speed Component (Non Hydrostatic Option)
C +  -----------------------------------------------

 333    CONTINUE

c #NH     DO k=1,mz
c #NH     DO j=1,my
c #NH     DO i=1,mx
c #NH       WKxyz1(i,j,k) = wairNH(i,j,k)
c #NH     END DO
c #NH     END DO
c #NH     END DO

c #NH     DO j=1,my
c #NH     DO i=1,mx
c #NH       vartop(i,j)   = wairNH(i,j,1)
c #NH       varbot(i,j)   = wairNH(i,j,mz)
c #NH     END DO
c #NH     END DO

        GO TO 330


C +--Potential Temperature
C +  ---------------------

 334    CONTINUE

          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k) = pktaDY(i,j,k)
          END DO
          END DO
          END DO

          DO j=1,my
          DO i=1,mx
            vartop(i,j)   = pktaDY(i,j,1)
c #Di       vartop(i,j)   = pkttDI(i,j)
            varbot(i,j)   = pktaDY(i,j,mz)
          END DO
          END DO

        GO TO 330


C +--Specific Humidity
C +  -----------------

 335    CONTINUE

          DO k=1,mz
          DO j=1,my
          DO i=1,mx
            WKxyz1(i,j,k) =   qvDY(i,j,k)
          END DO
          END DO
          END DO

          DO j=1,my
          DO i=1,mx
            vartop(i,j)   =   qvDY(i,j,1)
c #Di       vartop(i,j)   = qvtoDI(i,j)
            varbot(i,j)   =   qvDY(i,j,mz)
          END DO
          END DO

        GO TO 330


C +--Cloud Droplets Concentration
C +  ----------------------------

 336    CONTINUE

c #HY   IF (micphy)                                               THEN

c #HY     DO k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       WKxyz1(i,j,k) = qwHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY     END DO

c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       vartop(i,j)   = qwHY(i,j,1)
c #HY       varbot(i,j)   = qwHY(i,j,mz)
c #HY     END DO
c #HY     END DO

c #HY   END IF

        GO TO 330


C +--Ice Crystals Concentration
C +  --------------------------

 337    CONTINUE

c #HY   IF (micphy)                                               THEN

c #HY     DO k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       WKxyz1(i,j,k) = qiHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY     END DO

c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       vartop(i,j)   = qiHY(i,j,1)
c #HY       varbot(i,j)   = qiHY(i,j,mz)
c #HY     END DO
c #HY     END DO

c #HY   END IF

        GO TO 330


C +--Rain Drops Concentration
C +  ------------------------

 338    CONTINUE

c #HY   IF (micphy)                                               THEN

c #HY     DO k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       WKxyz1(i,j,k) = qrHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY     END DO

c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       vartop(i,j)   = qrHY(i,j,1)
c #HY       varbot(i,j)   = qrHY(i,j,mz)
c #HY     END DO
c #HY     END DO

c #HY   END IF

        GO TO 330


C +--Snow Flakes Concentration
C +  -------------------------

 339    CONTINUE

c #HY   IF (micphy)                                               THEN

c #HY     DO k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       WKxyz1(i,j,k) = qsHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY     END DO

c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       vartop(i,j)   = qsHY(i,j,1)
c #HY       varbot(i,j)   = qsrfHY(i,j)
c #HY     END DO
c #HY     END DO

c #HY   END IF

        GO TO 330


C +--Ice Crystals Number  
C +  -------------------

 340    CONTINUE

c #HY   IF (micphy)                                               THEN

c #HY     DO k=1,mz
c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       WKxyz1(i,j,k) = ccniHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY     END DO

c #HY     DO j=1,my
c #HY     DO i=1,mx
c #HY       vartop(i,j)   = ccniHY(i,j,1)
c #HY       varbot(i,j)   = ccniHY(i,j,mz)
c #HY     END DO
c #HY     END DO

c #HY   END IF

        GO TO 330


C +--Tracers
C +  -------

 341    CONTINUE

c #TC   itrac = ivar - 10

c #TC     DO k=1,mz
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC       WKxyz1(i,j,k) = qxTC(i,j,k,itrac)
c #TC     END DO
c #TC     END DO
c #TC     END DO

c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC       vartop(i,j)   = qxTC(i,j,1,itrac)
c #TC       varbot(i,j)   = qsTC(i,j,  itrac)
c #TC     END DO
c #TC     END DO

        GO TO 330

 330    CONTINUE


C +--Boundary Conditions
C +  ===================

          DO k=1,mz
          DO j=1,my
            WKxyz1( 1,j,k) = WKxyz1(ip11,j,k)
            WKxyz1(mx,j,k) = WKxyz1(mx1,j,k)
          END DO
          END DO

          DO j=1,my
            varbot( 1,j)   = varbot(ip11,j)
            varbot(mx,j)   = varbot(mx1,j)
          END DO

        IF (mmy.gt.1)                                             THEN
          DO k=1,mz
          DO i=1,mx
            WKxyz1(i, 1,k) = WKxyz1(i,jp11,k)
            WKxyz1(i,my,k) = WKxyz1(i,my1,k)
          END DO
          END DO

          DO i=1,mx
            varbot(i, 1)   = varbot(i,jp11)
            varbot(i,my)   = varbot(i,my1)
          END DO

        END IF


C +--Lateral Diffusion of the Horizontal Wind Speed Components
C + (proportional to the deformation, WITHOUT the hybrid terms)
C +  =========================================================

c #DF   IF (ivar.le.2)                                            THEN


C +--Diffusion in the x Direction on Sigma Surfaces
C +  ----------------------------------------------

c #DF     DO k=1,mz

c #DF       DO j=1,my
c #DF       DO i=ip11,mx1
c #DF         WKxyz5(i,j,k) = facxx *WKxy3(i,j)*
c #DF.       (WKxy1(i     ,j) *TUkhx(i     ,j,k) 
c #DF.                      *(WKxyz1(ip1(i),j,k)-WKxyz1(i,j,k))
c #DF.       -WKxy1(im1(i),j) *TUkhx(im1(i),j,k) 
c #DF.                      *(WKxyz1(i,j,k)-WKxyz1(im1(i),j,k)))
C +...        Contribution Axx

c #DF       END DO
c #DF       END DO


C +--Diffusion in the x,y Directions on Sigma Surfaces
C +  -------------------------------------------------

c #DF       IF (mmy.gt.2)                                         THEN

c #DF         GO TO (3511,3512) ivar
 3511         CONTINUE

c #DF           DO j=jp11,my1
c #DF           DO i=ip11,mx1
c #DF             WKxyz5(i,j,k) =       WKxyz5(i,j,k) 
c #DF.                          + facxy *WKxy3(i,j)* 0.25*
c #DF.            (pstDY(i     ,jp1(j)) *   akhm(i  ,jp1(j),k)
c #DF.          *(WKxyz2(ip1(i),jp1(j),k)-WKxyz2(im1(i),jp1(j),k))
c #DF.            -pstDY(i     ,jm1(j)) *   akhm(i  ,jm1(j),k)
c #DF.          *(WKxyz2(ip1(i),jm1(j),k)-WKxyz2(im1(i),jm1(j),k)))
C +...          Contribution Axy

c #DF           END DO
c #DF           END DO
c #DF         GO TO  3515

 3512         CONTINUE

c #DF           DO j=jp11,my1
c #DF           DO i=ip11,mx1
c #DF             WKxyz5(i,j,k) =       WKxyz5(i,j,k) 
c #DF.                          + facxy *WKxy3(i,j)* 0.25*
c #DF.            (pstDY(ip1(i),j  )    *   akhm(ip1(i),j  ,k)
c #DF.          *(WKxyz2(ip1(i),jp1(j),k)-WKxyz2(ip1(i),jm1(j),k))
c #DF.            -pstDY(im1(i),j  )    *   akhm(im1(i),j  ,k)
c #DF.          *(WKxyz2(im1(i),jp1(j),k)-WKxyz2(im1(i),jm1(j),k)))
C +...          Contribution Axy

c #DF           END DO
c #DF           END DO
c #DF         GO TO  3515

 3515         CONTINUE


C +--Diffusion in the y Direction on Sigma Surfaces
C +  ----------------------------------------------

c #DF           DO j=jp11,my1
c #DF           DO i=ip11,mx1
c #DF             WKxyz5(i,j,k) =       WKxyz5(i,j,k) 
c #DF.                          + facyy *WKxy3(i,j)* 
c #DF.            (WKxy2(i,j     ) *  TUkhy(i,j     ,k) 
c #DF.          *(WKxyz1(i,jp1(j),k)-WKxyz1(i,j,k))
c #DF.            -WKxy2(i,jm1(j)) *  TUkhy(i,jm1(j),k) 
c #DF.          *(WKxyz1(i,j     ,k)-WKxyz1(i,jm1(j),k)))
C +...          Contribution Ayy

c #DF           END DO
c #DF           END DO
c #DF       END IF
c #DF     END DO


C +--Lateral Diffusion of the Horizontal Wind Speed Components
C + (proportional to the deformation, WITH    the hybrid terms)
C +  =========================================================


C +--Diffusion in the x and Sigma Directions (except Model Top and Bottom)
C +  ---------------------------------------------------------------------

c #DC     DO k=kp1(1),mmz1

c #DC       DO j=1,my
c #DC       DO i=ip11,mx1
c #DC         WKxyz5(i,j,k) = 
c #DC.        WKxyz5(i,j,k) + facxx*WKxyz3(i,j,k)*
c #DC.                             (  rikx(ip1(i),j,k)  
c #DC.      *(WKxyz1(ip1(i),j,k+1) -WKxyz1(ip1(i),j,k-1))
c #DC.                             -  rikx(im1(i),j,k)  
c #DC.      *(WKxyz1(im1(i),j,k+1) -WKxyz1(im1(i),j,k-1))
C +...        Contribution Bxx

c #DC.                             +  rikx(i,j,k+1)  
c #DC.      *(WKxyz1(ip1(i),j,k+1) -WKxyz1(im1(i),j,k+1))
c #DC.                             -  rikx(i,j,k-1)  
c #DC.      *(WKxyz1(ip1(i),j,k-1) -WKxyz1(im1(i),j,k-1)))
C +...        Contribution Cxx

c #DC       END DO
c #DC       END DO

c #DC       IF (mmy.ge.2)                                         THEN


C +--Diffusion in the x,y and Sigma Directions (except Model Top and Bottom)
C +  -----------------------------------------------------------------------

c #DC         GO TO (3611,3612) ivar
 3611         CONTINUE
c #DC           DO j=jp11,my1
c #DC           DO i=ip11,mx1
c #DC             WKxyz5(i,j,k) = 
c #DC.            WKxyz5(i,j,k) + facxy *WKxyz3(i,j,k)*
c #DC.                                  (  rikx(i,jp1(j),k)  
c #DC.          *(WKxyz2(i,jp1(j),k+1)  -WKxyz2(i,jp1(j),k-1))
c #DC.                                  -  rikx(i,jm1(j),k)  
c #DC.          *(WKxyz2(i,jm1(j),k+1)  -WKxyz2(i,jm1(j),k-1))
C +...            Contribution Bxy

c #DC.                                  +  riky(i,j,k+1)  
c #DC.          *(WKxyz2(ip1(i),j,k+1)  -WKxyz2(im1(i),j,k+1))
c #DC.                                  -  riky(i,j,k-1)  
c #DC.          *(WKxyz2(ip1(i),j,k-1)  -WKxyz2(im1(i),j,k-1)))
C +...            Contribution Cxy

c #DC           END DO
c #DC           END DO
c #DC         GO TO 3615

 3612         CONTINUE
c #DC           DO j=jp11,my1
c #DC           DO i=ip11,mx1
c #DC             WKxyz5(i,j,k) = 
c #DC.            WKxyz5(i,j,k) + facxy *WKxyz3(i,j,k)*
c #DC.                                  (  riky(ip1(i),j,k)  
c #DC.          *(WKxyz2(ip1(i),j,k+1)  -WKxyz2(ip1(i),j,k-1))
c #DC.                                    -riky(im1(i),j,k)  
c #DC.          *(WKxyz2(im1(i),j,k+1)  -WKxyz2(im1(i),j,k-1))
C +...            Contribution Bxy

c #DC.                                  +rikx(i,j,k+1)  
c #DC.          *(WKxyz2(i,jp1(j),k+1)-WKxyz2(i,jm1(j),k+1))
c #DC.                                  -rikx(i,j,k-1)  
c #DC.          *(WKxyz2(i,jp1(j),k-1)-WKxyz2(i,jm1(j),k-1)))
C +...            Contribution Cxy

c #DC           END DO
c #DC           END DO
c #DC         GO TO 3615

 3615         CONTINUE

c #DC         DO j=jp11,my1
c #DC         DO i=ip11,mx1
c #DC             WKxyz5(i,j,k) =     
c #DC.            WKxyz5(i,j,k) +facyy  *WKxyz3(i,j,k)*
c #DC.                                  (  riky(i,jp1(j),k)
c #DC.          *(WKxyz1(i,jp1(j),k+1)  -WKxyz1(i,jp1(j),k-1))
c #DC.                                  -  riky(i,jm1(j),k)
c #DC.          *(WKxyz1(i,jm1(j),k+1)  -WKxyz1(i,jm1(j),k-1))
C +...            Contribution Byy

c #DC.                                  +  riky(i,j,k+1)   
c #DC.          *(WKxyz1(i,jp1(j),k+1)  -WKxyz1(i,jm1(j),k+1))
c #DC.                                  -  riky(i,j,k-1)   
c #DC.          *(WKxyz1(i,jp1(j),k-1)  -WKxyz1(i,jm1(j),k-1)))
C +...            Contribution Cyy

c #DC.                                  +( rhox(i,j,k  )   
c #DC.          *(WKxyz2(i,j,k+1)       -WKxyz2(i,j,k))
c #DC.                                  -  rhox(i,j,k-1)   
c #DC.          *(WKxyz2(i,j,k)         -WKxyz2(i,j,k-1)))/dsigm1(k-1)
C +...            Contribution Dxy

c #DC         END DO
c #DC         END DO
c #DC       END IF
c #DC     END DO


C +--Diffusion in the x and Sigma Directions (Model Top)
C +  ---------------------------------------------------

c #DC         k=1

c #DC         DO j=1,my
c #DC         DO i=ip11,mx1
c #DC           WKxyz5(i,j,k) =   
c #DC.          WKxyz5(i,j,k) + facxx *WKxyz3(i,j,k)*
c #DC.                                  (rikx(ip1(i),j,k)  
c #DC.        *(WKxyz1(ip1(i),j,k+1)  -WKxyz1(ip1(i),j,k  ))
c #DC.                                  -rikx(im1(i),j,k)  
c #DC.        *(WKxyz1(im1(i),j,k+1)  -WKxyz1(im1(i),j,k  ))
C +...          Contribution Bxx

c #DC.                                  +rikx(i,j,k+1)  
c #DC.          *(WKxyz1(ip1(i),j,k+1)-WKxyz1(im1(i),j,k+1)))
C +...          Contribution Cxx

c #DC         END DO
c #DC         END DO

c #DC       IF (mmy.ge.2)                                         THEN


C +--Diffusion in the x,y and Sigma Directions (Model Top)
C +  -----------------------------------------------------

c #DC         GO TO (3711,3712) ivar
 3711         CONTINUE

c #DC           DO  j=jp11,my1
c #DC           DO  i=ip11,mx1
c #DC             WKxyz5(i,j,k) =   
c #DC.            WKxyz5(i,j,k) + facxy *WKxyz3(i,j,k)*
c #DC.                                    (rikx(i,jp1(j),k)  
c #DC.          *(WKxyz2(i,jp1(j),k+1)  -WKxyz2(i,jp1(j),k  ))
c #DC.                                    -rikx(i,jm1(j),k)  
c #DC.          *(WKxyz2(i,jm1(j),k+1)  -WKxyz2(i,jm1(j),k  ))
C +...            Contribution Bxy

c #DC.                                    +riky(i,j,k+1)  
c #DC.          *(WKxyz2(ip1(i),j,k+1)  -WKxyz2(im1(i),j,k+1)))
C +...            Contribution Cxy

c #DC           END DO
c #DC           END DO
c #DC         GO TO 3715

 3712         CONTINUE
c #DC           DO  j=jp11,my1
c #DC           DO  i=ip11,mx1
c #DC             WKxyz5(i,j,k) =   
c #DC.            WKxyz5(i,j,k) + facxy *WKxyz3(i,j,k)*
c #DC.                                    (riky(ip1(i),j,k)  
c #DC.          *(WKxyz2(ip1(i),j,k+1)  -WKxyz2(ip1(i),j,k  ))
c #DC.                                    -riky(im1(i),j,k)  
c #DC.          *(WKxyz2(im1(i),j,k+1)  -WKxyz2(im1(i),j,k  ))
C +...            Contribution Bxy

c #DC.                                   +rikx(i,j,k+1)  
c #DC.          *(WKxyz2(i,jp1(j),k+1) -WKxyz2(i,jm1(j),k+1)))
C +...            Contribution Cxy

c #DC           END DO
c #DC           END DO

 3715         CONTINUE

c #DC           DO  j=jp11,my1
c #DC           DO  i=ip11,mx1
c #DC             WKxyz5(i,j,k) =   
c #DC.            WKxyz5(i,j,k) + facyy *WKxyz3(i,j,k)*
c #DC.                                    (riky(i,jp1(j),k)  
c #DC.          *(WKxyz1(i,jp1(j),k+1)  -WKxyz1(i,jp1(j),k  ))
c #DC.                                    -riky(i,jm1(j),k)  
c #DC.          *(WKxyz1(i,jm1(j),k+1)  -WKxyz1(i,jm1(j),k  ))
C +...            Contribution Byy

c #DC.                                    +riky(i,j,k+1)  
c #DC.          *(WKxyz1(i,jp1(j),k+1)  -WKxyz1(i,jm1(j),k+1)))
C +...            Contribution Cyy

c #DC.             +rhox(i,j,k  )  
c #DC.          *(WKxyz2(i,j  ,k+1)     -WKxyz2(i,j  ,k  )) /sigmid(k+1)
C +...            Contribution Dxy

c #DC           END DO
c #DC           END DO

c #DC       END IF


C +--Diffusion in the x and Sigma Directions (Model Bottom)
C +  ------------------------------------------------------

c #DC         k=mz

c #DC         DO j=1,my
c #DC         DO i=ip11,mx1
c #DC           WKxyz5(i,j,k) =   
c #DC.          WKxyz5(i,j,k) + facxx *WKxyz3(i,j,k)*
c #DC.                                  (rikx(ip1(i),j,k)  
c #DC.          *(varbot(ip1(i),j)    -WKxyz1(ip1(i),j,k-1))
c #DC.                                  -rikx(im1(i),j,k)  
c #DC.          *(varbot(im1(i),j)    -WKxyz1(im1(i),j,k-1))
C +...          Contribution Bxx

c #DC.                                  -rikx(i,j,k-1)  
c #DC.          *(WKxyz1(ip1(i),j,k-1)-WKxyz1(im1(i),j,k-1)))
C +...          Contribution Cxx

c #DC         END DO
c #DC         END DO

c #DC       IF (mmy.ge.2)                                         THEN


C +--Diffusion in the x,y and Sigma Directions (Model Bottom)
C +  --------------------------------------------------------

c #DC         GO TO (3811,3812) ivar
 3811         CONTINUE

c #DC           DO  j=jp11,my1
c #DC           DO  i=ip11,mx1
c #DC             WKxyz5(i,j,k) =   
c #DC.            WKxyz5(i,j,k) + facxy *WKxyz3(i,j,k)*
c #DC.                                    (rikx(i,jp1(j),k)  
c #DC.          *(varbou(i,jp1(j))      -WKxyz2(i,jp1(j),k-1))
c #DC.                                    -rikx(i,jm1(j),k)  
c #DC.          *(varbou(i,jm1(j))      -WKxyz2(i,jm1(j),k-1))
C +...            Contribution Bxy

c #DC.                                    -riky(i,j,k-1)  
c #DC.          *(WKxyz2(ip1(i),j,k-1)  -WKxyz2(im1(i),j,k-1)))
C +...            Contribution Cxy

c #DC           END DO
c #DC           END DO
c #DC         GO TO 3815

 3812         CONTINUE
c #DC           DO  j=jp11,my1
c #DC           DO  i=ip11,mx1
c #DC             WKxyz5(i,j,k) =   
c #DC.            WKxyz5(i,j,k) + facxy *WKxyz3(i,j,k)*
c #DC.                                    (riky(ip1(i),j,k)  
c #DC.          *(varbou(ip1(i),j)      -WKxyz2(ip1(i),j,k-1))
c #DC.                                    -riky(im1(i),j,k)  
c #DC.          *(varbou(im1(i),j)      -WKxyz2(im1(i),j,k-1))
C +...            Contribution Bxy

c #DC.                                    -rikx(i,j,k-1)  
c #DC.          *(WKxyz2(ip1(i),j,k-1)  -WKxyz2(im1(i),j,k-1)))
C +...            Contribution Cxy

c #DC           END DO
c #DC           END DO

c #DC         GO TO 3815

 3815         CONTINUE

c #DC           DO j=jp11,my1
c #DC           DO i=ip11,mx1
c #DC             WKxyz5(i,j,k) =   
c #DC.            WKxyz5(i,j,k) + facyy *WKxyz3(i,j,k)*
c #DC.                                    (rikx(i,jp1(j),k)  
c #DC.          *(varbot(i,jp1(j))      -WKxyz1(i,jp1(j),k-1))
c #DC.                                    -rikx(i,jm1(j),k)  
c #DC.          *(varbot(i,jm1(j))      -WKxyz1(i,jm1(j),k-1))
C +...            Contribution Byy

c #DC.                                    -riky(i,j,k-1)  
c #DC.          *(WKxyz1(i,jp1(j),k-1)  -WKxyz1(i,jm1(j),k-1)))
C +...            Contribution Cyy

c #DC.                                    -rhox(i,j,k-1)  
c #DC.          *(WKxyz2(i,j     ,k  )  -WKxyz2(i,j  ,k-1)) /dsigm1(k-1)
C +...            Contribution Dxy

c #DC           END DO
c #DC           END DO

c #DC       END IF

c #DF   ELSE


C +--Lateral Diffusion of non Vectorial Model Variables (c #DF ON)
C +  Lateral Diffusion of all           Model Variables (c #DF OFF)
C +     (proportional to the gradient, terms in sigma surfaces)
C +  ==============================================================


C +--Diffusion in the x Direction on Sigma Surfaces
C +  ----------------------------------------------

            DO k=1,mz
            DO i=ip11,mx1
            DO j=1,my
              WKxyz5(i,j,k) = WKxy3(i,j)*
     .        (WKxy1(i     ,j) *  TUkhx(i     ,j,k) 
     .                         *(WKxyz1(ip1(i),j,k)-WKxyz1(    i ,j,k))
     .        -WKxy1(im1(i),j) *  TUkhx(im1(i),j,k) 
     .                         *(WKxyz1(i,j,k)     -WKxyz1(im1(i),j,k)))
            END DO
            END DO
            END DO


C +--Diffusion in the y Direction on Sigma Surfaces
C +  ----------------------------------------------

          IF (mmy.gt.2)                                             THEN

            DO k=1,mz
            DO j=jp11,my1
            DO i=1,mx
              WKxyz5(i,j,k) = WKxyz5(i,j,k) + WKxy3(i,j)*
     .        (WKxy2(i,j)      *  TUkhy(i,j     ,k) 
     .                         *(WKxyz1(i,jp1(j),k)-WKxyz1(i,    j ,k))
     .        -WKxy2(i,jm1(j)) *  TUkhy(i,jm1(j),k) 
     .                         *(WKxyz1(i,j,k)     -WKxyz1(i,jm1(j),k)))
            END DO
            END DO
            END DO

          END IF


C +--Lateral Diffusion of non Vectorial Model Variables (c #DF ON)
C +  Lateral Diffusion of all           Model Variables (c #DF OFF)
C +     (proportional to the gradient,            hybrid terms)
C +  ==============================================================


C +--Diffusion in the x and Sigma Directions (except Model Top and Bottom) 
C +  ---------------------------------------------------------------------

c #CR       DO  k=kp1(1),mmz1

c #CR         DO j=1,my
c #CR         DO i=ip11,mx1
c #CR           WKxy4(i,j) = WKxyz3(i,j,k)*(
c #CR.                         rikx(ip1(i),j,k)  
c #CR.                     *(WKxyz1(ip1(i),j,k+1)-WKxyz1(ip1(i),j,k-1))
c #CR.                        -rikx(im1(i),j,k)  
c #CR.                     *(WKxyz1(im1(i),j,k+1)-WKxyz1(im1(i),j,k-1))
c #CR.          +rikx(i   ,j,k+1)  
c #CR.                     *(WKxyz1(ip1(i),j,k+1)-WKxyz1(im1(i),j,k+1))
c #CR.          -rikx(i   ,j,k-1)  
c #CR.                     *(WKxyz1(ip1(i),j,k-1)-WKxyz1(im1(i),j,k-1))
c #CR.                              )
c #CR         END DO
c #CR         END DO

c #CR         IF (mmy.eq.1)                                       THEN

c #CR           DO i=ip11,mx1
c #CR             WKxyz5(i,j,k) = WKxyz5(i,j,k) 
c #CR.                    + 0.25*(WKxy4(ip1(i),1) +2.0*WKxy4(i,1) 
c #CR.                           +WKxy4(im1(i),1))
c #CR           END DO


C +--Diffusion in the y and Sigma Directions (except Model Top and Bottom) 
C +  ---------------------------------------------------------------------

c #CR         ELSE

c #CR           DO j=jp11,my1
c #CR           DO i=1,mx
c #CR             WKxy4(i,j) = WKxy4(i,j) 
c #CR.                      + WKxyz3(i,j,k)*(
c #CR.                          riky(i,jp1(j),k)  
c #CR.                      *(WKxyz1(i,jp1(j),k+1)-WKxyz1(i,jp1(j),k-1))
c #CR.                         -riky(i,jm1(j),k)  
c #CR.                      *(WKxyz1(i,jm1(j),k+1)-WKxyz1(i,jm1(j),k-1))
c #CR.                         +riky(i,j,   k+1)  
c #CR.                      *(WKxyz1(i,jp1(j),k+1)-WKxyz1(i,jm1(j),k+1))
c #CR.                         -riky(i,j,   k-1)  
c #CR.                      *(WKxyz1(i,jp1(j),k-1)-WKxyz1(i,jm1(j),k-1))
c #CR.                                           )
c #CR           END DO
c #CR           END DO

c #CR           DO j=jp11,my1
c #CR           DO i=ip11,mx1
c #CR             WKxyz5(i,j,k) = WKxyz5(i,j,k)  + 0.0625*
c #CR.           (WKxy4(im1(i),jp1(j))+2.0*WKxy4(i,jp1(j))
c #CR.       +    WKxy4(ip1(i),jp1(j)) +
c #CR.        2.0*WKxy4(im1(i),j)     +4.0*WKxy4(i,j)     
c #CR.       +2.0*WKxy4(ip1(i),j) +
c #CR.            WKxy4(im1(i),jm1(j))+2.0*WKxy4(i,jm1(j))
c #CR.       +    WKxy4(ip1(i),jm1(j))  )
c #CR           END DO
c #CR           END DO

c #CR         END IF

c #CR       END DO


C +--Diffusion in the x and Sigma Directions (Model Top)  
C +  ---------------------------------------------------

c #CR       k=1

c #CR       DO j=1,my
c #CR       DO i=ip11,mx1
c #CR         WKxy4(i,j) = WKxyz3(i,j,k)*(
c #CR.                       rikx(ip1(i),j,k)  
c #CR.                   *(WKxyz1(ip1(i),j,k+1)-WKxyz1(ip1(i),j,k  ))
c #CR.                      -rikx(im1(i),j,k)  
c #CR.                   *(WKxyz1(im1(i),j,k+1)-WKxyz1(im1(i),j,k  ))
c #CR.                      +rikx(i,j,   k+1)  
c #CR.                   *(WKxyz1(ip1(i),j,k+1)-WKxyz1(im1(i),j,k+1)))
c #CR       END DO
c #CR       END DO

c #CR       IF (mmy.eq.1)                                         THEN

c #CR         DO i=ip11,mx1
c #CR           WKxyz5(i,j,k) = WKxyz5(i,j,k) 
c #CR.                  + 0.25*(WKxy4(ip1(i),1) +2.0*WKxy4(i,1) 
c #CR.                         +WKxy4(im1(i),1))
c #CR         END DO


C +--Diffusion in the y and Sigma Directions (Model Top) 
C +  ---------------------------------------------------

c #CR       ELSE

c #CR         DO j=jp11,my1
c #CR         DO i=1,mx
c #CR           WKxy4(i,j) = WKxy4(i,j) 
c #CR.                    + WKxyz3(i,j,k)*(
c #CR.                        riky(i,jp1(j),k)  
c #CR.                    *(WKxyz1(i,jp1(j),k+1)-WKxyz1(i,jp1(j),k  ))
c #CR.                       -riky(i,jm1(j),k)  
c #CR.                    *(WKxyz1(i,jm1(j),k+1)-WKxyz1(i,jm1(j),k  ))
c #CR.                       +riky(i,j,k+1)     
c #CR.                    *(WKxyz1(i,jp1(j),k+1)-WKxyz1(i,jm1(j),k+1)))
c #CR         END DO 
c #CR         END DO 

c #CR         DO j=jp11,my1
c #CR         DO i=ip11,mx1
c #CR           WKxyz5(i,j,k) = WKxyz5(i,j,k)  + 0.0625*
c #CR.          (WKxy4(im1(i),jp1(j))+2.0*WKxy4(i,jp1(j)) 
c #CR.     +     WKxy4(ip1(i),jp1(j)) +
c #CR.       2.0*WKxy4(im1(i),j)     +4.0*WKxy4(i,j)      
c #CR.     + 2.0*WKxy4(ip1(i),j) +
c #CR.           WKxy4(im1(i),jm1(j))+2.0*WKxy4(i,jm1(j)) 
c #CR.     +     WKxy4(ip1(i),jm1(j))  )
c #CR         END DO
c #CR         END DO

c #CR       END IF


C +--Diffusion in the x and Sigma Directions (Model Bottom) 
C +  ------------------------------------------------------

c #CR       k=mz

c #CR       DO j=1,my
c #CR       DO i=ip11,mx1
c #CR         WKxy4(i,j) = WKxyz3(i,j,k)*(
c #CR.                       rikx(ip1(i),j,k)  
c #CR.                   *(varbot(ip1(i),j)    -WKxyz1(ip1(i),j,k-1))
c #CR.                      -rikx(im1(i),j,k)  
c #CR.                   *(varbot(im1(i),j)    -WKxyz1(im1(i),j,k-1))
c #CR.                      -rikx(i,j,   k-1)  
c #CR.                   *(WKxyz1(ip1(i),j,k-1)-WKxyz1(im1(i),j,k-1)))
c #CR       END DO
c #CR       END DO

c #CR       IF (mmy.eq.1)                                         THEN

c #CR         DO i=ip11,mx1
c #CR           WKxyz5(i,j,k) = WKxyz5(i,j,k) 
c #CR.                  + 0.25*(WKxy4(ip1(i),1) +2.0*WKxy4(i,1) 
c #CR.                         +WKxy4(im1(i),1))
c #CR         END DO


C +--Diffusion in the y and Sigma Directions (Model Bottom) 
C +  ------------------------------------------------------

c #CR       ELSE

c #CR         DO j=jp11,my1
c #CR         DO i=1,mx
c #CR           WKxyz5(i,j,k) = WKxyz5(i,j,k) 
c #CR.                        + WKxyz3(i,j,k)*(
c #CR.                         riky(i,jp1(j),k)  
c #CR.                     *(varbot(i,jp1(j))    -WKxyz1(i,jp1(j),k-1))
c #CR.                        -riky(i,jm1(j),k)  
c #CR.                     *(varbot(i,jm1(j))    -WKxyz1(i,jm1(j),k-1))
c #CR.                        -riky(i,j,k-1)  
c #CR.                     *(WKxyz1(i,jp1(j),k-1)-WKxyz1(i,jm1(j),k-1))
c #CR.                                                 )
c #CR         END DO
c #CR         END DO
C +
c #CR         DO j=jp11,my1
c #CR         DO i=ip11,mx1
c #CR           WKxyz5(i,j,k) = WKxyz5(i,j,k)  + 0.0625*
c #CR.          (WKxy4(im1(i),jp1(j))+2.0*WKxy4(i,jp1(j))
c #CR.      +    WKxy4(ip1(i),jp1(j)) +
c #CR.       2.0*WKxy4(im1(i),j)     +4.0*WKxy4(i,j)     
c #CR.      +2.0*WKxy4(ip1(i),j) +
c #CR.           WKxy4(im1(i),jm1(j))+2.0*WKxy4(i,jm1(j))
c #CR.      +    WKxy4(ip1(i),jm1(j))  )
c #CR         END DO
c #CR         END DO
c #CR       END IF

c #DF   END IF


C +--Update of the Global Variables
C +  ==============================


c #TC   IF    (ivar.gt.10)                                   GO TO 411

        GO TO (401,402,403,404,405,406,407,408,409,410) ivar


C +--u Wind Speed Component
C +  ----------------------

 401    CONTINUE
          DO k=1,mz
          DO j=jp11,my1
          DO i=ip11,mx1
            uairDY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
          END DO
          END DO
          END DO
        GO TO 400


C +--v Wind Speed Component
C +  ----------------------

 402    CONTINUE
          DO k=1,mz
          DO j=jp11,my1
          DO i=ip11,mx1
            vairDY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
          END DO
          END DO
          END DO
        GO TO 400


C +--w Wind Speed Component (Non Hydrostatic Option)
C +  -----------------------------------------------

 403    CONTINUE
c #NH     DO k=1,mz
c #NH     DO j=jp11,my1
c #NH     DO i=ip11,mx1
c #NH       wairNH(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #NH     END DO
c #NH     END DO
c #NH     END DO
        GO TO 400


C +--Potential Temperature
C +  ---------------------

 404    CONTINUE
          DO k=1,mz
          DO j=jp11,my1
          DO i=ip11,mx1
            pktaDY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #KT.                                    * 0.50
! #KT.                                    * max(0,min(1,mzabso-k))
          END DO
          END DO
          END DO
        GO TO 400


C +-- Specific Humidity
C +   -----------------

 405    CONTINUE
          DO k=1,mz
          DO j=jp11,my1
          DO i=ip11,mx1
              qvDY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
! #kk.                                    * 0.50
          END DO
          END DO
          END DO
        GO TO 400


C +--Cloud Droplets Concentration
C +  ----------------------------

 406    CONTINUE
c #HY     IF (micphy)                                             THEN
c #HY       DO k=1,mz
c #HY       DO j=jp11,my1
c #HY       DO i=ip11,mx1
c #HY         qwHY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #HY       END DO
c #HY       END DO
c #HY       END DO
c #HY     END IF
        GO TO 400


C +--Ice Crystals Concentration
C +  --------------------------

 407    CONTINUE
c #HY     IF (micphy)                                             THEN
c #HY       DO k=1,mz
c #HY       DO j=jp11,my1
c #HY       DO i=ip11,mx1
c #HY         qiHY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #HY       END DO
c #HY       END DO
c #HY       END DO
c #HY     END IF
        GO TO 400


C +--Rain Drops Concentration
C +  ------------------------

 408    CONTINUE
c #HY     IF (micphy)                                             THEN
c #HY       DO k=1,mz
c #HY       DO j=jp11,my1
c #HY       DO i=ip11,mx1
c #HY         qrHY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #HY       END DO
c #HY       END DO
c #HY       END DO
c #HY     END IF
        GO TO 400


C +--Snow Flakes Concentration
C +  -------------------------

 409    CONTINUE
c #HY     IF (micphy)                                             THEN
c #HY       DO k=1,mz
c #HY       DO j=jp11,my1
c #HY       DO i=ip11,mx1
c #HY         qsHY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #HY       END DO
c #HY       END DO
c #HY       END DO
c #HY     END IF
        GO TO 400


C +--Ice Crystals Number
C +  -------------------

 410    CONTINUE
c #HY     IF (micphy)                                             THEN
c #HY       DO k=1,mz
c #HY       DO j=jp11,my1
c #HY       DO i=ip11,mx1
c #HY         ccniHY(i,j,k) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #HY       END DO
c #HY       END DO
c #HY       END DO
c #HY     END IF
        GO TO 400


C +--Tracers
C +  -------

 411    CONTINUE

c #TC     itrac = ivar - 10

c #TC     DO k=1,mz
c #TC     DO j=jp11,my1
c #TC     DO i=ip11,mx1
c #TC       qxTC(i,j,k,itrac) = WKxyz1(i,j,k) + WKxyz5(i,j,k) *dtHDif
c #TC     END DO
c #TC     END DO
c #TC     END DO

 400    CONTINUE

      END DO
      END DO


C +--Slope Effect on the Vertical Diffusion Coefficient
C +  ==================================================

c _PE DO k=1,mmz1
c _PE DO j=1,my
c _PE DO i=1,mx
c #PE DO k=1,mmz1
c #PE DO j=1,my
c #PE DO i=1,mx
c _HH   alph2 = 0.50 *(slopex(i,j,k+1) + slopex(i,j,k))
c _HH   beta2 = 0.50 *(slopey(i,j,k+1) + slopey(i,j,k))
c _HH   akhm2 = 0.50 *(  akhm(i,j,k+1) +   akhm(i,j,k))
c _HH   alph22= alph2 *alph2
c _HH   beta22= beta2 *beta2
c _HH   pente3(i,j,k) = akhm2 * (     alph22 +      beta22)

c #DF   alph2 = 0.50 *(slopex(i,j,k+1) + slopex(i,j,k))
c #DF   beta2 = 0.50 *(slopey(i,j,k+1) + slopey(i,j,k))
c #DF   akhm2 = 0.50 *(  akhm(i,j,k+1) +   akhm(i,j,k))
c #DF   alph22= alph2 *alph2
c #DF   beta22= beta2 *beta2
c #DF   pente1(i,j,k) = akhm2 * (     alph22 + 0.50*beta22)
c #DF   pente2(i,j,k) = akhm2 * (0.50*alph22 +      beta22)
c #DF   pente3(i,j,k) = akhm2 * (     alph22 +      beta22)
c _PE END DO
c _PE END DO
c _PE END DO
c #PE END DO
c #PE END DO
c #PE END DO


C +--Work Arrays Reset
C +  =================

      DO j=1,my
      DO i=1,mx
        WKxy1(i,j) = 0.00
        WKxy2(i,j) = 0.00
        WKxy3(i,j) = 0.00
        WKxy4(i,j) = 0.00
      END DO
      END DO

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.00
        WKxyz2(i,j,k) = 0.00
        WKxyz3(i,j,k) = 0.00
        WKxyz4(i,j,k) = 0.00
        WKxyz5(i,j,k) = 0.00
      END DO
      END DO
      END DO

      return
      end


       subroutine TURtke_gen(dt_dif)

C +------------------------------------------------------------------------+
C | MAR TURBULENCE (TKE)                               Mon 25-11-2010  MAR |
C |    SubRoutine TURtke_gen includes 1 1/2 Vertical Turbulence Closures   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | METHOD: 1. `Standard' Closure of Turbulence:                           |
C | ^^^^^^^     E - epsilon  , Duynkerke,           JAS 45, 865--880, 1988 |
C |  .OR.   2.  E - epsilon  , Huang and Raman,     BLM 55, 381--407, 1991 |
C |  .OR.   3.  TKE          , Therry et Lacarrere, BLM 25,  63-- 88, 1983 |
C |                                                                        |
C | INPUT  : itexpe: Nb of iterations                                      |
C | ^^^^^^^^ dt_dif: Local Time Step                                   (s) |
C |          explIO: Experiment Label                                  (s) |
C |                                                                        |
C | INPUT / OUTPUT: The Vertical Turbulent Fluxes are included for:        |
C | ^^^^^^^^^^^^^^                                                         |
C |   a) Turbulent Kinetic Energy             ect_TE(mx,my,mz)     (m2/s2) |
C |   b) Turbulent Kinetic Energy Dissipation eps_TE(mx,my,mz)     (m2/s3) |
C |                                                                        |
C | OUTPUT :  TUkvm(i,j,k): vertical diffusion coeff. for momentum  (m2/s) |
C | ^^^^^^^^  TUkvh(i,j,k): vertical diffusion coeff. for heat...   (m2/s) |
C |          zi__TE(i,j)  : inversion height                           (m) |
C |                                                                        |
C | OPTIONS: #De: Dirichlet Type Top Boundary Condit. for ect_TE & eps_TE  |
C | ^^^^^^^^ #WE: Output on MAR.TKE (unit 29)                              |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'

c #De include 'MAR_DI.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'

c #HY include 'MAR_HY.inc'

      include 'MAR_SL.inc'

      include 'MAR_WK.inc'
      include 'MAR_IO.inc'

      real     dt_dif


C +--Local  Variables
C +  ================

      logical                 log_KA
      integer                 locTKE,mz__KA
      common /TURtke_gen_loc/ locTKE,mz__KA

      integer i5    ,n5    ,kect  ,ke    
c #WE integer m30   ,m31

      real    aalme(mx,mz)
      real    aalmk(mx,mz)
      real    flott(mx,mz)

      real    epse  ,epsd  ,ectmin,turmx ,dkect
      real    sqrcmu,sqrcmu0
      real    cmu   ,c1ep  ,c2ep  ,rc1c2 ,betahr,voninv
      real    cmu0  ,c1ep0 ,c2ep0
      real    ectcrt,akz   ,alme  ,almk  ,pousse
c #HY real    hrel  ,base
      real    epslme,ectnew,produc,factur,zeta  ,stab_s,phimm
c #HR real    edtnum,edtden

      real    phim  ,dzlev
      real    sature,sgnLMO,absLMO,se
      real    alamb ,Ri_Sat,fRiMin
      real    fac_Ri,vuzvun,Kz_vun
      real    kz_max,kz_mix,kz2mix,KvhMax(mx,my,mz)


C +--DATA
C +  ====

      data epse  /0.00000100/
      data epsd  /0.00000001/

      data ectmin/0.00010000/
C +...     ectmin:Minimum SBL    turbulent kinetic   energy

      data cmu /0.090/
C +...Bintanja , 2000, BLM (95),milieu p. 355
c #PD data cmu0/0.033/
C +...Duynkerke, 1988, JAS (45),  haut p. 868 
c #KI data cmu0/0.090/
C +...Kitada   , 1987, BLM (41),  haut  p.220 

      data sqrcmu /3.333/
C +...Bintanja , 2000, BLM (95),milieu p. 355
c #PD data sqrcmu0/5.500/
C +...Duynkerke, 1988, JAS (45),  (19) p. 869 :(c_mu)^1/2=(0.033)^1/2=5.50 
c #KI data sqrcmu0/3.333/
C +...Kitada   , 1987, BLM (41),        p.220 :(c_mu)^1/2=(0.090)^1/2=3.333
c #Kl data sqrcmu0/4.000/
C +...Schayes and Thunis, 1990, Contrib. 60 Inst.Astr.Geoph. p.8

      data c1ep /1.46/
C +...Duynkerke, 1988, JAS (45),milieu p. 868 
C +...Bintanja , 2000, BLM (95),milieu p. 355
c #KI data c1ep0/1.44/
C +...Kitada   , 1987, BLM (41),  haut  p.220 

      data c2ep /1.92/
C +...Bintanja , 2000, BLM (95),milieu p. 355
c #PD data c2ep0/1.83/
C +...Duynkerke, 1988, JAS (45),milieu p. 868 
c #KI data c2ep0/1.92/
C +...Kitada   , 1987, BLM (41),  haut  p.220 

c #HR data betahr/2.00/
C +...Huang and Raman, 1991, BLM (55), p.386 and (A22) p.405

      data  alamb/0.1    /! 1 / 10 m
      data Ri_Sat/2.0    /! Mahalov&al., 2004, GRL
      data fRiMin/0.00925/! 1/(1+4.7*Ri_Sat)**2                    Louis  1979
c #82 data fRiMin/0.07970/! 1/(1+10 *Ri_Sat/(1+Ri_Sat))            Louis& 1982

c #PD cmu    = cmu0
c #KI cmu    = cmu0
c #PD sqrcmu = sqrcmu0
c #KI sqrcmu = sqrcmu0
c #Kl sqrcmu = sqrcmu0
c #KI c1ep   = c1ep0
c #PD c2ep   = c2ep0
c #KI c2ep   = c2ep0

      rc1c2  = c1ep / c2ep


C +--Parameters
C +  ==========

      voninv=1./vonkar

      n5    =         5
      n5    = min(mx,n5)


C +--Initialisation 
C +  ==============

c #KA  IF (.NOT. ini_KA_TE)                                         THEN
c #KA            ini_KA_TE = .true.
c #KA        mz__KA=mz1
 11      CONTINUE
c #KA    IF (zsigma(mz__KA).GT.  5..OR.mz__KA.LE.1)             GO TO 10
c #KA        mz__KA=mz__KA-1
c #KA                                                           GO TO 11
 10      CONTINUE
c #KA        write(6,1000)      mz  -  mz__KA
 1000        format(/,' TKE: Moving Average until mz -',i2,' Level',/)
c #KA  END IF


       IF (locTKE.eq.0.and.itexpe.le.1)                             THEN

c #Kl        log_KA = .false.
c #KA        log_KA = .true.
c #Kl    IF (log_KA)                                                THEN
c #Kl        write(6,6000)
 6000        format('!?%@&* Conflicting Use of #KA and  #Kl',
     .                ' ==> Emergency EXIT in TURtke_gen',6x,
     .                ' ### DO NOT PRE-PROCESS #KA with #Kl ###')
c #Kl        STOP 
c #Kl    END IF


C +--Minimum Vertical Turbulent Diffusion Coefficient (ARPS.4.0 Users Guide,
C +  ------------------------------------------------  fin para 6.3.4 p.143)

         DO k=1,mz1
           dzlev         =               zsigma(k)-zsigma(k+1)
           TUmin (    k) =                      akmol
c #ARPS    TUmin (    k) = min(0.15,     epsi * dzlev * dzlev )
         END DO
            k=  mz
           dzlev         =               zsigma(k)
           TUmin (    k) =                      akmol
c #ARPS    TUmin (    k) = min(0.15,     epsi * dzlev * dzlev )


C +--Initial E,e
C +  -----------

         DO k=1,mz
         DO j=1,my
         DO i=1,mx
           ect_TE(i,j,k) = epse
           eps_TE(i,j,k) = epsd
C +...     These initial values of TKE and epsilon correspond to K ~ Kmol

           TUkvm (i,j,k) = akmol
           TUkvh (i,j,k) = akmol
         END DO
         END DO
         END DO

         DO j=1,my
         DO i=1,mx
                 zi__TE(i,j) =  max(gpmiDY(i,j,mz)* grvinv-sh(i,j), 
     .                              zi__TE(i,j))
         END DO
         END DO


C +--Verification: TKE must be Positive Definite
C +  ===========================================

       ELSE
         DO k=1,mz
         DO j=1,my
         DO i=1,mx
           ect_TE(i,j,k)=max(epse,ect_TE(i,j,k))
           eps_TE(i,j,k)=max(epsd,eps_TE(i,j,k))
         END DO
         END DO
         END DO


C +--Inversion Height
C +  ================

         DO j=1,my
         DO i=1,mx
           WKxy1(i,j) = 0.05*max(max(ect_TE(i,j,mmz1),
     .                               ect_TE(i,j,mz  )),ectmin)
           WKxy2(i,j) = 1.
c #vK    ENDDO
c #vK    ENDDO

         DO k=1,mz
c #vK    DO j=1,my
c #vK    DO i=1,mx
           IF   (ect_TE(i,j,k) .lt. WKxy1(i,j))                     THEN
                  WKxy2(i,j) =  min(mz1,k)
           END IF
         ENDDO
c #vK    ENDDO
c #vK    ENDDO

c #vK    DO j=1,my
c #vK    DO i=1,mx
             k =  WKxy2(i,j)
             IF (ect_TE(i,j,k+1).lt.ectmin)                         THEN
                  WKxy1(i,j) =      gpmiDY(i,j,mz)* grvinv
     .                            -     sh(i,j)
             ELSE
                  dkect      =      ect_TE(i,j,k)  -ect_TE(i,j,k+1)
                  WKxy1(i,j) =  (   gpmiDY(i,j,k+2)
     .                            +(gpmiDY(i,j,k+1)-gpmiDY(i,j,k+2))
     .                            *(WKxy1(i,j)     -ect_TE(i,j,k+1))
     .             /(sign(unun ,    dkect                           )
     .               *max(eps9 ,abs(dkect                          )))
     .                            - gplvDY(i,j,mzz)
     .                          )                 * grvinv
             END IF
c #vK    ENDDO
c #vK    ENDDO

c #vK    DO j=1,my
c #vK    DO i=1,mx
                 zi__TE(i,j) =  min( WKxy1(i,j),
     .                              gpmiDY(i,j,1) * grvinv-sh(i,j))
c #vK    ENDDO
c #vK    ENDDO

c #vK    DO j=1,my
c #vK    DO i=1,mx
                 zi__TE(i,j) =  max(gpmiDY(i,j,mz)* grvinv-sh(i,j), 
     .                              zi__TE(i,j))
                  WKxy1(i,j) =  0.
                  WKxy2(i,j) =  0.

c #WR      IF   (zi__TE(i,j).gt.10000.)                           THEN
c #WR            kect = k
c #WR            kect = min(mz-3,kect)
c #WR            kect = max(   5,kect)
c #WR      write(6,6001) i,j,k,kect,(           ke ,ke=kect+3,kect-4,-1)
c #WR.           ,zi__TE(i,j),      (ect_TE(i,j,ke),ke=kect+3,kect-4,-1)
 6001      format('zi / TKE',2(i6,i4),8i10,/,d10.3,18x,8d10.3)
c #WR      END IF

         END DO
         END DO
       END IF


C +--TKE Production/Destruction by the Vertical Wind Shear
C +  =====================================================

       DO k=kp1(1),mmz1
       DO j=1,my
       DO i=1,mx
         WKxyz3(i,j,k)= uairDY(i,j,k)- uairDY(i,j,k+1)
         WKxyz4(i,j,k)= vairDY(i,j,k)- vairDY(i,j,k+1)
       END DO
       END DO
       END DO

       DO k=1,mz
       DO j=1,my
       DO i=1,mx
         WKxyz5(i,j,k)= 
     .             gravit/(gplvDY (i,j,k)-gplvDY (i,j,k+1))
C +...   1/dz(k+1/2)
       END DO
       END DO
       END DO

       DO k=kp1(1),mmz1
       DO j=1,my
       DO i=1,mx
         WKxyz1(i,j,k)=
     .    TUkvm(i,j,k)*(WKxyz3(i,j,k)*WKxyz3(i,j,k) 
     .                 +WKxyz4(i,j,k)*WKxyz4(i,j,k))
     .                * WKxyz5(i,j,k)*WKxyz5(i,j,k)
       END DO
       END DO
       END DO

       DO j=1,my
       DO i=1,mx
         WKxyz1(i,j,mz)=0.0
       END DO
       END DO


C +--Buoyancy
C +  ========

C +--Reduced (Equivalent) Potential Temperature
C +  ------------------------------------------

       DO j=1,my
       DO i=1,mx
          WKxy5(i,j)   = pktaDY(i,j,mzz)
c #AV.       * (1.0+0.715*virSL(i,j    ))
c #HY.       *exp(Lv_H2O*qvapSL(i,j)  /(cp*TairSL(i,j))  )
       END DO
       END DO

       DO k=1,mz
       DO j=1,my
       DO i=1,mx
         WKxyz2(i,j,k) = pktaDY(i,j,k)
c #AV.       * (1.0+0.715*virDY(i,j,k))
c #HY.         *exp(Lv_H2O*qvDY(i,j,k)/(cp*tairDY(i,j,k)))
       END DO
       END DO
       END DO


C +--Buoyancy Coefficients
C +  ---------------------

       DO k=1,mz
c #HY    DO j=1,my
c #HY    DO i=1,mx

c #HY        hrel       = 0.50*(  qvDY(i,j,k)     /qvswDY(i,j,k) +
c #HY.                            qvDY(i,j,kp1(k))/qvswDY(i,j,k))
c #HY        WKxy3(i,j) = 0.50*(qvswDY(i,j,k)+qvswDY(i,j,k+1))
c #HY        WKxy4(i,j) = 0.50*(tairDY(i,j,k)+tairDY(i,j,kp1(k)))

c #HY        sature     = max(0.,sign(1.,hrel+eps12-1.))
c #HY        base       =        WKxy3(i,j)*Lv_H2O/(RDryAi*WKxy4(i,j))

C +--Vectorization of the unsaturated (H<1) and saturated cases (H=1.)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #HY        WKxy1(i,j) =                                               !
c #HY.            1.-sature                                             ! H<1.
c #HY.              +sature*(1.0+base)                                  ! H=1.
c #HY.                     /(1.0+base*0.605*Lv_H2O/(cp    *WKxy4(i,j))) !
C +...       C_thq (Duynkerke & Driedonks 1987 JAS 44(1), Table 1 p.47) !

c #HY        WKxy2(i,j) =                                               !
c #HY.           (1.-sature)              *(Lv_H2O/(cp    *WKxy4(i,j))  ! H<1.
c #HY.                                     - 0.605                    ) !
c #HY.              +sature                                             ! H=1.
C +...       C_q_w (Duynkerke and Driedonks 1987)                       !
C +                with (1-Ra/Rv)/(Ra/Rv) =  0.605 [Ra=287.J/kg/K;      !
C +                                                 Rv=461.J/kg/K]      !

C +--Unsaturated Case
C +  ~~~~~~~~~~~~~~~~
C +        IF (hrel.lt.1.0)                                       THEN
C +          WKxy1(i,j) = 1.0
C +          WKxy2(i,j) =                    Lv_H2O/(cp*WKxy4(i,j))
C +  .                                     - 0.605

C +--Saturated   Case
C +  ~~~~~~~~~~~~~~~~
C +        ELSE
C +          base       =      WKxy3(i,j)*Lv_H2O/(RDryAi*WKxy4(i,j))
C +          WKxy1(i,j) = (1.0+base)
C +  .                   /(1.0+base*0.605*Lv_H2O/(cp    *WKxy4(i,j)))
C +          WKxy2(i,j) =  1.0
C +        END IF

c #HY    END DO
c #HY    END DO


C +--Buoyancy
C +  --------

         IF (k.le.mmz1)                                           THEN
           DO j=1,my
           DO i=1,mx
             WKxyz3(i,j,k)= gravit
     .      *WKxyz5(i,j,k) *( (WKxyz2(i,j,k)-WKxyz2(i,j,k+1)) *2.0
     .                       /(WKxyz2(i,j,k)+WKxyz2(i,j,k+1))     
c #HY.                       *  WKxy1(i,j)
c #HY.                      -   WKxy2(i,j)
c #HY.                       *(  qvDY(i,j,k)-  qvDY(i,j,kp1(k))
c #HY.                          +qwHY(i,j,k)-  qwHY(i,j,kp1(k))
c #HY.                          +qrHY(i,j,k)-  qrHY(i,j,kp1(k))
c #HY.                          +qiHY(i,j,k)-  qiHY(i,j,kp1(k))
c #HY.                          +qsHY(i,j,k)-  qsHY(i,j,kp1(k)))
     .                                                          )
C +...      (g/theta)                  X(dtheta/dz) : 
C +          Buoyancy Parameter beta X grad.vert.temp.pot. en k+1/2
           END DO
           END DO

         ELSE
           DO j=1,my
           DO i=1,mx
             WKxyz3(i,j,k)= gravit
     .      *WKxyz5(i,j,k) *( (WKxyz2(i,j,k)- WKxy5(i,j))     *2.0
     .                       /(WKxyz2(i,j,k)+ WKxy5(i,j))     
c #HY.                       *  WKxy1(i,j)
     .                                                          )
C +...      (g/theta)                  X(dtheta/dz) : 
C +          Buoyancy Parameter beta X grad.vert.temp.pot. en k+1/2
           END DO
           END DO
         END IF
       END DO


C +--Length Scales Parameters (Therry and Lacarrere 1983 Model)
C +  ========================

       DO j=1,my
       DO i=1,mx
         WKxy3 (i,j  )= 1.0/zi__TE(i,j)

         WKxy1 (i,j  )=15.0* WKxy3(i,j)
C +...   Ce1/hi 
         WKxy2 (i,j  )= 5.0* WKxy3(i,j)
C +...   Ce1/hi 
         WKxy4 (i,j  )=11.0* WKxy3(i,j)
C +...   Ck2/hi 
       END DO
       END DO

       DO j=1,my
       DO i=1,mx
         sgnLMO   = sign(unun,SLlmo(i,j))
         absLMO   =  abs(     SLlmo(i,j))
         SLlmo(i,j) =         sgnLMO      * max(absLMO,eps12)
         WKxy3(i,j) = -min(0.,sgnLMO)
     .          /(1.0 -min(0.,SLlmo(i,j))      /zi__TE(i,j))

C +--Replacement of:
C +      IF (SLlmo(i,j).lt.0.0)                                   THEN
C +          SLlmo(i,j) =        min(SLlmo(i,j),-eps12)
C +          WKxy3(i,j) =  1.0/(1.d0-SLlmo(i,j)/zi__TE(i,j)) 
C +      ELSE
C +          SLlmo(i,j) =        max(SLlmo(i,j), eps12)
C +          WKxy3(i,j) =  0.0
C +      END IF
C +...  m2
       END DO
       END DO

       DO k=kp1(1),mz
       DO j=1,my
       DO i=1,mx
         WKxyz4(i,j,k) = sqrt(max(zero,WKxyz3(i,j,k))/ect_TE(i,j,k))
C +...   1/ls
       END DO
       END DO
       END DO


C +--Dissipation Length
C +  ------------------

       DO k=kp1(1),mz
       DO j=1,my
       DO i=1,mx
         akz=voninv*gravit/(gpmiDY(i,j,k+1)-gplvDY(i,j,mzz))
C +...   1/kz(i,j,k+1/2)
C +
         alme=akz+WKxy1(i,j)
     .    -(akz+WKxy2(i,j))*WKxy3(i,j)/(1.+5.0e-3*zi__TE(i,j)*akz)
     .     +1.5*WKxyz4(i,j,k)
C +...   alme=1/Dissipation Length (Therry and Lacarrere, 1983 BLM 25 p.75)

C +--Mixing Length
C +  -------------

         almk=akz+WKxy1(i,j)
     .    -(akz+WKxy4(i,j))*WKxy3(i,j)/(1.+2.5e-3*zi__TE(i,j)*akz)
     .     +3.0*WKxyz4(i,j,k)
C +...   almk=1/Mixing Length      (Therry and Lacarrere, 1983 BLM 25 p.78)


C +--Contribution of Vertical Wind Shear + Buoyancy + Dissipation to TKE 
C +  ===================================================================

         pousse=-TUkvh(i,j,k) *   WKxyz3(i,j,k)

         epslme= eps_TE(i,j,k)
c #Kl    epslme= 0.125*alme*sqrt(ect_TE(i,j,k))*ect_TE(i,j,k)
         ectnew= ect_TE(i,j,k) * 
     .          (ect_TE(i,j,k)+dt_dif*(WKxyz1(i,j,k)+max(zero,pousse)))
     .         /(ect_TE(i,j,k)+dt_dif*(             -min(zero,pousse)
     .                                               +epslme       ))
C +...   Numerical Scheme : cfr. E. Deleersnijder, 1992 (thesis) pp.59-61 


C +--Contribution of Vertical Wind Shear + Buoyancy to epsilon
C +  =========================================================

c #HR                                                tranTE(i,j,k)=zero
         produc = WKxyz1(i,j,k)+max(pousse,zero)+max(tranTE(i,j,k),zero)

c #KI    produc = WKxyz1(i,j,k)+max(zero,pousse)
C +...   based on standard values of Kitada, 1987, BLM 41, p.220

c #BH    produc = WKxyz1(i,j,k)+max(zero,pousse) * 1.80
c #BH.                         -min(zero,pousse) * 1.15
C +...   based on          values of Betts et Haroutunian, 1983
C +      can be used by replacing strings `c #KI' (except the previous one) 
C +                                   and `c #BH' by blanks 
C +                            (cfr. Kitada, 1987, BLM 41, p.220):
C +      buoyancy > 0 (unstability) => (1-ce3) X buoyancy = 1.8  X buoyancy
C +      buoyancy < 0 (  stability) => (1-ce3) X buoyancy =-1.15 X buoyancy

         factur = eps_TE(i,j,k) /ect_TE(i,j,k)
         eps_TE(i,j,k) = 
     .            eps_TE(i,j,k)  
     .          *(eps_TE(i,j,k) +dt_dif *factur *c1ep *produc)
     .          /(eps_TE(i,j,k) +dt_dif *factur *c2ep *eps_TE(i,j,k))
C +...   Numerical Scheme : cfr. E. Deleersnijder, 1992 (thesis) pp.59-61 

c #Kl    eps_TE(i,j,k)=epslme 


C +--New TKE Value
C +  =============

         ect_TE(i,j,k)=ectnew


C +--Dissipation Lengths Variables are Assigned for Output Purpose
C +  =============================================================

         WKxyz1(i,j,k)=alme
         WKxyz2(i,j,k)=almk
       END DO
       END DO
       END DO


C +--OUTPUT Preparation
C +  ==================

       IF((  itexpe.gt.0.and.jmmMAR.eq.0.and.jssMAR.eq.0.and.
     .     ((IO_loc.ge.2.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.2.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.3)                            )       ).or.
     .       IO_loc.ge.7                                          ) THEN

         DO i5 = 1,n5
             aalme(i5,1)  =0.0
             aalmk(i5,1)  =0.0
             flott(i5,1)  =0.0
         DO k = kp1(1),mz
           IF (WKxyz1(igrdIO(i5),jgrdIO(i5),k).gt.0.0)              THEN
             aalme(i5,k) = 1.0/WKxyz1(igrdIO(i5),jgrdIO(i5),k)
           ELSE
             aalme(i5,k) = 0.0
           END IF
C +...       Le
           IF (WKxyz2(igrdIO(i5),jgrdIO(i5),k).gt.0.d0)             THEN
             aalmk(i5,k) = 1.0/WKxyz2(igrdIO(i5),jgrdIO(i5),k)
           ELSE
             aalmk(i5,k) = 0.0
           END IF
C +...       Lk
             flott(i5,k)  = - WKxyz3(igrdIO(i5),jgrdIO(i5),k)
C +...       proportional to the buoyant force (e.g. Demoor, 1978, p.47)
         END DO
         END DO
       END IF


C +--Lower Boundary Conditions
C +  =========================

       DO i=1,mx
       DO j=1,my
          WKxy1(i,j)    =  SLuus(i,j)      * SLuus(i,j)            ! -> TKE SBC
          WKxy3(i,j)    =(gplvDY(i,j,mz)   -gplvDY(i,j,mzz))*grvinv!    z_SBL
c #vL  ENDDO
c #vL  ENDDO

c #vL  DO i=1,mx
c #vL  DO j=1,my
          WKxy2(i,j)    =  WKxy1(i,j)      * SLuus(i,j)            ! -> e   SBC
         ect_TE(i,j,mz) =  WKxy1(i,j)      *sqrcmu                 !    TKE SBC

          WKxy4(i,j)    =  WKxy3(i,j)      / SLlmo(i,j)            !    zeta
          WKxy5(i,j)    =  max(0.0,sign(unun,SLlmo(i,j)))          !
c #vL  ENDDO
c #vL  ENDDO

c #vL  DO i=1,mx
c #vL  DO j=1,my
         eps_TE(i,j,mz) =  WKxy2(i,j) 
     .            *(      (WKxy5(i,j) *(1.+A_Turb*    WKxy4(i,j))  ! phim Stab.
     .               +(1.0-WKxy5(i,j))/(1.-20.*min(0.,WKxy4(i,j))))! phim Inst.
     .            *voninv /WKxy3(i,j)
     .            -voninv /SLlmo(i,j))
C +...   Duynkerke, 1988, JAS (45), (19) p. 869

c #KI    eps_TE(i,j,mz) =  WKxy2(i,j) 
c #KI.            *voninv /WKxy3(i,j)
c #vL  ENDDO
c #vL  ENDDO


C +--When TKE Closure is Used, TKE is Modified near the Lower Boundary
C +  -----------------------------------------------------------------

c #vL  DO i=1,mx
c #vL  DO j=1,my
c #KC    se = max(0.,sign(unun,ect_TE(i,j,mmz2)-ect_TE(i,j,mmz1)))
c #KC    ke =                             mmz1 -    se
c #KC    ect_TE(i,j,mmz1)=     ect_TE(i,j,ke  )
c #KC    eps_TE(i,j,mmz1)=     eps_TE(i,j,ke  )
C +...   Schayes and Thunis, 1990, Contrib. 60 Inst.Astr.Geoph. p.8, 1.4.4.

! #KC    ect_TE(i,j,mmz1)=     ect_TE(i,j,mz  )
! #KC    eps_TE(i,j,mmz1)=     eps_TE(i,j,mz  )


C +--Upper Boundary Conditions
C +  =========================

         ect_TE(i,j,1) = ect_TE(i,j,kp1(1))
c #De    ect_TE(i,j,1) = ect_TE(i,j,    mz)*rolvDY(i,j,mz)/rolvDY(i,j,1)
c #De    ect_DI(i,j)   = ect_TE(i,j,     1)

         eps_TE(i,j,1) = eps_TE(i,j,kp1(1))
c #De    eps_TE(i,j,1) = eps_TE(i,j,    mz)*rolvDY(i,j,mz)/rolvDY(i,j,1)
c #De    eps_DI(i,j)   = eps_TE(i,j,     1)
C +     
       END DO
       END DO


C +--TKE-e Vertical Moving Average
C +  =============================

c #KA  DO k=mz__KA,mz1
c #KA  DO j=1,my
c #KA  DO i=1,mx
c #KA     WKxyz7(i,j,k)=(dsigm1(kp1(k))*ect_TE(i,j,kp1(k))
c #KA.                  +dsigm1(    k )*ect_TE(i,j,    k )*2.
c #KA.                  +dsigm1(km1(k))*ect_TE(i,j,km1(k))   )
c #KA.                 /(dsigm1(kp1(k))
c #KA.                  +dsigm1(    k )                   *2.
c #KA.                  +dsigm1(km1(k))                      )
c #KA     WKxyz8(i,j,k)=(dsigm1(kp1(k))*eps_TE(i,j,kp1(k))
c #KA.                  +dsigm1(    k )*eps_TE(i,j,    k )*2.
c #KA.                  +dsigm1(km1(k))*eps_TE(i,j,km1(k))   )
c #KA.                 /(dsigm1(kp1(k))
c #KA.                  +dsigm1(    k )                   *2.
c #KA.                  +dsigm1(km1(k))                      )
c #KA  END DO
c #KA  END DO
c #KA  END DO

c #KA  DO k=mz__KA,mz1
c #KA  DO j=1,my
c #KA  DO i=1,mx
c #KA     ect_TE(i,j,k)= WKxyz7(i,j,k)
c #KA     eps_TE(i,j,k)= WKxyz8(i,j,k)
c #KA  END DO
c #KA  END DO
c #KA  END DO


C +--Verification: TKE must be Positive Definite
C +  ===========================================

       DO k=1,mz
       DO j=1,my
       DO i=1,mx
         ect_TE(i,j,k)=max(epse,ect_TE(i,j,k))
         eps_TE(i,j,k)=max(epsd,eps_TE(i,j,k))
       END DO
       END DO
       END DO


C +--Minimum Energy Dissipation Time
C +  ===============================

c #HR  DO j=1,my
c #HR  DO i=1,mx
c #HR      edtnum      = 0.0
c #HR      edtden      = 0.0
c #HR    DO k=1,mz
c #HR      edtnum      = edtnum + ect_TE(i,j,k)*dsig_1(k)
c #HR      edtden      = edtden + eps_TE(i,j,k)*dsig_1(k)
c #HR    END DO

c #HR    IF (edtden.gt.0.0)                                       THEN
c #HR      edt_TE(i,j) = betahr*edtnum/edtden 
c #HR    ELSE
c #HR      edt_TE(i,j) = 1.e-8
C +...     edt_TE set to an arbitrary small value
c #HR    END IF
c #HR  END DO
c #HR  END DO


C +--Turbulent Diffusion Coefficients
C +  ================================

       IF (locTKE.gt.0 .or.itexpe.gt.1)                           THEN


C +--Richardson Number (contributors)
C +  -----------------

         DO j=1,my
         DO i=1,mx
           TU_Pra(i,j,mz)  =   1.
         END DO
         END DO

         DO k=kp1(1),mz1
         DO j=1,my
         DO i=1,mx
           WKxyz6(i,j,k) =  0.0
c #RI      WKxyz6(i,j,k) =  0.5*(pktadY(i,j,k)-pktadY(i,j,k+1))*pcap 
c #RI.                   /      (tairDY(i,j,k)+tairDY(i,j,k+1))
c #RI      WKxyz7(i,j,k) =  max((uairDY(i,j,k)-uairDY(i,j,k+1))**2
c #RI.                         +(vairDY(i,j,k)-vairDY(i,j,k+1))**2,epsi)
c #vK    END DO
c #vK    END DO
c #vK    END DO


C +--Richardson Number
C +  -----------------

c #vK    DO k=kp1(1),mz1
c #vK    DO j=1,my
c #vK    DO i=1,mx
           WKxyz8(i,j,k) =  0.0
c #RI      WKxyz8(i,j,k) = (gravit/WKxyz5(i,j,k))         ! g * dz     (k+1/2)
c #RI.                            *WKxyz6(i,j,k)          ! d(theta)/T (k+1/2)
c #RI.                            /WKxyz7(i,j,k)          ! d|V|
c #vK    END DO
c #vK    END DO
c #vK    END DO


C +--Diffusion Coefficient for Heat
C +  ------------------------------

c #vK    DO k=kp1(1),mz
c #vK    DO j=1,my
c #vK    DO i=1,mx
           TUkvh(i,j,k)= 
     .            cmu * ect_TE(i,j,k)* ect_TE(i,j,k)/(eps_TE(i,j,k)
c #HR.                                +ect_TE(i,j,k)/ edt_TE(i,j)  
     .                                                             )
C +...     nu_t =c_mu X ECT          X ECT          / eps
c #Kl      TUkvh(i,j,k)=  0.50 * sqrt( ect_TE(i,j,k))/WKxyz2(i,j,k) 

           kz_max= vonkar *    (gplvDY(i,j,k+1)-gplvDY(i,j,mzz))*grvinv
           kz_mix= kz_max /    (1.             +kz_max          *0.1   )
           kz2mix= kz_mix *     kz_mix
           KvhMax(i,j,k) = max(   5000.        ,   100.
     .           * kz2mix *abs(( ssvSL(i,j,k)  - ssvSL(i,j,kp1(k)))
     .                         *WKxyz5(i,j,k)                      ))
           TUkvh(i,j,k)=   min( KvhMax(i,j,k)  , TUkvh(i,j,    k ))
           TUkvh(i,j,k)=   max( akmol          , TUkvh(i,j,    k ))
c #vK    END DO
c #vK    END DO
c #vK    END DO


C +--Prandtl Number (Sukoriansky et al., 2005,
C +  --------------  BLM 117: 231-257, Eq.15, 19, 20 & Fig.2)

c #vK    DO k=kp1(1),mz1
c #vK    DO j=1,my
c #vK    DO i=1,mx
c #RI      fac_Ri= 5.0 *     max(WKxyz8(i,j,k), epsi)
c #RI      vuzvun= 0.4 *(1.-(fac_Ri-1./fac_Ri)/(fac_Ri+1./fac_Ri)) + 0.2
c #RI      fac_Ri= 4.2 *     max(WKxyz8(i,j,k), epsi)
c #RI      Kz_vun= 0.7 *(1.-(fac_Ri-1./fac_Ri)/(fac_Ri+1./fac_Ri))
           TU_Pra(i,j,k) =                             1.
c #RI      TU_Pra(i,j,k) =   max(0.     ,sign(1.  , TUkvh(i,j,k)-0.20))
c #RI.                   -   min(0.     ,sign(1.  , TUkvh(i,j,k)-0.20))
c #RI.                   *   min(vuzvun / max(epsi,Kz_vun),     20.00)
         END DO
         END DO
         END DO


C +--Diffusion Coefficient for Momentum
C +  ----------------------------------

         DO k=kp1(1),mz
         DO j=1,my
         DO i=1,mx
           TUkvm(i,j,k)=                  TUkvh (i,j,k)
C +...     cfr Machiels, 1992, TFE (FSA/UCL) (3.21) p.21

c #Kl      TUkvm(i,j,k)=  0.7           * TUkvh (i,j,k)

c #RI      TUkvm(i,j,k)=  TU_Pra(i,j,k) * TUkvh (i,j,k)
         END DO
         END DO
         END DO

       END IF


C +--Lateral Boundary Conditions
C +  ===========================

c #OB  IF (openLB)                                                THEN 
c #OB    IF (mmx.gt.1)                                            THEN 
c #OB      DO k=1,mz
c #OB      DO j=jp11,my1
c #OB        ect_TE( 1,j,k) = ect_TE(ip11,j,k)
c #OB        ect_TE(mx,j,k) = ect_TE(mx1,j,k)
c #OB        eps_TE( 1,j,k) = eps_TE(ip11,j,k)
c #OB        eps_TE(mx,j,k) = eps_TE(mx1,j,k)
c #OB         TUkvm( 1,j,k) =  TUkvm(ip11,j,k)
c #OB         TUkvm(mx,j,k) =  TUkvm(mx1,j,k)
c #OB         TUkvh( 1,j,k) =  TUkvh(ip11,j,k)
c #OB         TUkvh(mx,j,k) =  TUkvh(mx1,j,k)
c #OB      END DO
c #OB      END DO
c #OB    END IF

c #OB    IF (mmy.gt.1)                                            THEN 
c #OB      DO k=1,mz
c #OB      DO i=ip11,mx1
c #OB        ect_TE(i, 1,k) = ect_TE(i,jp11,k)
c #OB        ect_TE(i,my,k) = ect_TE(i,my1,k)
c #OB        eps_TE(i, 1,k) = eps_TE(i,jp11,k)
c #OB        eps_TE(i,my,k) = eps_TE(i,my1,k)
c #OB         TUkvm(i, 1,k) =  TUkvm(i,jp11,k)
c #OB         TUkvm(i,my,k) =  TUkvm(i,my1,k)
c #OB         TUkvh(i, 1,k) =  TUkvh(i,jp11,k)
c #OB         TUkvh(i,my,k) =  TUkvh(i,my1,k)
c #OB      END DO
c #OB      END DO
c #OB    END IF
C +... Lateral Boundary Values of Kzm and Kzh are used
C +    during the Initialisation Procedure in 1-D Zone

c #OB  END IF


C +--Hourly Output on Listing
C +  ========================

       IF((  itexpe.gt.0.and.jmmMAR.eq.0.and.jssMAR.eq.0.and.
     .     ((IO_loc.ge.2.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.2.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.3)                            )       ).or.
     .       IO_loc.ge.7                                          ) THEN

         DO i5=1,n5

           DO k=1,mz
             WKxza(i5,k) = 6.6d-1 
     .                   * (ect_TE(igrdIO(i5),jgrdIO(i5),k)**1.50)
     .                    /(eps_TE(igrdIO(i5),jgrdIO(i5),k)
C +...            0.066  = cmu(Duynkerke) * 2
c #HR.                     +ect_TE(igrdIO(i5),jgrdIO(i5),k)
c #HR.                     /edt_TE(igrdIO(i5),jgrdIO(i5))
     .                                                )
           END DO

             write(4 ,61)explIO,igrdIO(i5),jgrdIO(i5),
     .            jdarGE,jhlrGE(igrdIO(i5),jgrdIO(i5)),
     .            jmmMAR,jssMAR,dt_dif,
     .                    xxkm(igrdIO(i5)),
     .                   SLlmo(igrdIO(i5),jgrdIO(i5)),
     .                  zi__TE(igrdIO(i5),jgrdIO(i5))
c #WE      IF (mod(jhaMAR,12).eq.0) 
c #WE.       write(25,61)explIO,igrdIO(i5),jgrdIO(i5),
c #WE.            jdarGE,jhlrGE(igrdIO(i5),jgrdIO(i5)),
c #WE.            jmmMAR,jssMAR,dt_dif,
c #WE.                    xxkm(igrdIO(i5)),
c #WE.                   SLlmo(igrdIO(i5),jgrdIO(i5)),
c #WE.                  zi__TE(igrdIO(i5),jgrdIO(i5))
 61          format(/,' EXP.',a3,' / Pt. (',i3,',',i3,')',
     .                      ' / Turbulence Characteristics on',
     .           i5,'d',i2,'LT',i2,'m',i2,'s - dt=',f6.0,
     .         /,' ------------------------------------------',
     .           '-----------------------------------------',
     .       /,' x =',f5.0,'km',3x,'Lo =',e9.2,'m' ,3x,'zi =',f6.0,'m',
     .       /,' lev  Altit. Temper.  Pot.T. Wind_u Wind_v   TKE   ',
     .         ' epsilon Buoyancy     Le    Lk   Le(e) Prandtl     Kvm',
     .                                               '     Kvh Kvh MAX',
     .       /,'       [m]     [K]      [K]   [m/s]  [m/s] [m2/s2] ',
     .         ' [m2/s2]    [s-2]    [m]   [m]  [m]        [-]  [m2/s]',
     .                                               '  [m2/s]  [m2/s]')
             write(4 ,62)(k,
     .              0.1019*gplvDY(igrdIO(i5),jgrdIO(i5),k),
     .                     tairDY(igrdIO(i5),jgrdIO(i5),k),
     .              3.7300*pktaDY(igrdIO(i5),jgrdIO(i5),k),
     .                     uairDY(igrdIO(i5),jgrdIO(i5),k),
     .                     vairDY(igrdIO(i5),jgrdIO(i5),k),
     .              0.1019*gpmiDY(igrdIO(i5),jgrdIO(i5),k+1),
     .                     ect_TE(igrdIO(i5),jgrdIO(i5),k),
     .                     eps_TE(igrdIO(i5),jgrdIO(i5),k),
     .              flott(i5,k) ,aalme(i5,k) ,aalmk(i5,k),WKxza(i5,k),
     .                       TU_Pra(igrdIO(i5),jgrdIO(i5),k),
     .                        TUkvm(igrdIO(i5),jgrdIO(i5),k),
     .                        TUkvh(igrdIO(i5),jgrdIO(i5),k),
     .                       KvhMax(igrdIO(i5),jgrdIO(i5),k),
     .               k=1,mz)
             write(4 ,620)  
 620         format(
     .         ' lev  Altit. Temper.  Pot.T. Wind_u Wind_v   TKE   ',
     .         ' epsilon Buoyancy     Le    Lk   Le(e) Prandtl     Kvm',
     .                                               '     Kvh Kvh MAX',
     .       /,'       [m]     [K]      [K]   [m/s]  [m/s] [m2/s2] ',
     .         ' [m2/s2]    [s-2]    [m]   [m]  [m]        [-]  [m2/s]',
     .                                               '  [m2/s]  [m2/s]',
     .       /,1x)
c #WE      IF (mod(jhaMAR,12).eq.0)                               THEN
c #WE        m30=min(mz,30)
c #WE        write(25,62)(k,
c #WE.              0.1019*gplvDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     tairDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.              3.7300*pktaDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     uairDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     vairDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.              0.1019*gpmiDY(igrdIO(i5),jgrdIO(i5),k+1),
c #WE.                     ect_TE(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     eps_TE(igrdIO(i5),jgrdIO(i5),k),
c #WE.              flott(i5,k) ,aalme(i5,k) ,aalmk(i5,k),WKxza(i5,k),
c #WE.                     TU_Pra(igrdIO(i5),jgrdIO(i5),k),
c #WE.                      TUkvm(igrdIO(i5),jgrdIO(i5),k),
c #WE.                      TUkvh(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     KvhMax(igrdIO(i5),jgrdIO(i5),k),
c #WE.               k=1,m30)
c #WE        write(25,64)
 64          format(/////)
c #WE        write(25,61)explIO,jhlrGE(igrdIO(i5),jgrdIO(i5)),
c #WE.                          minuGE,jsecGE,dt_dif,
c #WE.                    xxkm(igrdIO(i5)),
c #WE.                   SLlmo(igrdIO(i5),jgrdIO(i5)),
c #WE.                  zi__TE(igrdIO(i5),jgrdIO(i5))
c #WE        m31=min(mz,31)
c #WE        if (mz.ge.m31)
c #WE.       write(25,62)(k,
c #WE.              0.1019*gplvDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     tairDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.              3.7300*pktaDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     uairDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     vairDY(igrdIO(i5),jgrdIO(i5),k),
c #WE.              0.1019*gpmiDY(igrdIO(i5),jgrdIO(i5),k+1),
c #WE.                     ect_TE(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     eps_TE(igrdIO(i5),jgrdIO(i5),k),
c #WE.              flott(i5,k) ,aalme(i5,k) ,aalmk(i5,k),WKxza(i5,k),
c #WE.                     TU_Pra(igrdIO(i5),jgrdIO(i5),k),
c #WE.                      TUkvm(igrdIO(i5),jgrdIO(i5),k),
c #WE.                      TUkvh(igrdIO(i5),jgrdIO(i5),k),
c #WE.                     KvhMax(igrdIO(i5),jgrdIO(i5),k),
c #WE.               k=m31,mz)
c #WE      END IF
 62        format((i4,f8.0,2f8.2,2f7.2,
     .           /,4x,f8.0,30x,3e9.2,2f6.1,5f8.2))
           write(4,63) SL_z0(igrdIO(i5),jgrdIO(i5),1),
     .                TairSL(igrdIO(i5),jgrdIO(i5))  ,
     .                 SLuus(igrdIO(i5),jgrdIO(i5))
 63        format( 4x,f8.6, f8.2,8x,f8.3)

           DO k=1,mz
             WKxza(i5,k) = 0.0
           END DO

         END DO
       END IF


C +--Work Arrays Reset
C +  =================

      DO  j=1,my
      DO  i=1,mx
        WKxy1(i,j) = 0.0
        WKxy2(i,j) = 0.0
        WKxy3(i,j) = 0.0
        WKxy4(i,j) = 0.0
        WKxy5(i,j) = 0.0
      END DO
      END DO

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
        WKxyz3(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
        WKxyz5(i,j,k) = 0.0
        WKxyz6(i,j,k) = 0.0
        WKxyz7(i,j,k) = 0.0
        WKxyz8(i,j,k) = 0.0
        tranTE(i,j,k) = 0.0
      END DO
      END DO
      END DO

      locTKE = 1
C +...locTKE: turn on TKE Evolution

      return
      end


      subroutine TURtke_advh(dt_dif)

C +------------------------------------------------------------------------+
C | MAR TURBULENCE (TKE)                                   14-09-2001  MAR |
C |   SubRoutine TURtke_advh includes TKE Horizontal Advection Contribution|
C |              solved by a 1st Order Accurate in Space Upstream Scheme   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT         :  dt_dif: Local Time Step                          (s) |
C |  ^^^^^^^^^^^^^^                                                        |
C |                                                                        |
C |  INPUT / OUTPUT: The Vertical Turbulent Fluxes are included for:       |
C |  ^^^^^^^^^^^^^^                                                        |
C |       a) Turbulent Kinetic Energy             ect_TE(mx,my,mz) [m2/s2] |
C |       b) Turbulent Kinetic Energy Dissipation eps_TE(mx,my,mz) [m2/s3] |
C |                                                                        |
C |  REMARK : The Advected Variables Lateral Boundary Conditions           |
C |  ^^^^^^^^ are Fixed Implicitely                                        |
C |            1)  inflow => no change                                     |
C |            2) outflow => advected Value                                |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_TE.inc'

      include 'MAR_WK.inc'

      real     dt_dif


C +--Local  Variables
C +  ================

      real     dti   ,dtxe  ,dtye  ,tran


C +--Parameters
C +  ==========

      dti = 1.0 /dt_dif
      dtxe= dt_dif / dx
      dtye= dt_dif / dy  


C +--Courant Number
C +  ==============

      DO   k=1,mmz1
      DO   j=1,my
      DO   i=1,mx
        WKxyz1(i,j,k)=-max(zero,demi*(uairDY(i,j,k)+uairDY(i,j,kp1(k))))
     .               *dtxe
        WKxyz2(i,j,k)=-min(zero,demi*(uairDY(i,j,k)+uairDY(i,j,kp1(k))))
     .               *dtxe
        WKxyz3(i,j,k)=-max(zero,demi*(vairDY(i,j,k)+vairDY(i,j,kp1(k))))
     .               *dtye
        WKxyz4(i,j,k)=-min(zero,demi*(vairDY(i,j,k)+vairDY(i,j,kp1(k))))
     .               *dtye
C +...Velocities V are computed in the layers (i.e. at k+1/2) 
C +   Interpolation based on V=0 at the Surface (very approximative)

      END DO
      END DO
      END DO


C +--Advection (x-Direction)
C +  =======================

        DO   k=1,mmz1
        DO   i=ip11,mx1
        DO   j=jp11,my1
          tran         =WKxyz1(i,j,k)*(ect_TE(i,j,k)-ect_TE(im1(i),j,k))
     .                 +WKxyz2(i,j,k)*(ect_TE(ip1(i),j,k)-ect_TE(i,j,k))
c #TA   tranTE(i,j,k)=tranTE(i,j,k) + tran * dti
        ect_TE(i,j,k)=ect_TE(i,j,k) + tran
        eps_TE(i,j,k)=eps_TE(i,j,k)
     .                 +WKxyz1(i,j,k)*(eps_TE(i,j,k)-eps_TE(im1(i),j,k))
     .                 +WKxyz2(i,j,k)*(eps_TE(ip1(i),j,k)-eps_TE(i,j,k))
        END DO
        END DO
        END DO


C +--Advection (y-Direction)
C +  =======================

      IF (mmy.gt.1)                                               THEN
        DO  k=1,mmz1
        DO  j=jp11,my1
        DO  i=ip11,mx1
        tran         =WKxyz3(i,j,k)*(ect_TE(i,j,k)-ect_TE(i,jm1(j),k))
     .               +WKxyz4(i,j,k)*(ect_TE(i,jp1(j),k)-ect_TE(i,j,k))
c #TA   tranTE(i,j,k)=tranTE(i,j,k) + tran * dti
        ect_TE(i,j,k)=ect_TE(i,j,k) + tran
        eps_TE(i,j,k)=eps_TE(i,j,k)
     .               +WKxyz3(i,j,k)*(eps_TE(i,j,k)-eps_TE(i,jm1(j),k))
     .               +WKxyz4(i,j,k)*(eps_TE(i,jp1(j),k)-eps_TE(i,j,k))
        END DO
        END DO
        END DO
      END IF


C +--Work Arrays Reset
C +  =================

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
        WKxyz3(i,j,k) = 0.0
        WKxyz4(i,j,k) = 0.0
      END DO
      END DO
      END DO

      return
      end


      subroutine TURtke_advv(dt_dif)

C +------------------------------------------------------------------------+
C | MAR TURBULENCE (TKE)                                   14-09-2001  MAR |
C |   SubRoutine TURtke_advv includes TKE Vertical Advection Contribution  |
C |              solved by a 1st Order Accurate in Space Upstream Scheme   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT / OUTPUT: The Vertical Turbulent Fluxes are included for:       |
C |  ^^^^^^^^^^^^^^                                                        |
C |       a) Turbulent Kinetic Energy             ect_TE(mx,my,mz) [m2/s2] |
C |       b) Turbulent Kinetic Energy Dissipation eps_TE(mx,my,mz) [m2/s3] |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_TE.inc'

      include 'MAR_WK.inc'

      real     dt_dif


C +--Local  Variables
C +  ================

      real     tran


C +--Vertical Courant Number
C +  =======================

      IF (staggr)                                                   THEN
        DO  k=1,mmz1
        DO  j=1,my
        DO  i=1,mx
          WKxyz3(i,j,k) =                          psigDY(i,j,k) 
        END DO
        END DO
        END DO
      ELSE
        DO  k=1,mmz1
        DO  j=1,my
        DO  i=1,mx
          WKxyz3(i,j,k) = 0.50*(psigDY(i,j,kp1(k))+psigDY(i,j,k))
        END DO
        END DO
        END DO
      END IF

        DO  k=1,mmz1 
        DO  j=1,my
        DO  i=1,mx
          WKxyz1(i,j,k) = - max(zero,WKxyz3(i,j,k))
     .                      * dt_dif/(pstDYn(i,j)*dsigm1(k)  )
          WKxyz2(i,j,k) = - min(zero,WKxyz3(i,j,k))
     .                      * dt_dif/(pstDYn(i,j)*dsigm1(k+1))
        END DO
        END DO
        END DO

            k=  mz 
        DO  j=1,my
        DO  i=1,mx
          WKxyz1(i,j,k) = - max(zero,WKxyz3(i,j,k))
     .                      * dt_dif/(pstDYn(i,j)*dsigm1(k)  )
        END DO
        END DO


C +--Vertical Advection of TKE and TKE Dissipation
C +  =============================================

        DO  k=kp1(1),mz
        DO  j=1,my
        DO  i=1,mx
          WKxyz4(i,j,k) = ect_TE(i,j,k)-ect_TE(i,j,k-1)
          WKxyz5(i,j,k) = eps_TE(i,j,k)-eps_TE(i,j,k-1)
        END DO
        END DO
        END DO

        DO  k=kp1(1),mmz1
        DO  j=1,my
        DO  i=1,mx
          tran         =    zero
          tran         =WKxyz1(i,j,k)*WKxyz4(i,j,k)
     .                 +WKxyz2(i,j,k)*WKxyz4(i,j,k+1)
          ect_TE(i,j,k)=ect_TE(i,j,k) + tran 
          eps_TE(i,j,k)=eps_TE(i,j,k)
     .                 +WKxyz1(i,j,k)*WKxyz5(i,j,k)
     .                 +WKxyz2(i,j,k)*WKxyz5(i,j,k+1)

c #TA     tranTE(i,j,k)=tranTE(i,j,k) + tran / dt_dif

        END DO
        END DO
        END DO


C +--Work Arrays Reset
C +  =================

        DO  k=1,mz
        DO  j=1,my
        DO  i=1,mx
          WKxyz1(i,j,k) = 0.0
          WKxyz2(i,j,k) = 0.0
          WKxyz3(i,j,k) = 0.0
          WKxyz4(i,j,k) = 0.0
          WKxyz5(i,j,k) = 0.0
        END DO
        END DO
        END DO

      return
      end


      subroutine TURtke_difh(dt_dif)

C +------------------------------------------------------------------------+
C | MAR TURBULENCE (TKE)                                   18-09-2001  MAR |
C |   SubRoutine TURtke_difh includes TKE Horizontal Diffusion Contribution|
C |      to Turbulent Kinetic Energy (ect_TE) and Dissipation (eps_TE)     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT:TUkhx(mx,my,mz): Horizontal Diffusion Coefficient (x-Direction) |
C |  ^^^^^ TUkhy(mx,my,mz): Horizontal Diffusion Coefficient (y-Direction) |
C |                                                                        |
C |  INPUT / OUTPUT                                                        |
C |  ^^^^^^^^^^^^^^                                                        |
C |      The Horizontal Diffusion and Correction Terms are included for :  |
C |       a) Turbulent Kinetic Energy             ect_TE(mx,my,mz) [m2/s2] |
C |       b) Turbulent Kinetic Energy Dissipation eps_TE(mx,my,mz) [m2/s2] |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'

      include 'MAR_WK.inc'

      real     dt_dif


C +--Local  Variables
C +  ================

      real     tran  ,dx2inv


C +--Computes Horizontal Diffusion using an Explicit Scheme
C +  ======================================================

      DO i=1,mx1
      DO j=1,my
        WKxy1 (i,j) =  0.50*(pstDY(i,j)+pstDY(ip1(i),j))
      END DO
      END DO

      DO j=1,my1
      DO i=1,mx
        WKxy2 (i,j) =  0.50*(pstDY(i,j)+pstDY(i,jp1(j)))
      END DO
      END DO

                      dx2inv = 1.d0/dx/dx
      DO j=1,my
      DO i=1,mx
        WKxy3 (i,j) = dx2inv/pstDY(i,j)
      END DO
      END DO

C +   ================
      DO k=kp1(1),mmz1
C +   ================


C +--Horizontal Diffusion, x-Direction
C +  =================================

        DO i=ip11,mx1
        DO j=jp11,my1
C +
         tran          =          WKxy3(i     ,j) 
     .                         * (WKxy1(i     ,j)  * TUkhx(i     ,j,k)
     .                         *(ect_TE(ip1(i),j,k)-ect_TE(i     ,j,k))
     .                           -WKxy1(im1(i),j)  * TUkhx(im1(i),j,k)
     .                         *(ect_TE(i     ,j,k)-ect_TE(im1(i),j,k)))
c #TD    tranTE(i,j,k) = tranTE(i,j,k) + tran
         WKxyz1(i,j,k) = dt_dif        * tran

         WKxyz2(i,j,k) = dt_dif * WKxy3(i     ,j) 
     .                         * (WKxy1(i     ,j)  * TUkhx(i     ,j,k) 
     .                         *(eps_TE(ip1(i),j,k)-eps_TE(i,j,k))
     .                           -WKxy1(im1(i),j)  * TUkhx(im1(i),j,k) 
     .                         *(eps_TE(i     ,j,k)-eps_TE(im1(i),j,k)))
        END DO
        END DO

        DO j=jp11,my1
        DO i=ip11,mx1
         ect_TE(i,j,k) = ect_TE(i,j,k) + WKxyz1(i,j,k)
         eps_TE(i,j,k) = eps_TE(i,j,k) + WKxyz2(i,j,k)
        END DO
        END DO


C +--Horizontal Diffusion, y-Direction
C +  =================================

      IF (mmy.ge.2)                                                 THEN

        DO j=jp11,my1
        DO i=ip11,mx1

         tran          =          WKxy3(i,j) 
     .                         * (WKxy2(i,j)       * TUkhy(i,j     ,k) 
     .                         *(ect_TE(i,jp1(j),k)-ect_TE(i,j,k))
     .                           -WKxy2(i,jm1(j))  * TUkhy(i,jm1(j),k) 
     .                         *(ect_TE(i,j     ,k)-ect_TE(i,jm1(j),k)))
c #TD    tranTE(i,j,k) = tranTE(i,j,k) + tran
         WKxyz1(i,j,k) = dt_dif        * tran

         WKxyz2(i,j,k) = dt_dif * WKxy3(i,j) 
     .                         * (WKxy2(i,j)       * TUkhy(i,j     ,k) 
     .                         *(eps_TE(i,jp1(j),k)-eps_TE(i,j,k))
     .                           -WKxy2(i,jm1(j))  * TUkhy(i,jm1(j),k) 
     .                         *(eps_TE(i,j     ,k)-eps_TE(i,jm1(j),k)))
        END DO
        END DO

        DO j=jp11,my1
        DO i=ip11,mx1
         ect_TE(i,j,k) = ect_TE(i,j,k) + WKxyz1(i,j,k)
         eps_TE(i,j,k) = eps_TE(i,j,k) + WKxyz2(i,j,k)
        END DO
        END DO

      END IF

C +   ======
      END DO
C +   ======


C +--Work Arrays Reset
C +  =================

      DO     j=1,my
      DO     i=1,mx
        WKxy1(i,j) = 0.0
        WKxy2(i,j) = 0.0
        WKxy3(i,j) = 0.0
        WKxy4(i,j) = 0.0
      END DO
      END DO

      DO     k=1,mz
      DO     j=1,my
      DO     i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
      END DO
      END DO
      END DO

      return
      end


      subroutine TURtke_difv(dt_dif,alphaD) 

C +------------------------------------------------------------------------+
C | MAR TURBULENCE (TKE)                               Fri 11-03-2011  MAR |
C |   SubRoutine TURtke_difv includes TKE Vertical Turbulence Contribution |
C |      to Turbulent Kinetic Energy (ect_TE) and Dissipation (eps_TE)     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT: TUkvm(mx,my,mz): Vertical Turbulent Coeffic.(momentum) [m2/s2] |
C |  ^^^^^^                                                                |
C |                                                                        |
C |  INPUT / OUTPUT: The Vertical Turbulent Fluxes are included for:       |
C |  ^^^^^^^^^^^^^^                                                        |
C |       a) Turbulent Kinetic Energy             ect_TE(mx,my,mz) [m2/s2] |
C |       b) Turbulent Kinetic Energy Dissipation eps_TE(mx,my,mz) [m2/s3] |
C |                                                                        |
C | #OPTIONS: #De: Dirichlet Type Top Boundary Condit. for ect_TE & eps_TE |
C | #^^^^^^^^                                                              |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'

c #De include 'MAR_DI.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'
c _PE include 'MARpen.inc'
c #PE include 'MARpen.inc'

      include 'MAR_WK.inc'

      real     dt_dif


C +--Local  Variables
C +  ================

      integer  k1
      real     sige  ,sigk
      real     sige0 ,sigk0 ,sigek ,alpha ,beta  ,ab    ,alphaD


C +--DATA
C +  ====

      data sige /0.862e0/
C +...Bintanja , 2000, BLM (95),milieu p. 355 : 1/sig_e = 1./1.16 = 0.862
c #PD data sige0/0.420e0/
C +...Duynkerke, 1988, JAS (45), end a. p.868 : 1/sig_e = 1./2.38 = 0.420
c #KI data sige0/0.769e0/
C +...Kitada   , 1987, BLM (41),        p.220 : 1/sig_e = 1./1.30 = 0.769
c #Kl data sige0/0.420e0/
C +...For TKE Closure (Therry and Lacarrere, 1983)

      data sigk /1.000e0/
C +...Duynkerke, 1988, JAS (45), end a. p.868 : 1/sig_k  = 1./1.00=1.000
c #KI data sigk0/1.000e0/
C +...Kitada   , 1987, BLM (41),        p.220 : 1/sig_k  = 1./1.00=1.000
c #Kl data sigk0/1.200e0/
C +...Schayes and Thunis, Contribution 60 Inst.Astr.Geoph.(1990) p.6

c #PD sige  = sige0
c #KI sige  = sige0
c #Kl sige  = sige0
      sigek = sige / sigk


C +--Parameters for the Numerical Scheme of Vertical Turbulent Transport
C +  ===================================================================

      alpha = alphaD            ! Expliciteness := 0 (positive definite)
      beta  = 1.00-alpha        ! Impliciteness
      ab    = alpha/beta        !


C +--Work Arrays Reset
C +  =================

      DO k=   1,mz
      DO j=   1,my 
      DO i=   1,mx 
        WKxyz1(i,j,k) =0.0
        WKxyz2(i,j,k) =0.0
        WKxyz3(i,j,k) =0.0
      END DO
      END DO
      END DO


C +--Vertical Diffusion of Turbulent Kinetic Energy
C +  ==============================================


C +--Tridiagonal Matrix Coefficients - ect_TE 
C +  ----------------------------------------

        DO k=mmz2,1,-1

        DO j=   1,my 
        DO i=   1,mx 
          WKxyz1(i,j,k)=-gravi2*(TUkvm (i,j,k)+TUkvm (i,j,k+1)
c _PE.                          +pente3(i,j,k)+pente3(i,j,k+1)
c #PE.                          +pente3(i,j,k)+pente3(i,j,k+1)
     .                          )*0.50*beta*sigk
     .                         * romiDY(i,j,k)*rolvDY(i,j,k) 
     .                         /(pstDY2(i,j)  *dsigm1(k) *dsig_1(k))
        END DO
        END DO

        DO j=   1,my 
        DO i=   1,mx 
          WKxyz3(i,j,kp1(k)) = WKxyz1(i,j,k) *dsigm1(k)/dsigm1(kp1(k))   
     .                                  /rolvDY(i,j,k)*rolvDY(i,j,k+1) 
        END DO
        END DO

        END DO

        DO k=   1,mmz1
        DO j=   1,my 
        DO i=   1,mx 
          WKxyz1(i,j,k) =      WKxyz1(i,j,k) * dt_dif
          WKxyz3(i,j,k) =      WKxyz3(i,j,k) * dt_dif
          WKxyz2(i,j,k) = 1.0 -WKxyz3(i,j,k) -WKxyz1(i,j,k) 
        END DO
        END DO
        END DO


C +--Second Member of the Tridiagonal System - ect_TE
C +  ------------------------------------------------

        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,1) = 
     .    WKxyz1(i,j,1) *ab*(ect_TE(i,j,1)-ect_TE(i,j,kp1(1)))
c #De     WKxyz1(i,j,1) = 0.0
c #De     WKxyz2(i,j,1) = 1.0
c #De     WKxyz4(i,j,1) = ect_DI(i,j)
        END DO
        END DO

        DO k=kp1(1),mmz2
        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,k) = 
     .    WKxyz1(i,j,k) *ab*(ect_TE(i,j,k)-ect_TE(i,j,kp1(k)))
     .   -WKxyz3(i,j,k) *ab*(ect_TE(i,j,km1(k))-ect_TE(i,j,k))
        END DO
        END DO
        END DO

        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,mmz1)=-(alpha*ect_TE(i,j,mmz1)-ect_TE(i,j,mz))
     .                 *gravi2*(TUkvm (i,j,mmz1)+TUkvm (i,j,mmz2)
c _PE.                         +pente3(i,j,mmz1)+pente3(i,j,mmz2)
c #PE.                         +pente3(i,j,mmz1)+pente3(i,j,mmz2)
     .                                                           )*0.50
     .                        * romiDY(i,j,mmz1)*romiDY(i,j,mmz1) 
     .                        /(pstDY2(i,j)*dsigm1(mmz1)*dsig_1(mmz1))
     .   -WKxyz3(i,j,mmz1) *ab*(ect_TE(i,j,mmz2)-ect_TE(i,j,mmz1))
        END DO
        END DO


C +--Tridiagonal Matrix Inversion - ect_TE 
C +  -------------------------------------

             k1= 1
c #De        k1= 2
        DO k=k1,mz
        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,k)    = WKxyz4(i,j,k) + ect_TE(i,j,k)
        END DO
        END DO
        END DO

C +         ************
       call MARgz_1mx1my(1,mmz1)
C +         ************

        DO k=1,mmz1
        DO j=   1,my 
        DO i=   1,mx 
c #TD     tranTE(i,j,k) = tranTE(i,j,k) +(WKxyz7(i,j,k)-ect_TE(i,j,k))
c #TD.                                   /dt_dif
          ect_TE(i,j,k) = WKxyz7(i,j,k)
        END DO
        END DO
        END DO


C +--Vertical Diffusion of Dissipation
C +  =================================


C +--Update Tridiagonal Matrix Coefficients - eps_TE 
C +  -----------------------------------------------

        DO k=1,mmz1
        DO j=   1,my 
        DO i=   1,mx 
          WKxyz1(i,j,k) =       WKxyz1(i,j,k) * sigek
          WKxyz3(i,j,k) =       WKxyz3(i,j,k) * sigek
          WKxyz2(i,j,k) = 1.0 - WKxyz3(i,j,k) - WKxyz1(i,j,k) 
        END DO
        END DO
        END DO


C +--Second Member of the Tridiagonal System - eps_TE
C +  ------------------------------------------------

        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,1) = 
     .    WKxyz1(i,j,1) *ab*(eps_TE(i,j,1)-eps_TE(i,j,kp1(1)))
c #De     WKxyz1(i,j,1) = 0.0
c #De     WKxyz2(i,j,1) = 1.0
c #De     WKxyz4(i,j,1) = eps_DI(i,j)
        END DO
        END DO

        DO k=kp1(1),mmz2
        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,k) = 
     .    WKxyz1(i,j,k) *ab*(eps_TE(i,j,k)-eps_TE(i,j,kp1(k)))
     .   -WKxyz3(i,j,k) *ab*(eps_TE(i,j,km1(k))-eps_TE(i,j,k))
        END DO
        END DO
        END DO

        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,mmz1)=-(alpha*eps_TE(i,j,mmz1)-eps_TE(i,j,mz))
     .                 *gravi2*(TUkvm (i,j,mmz1)+TUkvm (i,j,mmz2)
c _PE.                         +pente3(i,j,mmz1)+pente3(i,j,mmz2)
c #PE.                         +pente3(i,j,mmz1)+pente3(i,j,mmz2)
     .                                                           )*0.50
     .                        * romiDY(i,j,mmz1)*romiDY(i,j,mmz1) 
     .                        /(pstDY2(i,j)*dsigm1(mmz1)*dsig_1(mmz1))
     .   -WKxyz3(i,j,mmz1) *ab*(eps_TE(i,j,mmz2)-eps_TE(i,j,mmz1))
        END DO
        END DO


C +--Tridiagonal Matrix Inversion - eps_TE 
C +  -------------------------------------

             k1= 1
c #De        k1= 2
        DO k=k1,mz
        DO j=   1,my 
        DO i=   1,mx 
          WKxyz4(i,j,k)    = WKxyz4(i,j,k) + eps_TE(i,j,k)
        END DO
        END DO
        END DO

C +         ************
       call MARgz_1mx1my(1,mmz1)
C +         ************

        DO k=1,mmz1
        DO j=   1,my 
        DO i=   1,mx 
          eps_TE(i,j,k) = WKxyz7(i,j,k)
        END DO
        END DO
        END DO


C +--Work Arrays Reset
C +  =================

      DO k=1,mz
      DO j=   1,my 
      DO i=   1,mx 
        WKxyz1(i,j,k) = 0.00
        WKxyz2(i,j,k) = 0.00
        WKxyz3(i,j,k) = 0.00
        WKxyz4(i,j,k) = 0.00
        WKxyz7(i,j,k) = 0.00
      END DO
      END DO
      END DO

      return
      end


      subroutine TURpbl_25 (dt_dif)
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (TKE)                                   18-09-2001  MAR |
C |    Subroutine TURpbl_25 includes Second Order Turbulence Closure       |
C |                         / 2.5 Level in Mellor & Yamada hierarchy       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |   METHOD:                                                              |
C |   ^^^^^^^                                                              |
C |   This scheme contains three prognostic equations for each velocity    |
C |   variance (u'u', v'v' and w'w'). The other variances and covariances  |
C |   are computed with algebraic equations based on quasi-equilibrium     |
C |   assumption. The mixing length and the dissipation are also given by  |
C |   algebraic relations or prognostic equation (switch).                 |
C |                                                                        |
C |   REFERENCE:                                                           |
C |   ^^^^^^^^^^                                                           |
C |   This scheme is mostly based on the following references :            |
C |   - Mellor and Yamada (1982), Review of Geophysics and Space Physics,  |
C |                               vol.20, no 4, pp 851-87.                 |
C |   - Hassid and Galperin   (1983), BLM 26, pp  397- 412.                |
C |   - Galperin and Hassid   (1988), JAS 45, pp   55-  62.                |
C |   - Weissbluth and Cotton (1993), JAS 50, pp 3852-3872.                |
C |   - Sun and Ogura         (1980), JAS 37, pp 1558-1572.                |
C |   - Duynkerke & Driedoncks(1987), JAS 44, pp   43-  64.                |
C |   - Duynkerke             (1988), JAS 45, pp  865- 880.                |
C |   - K. Emanuel            (1994), Atmospheric Convection               |
C |   - Stull                 (1988), An introduction to B.L. Meteorology  |
C |                                                                        |
C |   INPUT  :                                                             |
C |   ^^^^^^^^                                                             |
C |   - itexpe: Nb of iterations                                           |
C |   - dt_dif: Local Time Step                                       (s)  |
C |   - iboucl, nboucl : print control                                     |
C |                                                                        |
C |   INPUT / OUTPUT:                                                      |
C |   ^^^^^^^^^^^^^^                                                       |
C |   - three velocity variances : u'u', v'v', w'w'               (m2/s2)  |
C |                                                                        |
C |   OUTPUT :                                                             |
C |   ^^^^^^^^                                                             |
C |   - TUkvm(i,j,k): vertical diffusion coeff. for momentum       (m2/s)  |
C |   - TUkvh(i,j,k): vertical diffusion coeff. for heat...        (m2/s)  |
C |   - zi__TE(i,j) : inversion height                                (m)  |
C |                                                                        |
C |   TEMPORARY ARRAYS :                                                   |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |   - WKxyz1 = u'v'                                             (m2/s2)  |
C |   - WKxyz2 = u'w'                                             (m2/s2)  |
C |   - WKxyz3 = v'w'                                             (m2/s2)  |
C |   - WKxyz4 = potential temperature                                (K)  |
C |   - WKxy4  = potential temperature at the surface                 (K)  |
C |   - WKxyz5 = mix.length * q                                   ( m/s2)  |
C |   - WKxyz6 = g / teta * d(teta)/dz  (first  part of the code)          |
C |              shear production       (second part of the code) (m2/s3)  |
C |   - WKxyz7 = liquid water mixing ratio                        (kg/kg)  |
C |   - WKxyz8 = buoyancy production                              (m2/s3)  |
C |   - WKxy1 and WKxy2 used for computing of L0                           |
C |                                                                        |
C | # OPTIONS:                                                             |
C | # ^^^^^^^^                                                             |
C | # #WT if the output of mixing length, buoyancy and shear is included   |
C | #        in the Netcdf file (see also #WT in MAR_BR.inc).              |
C | # #AL if alpha1=u'u'/(q*q) is fixed (surface layer).                   |
C |                                                                        |
C |   REMARK:                                                              |
C |   ^^^^^^^                                                              |
C |   Three potential temperatures are available :                         |
C |   - reduced Equivalent Potential Temperature (Duynkerke & Driedoncks), |
C |   - virtual potential temperature (Stull),                             |
C |   - liquid water virtual potential temperature (Emanuel).              |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MARSND.inc'
C +
      include 'MAR_DY.inc'
      include 'MAR_SL.inc'
      include 'MAR_TE.inc'
      include 'MAR_TU.inc'
      include 'MAR_BR.inc'
C +
c #HY include 'MAR_HY.inc'
      include 'MAR_RA.inc'
C +
      include 'MAR_WK.inc'
      include 'MAR_IO.inc'
C +
      real     dt_dif
      real     phim
C +
C +  ----------------------------------------------------------------
C +
C +--Local Variables
C +  ===============
C +
      integer i5,ijk,ilb1,ilbm,jlb1,jlbm,lsf,ix1,ix2
C +
      real    A1,A2,B1,B2,C1,C2,C3,C4,Gm,Gh,Sm,Ssh,Km,Kh,lo,lb,
     . 	      ld,karman,al,aux,dtstab,prdt,ectcrt,brunt,c1ep,c2ep,
     .	      Saddif,addifx,addify,addifz,dstr,height,shprdx,cmu,
     .	      shprdy,wrl,wth,wqv,salpha,aux1,aux2,aux3,aux4,aux5,
     .	      aux6,integrale,altd,dlt,prsx,prsy,prsz,mlmax,Sqh,
     .	      Sqv,Sqvf,Advv,Advhx,Advhy,vphih,vphim,taup,Ctau,
     .	      Kmax,two,three,six,hund,Ghmin,Ghmax,dtmax,advdif,
     .	      oneth,twoth,epv,alpha1,alpha2,alpha3,hrel,ctq,
     .        cql,kiv,gav,rtm,rlm,cpd,cpv,cpl,eps10,epse,zz,zeta,
     .        Kvmax,ddx,ddy,aux7,aux8,aux9,sig_e,TKEfil,EPSfil,dzz
C +
      logical horizt,duynk,stull,eman,proeps,prgeps,TURfil
C +
      real   diag1u(mz),diag2u(mz),diag3u(mz),tindu(mz),soltu(mz),
     .	     diag1v(mz),diag2v(mz),diag3v(mz),tindv(mz),soltv(mz),
     .       diag1w(mz),diag2w(mz),diag3w(mz),tindw(mz),soltw(mz),
     .       diag1e(mz),diag2e(mz),diag3e(mz),tinde(mz),solte(mz),
     .       ziav(mx,my),TUvm(mz),TUvh(mz),fu(mx,my),fv(mx,my),
     .       fw(mx,my),fe(mx,my)
C +
C +  ----------------------------------------------------------------
C +
C +--Choice of computing method of dissipation
C +  =========================================
C +
      data proeps /  .false. /
C +   ^.. if true , prognostic equation on dissipation (Duynkerke, 1988)
C +                 -------------------
C +    .. if false, diagnostic relation.
C +                 -------------------
C +
      prgeps=proeps.and.itexpe.ge.2 
C +   ^.. use prognostic dissipation equation after several time
C +    .. steps (for initialisation)
C +
C +  ----------------------------------------------------------------
C +
C +--Choice of the POTENTIAL TEMPERATURE
C +  ===================================
C +
C +--Caution : only one of these boolean variable must be true !
C +
      data duynk  /  .true.  /
C +   ^.. reduced Equivalent Potential Temperature (Duynkerke)
C +       ----------------------------------------
C + 
      data stull  /  .false. /
C +   ^.. virtual potential temperature (Stull)
C +       -----------------------------
C +
      data eman   /  .false. /
C +   ^.. liquid water virtual potential temperature (Emanuel)
C +       ------------------------------------------
C +
C +  ----------------------------------------------------------------
C +
C +--Filtering Turbulent Kinetic Energy
C +  ==================================
C +
      data TURfil /  .false. /
      data TKEfil/  0.50e-01 /
      data EPSfil/  0.50e-01 /
C +   ^.. filtering u'u', v'v' and w'w'
C +       -----------------------------
C +
C +  ----------------------------------------------------------------
C +
C +--DATA
C +  ====
C +
      data epv    / 0.61   / 
      data cpd    / 1005.7 /
      data cpv    / 1870.  /
C +   ^.. Thermodynamical data (K. Emanuel - Atmosph. Convection)
      data cpl    / 4218.  /
C +   ^.. Thermodynamical data (P.G. Duynkerke - Personal communication)
C +
      data karman / 0.4    /
C +   ^.. Von Karman constant
C +
      data C1     / 0.     /
C +   ^.. Constant used in the shear term of the pressure term
C +
      data C2     / 0.3    /
C +   ^.. Constant used in the pressure term (for velocities) to
C +    .. take in account the buoyancy effect (Weissbluth)
C +
      data C3     / 0.     /
C +   ^.. Constant used in the pressure term (for velocities) to
C +    .. take in account the shear effect
C +
      data C4     / 0.5    /
C +   ^.. Constant used in the pressure term (for potential temp.)
C +    .. to take in account the buoyancy effect
C +
      data c1ep   / 1.46   /
      data c2ep   / 1.83   /
      data sig_e  / 2.38   /
C +   ^.. Duynkerke, 1988, JAS (45), p. 868
C +
      data eps10  / 1.e-08 /
C +   ^.. Minimum value of dissipation
C +
      data epse   / 1.e-07 /
C +   ^.. Minimum value of turbulent kinetic energy
C +
      data Kvmax  / 10000. /
C +   ^.. Maximum value for turbulent diffusion coefficient
C +
      data oneth  / 0.333  /
      data twoth  / 0.666  /
      data two    / 2.     /
      data three  / 3.     /
      data six    / 6.     /
      data hund   / 100.   /
      data lsf    / 1      /
C +
C +  ----------------------------------------------------------------
C +
C +--Parameters
C +  ==========
C +
c #AL data alpha1 / 4.     /
c #BO data alpha2 / 2.25   /
      data alpha2 / 3.5    /
      alpha3 = alpha2
C +   ^.. Proportionality constants between variances and 
C +    .. friction velocity in the surface layer
C +    .. Ref.: Andre et al., 1978, JAS 35, p.1866
C +
      cmu=( 2./(alpha1+alpha2+alpha3) ) ** 2.
C +
      if (C1.eq.0.) then
       alpha1 = (2.*(3.-2.*C3)/(3.*(1.-C3)*alpha2)) + alpha2
      else
       aux1=3.*C1
       aux2=3.*C1*alpha2 - 3.*alpha3*(1.-C3)
       aux3=(6.-4.*C3)-6.*C1*alpha2**2.+3.*alpha2*alpha3*(1.-C3)
       alpha1 = (-aux2-SQRT(aux2*aux2-4.*aux1*aux3))/(2.*aux1)
      endif
C +   ^.. Alpha1 is determined in order to set C1 equal to 0,
C +    .. and so avoiding negative values of the stability
C +    .. Function Sm
      salpha = alpha1+alpha2+alpha3
C +
      data vphim  / 1.     /
      data vphih  / 1.     /
C +   ^.. Values from the Monin-Obukhov theory
C +
      data Ctau   / 3.     /
C +   ^.. Constant in the relaxation time for the Return to
C +    .. isotropy
C +
      A1 = SQRT(salpha)*(alpha1-alpha2)*1.5 / (Ctau*vphim)
     .                                      / (3.-2.*C3  )
      B1 = SQRT(salpha)*salpha*3.  / vphim  / (3.-2.*C3  )
      A2 = SQRT(salpha) / (3.*vphih*alpha3)
      B2 = SQRT(salpha) / vphih
C +   ^.. Proportionality constants for the mixing lengths
C +    .. (Function of the master length and dependant of
C +    .. the lower boundary conditions)
C +
c #AL C1 = max( zero , alpha3*(unun-C3)/salpha 
c #AL.	       - unun/(Ctau*A1*vphim*SQRT(salpha)) )
C +
C +  ----------------------------------------------------------------
C +
C +--Control Parameters
C +  ==================
C +
      data Sqv    / 0.2      /
C +   ^.. vertical   diffusion coefficient
C +
      data Sqh    / 0.2      /
C +   ^.. horizontal diffusion coefficient
C +
      data Advv   / 1.0      /
C +   ^.. vertical   advection coefficient (normal value = 1)
C +
      horizt=.false.
C +   ^.. horizt is true if the horizontal turbulent transport terms are
C +    .. included in 2D and 3D simulations ; false otherwise.
C +
      mmx=mx
      mmy=my
      ddx=MAX(1.,dx)
      ddy=MAX(1.,dy)
C +
      IF (mmx.eq.1) THEN
       Advhx=0.
       ilb1 =1
       ilbm =1
      ELSE
       Advhx=Advv
       ilb1 =2
       ilbm =mx-1
      ENDIF
C +
      IF (mmy.eq.1) THEN
       Advhy=0.
       jlb1 =1
       jlbm =1
      ELSE
       Advhy=Advv
       jlb1 =2
       jlbm =my-1
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Bottom boundary condition for prognostic variables
C +  ==================================================
C +
C +--Velocity variances
C +  ------------------
C +
      DO j=1,my
      DO i=1,mx
C +
       aux3=(uairDY(i,j,mz)/2.)**2.+(vairDY(i,j,mz)/2.)**2.
       if (aux3.eq.0.) then
        aux1=0.5
        aux2=0.5
       else
        aux1=(uairDY(i,j,mz)/2.)**2./aux3
        aux2=(vairDY(i,j,mz)/2.)**2./aux3
       endif
C +
       uu_TE (i,j,mz)=(alpha2+(alpha1-alpha2)*aux1)*SLuus(i,j)**2.
       vv_TE (i,j,mz)=(alpha2+(alpha1-alpha2)*aux2)*SLuus(i,j)**2.
       ww_TE (i,j,mz)=alpha3*SLuus(i,j)**2.
C +
      ENDDO
      ENDDO
C +
C +--Dissipation
C +  -----------
C +
      IF (prgeps) THEN
C +
       DO j=1,my
       DO i=1,mx
C +
        zz  =(gpmiDY(i,j,mzz)-gplvDY(i,j,mzz))*grvinv
        zeta=zz/SLlmo(i,j)
C +
        eps_TE(i,j,mz)=SLuus(i,j)**3.
     .                *(phim(zeta)/karman/zz-1./karman/SLlmo(i,j))
C +
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Initialisation
C +  ==============
C +
      DO k=1,mz
      DO j=1,my
      DO i=1,mx
C +
       uu_TE (i,j,k)=max(epse*twoth,uu_TE(i,j,k))
       vv_TE (i,j,k)=max(epse*twoth,vv_TE(i,j,k))
       ww_TE (i,j,k)=max(epse*twoth,ww_TE(i,j,k))
C +    ^.. definite positive value of the variances
C +
       ect_TE(i,j,k)=SQRT(uu_TE(i,j,k)+vv_TE(i,j,k)+ww_TE(i,j,k))
C +
C +    ^^^^^^ !! ect_TE is defined here as the variable q :
C +           ect_TE = (u'u' + v'v' + w'w') ** 0.5
C +           This transformation is performed in order to save
C +           memory space.
C +
       eps_TE(i,j,k)=max(eps10,eps_TE(i,j,k))
C +    ^.. minimum value for dissipation
C +
       WKxyz6(i,j,k)=ml_TE(i,j,k)
C +
       WKxyz7(i,j,k)=0.
c #HY.     +qwHY(i,j,k)+qrHY(i,j,k)+qiHY(i,j,k)+qsHY(i,j,k)
C +    ^.. liquid water mixing ratio
C +
      ENDDO
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Potential temperature
C +  =====================
C +
C +--Atmosphere ...
C +  --------------
C +
C +--1) Reduced Equivalent Potential Temperature (Duynkerke)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
      IF (duynk) THEN
C +
       DO k=1,mz
       DO j=1,my
       DO i=1,mx
C +
        aux =0.
c #HY.      +(qwHY(i,j,k)+qiHY(i,j,k)+qsHY(i,j,k))
        aux1=RDryAi*(1.-aux)
        aux2=cp    *(1.+aux*((cpl/cp)-1.))
        aux3=Lv_H2O-RVapor*tairDY(i,j,k)*log(qvDY(i,j,k)/qvswDY(i,j,k))
C +
        WKxyz4(i,j,k)=tairDY(i,j,k)
     .               *((sigma(k)*pstDY(i,j)+ptopDY)
     .                /(         pstDY(i,j)+ptopDY))**(-aux1/aux2)
     .               *exp(aux3*qvDY(i,j,k)/aux2/tairDY(i,j,k))
C +     ^.. JAS 44, p. 48
       ENDDO
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +--2) Potential temperature (Stull)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
      IF (stull) THEN
C +
       DO k=1,mz
       DO j=1,my
       DO i=1,mx
        WKxyz4(i,j,k)=pktaDY(i,j,k)*pcap
C +     ^.. potential temperature (complete expression)
       ENDDO
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +--3) Liquid water virtual potential temperature (Emanuel)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C + 
      IF (eman) THEN
C +
       DO k=1,mz
       DO j=1,my
       DO i=1,mx
C +
        rlm=WKxyz7(i,j,k)
        rtm=max(1.e-5,qvDY(i,j,k)+rlm)
C +
        kiv=(RDryAi+rtm*RVapor)/(cpd+rtm*cpv)
        gav=        rtm*RVapor /(cpd+rtm*cpv)
        epv= RDryAi/RVapor
C +
        WKxyz4(i,j,k)=tairDY(i,j,k)
     .        *((pstDY(i,j)+ptopDY)/(sigma(k)*pstDY(i,j)+ptopDY))**kiv
     .        *(1.-(rlm/(1.+rtm)))
     .        *(1.-(rlm/(epv+rtm)))**(kiv-1.)
     .        *(1.-(rlm/rtm))**(-gav)
     .        *exp(-Lv_H2O*rlm/(cpd+rtm*cpv)/tairDY(i,j,k))
C +     ^.. Atmospheric convection, p. 122
C +
       ENDDO
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +--Surface ...
C +  -----------
C +
C +--1) Reduced Equivalent Potential Temperature (Duynkerke)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
      IF (duynk) THEN
C +
       DO j=1,my
       DO i=1,mx
C +
        WKxy4(i,j)=TairSL(i,j)
     .            *exp(Lv_H2O*qvapSL(i,j)/cp/TairSL(i,j))
C +     ^.. JAS 44, p. 48
C +
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +--2) Potential temperature (Stull)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
      IF (stull) THEN
C +
       DO j=1,my
       DO i=1,mx
        WKxy4(i,j)=TairSL(i,j)*pcap/(pstDY(i,j)+ptopDY)**cap
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +--3) Liquid water virtual potential temperature (Emanuel)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C + 
      IF (eman) THEN
C +
       DO j=1,my
       DO i=1,mx
        rtm=max(1.e-5,qvapSL(i,j))
        kiv=(RDryAi+rtm*RVapor)/(cpd+rtm*cpv)
        WKxy4(i,j)=TairSL(i,j)*pcap/(pstDY(i,j)+ptopDY)**kiv
C +     ^.. Atmospheric convection, p. 122
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Inversion Height
C +  ================
C +
      DO j=1,my
      DO i=1,mx
       ectcrt = 0.05 *max(ect_TE(i,j,mmz1),ect_TE(i,j,mz))
       k=mz
720    continue
       k=k-1
       if (           k .eq.0     ) go to 723
       if (ect_TE(i,j,k).lt.ectcrt) go to 721
       go to 720
721    continue
       zi__TE(i,j) =  gpmiDY(i,j,k+2)+(gpmiDY(i,j,k+1)-gpmiDY(i,j,k+2))
     .                               *(ectcrt         -ect_TE(i,j,k+1))
     .                               /(ect_TE(i,j,k)  -ect_TE(i,j,k+1))
     .              - gplvDY(i,j,mzz)
       zi__TE(i,j) = zi__TE(i,j)     *grvinv
       go to 722
723    continue
       zi__TE(i,j) = gpmiDY(i,j,1)   *grvinv
722    continue
      ENDDO
      ENDDO
C +
      DO j=1,my
      DO i=1,mx
       zi__TE(i,j) = max(1.e-6,zi__TE(i,j))
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Mixing Length
C +  =============
C +
      IF (prgeps) THEN
C +
       DO k=1,mz-1
       DO j=jlb1,jlbm
       DO i=ilb1,ilbm
C +
        ml_TE(i,j,k)=ect_TE(i,j,k)**three / B1 
     .              /max(eps_TE(i,j,k),eps10)
C +
        ml_TE(i,j,k)=min(ml_TE(i,j,k),karman
     .              *(gplvDY(i,j,k)+gplvDY(i,j,k+1))/2.*grvinv)
C +
        eps_TE(i,j,k)=ect_TE(i,j,k)**three / B1 / ml_TE(i,j,k)
C +
C +     IF ((gplvDY(i,j,k)*grvinv).gt.8000.) ml_TE(i,j,k)=0.0001
C +     ^.. These lines could be necessary if the mixing length 
C +      .. takes too high values in the upper troposphere
C +
       ENDDO
       ENDDO
       ENDDO
C +
       DO j=jlb1,jlbm
       DO i=ilb1,ilbm
        ml_TE (i,j,mz)=karman*gplvDY(i,j,mz)*grvinv/2.
        eps_TE(i,j,mz)=max(ect_TE(i,j,mz)**three
     .                /(B1*ml_TE(i,j,mz)),eps10)
       ENDDO
       ENDDO
C +
      ELSE
C +
C +--Integration of ect_TE and (z*ect_TE) Functions
C +  ----------------------------------------------
C +
       DO j=jlb1,jlbm
       DO i=ilb1,ilbm
C +
        WKxy1(i,j)=0.
        WKxy2(i,j)=0.
C +
        DO k=1,mz
         height=((gplvDY(i,j,k)+gplvDY(i,j,k+1))/2.
     .                     -gplvDY(i,j,mzz))*grvinv
C +
         dzz   =(gplvDY(i,j,k)-gplvDY(i,j,k+1)) * grvinv
C +
         WKxy1(i,j)=WKxy1(i,j) + ect_TE(i,j,k)*height*dzz
         WKxy2(i,j)=WKxy2(i,j) + ect_TE(i,j,k)       *dzz
        ENDDO
C +
       ENDDO
       ENDDO
C +
       DO k=1,mz
       DO j=jlb1,jlbm
       DO i=ilb1,ilbm
C +
        height=((gplvDY(i,j,k)+gplvDY(i,j,k+1))/2.
     .                    -gplvDY(i,j,mzz))*grvinv
C +
C +--Alpha value for L0 mixing length
C +  --------------------------------
C +
C +     al=0.1+0.45*EXP(-1000.*(fcorDY(i,j)*height
C +  .                 *grvinv/ect_TE(i,j,k))**2.)
C +     ^... Galperin, 1988
C +
C +     IF (height.ge.zi__TE(i,j)) THEN
C +      al=0.2
C +     ELSE
C +	 al=0.75+1.25*height/zi__TE(i,j)
C +     ENDIF
C +     ^... Sun & Ogura, 1980
C +
        al=0.2
C +     ^... Mellor & Yamada, 1982
C +
C +--L0 mixing length
C +  ----------------
C +
        lo=al*WKxy1(i,j)/WKxy2(i,j)
C +
C +--Blackadar's mixing lenght (for unstable and neutral cases)
C +  ----------------------------------------------------------
C +
        lb=karman*height/(1.+karman*height/lo)
C +
C +--LD mixing length (for stable stratification)
C +  --------------------------------------------
C +  Upper bound on the mixing length in the case of a stable
C +  stratification in order to limit the impact of the stra-
C +  tification on the size of the eddies
C +
        IF (WKxyz6(i,j,k).gt.0.) THEN
C +
         ld=0.53*ect_TE(i,j,k)/SQRT(WKxyz6(i,j,k))
C +      ^.. Ref.: Galperin, 1983, BLM 26, p. 403
C +
        ELSE
         ld=lb
        ENDIF
C +
C +--Global mixing lenght
C +  --------------------
C +
        ml_TE(i,j,k)=MIN(lb,ld)
C +
C +--Condition in order to avoid an upper mixed layer
C +  ------------------------------------------------
C +
        IF (((gplvDY(i,j,k+2)-gplvDY(i,j,mzz))*grvinv)
     .                .gt.zi__TE(i,j).and.k.lt.(mz-3)) 
     .          ml_TE(i,j,k)=MIN(1.,ml_TE(i,j,k)/100.)
C +
       ENDDO
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
      DO k=1,mz-1
      DO j=jlb1,jlbm
      DO i=ilb1,ilbm
C +
C +--Mixing Coefficients
C +  ===================
C +
C +--Gm (momemtum) and Gh (heat) coefficients
C +  ----------------------------------------
C +
       aux  = (gplvDY(i,j,k+1)-gplvDY(i,j,k))*grvinv
       aux1 = (uairDY(i,j,k+1)-uairDY(i,j,k))/aux
       aux2 = (vairDY(i,j,k+1)-vairDY(i,j,k))/aux
C +
       Gm=ml_TE(i,j,k)**2./max(ect_TE(i,j,k)**two,epse*two)
     .                           *( aux1**two + aux2**two )
C +
       Gh=-ml_TE(i,j,k)**2.*WKxyz6(i,j,k)
     .    /max(ect_TE(i,j,k)**two,epse*two)
C +
C +--Restriction on values of Gh to meaningful solutions
C +  ---------------------------------------------------
C +  ... Ref.: Hassid and Galperin, 1983, BLM 26, pp 397-412
C +
C +--1) Unstable stratification
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
       Ghmax= 0.0233
       Gh=min(Gh,Ghmax)
C +
C +--2) Stable stratification
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
C +
       Ghmin = -0.28
       Gh=max(Gh,Ghmin)
C +
C +--Stability Functions 
C +  -------------------
C +
       dlt=ww_TE(i,j,k)/max(ect_TE(i,j,k)**two,epse*two)
C +
       Ssh=max(zero,three*A2*dlt/(unun-three*(unun-C4)*A2*B2*Gh))
C +
C +    <<< MODIFICATION - DEBUT >>>
       Sm =max(zero,((three*A1*(unun-C3)*(dlt-C1)
     .    +(three+six)*(unun-C2)*A1*A2*Ssh*Gh))
     .    /(unun-(three+six)*A1*A2*(unun-C2)*Gh))
C +    <<< MODIFICATION -  FIN  >>>
C +
C +
C +--Vertical eddy mixing coefficients
C +  ---------------------------------
C +
       Km=ml_TE(i,j,k)*ect_TE(i,j,k)*Sm
       Kh=ml_TE(i,j,k)*ect_TE(i,j,k)*Ssh
C +
       IF (.not.prgeps) THEN
        Km=(TUkvm(i,j,k)+Km)/2.
        Kh=(TUkvh(i,j,k)+Kh)/2.
C +     ^... 2 Dx filter for diffusion coefficient values
       ENDIF
C +
       IF (prgeps.and.(Km.gt.Kvmax.or.Kh.gt.Kvmax)) THEN
        ml_TE(i,j,k)=min(Km,Kh,Kvmax)/ect_TE(i,j,k)
     .              /min(Sm,Ssh)
        Km=ml_TE(i,j,k)*ect_TE(i,j,k)*Sm
        Kh=ml_TE(i,j,k)*ect_TE(i,j,k)*Ssh
       ENDIF
C +
       TUkvm(i,j,k)=Km
       TUkvh(i,j,k)=Kh
C +
C +
C +--Variances and covariances
C +  =========================
C +
C +--Velocity variances
C +  ------------------
C +
       WKxyz1(i,j,k)=6.*A1*ml_TE(i,j,k)**2.*Sm*aux1*aux2
       WKxyz2(i,j,k)=-Km*aux1
       WKxyz3(i,j,k)=-Km*aux2
C +
C +--Heat flux and TETAil variance
C +  -----------------------------
C +
       wth=-Kh*(WKxyz4(i,j,k+1)-WKxyz4(i,j,k))/aux
C +
C +--Vapor, liquid and ice fluxes and variances
C +  ------------------------------------------
C +
       wqv=-Kh*(qvDY  (i,j,k+1)-qvDY  (i,j,k))/aux
       wrl=-Kh*(WKxyz7(i,j,k+1)-WKxyz7(i,j,k))/aux
C +
C +--Buoyancy
C +  ========
C +
       aux5=0.50*(qvDY  (i,j,k)+qvDY  (i,j,kp1(k)))
       aux6=0.50*(WKxyz4(i,j,k)+WKxyz4(i,j,kp1(k)))
       aux7=0.50*(WKxyz7(i,j,k)+WKxyz7(i,j,kp1(k)))
       aux8=0.50*(qvswDY(i,j,k)+qvswDY(i,j,kp1(k)))
       aux9=0.50*(tairDY(i,j,k)+tairDY(i,j,kp1(k)))
C +
C +--1) Duynkerke Formulation (JAS 44, p. 47)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
       IF (duynk) THEN
C +
        hrel = (aux5+aux7)/aux8
C +
        IF (hrel.lt.1.) THEN
C +
C +--Unsaturated case
C +  ----------------
C +
         ctq=1.
         cql=Lv_H2O/(cp*aux9)-(1-RDryAi/RVapor)/(RDryAi/RVapor)
C +
        ELSE
C +
C +--Saturated case
C +  --------------
C +
         aux=Lv_H2O*aux8/RDryAi/aux9
         ctq=(1.+aux)/(1.+aux*Lv_H2O*RDryAi/RVapor/cp/aux9)
         cql=1.
C +
        ENDIF
C +
C +--Buoyancy following Duynkerke and Driedonks 1987
C +  -----------------------------------------------
C +
        WKxyz8(i,j,k)=(gravit*ctq/aux6) * wth 
     .               -(gravit*cql)      * (wqv+wrl)
C +
       ENDIF
C +
C +--2) Stull Formulation :
C +  ~~~~~~~~~~~~~~~~~~~~~~
C +
       IF (stull) THEN
C +
        IF (WKxyz7(i,j,k).eq.0.) THEN
         wrl =0.
        ENDIF
C +
        WKxyz8(i,j,k)=gravit / aux6 / (1.+epv*aux5-aux7)
     .               * (aux6*(epv*wqv-wrl)+wth*(1.+epv*aux5-aux7))
C +     ^.. Stull, 1988 (p. 146)
C +
       ENDIF
C +
C +--3) Liquid water virtual potential temperature (Emanuel)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C + 
       IF (eman) THEN
C +
        gav=1.6
        epv=RDryAi/RVapor
C +
        rtm =aux5+aux7
        aux1=Lv_H2O*aux8/(RVapor*aux9*aux6)
        aux2=Lv_H2O/(cpd+rtm*cpv)/aux9-1./(epv+rtm)
        aux3=MAX(0.,((wrl+wqv)/ect_TE(i,j,k))**2.
     .           +aux1*aux1*(wth/ect_TE(i,j,k))**2.
     .           -2.*aux1*(wrl+wqv)*wth/(ect_TE(i,j,k))**2.)
        aux3=SQRT(2.*aux3)
        IF ((gav*aux3).ne.0.) THEN
         aux4=(1.+(rtm-aux8)/(gav*aux3))/2.
         aux4=MIN(1.,aux4)
         aux4=MAX(0.,aux4)
        ELSE
         aux4=0.
        ENDIF
C +
        WKxyz8(i,j,k)=gravit*(1./aux6-aux2*aux4*aux1) * wth
     .               +gravit*aux2*aux4                * (wqv+wrl)
C +     ^.. Atmospheric convection, p. 294
C + 
       ENDIF
C +
C +--Other computations
C +  ------------------
C +
       WKxyz5(i,j,k)=ml_TE(i,j,k)*ect_TE(i,j,k)
C +
      ENDDO
      ENDDO
      ENDDO
C +
C +--Condition at top level
C +  ----------------------
C +
      DO j=jlb1,jlbm
      DO i=ilb1,ilbm
       WKxyz1(i,j,1)=0.
       WKxyz2(i,j,1)=0.
       WKxyz3(i,j,1)=0.
       TUkvm (i,j,1)=0.
       TUkvh (i,j,1)=0.
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Prognostic equations on u'u',v'v',w'w'
C +  ======================================
C +
      DO k=kp1(1),mz1
      DO j=jlb1,jlbm
      DO i=ilb1,ilbm
C +
C +--Source & sink terms
C +  -------------------
C +
C +--Shear production
C +  ~~~~~~~~~~~~~~~~
C +
       aux   =(gplvDY(i,j,k+1)-gplvDY(i,j,k))*grvinv
       shprdx=-2.*WKxyz2(i,j,k)*(uairDY(i,j,k+1)-uairDY(i,j,k))/aux
       shprdy=-2.*WKxyz3(i,j,k)*(vairDY(i,j,k+1)-vairDY(i,j,k))/aux
       WKxyz6(i,j,k)=shprdx+shprdy
C +
C +--Buoyancy production
C +  ~~~~~~~~~~~~~~~~~~~
C +
C +    This term is given by 2.*WKxyz8(i,j,k)
C +
C +--Dissipation
C +  ~~~~~~~~~~~
C +
       IF (.not.prgeps) THEN
        eps_TE(i,j,k)=max(ect_TE(i,j,k)**three
     .               /(B1*ml_TE(i,j,k)),eps10)
       ENDIF
C +
C +
C +--Redistribution term (pressure)
C +  ------------------------------
C +
C +--Characteric time scale for the convergence to equilibrium
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
       taup=Ctau*A1*ml_TE(i,j,k) / ect_TE(i,j,k)
C +
C +--Return to isotropy term
C +  ~~~~~~~~~~~~~~~~~~~~~~~
C +
       prsx=((ect_TE(i,j,k)**2./3.-uu_TE(i,j,k))
     .      *(1.-EXP(-dt_dif/taup)) ) / dt_dif
       prsy=((ect_TE(i,j,k)**2./3.-vv_TE(i,j,k))
     .      *(1.-EXP(-dt_dif/taup)) ) / dt_dif
       prsz=((ect_TE(i,j,k)**2./3.-ww_TE(i,j,k))
     .      *(1.-EXP(-dt_dif/taup)) ) / dt_dif
C +
C +
C +--Resolution of prognostic equations for shear, buoyancy,
C +  dissipation and pressure terms ------------------------
C +  ------------------------------
C +
C +--u'u' equation
C +  ~~~~~~~~~~~~~
C +
       prdt=max( (unun-oneth*C3)*shprdx,zero)
     .	   +max( oneth*C3*shprdy,zero)
     .	   +max( twoth*C2*WKxyz8(i,j,k),zero)
     .	   +max( prsx,zero)
C +    ^... production
       dstr=max(-(unun-twoth*C3)*shprdx,zero)
     .     +max(-oneth*C3*shprdy,zero)
     .     +max(-twoth*C2*WKxyz8(i,j,k),zero)
     .     +max(-prsx,zero)
     .     +2./3.*eps_TE(i,j,k)
C +    ^... destruction
C +
       uu_TE(i,j,k)=uu_TE(i,j,k)*(uu_TE(i,j,k)+dt_dif*prdt)
     .                          /(uu_TE(i,j,k)+dt_dif*dstr)
C +
C +--v'v' equation
C +  ~~~~~~~~~~~~~
C +
       prdt=max( (unun-twoth*C3)*shprdy,zero)
     .     +max( oneth*C3*shprdx,zero)
     .     +max( twoth*C2*WKxyz8(i,j,k),zero)
     .     +max( prsy,zero)
C +    ^... production
       dstr=max(-(unun-twoth*C3)*shprdy,zero)
     .     +max(-oneth*C3*shprdx,zero)
     .     +max(-prsy,zero)
     .     +max(-twoth*C2*WKxyz8(i,j,k),zero)
     .     +2./3.*eps_TE(i,j,k)
C +    ^... destruction
C +
       vv_TE(i,j,k)=vv_TE(i,j,k)*(vv_TE(i,j,k)+dt_dif*prdt)
     .                          /(vv_TE(i,j,k)+dt_dif*dstr)
C +
C +--w'w' equation
C +  ~~~~~~~~~~~~~
C +
       prdt=max(prsz,zero)
     .     +max( oneth*C3*shprdx,zero)
     .     +max( oneth*C3*shprdy,zero)
     .     +max( (two-(unun+oneth)*C2)*WKxyz8(i,j,k),zero)
C +    ^... production
       dstr=max(-prsz,zero)
     .     +max(-oneth*C3*shprdx,zero)
     .     +max(-oneth*C3*shprdy,zero)
     .     +max(-(two-(unun+oneth)*C2)*WKxyz8(i,j,k),zero)
     .     +2./3.*eps_TE(i,j,k)
C +    ^... destruction
C +
C +
       ww_TE(i,j,k)=ww_TE(i,j,k)*(ww_TE(i,j,k)+dt_dif*prdt)
     .                          /(ww_TE(i,j,k)+dt_dif*dstr)
C +
C +... Numerical Scheme : cfr. E. Deleersnijder, 1992 (thesis) pp.59-61
C +
      ENDDO
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Dissipation equation
C +  ====================
C +
      IF (prgeps) THEN
C +
       DO k=kp1(1),mz1
       DO j=jlb1,jlbm
       DO i=ilb1,ilbm
C +
C +--Production term
C +  ---------------
C +
        prdt = (WKxyz6(i,j,k)/2.)+max(WKxyz8(i,j,k),zero)
C +             ^.. Shear          ^.. Buoyancy production
     .       +  max(tranTE(i,j,k)/2.,zero)
C +             ^.. Turbulent transport
C +
        aux  = eps_TE(i,j,k) / (ect_TE(i,j,k)**2./2.)
C +
C +--Numerical Scheme : cfr. E. Deleersnijder, 1992 (thesis) pp.59-61
C +  ----------------
C +
        eps_TE(i,j,k) = eps_TE(i,j,k)
     .       *(eps_TE(i,j,k) + dt_dif*aux*c1ep*prdt         )
     .       /(eps_TE(i,j,k) + dt_dif*aux*c2ep*eps_TE(i,j,k))
C +
       ENDDO
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Advection and Diffusion terms of 
C +--prognostic equations on u'u', v'v' and w'w'
C +  ===========================================
C +
C +--Resolution with a direct method (LU decomposition)
C +  --------------------------------------------------
C +
      DO j=jlb1,jlbm
      DO i=ilb1,ilbm
C +
C +--Boundary conditions
C +  -------------------
C +
       diag1u(1 )=0.
       diag2u(1 )=1.
       diag3u(1 )=0.
       diag1v(1 )=0.
       diag2v(1 )=1.
       diag3v(1 )=0.
       diag1w(1 )=0.
       diag2w(1 )=1.
       diag3w(1 )=0.
       diag1u(mz)=0.
       diag2u(mz)=1.
       diag3u(mz)=0.
       diag1v(mz)=0.
       diag2v(mz)=1.
       diag3v(mz)=0.
       diag1w(mz)=0.
       diag2w(mz)=1.
       diag3w(mz)=0.
C +
C +--Implicit Euler temporal scheme
C +  ------------------------------
C +
       DO k=kp1(1),mz1
C +
        aux4=(gplvDY(i,j,k-1)-gplvDY(i,j,k+1))*grvinv/2.
        aux5=(gplvDY(i,j,k  )-gplvDY(i,j,k+2))*grvinv/2.
        aux6=(gplvDY(i,j,k  )-gplvDY(i,j,k+1))*grvinv
C +
C +--1) Advection
C +  ~~~~~~~~~~~~
C +
        aux1=dt_dif * ( min(zero,wairDY(i,j,k)/hund) / aux4 * Advv
     .                + min(zero,uairDY(i,j,k))      / ddx  * Advhx
     .                + min(zero,vairDY(i,j,k))      / ddy  * Advhy ) 
C +
        aux2=dt_dif * ( max(zero,wairDY(i,j,k+1)/hund)/aux5 * Advv
     .                + max(zero,uairDY(i,j,k))      / ddx  * Advhx
     .                + max(zero,vairDY(i,j,k))      / ddy  * Advhy ) 
C +
        diag1u(k)=aux1
        diag2u(k)=1.-aux1-aux2
        diag3u(k)=aux2
C +
        diag1v(k)=aux1
        diag2v(k)=1.-aux1-aux2
        diag3v(k)=aux2
C +
        diag1w(k)=aux1
        diag2w(k)=1.-aux1-aux2
        diag3w(k)=aux2
C +
C +
C +--2) Eddy transport
C +  ~~~~~~~~~~~~~~~~~
C +
        Kmax=max(TUkvm(i,j,k),TUkvh(i,j,k))
C +
        aux=Sqv*Kmax*dt_dif
     .     /((gplvDY(i,j,k)-gplvDY(i,j,k+1))*grvinv)**2.
C +
        Sqvf=Sqv*(30./max(30.,aux))
C +     ^.. vertical diffusion coefficient corrected
C +      .. to ensure stability
C +
        aux1=Sqvf * 0.6 / aux4 / aux6 * WKxyz5(i,j,k  ) * dt_dif
        aux2=Sqvf * 0.6 / aux5 / aux6 * WKxyz5(i,j,k+1) * dt_dif
C +
        diag1u(k)=diag1u(k)-aux1
        diag2u(k)=diag2u(k)+aux1+aux2
        diag3u(k)=diag3u(k)-aux2
C +
        diag1v(k)=diag1v(k)-aux1
        diag2v(k)=diag2v(k)+aux1+aux2
        diag3v(k)=diag3v(k)-aux2
C +
        diag1w(k)=diag1w(k)-aux1*3.
        diag2w(k)=diag2w(k)+(aux1+aux2)*3.
        diag3w(k)=diag3w(k)-aux2*3.
C +
       ENDDO
C +
       DO k=1,mz
C +
C +--Independant term of the matrix system
C +  -------------------------------------
C +
        tindu(k)= uu_TE(i,j,k)
        tindv(k)= vv_TE(i,j,k)
        tindw(k)= ww_TE(i,j,k)
C +
       ENDDO
C +
       IF (horizt) THEN
C +
        IF (mmx.gt.1.and.(i.ne.ilb1.and.i.ne.ilbm)) THEN
C +
         DO k=1,mz
C +
C +--1) Diffusion : d/dx(u'u'u')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindu(k)=tindu(k)
     .	  +1.8*Sqh*( (WKxyz5(i+1,j,k)+WKxyz5(i,j,k))/2.
     .	             *(uu_TE(i+1,j,k)-uu_TE(i,j,k))/dx
     .		   - (WKxyz5(i-1,j,k)+WKxyz5(i,j,k))/2.
     .		     *(uu_TE(i,j,k)-uu_TE(i-1,j,k))/dx )/dx
C +
C +--2) Diffusion : second part of d/dz(u'u'w')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindu(k)=tindu(k)
     .	  +1.2*Sqh*( WKxyz5(i,j,k-1)
     .	  *(WKxyz2(i+1,j,k-1)-WKxyz2(i-1,j,k-1))/dx2
     .	           - WKxyz5(i,j,k+1)
     .    *(WKxyz2(i+1,j,k+1)-WKxyz2(i-1,j,k+1))/dx2 )
     .	  /(gplvDY(i,j,k-1)-gplvDY(i,j,k+1))*gravit
C +
C +--3) Diffusion : first part of d/dx(u'v'v')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindv(k)=tindv(k)
     .    +0.6*Sqh*( (WKxyz5(i+1,j,k)+WKxyz5(i,j,k))/2.
     .               *(vv_TE(i+1,j,k)-vv_TE(i,j,k))/dx
     .             - (WKxyz5(i-1,j,k)+WKxyz5(i,j,k))/2.
     .               *(vv_TE(i,j,k)-vv_TE(i-1,j,k))/dx )/dx
C +
C +--4) Diffusion : first part of d/dx(u'w'w')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindw(k)=tindw(k)
     .    +0.6*Sqh*( (WKxyz5(i+1,j,k)+WKxyz5(i,j,k))/2.
     .               *(ww_TE(i+1,j,k)-ww_TE(i,j,k))/dx
     .             - (WKxyz5(i-1,j,k)-WKxyz5(i,j,k))/2.
     .               *(ww_TE(i,j,k)-ww_TE(i-1,j,k))/dx )/dx
C +
C +--5) Diffusion : second part of d/dx(u'w'w')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
c        tindw(k)=tindw(k) + 1.2*Sqh*
c    .	         ( WKxyz5(i+1,j,k)
c    .		  *deriv1(i+1,j,k,WKxyz2,zero,zero)
c    .		 - WKxyz5(i-1,j,k)
c    .            *deriv1(i-1,j,k,WKxyz2,zero,zero))/dx2
C +
         ENDDO
C +
        ENDIF
C +
        IF (mmy.gt.1.and.(j.ne.jm1(1).and.j.ne.jp1(my))) THEN
C +
         DO k=1,mz
C +
C +--6) Diffusion : first part of d/dy(u'u'v')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindu(k)=tindu(k)
     .	  +0.6*Sqh*( (WKxyz5(i,j+1,k)+WKxyz5(i,j,k))/2.
     .	             *(uu_TE(i,j+1,k)-uu_TE(i,j,k))/dy
     .		   - (WKxyz5(i,j-1,k)+WKxyz5(i,j,k))/2.
     .		     *(uu_TE(i,j,k)-uu_TE(i,j-1,k))/dy )/dy
C +
C +--7) Diffusion : second part of d/dy(u'u'v')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindu(k)=tindu(k)
     .	  +1.2*Sqh*( WKxyz5(i,j+1,k)
     .	  *(WKxyz1(i+1,j+1,k)-WKxyz1(i-1,j+1,k))/dx2
     .	           - WKxyz5(i,j-1,k)
     .    *(WKxyz1(i+1,j-1,k)-WKxyz1(i-1,j-1,k))/dx2 )/dy2
C +
C +--8) Diffusion : second part of d/dx(u'v'v')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindv(k)=tindv(k)
     .	  +1.2*Sqh*( WKxyz5(i+1,j,k)
     .	  *(WKxyz1(i+1,j+1,k)-WKxyz1(i+1,j-1,k))/dy2
     .		   - WKxyz5(i-1,j,k)
     .	  *(WKxyz1(i-1,j+1,k)-WKxyz1(i-1,j-1,k))/dy2 )/dx2
C +
C +--9) Diffusion : d/dy(v'v'v')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindv(k)=tindv(k)
     .	  +1.8*Sqh*( (WKxyz5(i,j+1,k)+WKxyz5(i,j,k))/2.
     .		     *(vv_TE(i,j+1,k)-vv_TE(i,j,k))/dy
     .		   - (WKxyz5(i,j-1,k)+WKxyz5(i,j,k))/2.
     .		     *(vv_TE(i,j,k)-vv_TE(i,j-1,k))/dy )/dy
C +
C +--10) Diffusion : second part of d/dz(v'v'w')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindv(k)=tindv(k)
     .	  +1.2*Sqh*( WKxyz5(i,j,k-1)
     .	  *(WKxyz3(i,j+1,k-1)-WKxyz3(i,j-1,k-1))/dy2
     .	           - WKxyz5(i,j,k+1)
     .    *(WKxyz3(i,j+1,k+1)-WKxyz3(i,j-1,k+1))/dy2 )
     .	  /(gplvDY(i,j,k-1)-gplvDY(i,j,k+1))*gravit
C +
C +--11) Diffusion : first part of d/dy(v'w'w')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
         tindw(k)=tindw(k)
     .	  +0.6*Sqh*( (WKxyz5(i,j+1,k)+WKxyz5(i,j,k))/2.
     .	             *(ww_TE(i,j+1,k)-ww_TE(i,j,k))/dy
     .		   - (WKxyz5(i,j-1,k)+WKxyz5(i,j,k))/2.
     .		     *(ww_TE(i,j,k)-ww_TE(i,j-1,k))/dy )/dy
C +
C +--12) Diffusion : second part of d/dx(v'w'w')
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
c        tindw(k)=tindw(k) + 1.2*Sqh*
c    .	         ( WKxyz5(i,j+1,k)
c    .		  *deriv1(i,j+1,k,WKxyz3,zero,zero)
c    .	 	 - WKxyz5(i,j-1,k)
c    .            *deriv1(i,j-1,k,WKxyz3,zero,zero))/dy2
C +
         ENDDO
C +
        ENDIF 
C +
       ENDIF 
C +
C +--Solving algebraic tridiagonal matrix system
C +  -------------------------------------------
C +
C +    ****************************************************
       call tridag(diag1u,diag2u,diag3u,tindu,soltu,Saddif)
C +    ****************************************************
C +
C +    ****************************************************
       call tridag(diag1v,diag2v,diag3v,tindv,soltv,Saddif)
C +    ****************************************************
C +
C +    ****************************************************
       call tridag(diag1w,diag2w,diag3w,tindw,soltw,Saddif)
C +    ****************************************************
C +
       DO k=kp1(1),mz1
C +
C +--Effect of Advection and Eddy Transport terms
C +  --------------------------------------------
C +
        addifx=(soltu(k)-uu_TE(i,j,k))/dt_dif * Saddif
        addify=(soltv(k)-vv_TE(i,j,k))/dt_dif * Saddif
        addifz=(soltw(k)-ww_TE(i,j,k))/dt_dif * Saddif
C +
        tranTE(i,j,k)=addifx+addify+addifz
C +
C +--Introducing advection and diffusion in u'u',v'v',w'w' equations
C +  ---------------------------------------------------------------
C + 
        uu_TE(i,j,k)=uu_TE(i,j,k)+dt_dif*addifx
        vv_TE(i,j,k)=vv_TE(i,j,k)+dt_dif*addify
        ww_TE(i,j,k)=ww_TE(i,j,k)+dt_dif*addifz
C +
       ENDDO
C +
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Top boundary condition for the variances
C +  ========================================
C +
      DO j=jlb1,jlbm
      DO i=ilb1,ilbm
C +
       uu_TE (i,j,1)=uu_TE(i,j,2)
       vv_TE (i,j,1)=vv_TE(i,j,2)
       ww_TE (i,j,1)=ww_TE(i,j,2)
C  +
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Filtering Turbulent kinetic energy
C +  ----------------------------------
C +
      IF (TURfil) THEN
C +
       DO k=1,mz
C +
        DO j=1,my
        DO i=1,mx
         fu(i,j) = uu_TE(i,j,k)
         fv(i,j) = vv_TE(i,j,k)
         fw(i,j) = ww_TE(i,j,k)
        ENDDO
        ENDDO
C +
C +     **************************
        call DYNfil_2H (fu,TKEfil)
C +     **************************
C +
C +     **************************
        call DYNfil_2H (fv,TKEfil)
C +     **************************
C +
C +     **************************
        call DYNfil_2H (fw,TKEfil)
C +     **************************
C +
        DO j=1,my
        DO i=1,mx
         uu_TE(i,j,k) = fu(i,j)
         vv_TE(i,j,k) = fv(i,j)
         ww_TE(i,j,k) = fw(i,j)
        ENDDO
        ENDDO
C +
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Turbulent kinetic energy
C +  ------------------------
C +
      DO k=1,mz
      DO j=1,my
      DO i=1,mx
C +
       ect_TE(i,j,k)=(uu_TE(i,j,k)+vv_TE(i,j,k)+ww_TE(i,j,k))/2.
C +
      ENDDO
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Diffusion term of prognostic equations on dissipation
C +  =====================================================
C +
      IF (prgeps) THEN
C +
C +--Resolution with a direct method (LU decomposition)
C +  --------------------------------------------------
C +
       DO j=jlb1,jlbm
       DO i=ilb1,ilbm
C +
C +--Boundary conditions
C +  -------------------
C +
        diag1e(1 )=0.
        diag2e(1 )=1.
        diag3e(1 )=0.
        diag1e(mz)=0.
        diag2e(mz)=1.
        diag3e(mz)=0.
C +
C +--Implicit Euler temporal scheme
C +  ------------------------------
C +
        DO k=kp1(1),mz1
C +
         aux4=(gplvDY(i,j,k-1)-gplvDY(i,j,k+1))*grvinv/2.
         aux5=(gplvDY(i,j,k  )-gplvDY(i,j,k+2))*grvinv/2.
         aux6=(gplvDY(i,j,k  )-gplvDY(i,j,k+1))*grvinv
C +
         aux =-cmu / sig_e * ect_TE(i,j,k  )**4./4. / eps_TE(i,j,k  )
         aux1= dt_dif / aux4 / aux6 * aux
C +
         aux =-cmu / sig_e * ect_TE(i,j,k+1)**4./4. / eps_TE(i,j,k+1)
         aux2= dt_dif / aux5 / aux6 * aux
C +
         diag1e(k)=aux1
         diag2e(k)=1.-aux1-aux2
         diag3e(k)=aux2
C +
        ENDDO
C +
C +--Independant term of the matrix system
C +  -------------------------------------
C +
        DO k=1,mz
         tinde(k)=eps_TE(i,j,k)
        ENDDO
C +
C +--Solving algebraic tridiagonal matrix system
C +  -------------------------------------------
C +
C +     *************************************************
        call tridag(diag1e,diag2e,diag3e,tinde,solte,aux)
C +     *************************************************
C +
C +--Introducing transport in dissipation prognostic equation
C +  --------------------------------------------------------
C +
        DO k=1,mz
         eps_TE(i,j,k)=max(eps10,solte(k))
        ENDDO
C +
       ENDDO
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Filtering Prognostic Dissipation
C +  --------------------------------
C +
      IF (prgeps.and.TURfil) THEN
C +
       DO k=1,mz
C +
        DO j=1,my
        DO i=1,mx
         fe(i,j) = eps_TE(i,j,k)
        ENDDO
        ENDDO
C +
C +     **************************
        call DYNfil_2H (fe,EPSfil)
C +     **************************
C +
        DO j=1,my
        DO i=1,mx
         eps_TE(i,j,k) = fe(i,j)
        ENDDO
        ENDDO
C +
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Output --> file
C +  ===============
C +
C +--Printing used constants
C +  -----------------------
C +
      IF (itexpe.eq.1) THEN
C +
       write(4,254) alpha1,alpha2,alpha3,A1,A2,B1,B2,C1,C2,C3,C4
C +
254    format (/,/,
     .	'*****************************************************',/,/,
     .	'Constant values in the Subroutine turb.f',/,
     .	'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',/,/,
     .	'Surface layer :  u''u'' = ',f6.2,' u*',/,
     .	'                 v''v'' = ',f6.2,' u*',/,
     .	'                 w''w'' = ',f6.2,' u*',/,/,
     .	'Mixing length :  A1 = ',f7.3,'   A2 = ',f7.3,/,
     .	'                 B1 = ',f7.3,'   B2 = ',f7.3,/,/,
     .	'Pressure term :  C1 = ',f7.3,' (Shear)',/,
     .	'                 C2 = ',f7.3,' (Buoyancy - velocities)',/,
     .	'                 C3 = ',f7.3,' (Shear    - velocities)',/,
     .	'                 C4 = ',f7.3,' (Buoyancy - pot. temp.)',/,/,
     .	'*****************************************************',/,/)
C +
      ENDIF
C +
C +--Printing the turbulence variables
C +  ---------------------------------
C +
      IF ((iboucl+1).eq.nboucl) THEN
C +
       DO i5=1,MIN(mx,5)
C +
        ix1=igrdIO(i5)
        ix2=jgrdIO(i5)
C +
	write(4,256) ix1,ix2,GElat0,GElon0,jdarGE,mmarGE,jhlrGE,
     .       minuGE,jsecGE,itexpe,zi__TE(ix1,ix2),SLlmo(ix1,ix2)
C +
256	format(/,/,
     .	   'SECOND ORDER TURBULENCE CLOSURE (LEVEL 2.5)',/,
     .	   '*******************************************',/,/,/,
     .     'MESH COORDINATES :  ix =',i4,'  *  iy =',i4,/,/,
     .	   'Exp. -->   Lat.=',f6.1,3x,'Long.=',f7.1,4x,
     .     'Date :',i3,'-',i2,' / ',i2,' h.',i3,' min.',i3,' sec.',
     .     '    Iter. temp. ',i6,/,/,
     .	   'Inversion height = ',f7.1,
     .	   '    Monin-Obukhov lenght = ',f7.1,/,/,/,
     .	   'Characterictics of Turbulence',/,
     .     '=============================',/,/,
     .	   'Lev. Altit.   Temp.  Pot.T. Wind_U Wind_V      TKE',
     .     '     u''u''     v''v''     w''w''    Shear Buoyancy',
     .     '  Epsilon Mix.L      Km      Kh',/,
     .     '       [m]     [K]    [K]    [m/s]  [m/s]  [m2/s2]',
     .     '  [m2/s2]  [m2/s2]  [m2/s2]  [m2/s3]  [m2/s3]',
     .     '  [m2/s3]   [m]  [m2/s]  [m2/s]',/)
C +
C +
        DO k=kp1(1),mz1
C +
         altd=((gplvDY(ix1,ix2,k)+gplvDY(ix1,ix2,k+1))/2.
     .        -gplvDY(ix1,ix2,mzz))*grvinv
C +
	 write(4,257) k,altd,
     .     (tairDY (ix1,ix2,k)+tairDY (ix1,ix2,k+1))/2.,
     .	   (WKxyz4 (ix1,ix2,k)+WKxyz4 (ix1,ix2,k+1))/2.,
     .     (uairDY (ix1,ix2,k)+uairDY (ix1,ix2,k+1))/2.,
     .	   (vairDY (ix1,ix2,k)+vairDY (ix1,ix2,k+1))/2.,
     .      ect_TE (ix1,ix2,k),
     .	    uu_TE  (ix1,ix2,k),
     .      vv_TE  (ix1,ix2,k),
     .	    ww_TE  (ix1,ix2,k),
     .      WKxyz6 (ix1,ix2,k),
     .	    WKxyz8 (ix1,ix2,k)*2.,
     .	    eps_TE (ix1,ix2,k)*(-2.),
     .      ml_TE  (ix1,ix2,k),
     .	    TUkvm  (ix1,ix2,k),
     .      TUkvh  (ix1,ix2,k)
C +
257	 format(i3,f8.0,2f8.2,2f7.2,7e9.2,f6.1,2f10.4)
C +
        ENDDO
C +
        write(4,*)
C +
       ENDDO
C +
      ENDIF
C +
C +  ----------------------------------------------------------------
C +
C +--Compute the LD mixing length for the next time step
C +  ===================================================
C +
      DO k=1,mz
      DO j=1,my
      DO i=1,mx
c #WT  shearT(i,j,k)= WKxyz6(i,j,k)/2.
c #WT  buoyTE(i,j,k)= WKxyz8(i,j,k)
        ml_TE(i,j,k)=-WKxyz8(i,j,k)/MAX(1.e-5,TUkvh(i,j,k))
C +     ^.. ml_TE is used to store [1 / (g / teta * d(teta)/dz)]
C +      ..       between two time steps (save memory space !)
      ENDDO
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +
C +--Reset of the working arrays
C +  ===========================
C +
      DO j=1,my
      DO i=1,mx
       WKxy1(i,j)=0.
       WKxy2(i,j)=0.
       WKxy4(i,j)=0.
       WKxy5(i,j)=0.
      ENDDO
      ENDDO
C +
      DO k=1,mz
      DO j=1,my
      DO i=1,mx
       WKxyz1(i,j,k)=0.
       WKxyz2(i,j,k)=0.
       WKxyz3(i,j,k)=0.
       WKxyz4(i,j,k)=0.
       WKxyz5(i,j,k)=0.
       WKxyz6(i,j,k)=0.
       WKxyz7(i,j,k)=0.
       WKxyz8(i,j,k)=0.
      ENDDO
      ENDDO
      ENDDO
C +
C +  ----------------------------------------------------------------
C +  ----------------------------------------------------------------
C +
      return
      end
      subroutine tridag(A,B,C,R,U,Sol)
C +
C +------------------------------------------------------------------------+
C | MAR SOLVE                                              14-09-2001  MAR |
C |   Subroutine tridag solves a tridiagonal matrix system                 |
C |                                                                        |
C +------------------------------------------------------------------------+
C |   METHOD:  LU decomposition                                            |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   REFERENCE:  Numerical Recipies (Press)                               |
C |   ^^^^^^^^^^                                                           |
C |                                                                        |
C |   INPUT  :  - A,B,C : diagonals of the matrix                          |
C |   ^^^^^^^^  - R : independant term of the system                       |
C |                                                                        |
C |   OUTPUT :  - U : solution of the system                               |
C |   ^^^^^^^^  - Sol : 1. if there exists a solution                      |
C |                     0. otherwise                                       |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      INCLUDE 'MARdim.inc'
C +
C +
C +--Local variables
C +  ===============
C +
      real      GAM(mz),A(mz),B(mz),C(mz),R(mz),U(mz)
      real      Sol    ,BET
      integer   J
C +
C +
C +--Solve tridiagonal system - direct method
C +  ========================================
C +
      IF(B(1).EQ.0.) THEN
       Sol=0.
       GOTO 812
      ELSE
       Sol=1.
      ENDIF
      BET=B(1)
      U(1)=R(1)/BET
      DO J=2,mz
       GAM(J)=C(J-1)/BET
       BET=B(J)-A(J)*GAM(J)
       IF(BET.EQ.0.) THEN
        Sol=0.
        GOTO 812
       ENDIF
       U(J)=(R(J)-A(J)*U(J-1))/BET
      ENDDO
      DO J=mz-1,1,-1
       U(J)=U(J)-GAM(J+1)*U(J+1)
      ENDDO
812   CONTINUE
C +
      return
      end
      subroutine TURsbl
C +                 
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ASL)                                   23-09-2002  MAR |
C |   SubRoutine TURsbl includes Turbulent Fluxes Computation in the SL    |
C |           and eventually a 1st Order Closure of Vertical Turbulence    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | INPUT  : psigDY(i,j,k): Vertical Wind Speed (Sigma Coordinate system)  |
C | ^^^^^^^^                on Level k                                     |
C |          uairDY(i,j,k): k Sigma Level Wind (x-direction)        [m/s]  |
C |          vairDY(i,j,k): k Sigma Level Wind (y-direction)        [m/s]  |
C |          pktaDY(i,j,k): Potential Temperature,                         |
C |                         divided by 100kPa**(R/Cp)                      |
C |        ! SLuqsl(i,j,n): Vertical Turbulent Flux of Moisture(kg/kg.m/s) |
C |                                                                        |
C | OUTPUT : ssvSL (i,j,k): Horizontal Wind Speed                    (m/s) |
C | ^^^^^^^^ SLuusl(i,j,n): Friction Velocity                        (m/s) |
C |          SLuus (i,j)  : Friction Velocity                        (m/s) |
C |          SLutsl(i,j,n): Vertical Turbulent Flux of Heat        (K.m/s) |
C |          SLuts (i,j)  : Vertical Turbulent Flux of Heat        (K.m/s) |
C |        ! SLuqs (i,j)  : Vertical Turbulent Flux of Moisture(kg/kg.m/s) |
C |          SLlmol(i,j,n): Monin-Obukhov Length                       (m) |
C |          SLlmo (i,j)  : Monin-Obukhov Length                       (m) |
C |          raerSL(i,j)  : Surface Aerodynamic Resistance           (s/m) |
C |          TUkvm (i,j,k): vertical diffusion coeff. for momentum  (m2/s) |
C |          TUkvh (i,j,k): vertical diffusion coeff. for heat...   (m2/s) |
C |                                                                        |
C | REFERERENCE :  Louis,        1979. BLM 17, 187--202                    |
C | ^^^^^^^^^^^    Louis et al., 1982. ECMWF 1981 Workshop                 |
C |                                                                        |
C | #OPTIONS: #_I: Louis et al., 1982  Scheme  I                           |
C | #^^^^^^^^ #VI                             VI                           |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
      include 'MAR_SL.inc'
      include 'MAR_TU.inc'
C +
c #HY include 'MAR_HY.inc'
c #BS include 'MAR_BS.inc'
C +
c #SN include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'
c #PO include 'MAR_PO.inc'
C +
      include 'MAR_WK.inc'
      include 'MAR_IO.inc'
C +
c #BS integer            loBlow
c #BS common /TURsbl_loc/loBlow
C +
C +
C +--Local  Variables
C +  ================
C +
      real    vstar(mx,my,mw)
C +
      real      cmm(mx,my,mw)
      real      cmh(mx,my,mw)
      real      cdz(mx,my,mw)
      real      cdr(mx,my,mw)
C +
      real    phimm(mx,mw)
      real    phihh(mx,mw)
C +
c #LE real     cden(mx,my,mz)
c #LE real     rich(mx,my,mz)
c #LE real    fric1(mx,my)
c #LE real    fric2(mx,my)
c #LE real     vecx(mx)
C +
c #BS real    usthr  ,usthr2 ,tfvk   ,expPom,A__Pom,B__Pom,SblPom
c #BS real    zz_pro ,exp__z ,zt_pro ,bt_pro,dz_pro,bz_pro,z__pro
c #BS real    blopro
c #Zn real    z0mlmn ,z0mlmx ,dz0mlt
c #zn real    dusta  ,dusta2
c #DS real    qqsmid ,dqs_dz ,zetam
c #SS real    us_thr ,sss__F ,sss__K ,sss__G,sss_KG
c #SS real    ust__1 ,ust__2 ,ust__3 ,ust127,ust227,ust327
c #SS real    sss__N ,ustar
C +
c #LE real    alamb  ,xarg   ,xfac1  ,xfac2 ,g2    ,ztmp1 
c #LE real    xtmp1  ,xtmp2  ,ri     ,cde   ,ri1   ,ri2   ,svx
c #EK real    turcon ,ustarr
C +
c #BS integer numpro
c #SS integer logsss
C +
      integer ncount ,isolz0 ,n      ,icount
      real    rstar  ,alors  ,rstar0 ,rstar1,rstar2,z0bsmn
      real    zetMax ,fac001 ,z0mx   ,eps2  ,septa ,vsmin ,u2min
      real    hfra   ,crit   ,ssstar ,sv2   ,dtdz  ,ziloc ,wstar
      real    theta  ,ustar2 ,thstar ,qqstar,qqsfac
      real    thstarv,thstars,thstara,s_load,Snoz0
      real    zeta   ,zeta0  ,zetah  ,ustaro,ustarv,dustr ,adustr
c #FR real    psim   ,psih   ,phim   ,phih
C +
      logical GL_run
C +
C +--DATA
C +  ====
C +
c #BS data usthr / 0.3800e0/
C +...     Threshold Friction Velocity for Blowing Snow (Budd et al., 1966)
c #BS data usthr2/ 0.0784e0/
c +...     usthr2= usthr**2
C +
c #BS data tfvk  / 0.540e0/
C +...     tfvk  = 0.216e0/0.400e0
C +                0.216m/s is an estimation of the terminal fall velocity
C +                         (Wamser & Lykossov 1995 Cont.Atm.Phy.68 p.  90)
C +                        0.400   is the Von Karman Constant
C +
c #BS data expPom /-0.54400e0/
c #BS data A__Pom /-1.55000e0/
c #BS data B__Pom / 0.05628e0/
C +...Pommeroy, Gray and Landine 1993, J. Hydrology, 144,  (7) p.169
C +   (Steady State Mass Concentration of  Suspended Snow)
C +
c #BS data SblPom / 1.27000e0/
C +...Pommeroy, Gray and Landine 1993, J. Hydrology, 144,  (8) p.169
C +   (Lower Boundary Height Parameter for Suspension)               
C +
c #zn data z0bsmn/ 1.0e-4/
c #Zn data z0bsmn/ 0.5e-6/
C +***     z0bsmn= 1.0e-4: Dry Snow Roughness Length  (MAR Publications)
C +***     z0bsmn= 1.0e-5: Dry Snow Roughness Length  (Pielke 1984, p. 143)
C +
      data ncount/ 1 /
C +
c #Zn data z0mlmn/ 1.3e-3/
c #zn data z0mlmx/ 3.2e-3/
c #zn data dz0mlt/ 5.9e-6/
C +***     z0mlmn:     Melting Snow Roughness Length
C +        z0mlmx:              Ice Roughness Length
C +        dz0mlt= 5.9e-6 = (3.2mm-1.3mm) / (920.kg/m3-600.kg/m3)
C +               (Greuell and Konzelmann    1994, Gl.Pl.Chan. 9, T1 p.98)
C +
c #Zn data z0mlmx/ 1.2e-1/
c #Zn data dz0mlt/ 3.7e-4/
C +        dz0mlt= 3.7e-4 = (12.cm-1.3mm) / (920.kg/m3-600.kg/m3)
C +               (van den Broeke and Gallee 1996, QJRMS                 )
C +
      data zetMax/ 4.28e0/
C +...     zetMax= 4.28 BakGround Stability Parameter  (stable situations)
C +                ===> phi < 12 (King et al., 1996, JGR 101 (7)  p.19121)
C +
c #SS data logsss/ 3     /
C +...     logsss: Blowing Snow Virtual Theta *
C +                1 ----> Full       Iterative Method (Bulk   Formulation)
C +                2 ----> Full       Iterative Method (Linear Formulation)
C +                3 ----> Linearized Iterative Method
C +
c #EK data turcon/ 5.0e+0/
C +***     K     = 5 m2/s : used by Alpert and Savijarvi
C +
c #LE data alamb/1.000000e-01/
C +...     alamb=1/lambda, with lambda= 10m
C +                lambda: limit mixing length for vertical turbulence
C +***                    (is used in the Louis         1979 scheme)
C +
c #_I data alamb/3.333333e-03/
C +...     alamb=1/lambda, with lambda=300m, "I"  in Louis et al., 1982
C +
c #VI data alamb/6.666667e-03/
C +...     alamb=1/lambda, with lambda=150m, "VI" in Louis et al., 1982
C +                lambda: limit mixing length for vertical turbulence
C +***                    (is used in the Louis et al., 1982 scheme)
C +
      data fac001/-4.60517e+01/
C +...exp(-x/0.1)=0.01 ===> x = -4.60517d+01 
C +                    roughness length X 0.01 if frazil thickness = 10 cm
C +
      data z0mx /2.000000e+00/
      data eps2 /1.000000e-02/
      data septa/7.000000e+01/
C +
      data vsmin/1.000000e-02/
      data u2min/0.000613e+00/
C +
c #BS data loBlow/0/
C + 
C + 
C +--Initialisations
C +  ===============
C +
      GL_run = .false.
      GL_run = .true.
C +
C +--Suspension Layer: Blowing Snow Profile
C +  --------------------------------------
C +
c #BS IF     (loBlow.eq.0)                                        THEN
c #BS         loBlow =  1
C +
c #BS         write(4,4000) 
 4000         format(/,' Blowing Snow Profile:',
     .               /,' =====================',
     .              //,'   n |    z[m] | Concentration |',
     .               /,'-----+---------+---------------+')
c #BS         zz_pro    =                0.0e-2
c #BS         exp__z    =                1.0
c #BS                n  =                1
c #BS         zt_pro    =                0.0
c #BS         bt_pro    =                0.0
C +
 300    CONTINUE
c #BS         dz_pro    =      1.0e-2    /exp__z
c #BS         zz_pro    =      zz_pro+    dz_pro
c #BS         exp__z    = exp( expPom*log(zz_pro))
c #BS         bz_pro    = exp(-A__Pom*    exp__z)
c #BS         bt_pro    =      bt_pro    +bz_pro *dz_pro
c #BS     IF (zz_pro    .gt.          n         )                 THEN
c #BS         z__pro    =                 zz_pro
c #BS         BS_pro(n) =      bt_pro    /zz_pro
c #BS         write(4,4001) n, z__pro    ,BS_pro(n)
 4001         format( i4,' |',f8.2,' |',f14.6,' |')
c #BS         n         =             n  +1
c #BS     END IF
C +
c #BS     IF (n         .gt.              nn_pro)            GO TO 301
c #BS   GO TO 300
 301    CONTINUE
C +
c #BS     write(4,4002) 
 4002     format('-----+---------+---------------+',/,1x)
C +
c #BS END IF
C +
C +
C +--Constants
C +  ---------
C +
      hfra   = 0.00
      crit   = 0.50 / pcap
      ssstar = 0.00
C +
C +
C +--Roughness Length
C +  ----------------
C +
      do 150 j =1,my
      do 150 i =1,mx
c #PO hfra =  min(zero,fac001*hfraPO(i,j))
C +
                                                    isolz0=isolSL(i,j)
c #SN if (zl_SL.le.z0bsmn.and.dzSNow(i,j,1).gt.0.0) isolz0=3
C +...    allows blowing Snow over Land Surfaces covered by Snow
C +
      go to (1501,1502,1503,1504,1504)              isolz0
C +
C +  1) Ocean
C +  ~~~~~~~~
C +
 1501 continue
c #ZS   SL_z0(i,j,1) = 1.6d-2 *SLuusl(i,j,1) *SLuusl(i,j,1) *grvinv
c #ZS.               * exp(hfra) ! Charnock's relationship
c #ZS   SL_z0(i,j,1) = min(z0mx,SL_z0(i,j,1))
c #ZS   SL_z0(i,j,1) = max(epsi,SL_z0(i,j,1))
C +***   Lower Limit : Roughness Length over Ice Surfaces 
C +                    (Pielke, 1984, p.143)
C +
c #ZS   IF (GL_run)          THEN
c #ZS   sv2           = max((uairDY(i,j,mz-2)*uairDY(i,j,mz-2)
c #ZS.                      +vairDY(i,j,mz-2)*vairDY(i,j,mz-2)),epsi)
c #ZS   sv2           = sqrt(sv2)
c #ZS   if (sv2 .lt. 2.5)   then ! smooth surface
c #ZS    SL_r0(i,j,1) = SL_z0(i,j,1) 
c #ZS   else                     ! Rough surface
c #ZS    rstar        = SL_z0(i,j,1) *  SLuusl(i,j,1) / akmol
c #ZS    SL_r0(i,j,1) = SL_z0(i,j,1) / exp((2.5*sqrt(sqrt(rstar)))
c #ZS.                - 2.0)     ! Garratt's relationship
c #ZS   endif
c #ZS   ELSE
c #ZS    SL_r0(i,j,1) = 1.0d-1 * SL_z0(i,j,1)
c #ZS   END IF
C +
      go to 1500
C +
C +  2) Polynya
C +  ~~~~~~~~~~
C +
 1502 continue
c #ZS  if (nSLsrf(i,j).eq.2) then
c #ZS   SL_z0(i,j,2) = 1.6d-2 *SLuusl(i,j,2) *SLuusl(i,j,2) *grvinv
c #ZS.                        *exp(hfra)
c #ZS   SL_z0(i,j,2) = min(z0mx,SL_z0(i,j,2))
c #ZS   SL_z0(i,j,2) = max(epsi,SL_z0(i,j,2))
C +***   Lower Limit : Roughness Length over Ice Surfaces 
C +                    (Pielke, 1984, p.143)
c #ZS   SL_r0(i,j,2) = 1.0d-1 * SL_z0(i,j,2)
c #ZS  end if
C +
C +  3) Sea Ice
C +  ~~~~~~~~~~
C +
       IF (GL_run) THEN
        SL_z0(i,j,1) = 0.001
        rstar        = SL_z0(i,j,1) *  SLuusl(i,j,1) / akmol
C ......Andreas with z0 = 1mm 
C ......Following Denby(2000) research and Smeets(2000)
        rstar   = min(rstar,thous)
        rstar   = max(rstar,epsi)
        alors   = log(rstar)
        if (rstar.lt.0.135) then
          rstar0 = 1.250
          rstar1 = 0.000
          rstar2 = 0.000
        else
         if (rstar.lt.2.500) then
          rstar0 = 0.149
          rstar1 =-0.550
          rstar2 = 0.000
         else
          rstar0 = 0.317 
          rstar1 =-0.565
          rstar2 =-0.183
         end if
        end if
        SL_r0(i,j,1) = 0.001
     .               * exp(rstar0+rstar1*alors+rstar2*alors*alors)
       END IF
      go to 1500
C +
C +  4) Snow Surface
C +  ~~~~~~~~~~~~~~~
 1503 continue
C +
C +- Melting  occurred
c #Zn  if (ro_SL(i,j).gt.0.0) then
c #Zn      SL_z0(i,j,1) =     z0mlmn+dz0mlt * (ro_SL(i,j)-600.0)
c #Zn      SL_z0(i,j,1) = max(z0mlmn,          SL_z0(i,j,1))
C +        SL_z0(i,j,1) = [1.2mm;3.2mm]
C +***        z0 here   : Roughness Length over melt. Snow Surfaces
C +                      (Greuell and Konzelmann 1994, Gl.Pl.Chan. 9, T1 p.98)
C +
c #Zn      IF (GL_run) THEN  
c #Zn       if ((nsSNow(i,j).eq.niSNow(i,j))
c #Zn.           .and.(maskSN(i,j).eq. 90)) then 
c #Zn        SL_z0(i,j,1) = 0.050
C +          SL_z0(i,j,1) = [50 mm; 120 mm]
c #Zn       endif
c #Zn      END IF
C + Old ice value and not superimposed ice value (is maybe not always stable)
C + This value is between the 120 mm value of Broeke and the 50 mm of Bruce.
C + Smeets indicate also 50 mm
C +
c #Zn  else  
C +
C +- No Melting Effect
c #zn   dusta        = max(zero, SLuusl(i,j,1) -SaltSL(i,j))
c #zn   dusta2       =           dusta         *dusta 
c #zn   Snoz0        = 1.6d-2  * dusta2 *grvinv+z0bsmn
C +***     z0 here   : Roughness Length over dry   Snow Surfaces
C +                   (Chamberlain            1983, BLM        25,  p.406)
C +- No Melting Effect
c #Zn   Snoz0        =-61.8d-6 + SLuusl(i,j,1) *SLuusl(i,j,1) * 0.536d-3
c #Zn   Snoz0        = max(z0bsmn,Snoz0)
C +
C +***     z0 here   : Roughness Length over dry   Snow Surfaces
C +                   (Fit on Budd et al.     1966  Data)
c #Zn   SL_z0(i,j,1) = fracSL*Snoz0 + (1.0-fracSL)* SL_z0(i,j,1)         
c #Zn  end if
C +
c #RN   rstar   = SL_z0(i,j,1) *  SLuusl(i,j,1) / akmol 
C +
c #RN   IF (GL_run) THEN
c #RN   rstar   = 0.001        *  SLuusl(i,j,1) / akmol
c #RN   END IF
C +     Andreas with z0 = 1mm
C +     Following Denby(2000) research and Smeets(2000)
C +
c #RN   rstar   = min(rstar,thous)
c #RN   rstar   = max(rstar,epsi)
c #RN   alors   = log(rstar)
c #RN   if (rstar.lt.0.135) then
c #RN     rstar0 = 1.250
c #RN     rstar1 = 0.000
c #RN     rstar2 = 0.000
c #RN   else 
c #RN    if (rstar.lt.2.500) then
c #RN     rstar0 = 0.149
c #RN     rstar1 =-0.550
c #RN     rstar2 = 0.000
c #RN    else
c #RN     rstar0 = 0.317
c #RN     rstar1 =-0.565
c #RN     rstar2 =-0.183
c #RN    end if
c #RN   end if
c #RN   SL_r0(i,j,1) = SL_z0(i,j,1)
c #RN.               * exp(rstar0+rstar1*alors+rstar2*alors*alors)
c #RN   IF (GL_run) THEN
c #RN   SL_r0(i,j,1) = 0.001
c #RN.               * exp(rstar0+rstar1*alors+rstar2*alors*alors)
c #RN   END IF
C +***  SL_r0: cfr. Andreas 1987, BLM 38, 159--184

C +***  SL_r0: cfr. Andreas 1987, BLM 38, 159--184
C +            usually 0.01 < R* < 1000.
      go to 1500
C +
C +  5) Soil
C +  ~~~~~~~
 1504 continue
C +
c #RN   IF (GL_run) THEN
c #RN   SL_z0(i,j,1) = 0.012    ! Snow-free tundra
C +     Meesters       (10mm)
C +     van den Broeke (12mm)
C +     Bruce takes    (20mm)
c #RN   SL_r0(i,j,1) = SL_z0(i,j,1) / exp(2.0) ! Garrat p 90/Bruce 
C +     Comment: Snow on top of tundra does not influence SL_z0 value
C +     ¨¨¨¨¨¨¨¨
c #RN   END IF
C +
        go to 1500
 1500   continue
C +
 150    continue
C +
C +
C +--Work Arrays
C +  -----------
C +
      DO k = 1,mz
         DO j = 1,my
            DO i = 1,mx
               WKxyz1(i,j,k) =  (gplvDY(i,j,k)  -gplvDY(i,j,k+1))*grvinv
               WKxyz2(i,j,k) =  (gplvDY(i,j,k+1)-gplvDY(i,j,mzz))*grvinv
     &                   + 0.5 * WKxyz1(i,j,k)  + SL_z0(i,j,1)
C +...CAUTION: the same SL_z0 is used here for both sectors of gridbox
C +            (assumption having a negligible effect)
               WKxyz3(i,j,k) = vonkar*WKxyz2(i,j,k)
c #LE          WKxyz4(i,j,k) = WKxyz3(i,j,k) 
c #LE&                 /(1.0 + WKxyz3(i,j,k)*alamb)
c #LE          WKxyz5(i,j,k) = WKxyz4(i,j,k)*WKxyz4(i,j,k)
            END DO
         END DO
      END DO
C +
      DO j = 1,my
         DO i = 1,mx
           sv2           = max((uairDY(i,j,mz)*uairDY(i,j,mz)
     .                         +vairDY(i,j,mz)*vairDY(i,j,mz)),epsi)
           ssvSL(i,j,mz) = sqrt(sv2)
           WKxy1(i,j)    = TairSL(i,j)    / (pstDY(i,j)+ptopDY)**cap
C +...     Takes Surface Air Temperature
C +
         END DO
      END DO
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ TURBULENT CHARACTERISTICS OF THE SURFACE LAYER +++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +
C +--Local Inversion Height
C +  ======================
C +
      do 199 j=1,my
      do 109 i=1,mx
      do 109 n=1,nSLsrf(i,j)
C +
C +
C +--Unstable Case
C +  -------------
C +
      if (SLutsl(i,j,n).lt.0.0.and.mmz.gt.1) then
C +
C +--Local Inversion Height
C +  ~~~~~~~~~~~~~~~~~~~~~~
C +do while
       k = mz
C +begin dowhile
  101  continue
       if (k.eq.1.or.(pktaDY(i,j,k)  -pktaDY(i,j,k+1)).gt.crit)goto 100
       k = k - 1
       go to 101
  100  continue
C +end do while
C +
        dtdz       = (pktaDY(i,j,k)  -pktaDY(i,j,k+1))/WKxyz1(i,j,k)
        ziloc      = (gplvDY(i,j,k+1)-gplvDY(i,j,mzz))*grvinv+crit/dtdz
C +
C +--Convective Friction Velocity V*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        wstar         = exp(third*log(-gravit*SLutsl(i,j, n)*ziloc
     .                                      /(pktaDY(i,j,mz)*pcap)))
C +
       if (ssvSL(i,j,mz).lt.wstar) then
         vstar(i,j,n) = max(wstar       , vsmin)
       else
         vstar(i,j,n) = max(ssvSL(i,j,mz),vsmin)
       end if
C +
C +
C +--Stable   Case
C +  -------------
C +
      else
        ziloc        = 0.3*SLuusl(i,j,n)/(abs(fcorDY(i,j))+epsi)
C +***  cfr. Therry and Lacarrere, BLM 25 (1983) p.75
C +
        vstar(i,j,n) = max(ssvSL(i,j,mz),vsmin)
      end if
 109  continue
C +
C +
C +--Neutral Drag Coefficient
C +  ========================
C +
             k=  mz
      do 111 i=1,mx
       cdz  (i,j,1) = log((WKxyz1(i,j,k)+SL_z0(i,j,1))/SL_z0(i,j,1))
       cdr  (i,j,1) = log((WKxyz1(i,j,k)+SL_r0(i,j,1))/SL_r0(i,j,1))
       cdmSL(i,j,1) = vonkar /cdz(i,j,1)
       cdhSL(i,j,1) = vonkar /cdr(i,j,1)
       cdnSL(i,j,1) = cdmSL(i,j,1)
       cmm  (i,j,1) = cdmSL(i,j,1)      *cdmSL(i,j,1)
       cmh  (i,j,1) = cdmSL(i,j,1)      *cdhSL(i,j,1)
c #DR  cmh  (i,j,1) = cdmSL(i,j,1)      *cdhSL(i,j,1)
c #BU  cmh  (i,j,1) = cdmSL(i,j,1)      *cdhSL(i,j,1) /0.74
 111  continue
C +
      do 112 i=1,mx
      if (nSLsrf(i,j).eq.2) then
       cdz  (i,j,2) = log((WKxyz1(i,j,k)+SL_z0(i,j,2))/SL_z0(i,j,2))
       cdr  (i,j,2) = log((WKxyz1(i,j,k)+SL_r0(i,j,2))/SL_r0(i,j,2))
       cdmSL(i,j,2) = vonkar /cdz(i,j,2)
       cdhSL(i,j,2) = vonkar /cdr(i,j,2)
       cmm  (i,j,2) = cdmSL(i,j,2)      *cdmSL(i,j,2)
       cmh  (i,j,2) = cdmSL(i,j,2)      *cdhSL(i,j,2)
c #DR  cmh  (i,j,2) = cdmSL(i,j,2)      *cdhSL(i,j,2)
c #BU  cmh  (i,j,2) = cdmSL(i,j,2)      *cdhSL(i,j,2) /0.74
      end if
 112  continue
C +
C +
C +--Friction Velocity u*, ut*, LMO
C +  ==============================
C +
      do 125 i=1,mx
C +
C +--Arbitrary Initial Values
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
      phimm(i,2)=1.0
      phihh(i,2)=1.0
C +
C +
C +--Initial Values
C +  --------------
C +
      theta      = 0.500* pcap *(pktaDY(i,j,mz)  + pktaDY(i,j,mzz))
C +...theta      : Layer Averaged 'Potential Temperature'
C +
C +--Loading
C +  ~~~~~~~
c #BS s_load     = -                 qsHY(i,j,mz)
c #BV s_load     =                  virSL(i,j)
C +
      do 122 n=1,nSLsrf(i,j)
C +
C +--u*
C +  ~~
      SLuusl(i,j,n) = max(SLuusl(i,j,n),eps2)
      ustar2     =        SLuusl(i,j,n)*SLuusl(i,j,n)
C +
C +--Other Turbulent Scales
C +  ~~~~~~~~~~~~~~~~~~~~~~
      thstar     =                 SLutsl(i,j,n)    /SLuusl(i,j,n)
      qqstar     =                 SLuqsl(i,j,n)    /SLuusl(i,j,n)
c #BS ssstar     =                 uss_HY(i,j)      /SLuusl(i,j,n)
C +
C +--Virtual Theta *
C +  ~~~~~~~~~~~~~~~
c #SS go to (131,131,133) logsss
 131  continue
      thstarv    =        thstar +theta *(0.608*qqstar-ssstar)
c #BS.                                  /(1.000+s_load)
c #SS go to 139
 133  continue
c #SS thstarv    =        thstar +theta *(0.608*qqstar       )
c #SS.                                  /(1.000+s_load)
c #SS go to 139
 139  continue
C +
      thstars    =   sign(unun,thstarv)
      thstara    =    abs(     thstarv)
      thstarv    =    max(epsi,thstara)                 *thstars
C +
C +--Monin Obukhov Length
C +  ~~~~~~~~~~~~~~~~~~~~
      SLlmol(i,j,n) = theta  * ustar2 /(vonkar * gravit *thstarv)
C +
C +--Normalized Heights
C +  ~~~~~~~~~~~~~~~~~~
       zeta  =  WKxyz1(i,j,k)    / SLlmol(i,j,n)
      IF                          (SLlmol(i,j,n) .gt.0.d+00)  THEN
       zeta  = min(zetMax,zeta)
C +...             zetMax=4.28 ===> phi < 12 
C +               (King et al. 1996 JGR 101(7) p.19121)
C +
       SLlmol(i,j,n) = WKxyz1(i,j,k) / zeta
      END IF
C +
       zeta0 =   SL_z0(i,j,n)    / SLlmol(i,j,n)
       zetah =   SL_r0(i,j,n)    / SLlmol(i,j,n)
C +
C +
C +--Recurrence
C +  ----------
C +
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if (SBLitr.and.(.not.(vegmod.and.isolSL(i,j).ge.4)))        THEN
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
C +dowhile
       icount    =            0
  121  continue
       icount    = icount   + 1
C +
       ustaro    = SLuusl(i,j,n)
       ustarv    = SLuusl(i,j,n)
C +
C +--New Drag Coefficients
C +  ~~~~~~~~~~~~~~~~~~~~~
C +                                      ****       ****
c #FR  cdmSL(i,j,n) = vonkar/(cdz(i,j,n)-psim(zeta)+psim(zeta0))
c #FR  cdhSL(i,j,n) = vonkar/(cdr(i,j,n)-psih(zeta)+psih(zetah)) 
C +                                      ****       ****
C +
c #BU  cdhSL(i,j,n) =       cdhSL(i,j,n) / 0.74
C +
       cmm  (i,j,n) =       cdmSL(i,j,n) * cdmSL(i,j,n)
       cmh  (i,j,n) =       cdmSL(i,j,n) * cdhSL(i,j,n)
C +
c #BU  cmh  (i,j,n) =         cmh(i,j,n) / 0.74
C +
C +--New Momentum     Turbulent Scale u*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       SLuusl(i,j,n)= cdmSL(i,j,n)* vstar(i,j,n)
       SLuusl(i,j,n)=          max(SLuusl(i,j,n),eps2)
       ustar2       =              SLuusl(i,j,n)*SLuusl(i,j,n)
C +
C +--New Temperature  Turbulent Scale theta*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       thstar       = cdhSL(i,j,n)*pcap*(pktaDY(i,j,mz)-tsrfSL(i,j,n) 
     .                                 /exp(cap*log(pstDY(i,j)+ptopDY)))
c #NL  thstar       = 0.0
C +*** Nearly Neutral Layer Test (Duynkerke 1988 JAS 45, No 5 p.875 Last Line)
C +
       SLutsl(i,j,n)=        thstar *SLuusl(i,j,n)
C +
C +--New Humidity     Turbulent Scale qq*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       qqstar       =SLuqsl(i,j,n)/SLuusl(i,j,n)
       qqsfac       =0.0
C +
C +--New Blowing Snow Turbulent Scale (Bulk  Method)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SS  go to (141,142,149) logsss
 141   continue
c #BS  u_stBS(i,j)=(1.0-fracSL) *u_stBS(i,j) +fracSL      *SLuusl(i,j,1)
c #BS  hSalBS(i,j)= 8.436e-2*exp(SblPom  *log(u_stBS(i,j)))
c #BS  qsrfHY(i,j)=(u_stBS(i,j) *u_stBS(i,j) -SaltSL(i,j) *SaltSL(i,j))
c #BS.            /(u_stBS(i,j) *3.25        *gravit      *hSalBS(i,j))
c #BS  qsrfHY(i,j)=          max(zero                     ,qsrfHY(i,j))
c #BS  ssstar     =  cdmSL(i,j,n)           *(qsHY(i,j,mz)-qsrfHY(i,j))
c #BS  ssstar     =  min(ssstar ,zero)
C +
c #BS  qqsfac     = qsrfHY(i,j)
c #BS.                *exp(A__Pom*(exp(expPom*log(B__Pom*ustarv))))
c #SS  go to 149
C +
C +--New Blowing Snow Turbulent Scale (Local Method)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 142   continue
c #DS  exp__z     =               exp( expPom*log(WKxyz2(i,j,mz)))
c #DS  qqsmid     = qqsfac       *exp(-A__Pom*exp__z)
c #DS  dqs_dz     =-qqsmid*A__Pom*     expPom*exp__z    /WKxyz2(i,j,mz)
c #DS  zetam      = WKxyz2(i,j,k)    / SLlmol(i,j,n)
c #DS if                              (SLlmol(i,j,n) .gt.0.d+00) 
c #DS. zetam  = min(zetMax,zetam)
C +...              zetMax=4.28 ===> phi < 12 
C +                (King et al. 1996 JGR 101(7) p.19121)
C +
c #DS  ssstar     = dqs_dz*vonkar* WKxyz2(i,j,mz) / phim(zetam)
c #DS  ssstar     =  min(ssstar ,zero)
C +
c #SS  go to 149
 149   continue
C +
C +--New Virtual Theta *
C +  ~~~~~~~~~~~~~~~~~~~
c #SS  go to (161,161,163) logsss
 161   continue
       thstarv    =      thstar +theta *(0.608*qqstar-ssstar)
c #BS.                                 /(1.000+s_load)
c #SS  go to 169
 163   continue
c #SS  thstarv    =      thstar +theta *(0.608*qqstar       )
c #SS.                                 /(1.000+s_load)
c #SS  go to 169
 169   continue
C +
       thstars    = sign(unun,thstarv)
       thstara    =  abs(     thstarv)
       thstarv    =  max(epsi,thstara)                   *thstars
C +
C +--New Monin Obukhov Length
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
       SLlmol(i,j,n) = theta  * ustar2 /(vonkar * gravit *thstarv)
C +
C +--New Normalized Heights
C +  ~~~~~~~~~~~~~~~~~~~~~~
       zeta  =  WKxyz1(i,j,k)    / SLlmol(i,j,n)
      IF                          (SLlmol(i,j,n) .gt.0.d+00)  THEN
       zeta  = min(zetMax,zeta)
C +...             zetMax=4.28 ===> phi < 12 
C +               (King et al. 1996 JGR 101(7) p.19121)
C +
       SLlmol(i,j,n) = WKxyz1(i,j,k) / zeta
      END IF
C +
       zeta0 =   SL_z0(i,j,n)    / SLlmol(i,j,n)
       zetah =   SL_r0(i,j,n)    / SLlmol(i,j,n)
C +
C +--New u* and Blowing Snow Turbulent Scale (Linear Method)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SS  if (logsss.eq.3) then
c #SS      us_thr  =              SaltSL(i,j)
c #S0      us_thr  =              0.38
C +...     us_thr  :  Threshold Friction Velocity 
C +...     us_thr  :  Here Fit on Byrd Snow Project Data (Budd et al. 1966)
C +
c #SS      sss__F  = (cdz(i,j,n) -psim(zeta))
c #SS      sss__K  =  cmm(i,j,n) *gravit *  6.0 
c #SS.            *WKxyz2(i,j,mz)         /(1.0+s_load)
c #SS      sss__G  =  0.27417    *gravit
c #S0      sss__G  =  0.56200
C +...     sss__G  :  Here Fit on Byrd Snow Project Data (Budd et al. 1966)
C +                   0.562     = 1/1.78
C +
c #SS      sss_KG  =  sss__K    / sss__G
c #SS      ust__1  =  1.0000    / us_thr
c #SS      ust__2  =  ust__1    * ust__1 *     sss__K *qsHY(i,j,mz)
c #SS      ust__3  =  ust__1    * ust__2
c #SS      ust127  =  2.0000    * sss_KG *exp(-SblPom * log(us_thr))
c #S0      ust127  =  sss_KG 
C +...     ust127  :  Here Fit on Byrd Snow Project Data (Budd et al. 1966)
C +
c #SS      ust227  =  ust__1    * ust127
c #SS      ust327  =  ust__1    * ust227
C +
c #SS      sss__N  =  vonkar    * vstar(i,j,n)
c #SS      ustar   =  sss__N
c #SS.             * (1.0000 +        3.00 * ust__2 + ust227)
c #SS.             / (sss__F +sss__N*(2.00 * ust__3 + ust327))
C +
c #SS   if (ustar.lt.us_thr) then 
c #SS       ustar  =  sss__N /sss__F
c #SS      ssstar  =  zero
c #SS   else
c #SS      hSalBS(i,j)= 8.436d-2 *exp(SblPom  *log(ustar))
c #SS      qsrfHY(i,j)=(ustar *ustar -us_thr  *    us_thr)
c #SS.                /(ustar *3.250 *gravit      *hSalBS(i,j))
c #S0      qsrfHY(i,j)=(ustar        -us_thr             )   *1.78
C +
c #SS      qsrfHY(i,j)=   max(zero                ,qsrfHY(i,j))
c #SS      ssstar     = cdmSL(i,j,n)*(qsHY(i,j,mz)-qsrfHY(i,j))
c #SS      ssstar     =   min(zero                ,ssstar)
c #SS   end if
c #SS      thstarv =      thstar +theta * (0.608 * qqstar -ssstar)
c #SS.                                  / (1.000 + s_load)
c #SS      thstars = sign(unun,thstarv)
c #SS      thstara =  abs(     thstarv)
c #SS      thstarv =  max(epsi,thstara)                      *thstars
C +
C +--New Monin Obukhov Length
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
c #SS      SLlmol(i,j,n) = theta  * ustar2 /(vonkar * gravit *thstarv)
c #SS      zeta          = WKxyz1(i,j,k)   / SLlmol(i,j,n)
c #SS     IF                          (SLlmol(i,j,n) .gt.0.d+00)  THEN
c #SS      zeta      = min(zetMax,zeta)
C +...                     zetMax=4.28 ===> phi < 12
C +                       (King et al. 1996 JGR 101(7) p.19121)
C +
c #SS      SLlmol(i,j,n) = WKxyz1(i,j,k) / zeta
c #SS     END IF
c #SS  end if
C +
C +--New Blowing Snow Turbulent Scale (Summary)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS   uss_HY(i,j)=      ssstar  *ustarv
C +...  uss_HY(i,j) : Blowing Snow Turbulent Flux in the Surface Layer
C +
         dustr    = SLuusl(i,j,n) - ustaro
        adustr    = abs(dustr)
C +
C +    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       if (mmx.eq.1.and.IO_loc.ge.7) then
C +    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        write(4,126) itexpe,icount,n  
     .      , ssvSL(i,j,mz),    SL_z0(i,j,n) *1.d3,SLlmol(i,j,n)
     .      ,SLuusl(i,j,n),     vstar(i,j,n)      ,  zeta                
     .      ,SLutsl(i,j,n)
c #BS.      ,uss_HY(i,j) *1.d3,ssstar*1.d3
 126    format(/,' --- TURsbl --- It.',i6,2i3,
     .       '  V  =',f8.2,  '  z0 =',f8.3,' mm  Lmo=',d10.3,
     . /,31x,'  u* =',f6.3,'    V* =',f8.3,'    zeta=', f6.3,
     . /,31x,'  uT*=',f6.3,
     . /,31x,'  uS*=',f6.3,'    S* =',f6.3,'  X 1000',/,1x)
C +
C +    ~~~~~~
       end if
C +    ~~~~~~
C +
       if (adustr.lt.1.0d-2) go to 120
       if (icount.ge.ncount) go to 120
C +
       go to 121
C +continue dowhile
C +
 120   continue
C +end dowhile
C +
C +   ~~~~
      else
C +   ~~~~
C +
C +--New Drag Coefficients
C +  ~~~~~~~~~~~~~~~~~~~~~
C +                                      ****       ****
c #FR  cdmSL(i,j,n) = vonkar/(cdz(i,j,n)-psim(zeta)+psim(zeta0))
c #FR  cdhSL(i,j,n) = vonkar/(cdr(i,j,n)-psih(zeta)+psih(zetah)) 
C +                                      ****       ****
C +
C +   ~~~~~~
      end if
C +   ~~~~~~
C +
C +--Blowing Snow Concentration below level mz+1/2
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS  qsHY(i,j,mzz)= hSalBS(i,j)                  *qsrfHY(i,j)
c #BS.         +(unun-hSalBS(i,j))         *qqsfac *BS_pro(1)
C +
c #BS  numpro       = 2
c #BS  blopro       = 0.0
 10    continue
c #BS  blopro       = blopro + BS_pro(numpro)
c #BS  numpro       = numpro + 1
c #BS  if (numpro.gt.WKxyz2(i,j,k)) go to 11
c #BS                               go to 10
 11    continue
c #BS  qsHY(i,j,mzz)=(qsHY(i,j,mzz) +blopro*qqsfac)/WKxyz2(i,j,mz)
C +
C +                ****
c #FR phimm(i,n) = phim(zeta)
c #FR phihh(i,n) = phih(zeta)
C +                ****
C +
c #WS   write(6,6003)u_stBS(i,j),1.d3*uss_HY(i,j),
c #WS.                           1.d3*ssstar
 6003   format(30x,f6.3,51x,2f6.3)
C +...  Output for Verification; may be used in Conjunction with #b2
C +
 122  continue
C +
 125  continue
C +
C +
C +--Grid Box Averages
C +  -----------------
C +
      do 129 i=1,mx
C +
C +--Monin Obukhov Length
C +  ~~~~~~~~~~~~~~~~~~~~
        SLlmo(i,j)   = 
     .     SLsrfl(i,j,1)*SLlmol(i,j,1)
     .    +SLsrfl(i,j,2)*SLlmol(i,j,2) 
C +
C +--Turbulent Transport of Momentum
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        SLuus(i,j)   = 
     .     SLsrfl(i,j,1)*SLuusl(i,j,1)
     .    +SLsrfl(i,j,2)*SLuusl(i,j,2) 
        TUkvm(i,j,k) = vonkar*WKxyz2(i,j,k)
     .   *(SLsrfl(i,j,1)*SLuusl(i,j,1)/phimm(i,1)
     .    +SLsrfl(i,j,2)*SLuusl(i,j,2)/phimm(i,2))
C +
C +--Turbulent Transport of Heat
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        SLuts(i,j)   = 
     .     SLsrfl(i,j,1)*SLutsl(i,j,1)
     .    +SLsrfl(i,j,2)*SLutsl(i,j,2)
        TUkvh(i,j,k) = vonkar*WKxyz2(i,j,k)
     .   *(SLsrfl(i,j,1)*SLuusl(i,j,1)/phihh(i,1)
     .    +SLsrfl(i,j,2)*SLuusl(i,j,2)/phihh(i,2))
C +
C +--Turbulent Transport of Moisture
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        SLuqs(i,j)   = 
     .     SLsrfl(i,j,1)*SLuqsl(i,j,1)
     .    +SLsrfl(i,j,2)*SLuqsl(i,j,2)
C +...CAUTION: SLuqsl is computed in Surface Models
C +
C +--Surface Aerodynamic Resistance
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       raerSL(i,j)     = 1.0 / (    cmh(i,j,1)*SLuus(i,j))
c #DR  raerSL(i,j)     = 1.0 / (    cmh(i,j,1)*SLuus(i,j))
c #BU  raerSL(i,j)     = 1.0 / (.74*cmh(i,j,1)*SLuus(i,j))
       raerSL(i,j)     = min(raerSL(i,j),thous)
C +
C +
C +--EKMAN Spiral (Assumed to be run with nSLsrf=1)
C +  ------------
C +
c #EK   TUkvm(i,j,k) = turcon
c #EK   TUkvh(i,j,k) = turcon
c #EK  ustarr        = SLuusl(i,j,1)
c #EK  SLuusl(i,j,1) =  TUkvm(i,j,k) /(vonkar *WKxyz2(i,j,k))
c #EK  SLutsl(i,j,1) = SLutsl(i,j,1) * SLuusl(i,j,1) / ustarr
 129  continue
C +
 199  continue
C +
C +
C +--Blown Snow Accumulation
C +  -----------------------
C +
c #BS DO i=1,mx
c #BS DO j=1,my
c #BS   WKxy2(i,j) = uss_HY(im1(i),jp1(j)) 
c #BS.          +2.0*uss_HY(i     ,jp1(j)) +    uss_HY(ip1(i),jp1(j))
c #BS.          +2.0*uss_HY(im1(i),j)      
c #BS.          +4.0*uss_HY(i     ,j)      +2.0*uss_HY(ip1(i),j)
c #BS.          +    uss_HY(im1(i),jm1(j)) 
c #BS.          +2.0*uss_HY(i     ,jm1(j)) +    uss_HY(ip1(i),jm1(j))
c #BS END DO
c #BS END DO
C +
c #BS DO i=1,mx
c #BS DO j=1,my
c #BS   uss_HY(i,j) =  WKxy2(i,j)          * 62.5d-3
c #BS   snobSL(i,j) = snobSL(i,j) + dt_Loc * rolvDY(i,j,mz)*uss_HY(i,j)
C +...  rolvDY(i,j,mz) *1.d+3 /ro_Wat -----> rolvDY(i,j,mz) (Implicit!)
C +                     1.d+3  [T/m3] -----> [kg/m3]
C +
C +--Snow Erosion (Blowing Snow)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS   snowHY(i,j) = snowHY(i,j) + dt_Loc * rolvDY(i,j,mz)*uss_HY(i,j)
C +
c #BS END DO
c #BS END DO
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++ TURBULENT CHARACTERISTICS OF THE EKMAN   LAYER +++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
c #EK DO 200 k = 1,mmz1
c #EK DO 200 j = 1,my
c #EK DO 200 i = 1,mx
c #EK   TUkvm(i,j,k) = turcon
c #EK   TUkvh(i,j,k) = turcon
 200  CONTINUE
C +
c #LE DO k = 1,mmz1
c #LE    DO j = 1,my
c #LE       DO i = 1,mx
c #LE          xarg    = 1.0    + WKxyz1(i,j,k)/WKxyz2(i,j,k)
c #LE          vecx(i) = exp ( third  * log(xarg) ) - 1.0
c #LE       END DO
C +
c #LE       DO i = 1,mx
c #LE          xfac1 = (vecx(i) / WKxyz1(i,j,k))**3
c #LE          xfac2 =  xfac1   / WKxyz2(i,j,k)
c #LE          cden(i,j,k) = sqrt ( xfac2 ) * WKxyz5(i,j,k)
c #LE       END DO
c #LE    END DO
c #LE END DO
C +
c #LE g2 = 2.0 * gravit
C +
c #LE DO k = 1,mmz1
c #LE    DO j = 1,my
c #LE       DO i = 1,mx
c #LE          xfac1 =(g2*WKxyz1(i,j,k))*(pktaDY(i,j,k)-pktaDY(i,j,k+1))
c #LE          xfac2 = pktaDY(i,j,k) + pktaDY(i,j,k+1)
c #LE          ztmp1 = xfac1 / xfac2
c #LE          xtmp2 = (uairDY(i,j,k)-uairDY(i,j,k+1))**2 
c #LE.               + (vairDY(i,j,k)-vairDY(i,j,k+1))**2
c #LE          xtmp1 =       max  ( xtmp2, epsi )
c #LE          ssvSL(i,j,k) = sqrt ( xtmp1 )
c #LE           rich(i,j,k) = min  ( septa, ztmp1/xtmp1 )
C +...          rich        : Richardson Number
c #LE       END DO
c #LE    END DO
C +
c #LE    DO j = 1,my
c #LE       DO i = 1,mx
C +...vector ->fric1(i,j)  = fm(rich(i,j,k),cden(i,j,k) )
c #LE          ri  = rich(i,j,k)
c #LE          cde = cden(i,j,k)
c #LE          if ( ri.gt.0.0) then
c #LE             
C +
c #LE             ri1 = 1.  + ri * 4.7       ! Louis,        1979,  ECMWF  I
c #LE             ri2 = ri1 * ri1            !
c #LE             fric1(i,j) = 1.    /ri2    !
c #LE             fric2(i,j) = fric1(i,j)    !
C +
c #VI             ri1 = 1.  + ri * 10. 
c #VI.                  /sqrt(unun+ri)       ! Louis et al., 1982,  ECMWF VI
c #VI             fric1(i,j) = 1.    /ri1    !             + 1995 Correction
c #VI             ri2 = 1.  + ri * 15.       !
c #VI.                  *sqrt(unun+ri)       !
c #VI             fric2(i,j) = 1.    /ri2    !
C +
c #LE          else
c #LE             fric1(i,j) = 1.0 
c #LE.               - 9.4*ri/(1.0+7.4*cde* 9.4*sqrt(abs(ri)))
c #LE             fric2(i,j) = 1.0 
c #LE.               - 9.4*ri/(1.0+5.3*cde* 9.4*sqrt(abs(ri)))
C +
c #LE          end if
C +...vector ->fric2(i,j)  = fh(rich(i,j,k),cden(i,j,k) )
c #LE       END DO
c #LE    END DO
C +
c #LE    DO j = 1,my
c #LE       DO i = 1,mx
c #LE          svx          = ssvSL(i,j,k) /WKxyz1(i,j,k) *WKxyz5(i,j,k)
c #LE          TUkvm(i,j,k) = max (svx * fric1(i,j),akmol)
c #LE          TUkvh(i,j,k) = max (svx * fric2(i,j),akmol)
c #LE       END DO
c #LE   END DO
C +
c #LE END DO
C +
C +
C +--Wind Speed Norm
C +  ===============
C +
      DO k = 1,mmz1
        DO j = 1,my
          DO i = 1,mx
             sv2          = max((uairDY(i,j,k)*uairDY(i,j,k)
     .                          +vairDY(i,j,k)*vairDY(i,j,k)),epsi)
             ssvSL(i,j,k) = sqrt(sv2)
          END DO
        END DO
      END DO
C +
C +
C +--Work Arrays Reset
C +  =================
C +
      do 50  j=1,my
      do 50  i=1,mx
      WKxy1(i,j) = 0.0
      WKxy2(i,j) = 0.0
 50   continue
      do 500 k=1,mz
      do 500 j=1,my
      do 500 i=1,mx
      WKxyz1(i,j,k) = 0.0
      WKxyz2(i,j,k) = 0.0
      WKxyz3(i,j,k) = 0.0
      WKxyz4(i,j,k) = 0.0
      WKxyz5(i,j,k) = 0.0
 500  continue
C +
      return
      end
      function psim(zetaIm)
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ASL)                                    9-10-2001  MAR |
C |   Function psim is the Integrated Universal Function for Momentum      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | OPTIONS:Duynkerke,MWR 119,                         324--341, 1991 (#DU |
C | ^^^^^^^ Businger, Workshop on Micrometeorology AMS, 67--100, 1973 (#BU |
C |         Dyer,     BLM 7,                           363--372, 1974 (#DR |
C |         Noihlan,  EERM Internal Note No 171,                 1986 (#NO |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
      include 'MARphy.inc'
C +
      real     psim
      real     zetaIm
      real     r6p1  ,beta  ,x
C +
      data     r6p1/6.25e0/
c #DR data     beta/5.00e0/
c #BU data     beta/4.70e0/
C +
C +--Stability   
C +  ~~~~~~~~~
      IF  (zetaIm.gt.0.0)                                          THEN
           psim=-6.0*zetaIm
C +...     Bintanja 1997, Annals of Glaciology
C +
c #DU      psim=-exp(0.8d0*log(unun+r6p1*zetaIm))
c #NO   IF(zetaIm.lt.1.d0)                                          THEN
c #DR      psim=-5.0*zetaIm
c #BU      psim=-4.7*zetaIm
c #NO   ELSE
C +
C +--Strong Stability
C +  ~~~~~~~~~~~~~~~~
c #NO      psim=-beta*(1.0+log(zetaIm))
c #NO   END IF
      ELSE 
C +
C +--Unstability 
C +  ~~~~~~~~~~~
           x   = sqrt(sqrt(1.0-20.0*zetaIm))
c #DR      x   = sqrt(sqrt(1.0-16.0*zetaIm))
c #BU      x   = sqrt(sqrt(1.0-15.0*zetaIm))
           psim= 2.0*log(demi*(unun+x)) +log(demi*(unun+x*x)) 
     .          -2.0*atan(x) +demi*pi
      END IF
C +
      return
      end
      function psih(zetaIh)
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ASL)                                    9-10-2001  MAR |
C |   Function psih is the Integrated Universal Function for Heat          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | OPTIONS:Duynkerke,MWR 119,                         324--341, 1991 (#DU |
C | ^^^^^^^ Businger, Workshop on Micrometeorology AMS, 67--100, 1973 (#BU |
C |         Dyer,     BLM 7,                           363--372, 1974 (#DR |
C |         Noihlan,  EERM Internal Note No 171,                 1986 (#NO |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
      include 'MARphy.inc'
C +
      real     psih
      real     zetaIh
      real     r9p3  ,beta,r     ,y
C +
      data     r9p3/9.375e0/
c #DR data     beta/5.0e0/,r/1.0e0/
c #BU data     beta/4.7e0/,r/.74e0/
C +
C +--Stability
C +  ~~~~~~~~~
      IF  (zetaIh.gt.0.0)                                          THEN
           psih=-6.0*zetaIh
C +...     Bintanja 1997, Annals of Glaciology
C +
c #DU      psih=-exp(0.80*log(unun+r9p3*zetaIh))
c #NO   IF(zetaIh.lt.1.0)                                          THEN
c #DR      psih=-beta*zetaIh
c #BU      psih=-beta*zetaIh/r
c #NO   ELSE 
C +
C +--Strong Stability
C +  ~~~~~~~~~~~~~~~~
c #NO      psih=-beta*(unun+log(zetaIh))/r
c #NO   END IF
      ELSE 
C +
C +--Unstability 
C +  ~~~~~~~~~~~
           y   = sqrt(1.0-15.0*zetaIh)
c #DR      y   = sqrt(1.0-16.0*zetaIh)
c #BU      y   = sqrt(1.0- 9.0*zetaIh)
           psih= 2.0*log(demi*(unun+y))
      END IF
C +
      return
      end
      function phim(zeta_m)
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ASL)                                   27-09-2001  MAR |
C |   Function phim is the            Universal Function for Momentum      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | OPTIONS:Duynkerke,MWR 119,                         324--341, 1991 (#DU |
C | ^^^^^^^ Businger, Workshop on Micrometeorology AMS, 67--100, 1973 (#BU |
C |         Dyer,     BLM 7,                           363--372, 1974 (#DR |
C |         Noihlan,  EERM Internal Note No 171,                 1986 (#NO |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
      include 'MARphy.inc'
C +
      real     phim
      real     zeta_m
      real     r6p1
C +
      data     r6p1/6.25e00/
C +
C +--Stability   
C +  ~~~~~~~~~
      IF  (zeta_m.gt.eps9)                                          THEN
           phim=1.0+6.0*zeta_m
C +...     Bintanja 1997, Annals of Glaciology
C +
c #DU      phim=1.0+5.00*zeta_m/exp(0.20*log(unun+r6p1*zeta_m))
c #NO   IF(zeta_m.lt.1.0)                                           THEN
c #DR      phim=1.0+5.00*zeta_m
c #BU      phim=1.0+4.70*zeta_m
c #NO   ELSE
C +
C +--Strong Stability
C +  ~~~~~~~~~~~~~~~~
c #NO      phim=   5.7
c #NO   END IF
      ELSE
C +
C +--Unstability 
C +  ~~~~~~~~~~~
           phim=1.0/(1.0-20.0*zeta_m) 
c #DR      phim=1.0/(1.0-16.0*zeta_m) 
c #BU      phim=1.0/(1.0-15.0*zeta_m) 
           phim=sqrt(sqrt(phim))
      END IF
C +
      return
      end
      function phih(zeta_h)
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ASL)                                   27-09-2001  MAR |
C |   Function phih is the            Universal Function for Heat          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | OPTIONS:Duynkerke,MWR 119,                         324--341, 1991 (#DU |
C | ^^^^^^^ Businger, Workshop on Micrometeorology AMS, 67--100, 1973 (#BU |
C |         Dyer,     BLM 7,                           363--372, 1974 (#DR |
C |         Noihlan,  EERM Internal Note No 171,                 1986 (#NO |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
      include 'MARphy.inc'
C +
      real     phih
      real     zeta_h
      real     r9p3
C +
      data     r9p3/9.375e0/
C +
C +--Stability   
C +  ~~~~~~~~~
      IF  (zeta_h.gt.eps9)                                          THEN
           phih=1.0+6.0*zeta_h
C +...     Bintanja 1997, Annals of Glaciology
C +
c #DU      phih=1.0+7.5*zeta_h/exp(0.20*log(unun+r9p3*zeta_h))
c #NO   IF(zeta_h.lt.1.0)                                           THEN
c #DR      phih=1.0+5.0*zeta_h
c #BU      phih=.74+4.7*zeta_h
c #NO   ELSE
C +
C +--Strong Stability
C +  ~~~~~~~~~~~~~~~~
c #NO      phih=    5.44
c #NO   END IF
      ELSE
C +
C +--Unstability 
C +  ~~~~~~~~~~~
           phih=1.0/sqrt(1.0-15.*zeta_h) 
c #DR      phih=1.0/sqrt(1.0-16.*zeta_h) 
c #BU      phih=.74/sqrt(1.0- 9.*zeta_h) 
      END IF
C +
      return
      end


      subroutine TURabl

C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ABL)                                   28-07-2006  MAR |
C |   SubRoutine TURabl includes the Contribution of Vertical Turbulence   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT (via common block)                                              |
C |  ^^^^^  micphy         : Cloud Microphysics Switch                     |
C |         dt_Loc         : Vertical Diffusion Time Step              [s] |
C |                                                                        |
C |         TUkvm(mx,my,mz): Vertical Turbulent Coeffic.(momentum) [m2/s]  |
C |         TUkvh(mx,my,mz): Vertical Turbulent Coeffic.(heat)     [m2/s]  |
C |         SLuus(mx,my)   : Friction Velocity                     [m/s]   |
C |         SLuts(mx,my)   : Surface Layer Heat     Turbulent Flux [mK/s]  |
C |         SLuqs(mx,my)   : Surface Layer Moisture Turbulent Flux [m/s]   |
C |        uss_HY(mx,my)   : Surface Layer Blowing* Turbulent Flux [m/s]   |
C |                                                                        |
C |  INPUT / OUTPUT: The Vertical Turbulent Fluxes are included for:       |
C |  ^^^^^^^^^^^^^^                                                        |
C |       1) The Horizontal     x-Wind Component uairDY(mx,my,mz)    [m/s] |
C |       2) The Horizontal     y-Wind Component vairDY(mx,my,mz)    [m/s] |
C |                                                                        |
C |       3) The Potential      Temperature      pktaDY(mx,my,mzz)         |
C |       4) The Air Specific   Humidity           qvDY(mx,my,mz)  [kg/kg] |
C |                                                                        |
C |       5) The Ice Crystals   Concentration      qiHY(mx,my,mz)  [kg/kg] |
C |       6) The Ice Crystals   Number           ccniHY(mx,my,mz)  [Nb/m3] |
C |       7) The Cloud Droplets Concentration      qwHY(mx,my,mz)  [kg/kg] |
C |       8) The Snow Flakes    Concentration      qsHY(mx,my,mz)  [kg/kg] |
C |       9) The Rain Drops     Concentration      qrHY(mx,my,mz)  [kg/kg] |
C |                                                                        |
C |      10) The Tracer         Concentration      qxTC(mx,my,mz,ntrac)    |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
c #NH include 'MAR_NH.inc'
c #Di include 'MAR_DI.inc'

      include 'MAR_TU.inc'
c _PE include 'MARpen.inc'
c #PE include 'MARpen.inc'

c #HY include 'MAR_HY.inc'
c #TC include 'MAR_TC.inc'
c #EW include 'MAR_EW.inc'

      include 'MAR_SL.inc'

      include 'MAR_WK.inc'

      logical                Q_Impl
      common  /TURabl_lo/    Q_Impl

      integer                lous  ,lotu
      common  /TURabl_IN/    lous  ,lotu

      real                   alpha ,beta  ,ab
      common  /TURabl_re/    alpha ,beta  ,ab

C +--OUTPUT of Snow Erosion Statistics (see assignation in PHY_SISVAT)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #EV integer                iEVwri,jEVwri,nEVwri,kEVwri,lEVwri
c #EV common  /SISVAT_EV/    iEVwri,jEVwri,nEVwri,kEVwri,lEVwri


C +--Local  Variables
C +  ================

      integer  i1_tua,i2_tua,j1_tua,j2_tua,k1_tua,k2_tua,n,km,kp
      real     uustar       ,ssvu(mx,my),ssvv(mx,my)
      real     utstar       ,uqstar     ,qvap
      real     waterb       ,ussno      ,dd_sno
c #CL real     h0


C +--Parameters
C +  ==========

      IF (iterun.EQ.0)                                              THEN


C +--Parameters for the Inclusion of the Friction Velocity u*
C +  --------------------------------------------------------

        lous =1
c #EK   lous =0
c #FI   lous =1
C +...  lous =1 : SLuus    is          used
C +     lous =0 : SLuus**2 is (partly) replaced by  K du / dz
C +     CAUTION : DO NOT USE lous =0 EXCEPT WHEN VERIFYING THE EKMAN SPIRAL


C +--Parameters for the Numerical Scheme of Vertical Turbulent Transport
C +  -------------------------------------------------------------------

        Q_Impl=.FALSE.
c #TI   Q_Impl=.TRUE.
c #QE   Q_Impl=.FALSE.
c #TC   IF     (Q_Impl)
c #TC.    stop       ' #~¹@è! BAD Vertical Diffusion of gaseous tracers'

      END IF

        alpha = 0.25               !
        beta  = 1.00-alpha         ! Impliciteness
        ab    = alpha/beta         !


C +-------------------------------------------------------------------------


C +--INITIALIZATION
C +  ==============

      IF (itexpe.EQ.0)                                              THEN
        DO  j=1,my
        DO  i=1,mx
           ssvSL(i,j,mz)=  max(sqrt(uairDY(i,j,mz)*uairDY(i,j,mz)
     .                             +vairDY(i,j,mz)*vairDY(i,j,mz)),epsi)
        DO  n=1,mw
           cdmSL(i,j,n) =  0.04
           cdhSL(i,j,n) =  0.04
          SLuusl(i,j,n) = cdmSL(i,j,n) *ssvSL(i,j,mz)
        ENDDO
        ENDDO
        ENDDO

        DO  j=1,my
        DO  i=1,mx
          duusSL(i,j)   = 0.
          dutsSL(i,j)   = 0.
        ENDDO
        ENDDO
      END IF


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of Horizontal Momentum
C +  =========================================

C +--Implicit Surface Scheme
C +  -----------------------

        DO j = jp11,my1
        DO i = ip11,mx1
            Kv__SL(i,j) = 0.
c #FI       aeCdSL(i,j) = 0.
        END DO
        END DO

c #FI   DO  n=1,mw
c #FI   DO  j=jp11,my1
c #FI   DO  i=ip11,mx1
c #FI       aeCdSL(i,j) = aeCdSL(i,j) +cdmSL(i,j,n)*SLuusl(i,j,n) ! aerodynamic
c #FI.                                             *Slsrfl(i,j,n) ! conductance
c #FI   ENDDO
c #FI   ENDDO
c #FI   ENDDO


c #EK   DO  j=jp11,my1
c #EK   DO  i=ip11,mx1
c #EK       Kv__SL(i,j) =                                         ! Kv Contrib.
c #EK.     -gravi2*romiDY(i,j,mz) *TUkvm(i,j,mz)          *beta   ! Ekman Spir.
c #EK.            *rolvDY(i,j,mz)/(pstDY2(i,j)* dsigm1(mz)*dsig_1(  mz))
C +                                TUkvm(i,j,mz) accounted only 
C +                                        in Ekman Spiral Test
C +                                       (i.e.,  when lotu = 1)
c #EK   ENDDO
c #EK   ENDDO


c #FI   DO  j=jp11,my1
c #FI   DO  i=ip11,mx1
c #FI       Kv__SL(i,j) =                                         ! Kv Contrib.
c #FI.     -gravit                *aeCdSL(i,j)            *beta   ! in      SL
c #FI.            *rolvDY(i,j,mz)/(pstDY (i,j)* dsigm1(mz))
c #FI   ENDDO
c #FI   ENDDO


C +--Tridiagonal Matrix Coefficients : u and v
C +  -----------------------------------------

        DO  j=jp11,my1
        DO  i=ip11,mx1
          ssvu(i,j) = uairDY(i,j,mz) / ssvSL(i,j,mz)
          ssvv(i,j) = vairDY(i,j,mz) / ssvSL(i,j,mz)
        END DO 
        END DO 

C +--Diagonal A
C +  ~~~~~~~~~~
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,mz)=             Kv__SL(i,j)
        END DO
        END DO

      DO  k=mmz1,1,-1
         kp=kp1(k)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)=-gravi2*beta*romiDY(i,j,k)*(TUkvm(i,j,k)
c _HH.                                                +pente3(i,j,k) 
     .              )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
c #DF     WKxyz1(i,j,k)=-gravi2*beta*romiDY(i,j,k)*(TUkvm(i,j,k)
c #PE.                                                +pente1(i,j,k) 
c #DF.              )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
        END DO
        END DO

C +--Diagonal C
C +  ~~~~~~~~~~
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz3(i,j,kp)=WKxyz1(i,j,k)   *dsigm1(k)     /dsigm1(kp)    
     .                                  *(rolvDY(i,j,kp)/rolvDY(i,j,k)) 
        END DO
        END DO

      END DO

C +--A, B, C
C +  ~~~~~~~
      DO  k=1,mmz1
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)  =       WKxyz1(i,j,k) * dt_Loc
          WKxyz3(i,j,k)  =       WKxyz3(i,j,k) * dt_Loc
          WKxyz2(i,j,k)  = 1.0 - WKxyz3(i,j,k) - WKxyz1(i,j,k) 
        END DO
        END DO
      END DO

C +--Vertical B.C.
C +  ~~~~~~~~~~~~~
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz3(i,j, 1) = 0.0
          WKxyz2(i,j, 1) = 1.0 - WKxyz1(i,j,1)

          WKxyz1(i,j,mz) =       WKxyz1(i,j,mz) *dt_Loc
          WKxyz3(i,j,mz) =       WKxyz3(i,j,mz) *dt_Loc
          WKxyz2(i,j,mz) = 1.0 - WKxyz3(i,j,mz) -WKxyz1(i,j,mz) 
        END DO
        END DO


C +--Second Member of the Tridiagonal System - u
C +  -------------------------------------------

           kp=kp1(1)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,1) = WKxyz1(i,j,1) 
     .               *ab*(uairDY(i,j,1)-uairDY(i,j,kp))
c #Di     WKxyz1(i,j,1) = 0.0
c #Di     WKxyz2(i,j,1) = 1.0
c #Di     WKxyz4(i,j,1) = uairDI(i,j)
        END DO
        END DO

      DO    k=kp1(1),mmz1
           kp=kp1(k)
           km=km1(k)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,k) = 
     .    WKxyz1(i,j,k) *ab*(uairDY(i,j,k )-uairDY(i,j,kp))
     .   -WKxyz3(i,j,k) *ab*(uairDY(i,j,km)-uairDY(i,j,k ))
        END DO
        END DO
      END DO

        DO  j=jp11,my1
        DO  i=ip11,mx1

          uustar         =     SLuus(i,j)*SLuus(i,j)

C +--Implicit Surface Scheme
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #FI     uustar        = 0.1*duusSL(i,j)                         ! explicit

          WKxyz4(i,j,mz)= 
     .    WKxyz1(i,j,mz)*ab* uairDY(i,j,mz)
     .   -WKxyz3(i,j,mz)*ab*(uairDY(i,j,mmz1)-uairDY(i,j,mz))
     .    -lous*alpha * gravit * romiDY(i,j,mz) *dt_Loc
     .    *uustar              *   ssvu(i,j)    /(pstDY(i,j)*dsigm1(mz)) 
        END DO
        END DO


C +--Tridiagonal Matrix Inversion - u 
C +  --------------------------------

              k1_tua= 1
c #Di         k1_tua= 2
      DO    k=k1_tua,mz
        DO  j=     jp11,my1
        DO  i=     ip11,mx1
          WKxyz4(i,j,k)  = WKxyz4(i,j,k) + uairDY(i,j,k)
        END DO
        END DO
      END DO

      k1_tua = 1
      k2_tua = mz

C +        ************
      call MARgz_2mx1y1(k1_tua,k2_tua)
C +        ************

      DO    k=1,mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          uairDY(i,j,k) = WKxyz7(i,j,k)
        END DO
        END DO
      END DO


C +--Tridiagonal Matrix Coefficients - v 
C +  (RELOAD if horiz.correct. included) 
C +  -----------------------------------

C +--Diagonal A
C +  ~~~~~~~~~~
c #DF DO    k=mz,1,-1
c #DF       kp=kp1(k)
C +
c #DF   DO  j=jp11,my1
c #DF   DO  i=ip11,mx1
c #DF     WKxyz1(i,j,k)=-gravi2*beta*romiDY(i,j,k)*(TUkvm(i,j,k)
c _HH.                                            +pente3(i,j,k) 
c #PE.                                            +pente2(i,j,k) 
c #DF.          )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
c #DF   END DO
c #DF   END DO

C +--Diagonal C
C +  ~~~~~~~~~~
c #DF   DO  j=jp11,my1
c #DF   DO  i=ip11,mx1
c #DF     WKxyz3(i,j,kp)=WKxyz1(i,j,k)  *dsigm1(k)  /dsigm1(kp)
c #DF.                            /rolvDY(i,j,k)*rolvDY(i,j,kp) 
c #DF   END DO
c #DF   END DO
C +
c #DF END DO

C +--A, B, C
C +  ~~~~~~~
c #DF DO       k=1,mmz1
c #DF   DO  j=jp11,my1
c #DF   DO  i=ip11,mx1
c #DF     WKxyz1(i,j,k)  =       WKxyz1(i,j,k) * dt_Loc
c #DF     WKxyz3(i,j,k)  =       WKxyz3(i,j,k) * dt_Loc
c #DF     WKxyz2(i,j,k)  = 1.0 - WKxyz3(i,j,k) - WKxyz1(i,j,k) 
c #DF   END DO
c #DF   END DO
c #DF END DO

C +--Vertical B.C.
C +  ~~~~~~~~~~~~~
c #DF   DO  j=jp11,my1
c #DF   DO  i=ip11,mx1
c #DF     WKxyz3(i,j, 1) = 0.0
c #DF     WKxyz2(i,j, 1) = 1.0 - WKxyz1(i,j,1)
c #DF     WKxyz1(i,j,mz) =       WKxyz1(i,j,mz) * dt_Loc
c #DF     WKxyz3(i,j,mz) =       WKxyz3(i,j,mz) * dt_Loc
c #DF     WKxyz2(i,j,mz) = 1.0 - WKxyz3(i,j,mz) - WKxyz1(i,j,mz) 
c #DF.    +lous*beta*gravit*dt_Loc*romiDY(i,j,mz)
c #DF.      *SLuus(i,j)*SLuus(i,j)/(ssvSL(i,j,mz)*pstDY(i,j)*dsigm1(mz))
c #DF   END DO
c #DF   END DO


C +--Second Member of the Tridiagonal System - v
C +  -------------------------------------------

            kp=kp1(1)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,1) = WKxyz1(i,j,1) 
     .               *ab*(vairDY(i,j,1)-vairDY(i,j,kp))
c #Di     WKxyz1(i,j,1) = 0.0
c #Di     WKxyz2(i,j,1) = 1.0
c #Di     WKxyz4(i,j,1) = vairDI(i,j)
        END DO
        END DO

      DO    k=kp1(1),mmz1
           km=km1(k)
           kp=kp1(k)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,k) = 
     .    WKxyz1(i,j,k) *ab*(vairDY(i,j,k )-vairDY(i,j,kp))
     .   -WKxyz3(i,j,k) *ab*(vairDY(i,j,km)-vairDY(i,j,k ))
        END DO
        END DO
      END DO

        DO  j=jp11,my1
        DO  i=ip11,mx1

          uustar         =     SLuus(i,j)*SLuus(i,j)

C +--Implicit Surface Scheme
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #FI     uustar        = 0.1*duusSL(i,j)                         ! explicit
c #FI     duusSL(i,j)   = 0.9*duusSL(i,j)                         !

          WKxyz4(i,j,mz)= 
     .    WKxyz1(i,j,mz)*ab* vairDY(i,j,mz)
     .   -WKxyz3(i,j,mz)*ab*(vairDY(i,j,mmz1)-vairDY(i,j,mz))
     .    -lous*alpha * gravit * romiDY(i,j,mz) *dt_Loc
     .    *uustar              *   ssvv(i,j)    /(pstDY(i,j)*dsigm1(mz)) 
        END DO
        END DO


C +--Tridiagonal Matrix Inversion - v 
C +  --------------------------------

              k1_tua= 1
c #Di         k1_tua= 2
      DO    k=k1_tua,mz
        DO  j=     jp11,my1
        DO  i=     ip11,mx1
          WKxyz4(i,j,k)  = WKxyz4(i,j,k) + vairDY(i,j,k)
        END DO
        END DO
      END DO

      k1_tua = 1
      k2_tua = mz

C +        ************
      call MARgz_2mx1y1(k1_tua,k2_tua)
C +        ************

c #FI   DO  j=jp11,my1
c #FI   DO  i=ip11,mx1
c #FI     uustar=aeCdSL(i,j)*((alpha* WKxy1(i,j)   +beta*uairDY(i,j,mz))
c #FI.                       *         ssvu(i,j)
c #FI.                       +(alpha*vairDY(i,j,mz)+beta*WKxyz7(i,j,mz))
c #FI.                       *         ssvv(i,j)                       )
c #FI     duusSL(i,j)   = duusSL(i,j) + SLuus(i,j)*SLuus(i,j) - uustar
c #FI   END DO
c #FI   END DO

      DO    k=1,mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          vairDY(i,j,k) = WKxyz7(i,j,k)
        END DO
        END DO
      END DO


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of Heat and Water Vapor
C +  ==========================================

C +--Implicit Surface Scheme
C +  -----------------------

        DO  j=jp11,my1
        DO  i=ip11,mx1
            Kv__SL(i,j) = 0.
c #TI       aeCdSL(i,j) = 0.
        ENDDO
        ENDDO

c #TI   DO  n=1,mw
c #TI   DO  j=jp11,my1
c #TI   DO  i=ip11,mx1
c #TI       aeCdSL(i,j) = aeCdSL(i,j) +cdhSL(i,j,n)*SLuusl(i,j,n) ! aerodynamic
c #TI.                                             *Slsrfl(i,j,n) ! conductance
c #TI   END DO
c #TI   END DO
c #TI   END DO

c #TI   DO  j=jp11,my1
c #TI   DO  i=ip11,mx1
C +         Kv__SL(i,j) =                                         ! Kv Contrib.
C +  .     -gravi2*romiDY(i,j,mz) * TUkvh(i,j,mz)         *beta   ! above   SL
C +  .            *rolvDY(i,j,mz)/(pstDY2(i,j)* dsigm1(mz)*dsig_1(mz))

c #TI       Kv__SL(i,j) =                                         ! Kv Contrib.
c #TI.     -gravit                *aeCdSL(i,j)            *beta   ! in      SL
c #TI.            *rolvDY(i,j,mz)/(pstDY (i,j)* dsigm1(mz))       !
c #TI   END DO
c #TI   END DO


C +--Tridiag. Matrix Coeff. : pktaDY,   qvDY
C +  ---------------------------------------

C +--Diagonal A
C +  ~~~~~~~~~~
            k=  mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)=                            Kv__SL(i,j)
c #qe.                  -gravi2*beta*romiDY(i,j,k)*(  zero
c _HH.                                             +pente3(i,j,k)
c #PE.                                             +pente3(i,j,k)
c #qe.           )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
        END DO
        END DO
      DO    k=mmz1,1,-1
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)=-gravi2*beta*romiDY(i,j,k)*( TUkvh(i,j,k)
c _HH.                                             +pente3(i,j,k)
c #PE.                                             +pente3(i,j,k)
     .           )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
        END DO
        END DO
      END DO

C +--Diagonal C
C +  ~~~~~~~~~~
      DO    k=mz  ,1,-1
           kp=kp1(k)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz3(i,j,kp)=WKxyz1(i,j,k)  *dsigm1(k)    /dsigm1(kp)
     .                                  /rolvDY(i,j,k)*rolvDY(i,j,kp)
        END DO
        END DO
      END DO

C +--A, B, C
C +  ~~~~~~~
      DO    k=1,mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)  =       WKxyz1(i,j,k) * dt_Loc
          WKxyz3(i,j,k)  =       WKxyz3(i,j,k) * dt_Loc
          WKxyz2(i,j,k)  = 1.0 - WKxyz3(i,j,k) - WKxyz1(i,j,k)
        END DO
        END DO
      END DO

C +--Vertical B.C.
C +  ~~~~~~~~~~~~~
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz3(i,j, 1) = 0.0
          WKxyz2(i,j, 1) = 1.0 - WKxyz1(i,j,1)
        END DO
        END DO


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of Heat
C +  ==========================

c #CL   DO  j=jp11,my1
c #CL   DO  i=ip11,mx1

C +--Set-Up of the Convective Mixed Layer Test
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #CL     h0      =  100.0
C +...           i.e.100 W/m2 upward
c #CL     SLuts (i,j)   =-h0 /cp /rolvDY(i,j,mz) /1000.
c #CL     SLutsl(i,j,1) =-h0 /cp /rolvDY(i,j,mz) /1000.
C +...    In Order to Test the Convective Mixed Layer 

c #CL   END DO
c #CL   END DO


C +--SBC           of the Tridiagonal System - pktaDY
C +  ------------------------------------------------

        DO  j=jp11,my1
        DO  i=ip11,mx1
          utstar        =  SLuts(i,j) 

C +--Implicit Surface Scheme
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #TI     utstar        = 0.1*dutsSL(i,j)                         ! explicit
c #TI     dutsSL(i,j)   = 0.9*dutsSL(i,j)                         !
                                                                  ! set := 0
          WKxyz4(i,j,mz)=     WKxyz1(i,j,mz)                      ! partly  
     .                  *(ab *pktaDY(i,j,mz)  -pktaSL(i,j)/beta)  ! explicit
     .   -WKxyz3(i,j,mz)* ab*(pktaDY(i,j,mmz1)-pktaDY(i,j,mz))    !
     .                          -gravit*dt_Loc*rolvDY(i,j,mz)     ! u*T* all
     .                  * utstar/(pcap* pstDY(i,j)*dsigm1(mz))    ! explicit
        END DO
        END DO


C +--Second Member of the Tridiagonal System - pktaDY
C +  ------------------------------------------------

      DO    k=kp1(1),mmz1
           km=km1(k)
           kp=kp1(k)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,k) = 
     .    WKxyz1(i,j,k) *ab*(pktaDY(i,j,k )-pktaDY(i,j,kp))
     .   -WKxyz3(i,j,k) *ab*(pktaDY(i,j,km)-pktaDY(i,j,k ))
        END DO
        END DO
      END DO


C +--UBC           of the Tridiagonal System - pktaDY
C +  ------------------------------------------------

           kp=kp1(1)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,1) = 
     .    WKxyz1(i,j,1) *ab*(pktaDY(i,j,1)-pktaDY(i,j,kp))
c #Di     WKxyz1(i,j,1) = 0.0
c #Di     WKxyz2(i,j,1) = 1.0
c #Di     WKxyz4(i,j,1) = pkttDI(i,j)
        END DO
        END DO


C +--Tridiagonal Matrix Inversion - pktaDY 
C +  -------------------------------------

              k1_tua= 1
c #Di         k1_tua= 2
      DO    k=k1_tua,mz
        DO  j=     jp11,my1
        DO  i=     ip11,mx1
          WKxyz4(i,j,k)    = WKxyz4(i,j,k) + pktaDY(i,j,k)
        END DO
        END DO
      END DO

      k1_tua = 1
      k2_tua = mz

C +        ************
      call MARgz_2mx1y1(k1_tua,k2_tua)
C +        ************

c #TI   DO  j=jp11,my1
c #TI   DO  i=ip11,mx1
c #TI     utstar=aeCdSL(i,j)*(alpha*pktaDY(i,j,mz)+beta*WKxyz7(i,j,mz)
c #TI.                       -      pktaDY(i,j,mzz)                   )
c #TI.                      * pcap
c #TI     dutsSL(i,j)   = dutsSL(i,j) + SLuts(i,j) - utstar
c #TI   END DO
c #TI   END DO

      DO    k=1,mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          pktaDY(i,j,k) = WKxyz7(i,j,k)
        END DO
        END DO
      END DO


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of Moisture
C +  ==============================

C +--Tridiag. Matrix Coeff. : qvDY
C +  -----------------------------

C +--Diagonal A
C +  ~~~~~~~~~~
c #QE       k=  mz
c #QE   DO  j=jp11,my1
c #QE   DO  i=ip11,mx1
c #QE     Kv__SL(i,j)  = 0.
c #QE     WKxyz1(i,j,k)=                            Kv__SL(i,j)
c #qe.                  -gravi2*beta*romiDY(i,j,k)*(  zero
c _HH.                                             +pente3(i,j,k)
c #PE.                                             +pente3(i,j,k)
c #qe.           )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
c #qe     WKxyz1(i,j,k)= WKxyz1(i,j,k)* dt_Loc

C +--Diagonal B
C +  ~~~~~~~~~~
c #QE     WKxyz2(i,j,k)  = 1.00 - WKxyz3(i,j,k) 
c #qe.                          - WKxyz1(i,j,k)
c #QE   END DO
c #QE   END DO


C +--UBC           of the Tridiagonal System - qvDY
C +  ----------------------------------------------

           kp=kp1(1)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,1)=  
     .    WKxyz1(i,j,1)*ab*(qvDY(i,j,1)-qvDY(i,j,kp))
C +...    Upper BC: zero gradient                 (Condition von Neuman)
C +
c #V+     WKxyz1(i,j,1)= 1.0
c #V+     WKxyz2(i,j,1)=-1.0
c #V+     WKxyz4(i,j,1)=-(gplvDY(i,j,1)-gplvDY(i,j,2))*qvtoDI(i,j)
c #V+.                   *grvinv
C +...    c #V+ pour un gradient constant non nul (Condition von Neuman)

c #Di     WKxyz1(i,j,1)= 0.0
c #Di     WKxyz2(i,j,1)= 1.0
c #Di     WKxyz4(i,j,1)= qvtoDI(i,j)
        END DO
        END DO


C +--Second Member of the Tridiagonal System - qvDY 
C +  ----------------------------------------------

      DO    k=kp1(1),mmz1
           kp=kp1(k)
           km=km1(k)
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,k)= WKxyz1(i,j,k)*ab*(qvDY(i,j,k )-qvDY(i,j,kp))
     .                  -WKxyz3(i,j,k)*ab*(qvDY(i,j,km)-qvDY(i,j,k ))
        END DO
        END DO
      END DO


C +--SBC           of the Tridiagonal System - qvDY
C +  ----------------------------------------------

        DO  j=jp11,my1
        DO  i=ip11,mx1

C +--Implicit Surface Scheme
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #TI       qvap       =   qvDY(i,j,mz) 
c #TI.                 -  SLuqs(i,j)/aeCdSL(i,j)

c #TI       uqstar     = 0.                                       ! explicit
C +         uqstar    is replaced by aeCdSL*(  qvDY-qvapSL)       ! set := 0

C +--Explicit Surface Scheme
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #QE       qvap       = qvapSL(i,j)
c #QE       uqstar     =  SLuqs(i,j) 

          WKxyz4(i,j,mz)=     WKxyz1(i,j,mz)                      ! partly  
     .                  *(ab *  qvDY(i,j,mz)  -  qvap / beta)     ! explicit
     .   -WKxyz3(i,j,mz)* ab*(  qvDY(i,j,mmz1)-  qvDY(i,j,mz))
     .                          -gravit*dt_Loc*rolvDY(i,j,mz)     ! u*q* all
     .                  * uqstar /(     pstDY(i,j)*dsigm1(mz))    ! explicit
        END DO
        END DO


C +--Tridiagonal Matrix Inversion - qvDY 
C +  -----------------------------------

              k1_tua =1
c #Di         k1_tua =2
      DO    k=k1_tua,mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz4(i,j,k)  = WKxyz4(i,j,k) + qvDY(i,j,k)
        END DO
        END DO
      END DO

      k1_tua = 1
      k2_tua = mz

C +        ************
      call MARgz_2mx1y1(k1_tua,k2_tua)
C +        ************

      DO    k=1,mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          qvDY(i,j,k) = WKxyz7(i,j,k)
        END DO
        END DO
      END DO


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of gazeous Tracers
C +  =====================================

c #TC IF (dt_ODE.eq.dtDiff)                                         THEN


C +--Second Member of the Tridiagonal System - qxTC
C +  ----------------------------------------------

c #TC   DO     n=nterr+1,ntrac            ! CAUTION: defines nterr as the Nb
                                          !          of terregenous aerosols 
                                          !          (usually 0 .OR. 1)
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz1(i,j,1)= 0.0
c #TC         WKxyz2(i,j,1)= 1.0
c #TC         WKxyz4(i,j,1)= qxTC(i,j,1,n)
c #TC       END DO
c #TC       END DO

c #TC     DO   k=kp1(1),mmz1
c #TC         kp=kp1(k)
c #TC         km=km1(k)
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz4(i,j,k) = 
c #TC.        WKxyz1(i,j,k)*ab*(qxTC(i,j,k ,n)-qxTC(i,j,kp,n))
c #TC.       -WKxyz3(i,j,k)*ab*(qxTC(i,j,km,n)-qxTC(i,j,k ,n))
c #TC       END DO
c #TC       END DO
c #TC     END DO

c #TC     IF (.NOT.BloMod)                                          THEN
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         uqTC(i,j,n)=-cdhSL(i,j,1)* SLuusl(i,j,1)
c #TC.                                 *  (qsTC(i,j,n)- qxTC(i,j,mz,n))
c #TC       END DO
c #TC       END DO 
c #TC     END IF

c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz4(i,j,mz)=  WKxyz1(i,j,mz)
c #TC.                     *(ab* qxTC(i,j,mz  ,n)-qsTC(i,j,n)/beta)
c #TC.      - WKxyz3(i,j,mz)*ab*(qxTC(i,j,mmz1,n)-qxTC(i,j,mz,n))
c #TC.            +(gravit*dt_Loc
c #TC.              *rolvDY(i,j,mz)/(pstDY(i,j)*(sigmid(mz)-1.0d+0))) 
c #TC.                *uqTC(i,j,n) 
c #TC       END DO
c #TC       END DO 


C +--Tridiagonal Matrix Inversion - qxTC 
C +  -----------------------------------

c #TC     DO   k=kp1(1),mz
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz4(i,j,k) = WKxyz4(i,j,k) + qxTC(i,j,k,n)
c #TC       END DO
c #TC       END DO
c #TC     END DO

c #TC     k1_tua = 1
c #TC     k2_tua = mz

C +            ************
c #TC     call MARgz_2mx1y1(k1_tua,k2_tua)
C +            ************

c #TC     DO   k=1,mz
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC        qxTC(i,j,k,n) = WKxyz7(i,j,k)
c #TC       END DO
c #TC       END DO
c #TC     END DO

c #TC   END DO

c #TC END IF


C +-------------------------------------------------------------------------


C +--Atmospheric Water Budget
C +  ========================

c #EW   DO   j=jp11,my1
c #EW   DO   i=ip11,mx1
c #EW       wat0EW(i,j) = 0.0
c #EW     DO k=1,mz
c #EW       wat0EW(i,j) = wat0EW(i,j)
c #EW.                  +  (qvDY(i,j,k)
c #EW.                  +   qwHY(i,j,k) + qrHY(i,j,k)
c #EW.                  +   qiHY(i,j,k) + qsHY(i,j,k)) *dsigm1(k)
c #EW     END DO
c #EW       wat0EW(i,j) = wat0EW(i,j)  * pstDY(i,j)    *grvinv
c #EW   END DO
c #EW   END DO


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of Hydrometeors and non gazeous Tracers
C +  ==========================================================

C +--Parameters for the Numerical Scheme of Vertical Turbulent Transport
C +  -------------------------------------------------------------------

      alpha = 0.00               ! Expliciteness = 0 (positive definite)
      beta  = 1.00-alpha         ! Impliciteness
      ab    = alpha/beta         !


C +--Tridiagonal Matrix Coefficients:  qiHY, ccniHY, qwHY, qrHY
C +  (Turbulent Diffusion Coefficient X 3:  Bintanja, 2000, BLM) --+
C +  -----------------------------------------------------------   V

C +--Diagonal A
C +  ~~~~~~~~~~
      DO    k=mz,1,-1
           kp=kp1(k)

        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz8(i,j,k)=                            TUkvh(i,j,k)*r_Turb
c _HH.                                            +pente3(i,j,k)
c #PE.                                            +pente3(i,j,k)
c #vL   END DO
c #vL   END DO

c #vL   DO  j=jp11,my1
c #vL   DO  i=ip11,mx1
          WKxyz1(i,j,k)=-gravi2*beta*romiDY(i,j,k)*WKxyz8(i,j,k)
     .           *rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
        END DO
        END DO

C +--Diagonal C
C +  ~~~~~~~~~~
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz3(i,j,kp)=WKxyz1(i,j,k)  *dsigm1(k)    /dsigm1(kp)
     .                                  /rolvDY(i,j,k)*rolvDY(i,j,kp)
        END DO
        END DO

      END DO

C +--A, B, C
C +  ~~~~~~~
      DO    k=1,mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)  =       WKxyz1(i,j,k) * dt_Loc
          WKxyz3(i,j,k)  =       WKxyz3(i,j,k) * dt_Loc
          WKxyz2(i,j,k)  = 1.0 - WKxyz3(i,j,k) - WKxyz1(i,j,k)
        END DO
        END DO
      END DO

C +--Vertical B.C.
C +  ~~~~~~~~~~~~~
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz3(i,j, 1) = 0.0
          WKxyz2(i,j, 1) = 1.0 - WKxyz1(i,j,1)
        END DO
        END DO


C +-------------------------------------------------------------------------


C +--BEGIN Cloud Microphysics (qiHY, ccniHY, qwHY, qrHY)
C +  ===================================================

c #HY IF (micphy)                                                   THEN


C +--Vertical Diffusion of Ice Crystals
C +  ==================================


C +--Second Member of the Tridiagonal System - qiHY
C +  ----------------------------------------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz1(i,j,1)= 0.0
c #HY       WKxyz2(i,j,1)= 1.0
c #HY       WKxyz4(i,j,1)= qiHY(i,j,1)
c #HY     END DO
c #HY     END DO

c #HY   DO    k=kp1(1),mmz1
c #HY        kp=kp1(k)
c #HY        km=km1(k)
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = 
c #HY.      WKxyz1(i,j,k)*ab*(qiHY(i,j,k )-qiHY(i,j,kp))
c #HY.     -WKxyz3(i,j,k)*ab*(qiHY(i,j,km)-qiHY(i,j,k ))
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,mz)= 
c #HY.      WKxyz1(i,j,mz)*ab*(qiHY(i,j,mz)  -zero        )
c #HY.    - WKxyz3(i,j,mz)*ab*(qiHY(i,j,mmz1)-qiHY(i,j,mz))
c #HY     END DO
c #HY     END DO


C +--Tridiagonal Matrix Inversion - qiHY
C +  -----------------------------------

c #HY   DO    k=kp1(1),mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = WKxyz4(i,j,k) + qiHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY   k1_tua = 1
c #HY   k2_tua = mz

C +          ************
c #HY   call MARgz_2mx1y1(k1_tua,k2_tua)
C +          ************

c #HY   DO    k=1,mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       qiHY(i,j,k) = WKxyz7(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Second Member of the Tridiagonal System - ccniHY
C +  ------------------------------------------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz1(i,j,1)= 0.0
c #HY       WKxyz2(i,j,1)= 1.0
c #HY       WKxyz4(i,j,1)= ccniHY(i,j,1)
c #HY     END DO
c #HY     END DO

c #HY   DO    k=kp1(1),mmz1
c #HY        kp=kp1(k)
c #HY        km=km1(k)
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = 
c #HY.      WKxyz1(i,j,k)*ab*(ccniHY(i,j,k )-ccniHY(i,j,kp))
c #HY.     -WKxyz3(i,j,k)*ab*(ccniHY(i,j,km)-ccniHY(i,j,k ))
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,mz)= 
c #HY.      WKxyz1(i,j,mz)*ab*(ccniHY(i,j,mz)  -zero          )
c #HY.    - WKxyz3(i,j,mz)*ab*(ccniHY(i,j,mmz1)-ccniHY(i,j,mz))
c #HY     END DO
c #HY     END DO


C +--Tridiagonal Matrix Inversion - ccniHY
C +  -------------------------------------

c #HY   DO    k=kp1(1),mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = WKxyz4(i,j,k) + ccniHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY   k1_tua = 1
c #HY   k2_tua = mz

C +          ************
c #HY   call MARgz_2mx1y1(k1_tua,k2_tua)
C +          ************

c #HY   DO    k=1,mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       ccniHY(i,j,k) = WKxyz7(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Precipitation
C +  -------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       dd_sno      =               dt_Loc * rolvDY(i,j,mz)
c #HY.                         * WKxyz8(i,j,mz)*   qiHY(i,j,mz)
c #HY.                         /(gplvDY(i,j,mz)* grvinv-sh(i,j))
c #HY       crysHY(i,j) = crysHY(i,j) + dd_sno
c #HY       snohSL(i,j) = snohSL(i,j) + dd_sno
c #HY     END DO
c #HY     END DO


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of Cloud Droplets
C +  ====================================


C +--Second Member of the Tridiagonal System - qwHY
C +  ----------------------------------------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz1(i,j,1)= 0.0
c #HY       WKxyz2(i,j,1)= 1.0
c #HY       WKxyz4(i,j,1)= qwHY(i,j,1)
c #HY     END DO
c #HY     END DO

c #HY   DO    k=kp1(1),mmz1
c #HY        kp=kp1(k)
c #HY        km=km1(k)
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = 
c #HY.      WKxyz1(i,j,k)*ab*(qwHY(i,j,k )-qwHY(i,j,kp))
c #HY.     -WKxyz3(i,j,k)*ab*(qwHY(i,j,km)-qwHY(i,j,k ))
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,mz)= 
c #HY.      WKxyz1(i,j,mz)*ab*(qwHY(i,j,mz)  -zero        )
c #HY.    - WKxyz3(i,j,mz)*ab*(qwHY(i,j,mmz1)-qwHY(i,j,mz))
c #HY     END DO
c #HY     END DO


C +--Tridiagonal Matrix Inversion - qwHY
C +  -----------------------------------

c #HY   DO    k=kp1(1),mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = WKxyz4(i,j,k) + qwHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY   k1_tua = 1
c #HY   k2_tua = mz

C +          ************
c #HY   call MARgz_2mx1y1(k1_tua,k2_tua)
C +          ************

c #HY   DO    k=1,mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       qwHY(i,j,k) = WKxyz7(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Precipitation
C +  -------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       rainHY(i,j) = rainHY(i,j) + dt_Loc * rolvDY(i,j,mz)
c #HY.                         * WKxyz8(i,j,mz)*   qwHY(i,j,mz)
c #HY.                         /(gplvDY(i,j,mz)* grvinv-sh(i,j))
c #HY     END DO
c #HY     END DO


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of Rain Drops
C +  ================================


C +--Second Member of the Tridiagonal System - qrHY
C +  ----------------------------------------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz1(i,j,1)= 0.0
c #HY       WKxyz2(i,j,1)= 1.0
c #HY       WKxyz4(i,j,1)= qrHY(i,j,1)
c #HY     END DO
c #HY     END DO

c #HY   DO    k=kp1(1),mmz1
c #HY        kp=kp1(k)
c #HY        km=km1(k)
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = 
c #HY.      WKxyz1(i,j,k)*ab*(qrHY(i,j,k )-qrHY(i,j,kp))
c #HY.     -WKxyz3(i,j,k)*ab*(qrHY(i,j,km)-qrHY(i,j,k ))
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,mz)= 
c #HY.      WKxyz1(i,j,mz)*ab*(qrHY(i,j,mz)  -zero        )
c #HY.    - WKxyz3(i,j,mz)*ab*(qrHY(i,j,mmz1)-qrHY(i,j,mz))
c #HY     END DO
c #HY     END DO


C +--Tridiagonal Matrix Inversion - qrHY
C +  -----------------------------------

c #HY   DO    k=kp1(1),mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = WKxyz4(i,j,k) + qrHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY   k1_tua = 1
c #HY   k2_tua = mz

C +          ************
c #HY   call MARgz_2mx1y1(k1_tua,k2_tua)
C +          ************

c #HY   DO    k=1,mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       qrHY(i,j,k) = WKxyz7(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO


C +--Precipitation
C +  -------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       rainHY(i,j) = rainHY(i,j) + dt_Loc * rolvDY(i,j,mz)
c #HY.                         * WKxyz8(i,j,mz)*   qrHY(i,j,mz)
c #HY.                         /(gplvDY(i,j,mz)* grvinv-sh(i,j))
c #HY     END DO
c #HY     END DO


C +--END   Cloud Microphysics (qiHY, ccniHY, qwHY, qrHY)
C +  ===================================================

c #HY END IF


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of (Terrigeneous) Hydrometeors and Tracers
C +  =============================================================

C +--Tridiagonal Matrix Coefficients: Modifications for qsHY, qxTC
C +  -------------------------------------------------------------

C +--Diagonal A
C +  ~~~~~~~~~~
            k=  mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)= 0.
c #se     WKxyz1(i,j,k)=-gravi2*beta*romiDY(i,j,k)*(zero
c _HH.                                            +pente3(i,j,k)
c #PE.                                            +pente3(i,j,k)
c #se.          )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
        END DO
        END DO

C +--A, B, C
C +  ~~~~~~~
            k=  mz
        DO  j=jp11,my1
        DO  i=ip11,mx1
          WKxyz1(i,j,k)  =       WKxyz1(i,j,k) * dt_Loc
          WKxyz2(i,j,k)  = 1.0 - WKxyz3(i,j,k) - WKxyz1(i,j,k)
        END DO
        END DO


C +-------------------------------------------------------------------------


C +--BEGIN Cloud Microphysics (qsHY)
C +  ===============================

      IF (micphy)                                                   THEN


C +--Vertical Diffusion of Snow Flakes
C +  =================================


C +--Second Member of the Tridiagonal System - qsHY
C +  ----------------------------------------------

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz1(i,j,1)= 0.0
c #HY       WKxyz2(i,j,1)= 1.0
c #HY       WKxyz4(i,j,1)= qsHY(i,j,1)
c #HY     END DO
c #HY     END DO

c #HY   DO    k=kp1(1),mmz1
c #HY        kp=kp1(k)
c #HY        km=km1(k)
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = 
c #HY.      WKxyz1(i,j,k)*ab*(qsHY(i,j,k )-qsHY(i,j,kp))
c #HY.     -WKxyz3(i,j,k)*ab*(qsHY(i,j,km)-qsHY(i,j,k ))
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       ussno   = uss_HY(i,j)
c #HY       WKxyz4(i,j,mz)=
c #HY.      WKxyz1(i,j,mz)
c #HY.                   *(ab* qsHY(i,j,mz)  -qsrfHY(i,j)/beta)
c #HY.    - WKxyz3(i,j,mz)*ab*(qsHY(i,j,mmz1)-  qsHY(i,j,mz))
c #HY.    +(gravit*dt_Loc *  rolvDY(i,j,mz) 
c #HY.                      /(pstDY(i,j) *(sigmid(mz)-1.0))) 
c #HY.                    *   ussno
c #HY     END DO
c #HY     END DO


C +--Tridiagonal Matrix Inversion - qsHY
C +  -----------------------------------

c #HY   DO    k=kp1(1),mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       WKxyz4(i,j,k) = WKxyz4(i,j,k) + qsHY(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO

c #HY   k1_tua = 1
c #HY   k2_tua = mz

C +          ************
c #HY   call MARgz_2mx1y1(k1_tua,k2_tua)
C +          ************

c #HY   DO    k=1,mz
c #HY     DO  j=jp11,my1
c #HY     DO  i=ip11,mx1
c #HY       qsHY(i,j,k) = WKxyz7(i,j,k)
c #HY     END DO
c #HY     END DO
c #HY   END DO

C +--OUTPUT of Snow Erosion Statistics
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #EV   IF (lEVwri.GT.0  .AND.  lEVwri.LE.2)                        THEN
c #EV     write(6,6011)  itexpe,iEVwri,jEVwri,nEVwri,
c #EV.                   uss_HY(iEVwri,jEVwri)  *1.e3
 6011     format(/,'Iteration',i6,'    Point',3i4,
     .         /,10x,'After TURabl   : us* [mm/s] =',f9.3)
c #EV     write(6,6012)   (qsHY(iEVwri,jEVwri,k)*1.e3,k=mz,mz-4,-1)
 6012     format(10x,'               : q   [g/kg] =',5f9.6)
c #EV   END IF


C +--END   Cloud Microphysics (qsHY)
C +  ===============================

      END IF


C +-------------------------------------------------------------------------


C +--Vertical Diffusion of non gazeous Tracers
C +  =========================================

c #TC IF (dt_ODE.eq.dtDiff.AND.nterr.GT.0)                          THEN


C +--Second Member of the Tridiagonal System - qxTC
C +  ----------------------------------------------

c #TC   DO     n=1,nterr

c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz1(i,j,1)= 0.0
c #TC         WKxyz2(i,j,1)= 1.0
c #TC         WKxyz4(i,j,1)= qxTC(i,j,1,n)
c #TC       END DO
c #TC       END DO

c #TC     DO   k=kp1(1),mmz1
c #TC         kp=kp1(k)
c #TC         km=km1(k)
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz4(i,j,k) = 
c #TC.        WKxyz1(i,j,k)*ab*(qxTC(i,j,k ,n)-qxTC(i,j,kp,n))
c #TC.       -WKxyz3(i,j,k)*ab*(qxTC(i,j,km,n)-qxTC(i,j,k ,n))
c #TC       END DO
c #TC       END DO
c #TC     END DO

c #TC     IF (.NOT.BloMod)                                          THEN
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         uqTC(i,j,n)=-cdhSL(i,j,1)* SLuusl(i,j,1)
c #TC.                                 *  (qsTC(i,j,n)- qxTC(i,j,mz,n))
c #TC       END DO
c #TC       END DO 
c #TC     END IF

c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz4(i,j,mz)=  WKxyz1(i,j,mz)
c #TC.                     *(ab* qxTC(i,j,mz  ,n)-qsTC(i,j,n)/beta)
c #TC.      - WKxyz3(i,j,mz)*ab*(qxTC(i,j,mmz1,n)-qxTC(i,j,mz,n))
c #TC.            +(gravit*dt_Loc
c #TC.              *rolvDY(i,j,mz)/(pstDY(i,j)*(sigmid(mz)-1.0d+0))) 
c #TC.                *uqTC(i,j,n) 
c #TC       END DO
c #TC       END DO 


C +--Tridiagonal Matrix Inversion - qxTC
C +  -----------------------------------

c #TC     DO   k=kp1(1),mz
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC         WKxyz4(i,j,k) = WKxyz4(i,j,k) + qxTC(i,j,k,n)
c #TC       END DO
c #TC       END DO
c #TC     END DO

c #TC     k1_tua = 1
c #TC     k2_tua = mz

C +            ************
c #TC     call MARgz_2mx1y1(k1_tua,k2_tua)
C +            ************

c #TC     DO   k=1,mz
c #TC       DO j=jp11,my1
c #TC       DO i=ip11,mx1
c #TC        qxTC(i,j,k,n) = WKxyz7(i,j,k)
c #TC       END DO
c #TC       END DO
c #TC     END DO

c #TC   END DO

c #TC END IF


C +-------------------------------------------------------------------------


C +--Atmospheric Water Budget
C +  ========================

c #EW DO     i=ip11,mx1
c #EW DO     j=jp11,my1
c #EW     wat1EW(i,j) =  0.00
c #EW   DO   k=1,mz
c #EW     wat1EW(i,j) =  wat1EW(i,j)
c #EW.                +   (qvDY(i,j,k)
c #EW.                +    qwHY(i,j,k) + qrHY(i,j,k)
c #EW.                +    qiHY(i,j,k) + qsHY(i,j,k) ) *dsigm1(k)
c #EW   END DO
c #EW     wat1EW(i,j) =  wat1EW(i,j)  * pstDY(i,j)     *grvinv
c #EW     watfEW(i,j) =-(uss_HY(i,j)  + SLuqs(i,j)) 
c #EW.          *dt_Loc *rolvDY(i,j,mz)
c #EW END DO
c #EW END DO


C +-------------------------------------------------------------------------


C +--Atmospheric Water Budget: Output
C +  ================================
C +
c #EW     waterb = wat1EW(imez,jmez)
c #EW.            -wat0EW(imez,jmez)-watfEW(imez,jmez)
c #EW     write(6,606) jdaMAR,jhaMAR,jmmMAR,
c #EW.               1.d3*wat0EW(imez,jmez),1.d3*wat1EW(imez,jmez),
c #EW.                                      1.d3*watfEW(imez,jmez),
c #EW.                                      1.d3*waterb
 606    format(3i3,'  Before vDif:      ', 12x ,'  W0 = ',f9.6,
     .        /,9x,'  After  vDif:      ', 12x ,'  W1 = ',f9.6,
     .                                          '  W Flux =',f9.6,
     .                                          '  Div(W) =',e9.3)


C +-------------------------------------------------------------------------


C +--Work Arrays Reset
C +  =================

      DO k=1,mz
         DO j=jp11,my1
         DO i=ip11,mx1
            WKxyz1(i,j,k) = 0.00
            WKxyz2(i,j,k) = 0.00
            WKxyz3(i,j,k) = 0.00
            WKxyz4(i,j,k) = 0.00
            WKxyz5(i,j,k) = 0.00
            WKxyz6(i,j,k) = 0.00
            WKxyz7(i,j,k) = 0.00
         END DO
         END DO
      END DO

         DO j=jp11,my1
         DO i=ip11,mx1
            WKxy1(i,j) = 0.00
         END DO
         END DO

      return
      end


      subroutine TURabl_TC
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ABL)                                    2-10-2002  MAR |
C |   SubRoutine TURabl_TC includes Contribution of Vertical Turbulence    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT (via common block)                                              |
C |  ^^^^^  dt_Loc         : Vertical Diffusion Time Step              [s] |
C |         TUkvh(mx,my,mz): Vertical Turbulent Coeffic.(heat)     [m2/s2] |
C |                                                                        |
C |  INPUT / OUTPUT: The Vertical Turbulent Fluxes are included for:       |
C |  ^^^^^^^^^^^^^^                                                        |
C |          Tracers                       qxTC(mx,my,mz,ntrac)    [kg/kg] |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
      include 'MAR_TU.inc'
c #PE include 'MARpen.inc'
C +
c #TC include 'MAR_TC.inc'
C +
      include 'MAR_SL.inc'
C +
      include 'MAR_WK.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  n     ,i1_tuc,i2_tuc,j1_tuc,j2_tuc,k1_tuc,k2_tuc 
      real     alpha ,beta  ,ab
C +
C +
C +--Parameters
C +  ==========
C +
C +
C +--For the Numerical Scheme of Vertical Turbulent Transport
C +  --------------------------------------------------------
C +
      alpha = 0.25
      beta  = 1.00-alpha
      ab    = alpha/beta
C +...For the implicit scheme
C +
C +
C +-------------------------------------------------------------------------
C +
C +
C +--Height above the Surface
C +  ========================
C +
      DO j = 1,my
         DO i = 1,mx
               WKxy1(i,j) =  (gplvDY(i,j,mz)-gplvDY(i,j,mzz)) *grvinv
C +...         CAUTION: same SL_z0 is used here for both sectors of gridbox
C +            (assumption having a negligible effect)
C +
         END DO
      END DO
C +
C +
C +-------------------------------------------------------------------------
C +
C +
C +--Vertical Diffusion of Tracers
C +  =============================
C +
C +
C +--Tridiag. Matrix Coeff.
C +  ----------------------
C +
        DO j=1,my
        DO i=1,mx
          TUkvh(i,j,mz) = 0.0
        END DO
        END DO
C +
C +--Diagonal A
C +  ~~~~~~~~~~
      DO k=mz,1,-1
        DO j=1,my
        DO i=1,mx
          WKxyz1(i,j,k)=-gravi2*beta*romiDY(i,j,k)*(TUkvh(i,j,k)
c _HH.                                            +pente3(i,j,k)
c #PE.                                            +pente3(i,j,k)
     .          )*rolvDY(i,j,k)/(pstDY2(i,j)*dsigm1(k)*dsig_1(k))
        END DO
        END DO
C +
C +--Diagonal C
C +  ~~~~~~~~~~
        DO j=1,my
        DO i=1,mx
          WKxyz3(i,j,kp1(k))=
     .    WKxyz1(i,j,k)  *dsigm1(k)    /dsigm1(kp1(k))
     .               /rolvDY(i,j,k)*rolvDY(i,j,kp1(k))
        END DO
        END DO
C +
      END DO
C +
C +--A, B, C
C +  ~~~~~~~
      DO k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz1(i,j,k)  =       WKxyz1(i,j,k) * dt_Loc
          WKxyz3(i,j,k)  =       WKxyz3(i,j,k) * dt_Loc
          WKxyz2(i,j,k)  = 1.0 - WKxyz3(i,j,k) - WKxyz1(i,j,k)
        END DO
        END DO
      END DO
C +
C +--Vertical B.C.
C +  ~~~~~~~~~~~~~
        DO j=1,my
        DO i=1,mx
          WKxyz3(i,j, 1) = 0.0
          WKxyz2(i,j, 1) = 1.0 - WKxyz1(i,j,1)
        END DO
        END DO
C +
C +
C +--Second Member of the Tridiagonal System - qxTC
C +  ----------------------------------------------
C +
c #TC DO n=1,ntrac
C +
c #TC     DO j=1,my
c #TC     DO i=1,mx
C +
c #TC       WKxyz1(i,j,1)= 0.0
c #TC       WKxyz2(i,j,1)= 1.0
c #TC       WKxyz4(i,j,1)= qxTC(i,j,1,n)
C +
c #TC     END DO
c #TC     END DO
C +
c #TC   DO k=kp1(1),mmz1
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC       WKxyz4(i,j,k) = 
c #TC.      WKxyz1(i,j,k)*ab*(qxTC(i,j,k,n)-qxTC(i,j,kp1(k),n))
c #TC.     -WKxyz3(i,j,k)*ab*(qxTC(i,j,km1(k),n)-qxTC(i,j,k,n))
c #TC     END DO
c #TC     END DO
c #TC   END DO
C +
c #TC     IF (.NOT.BloMod)                                        THEN
c #TC       DO j=1,my
c #TC       DO i=1,mx
c #TC         uqTC(i,j,n)=-cdhSL(i,j,1)* SLuusl(i,j,1)
c #TC.                                 *  (qsTC(i,j,n)- qxTC(i,j,mz,n))
c #TC       END DO
c #TC       END DO
c #TC     END IF
C +
c #TC       DO j=1,my
c #TC       DO i=1,mx
c #TC         WKxyz4(i,j,mz)=  WKxyz1(i,j,mz)
c #TC.                     *(ab* qxTC(i,j,mz  ,n)-qsTC(i,j,n)/beta)
c #TC.      - WKxyz3(i,j,mz)*ab*(qxTC(i,j,mmz1,n)-qxTC(i,j,mz,n))
c #TC.            +(gravit*dt_Loc
c #TC.              *rolvDY(i,j,mz)/(pstDY(i,j)*(sigmid(mz)-1.0d+0)))
c #TC.                *uqTC(i,j,n)
c #TC       END DO
c #TC       END DO
C +
C +
C +--Tridiagonal Matrix Inversion - qxTC 
C +  -----------------------------------
C +
c #TC   DO k=kp1(1),mz
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC       WKxyz4(i,j,k) = WKxyz4(i,j,k) + qxTC(i,j,k,n)
c #TC     END DO
c #TC     END DO
c #TC   END DO
C +
c #TC   i1_tuc = 1
c #TC   i2_tuc = mx
c #TC   j1_tuc = 1
c #TC   j2_tuc = my
c #TC   k1_tuc = 1
c #TC   k2_tuc = mz
C +
C +     *************
c #TC   call MARgau_z(i1_tuc,i2_tuc,j1_tuc,j2_tuc,k1_tuc,k2_tuc)
C +     *************
C +
c #TC   DO k=1,mz
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC       qxTC(i,j,k,n) = WKxyz7(i,j,k)
c #TC     END DO
c #TC     END DO
c #TC   END DO
C +
c #TC END DO
C +
C +
C +-------------------------------------------------------------------------
C +
C +
C +--Work Arrays Reset
C +  =================
C +
      do k=1,mz
         do j=1,my
         do i=1,mx
            WKxyz1(i,j,k) = 0.00
            WKxyz2(i,j,k) = 0.00
            WKxyz3(i,j,k) = 0.00
            WKxyz4(i,j,k) = 0.00
            WKxyz5(i,j,k) = 0.00
            WKxyz6(i,j,k) = 0.00
            WKxyz7(i,j,k) = 0.00
         end do
         end do
      end do
C +
      do j=1,my
         do i=1,mx
            WKxy1(i,j) = 0.00
         end do
      end do
C +
      return
      end
      subroutine TURgau_v(i1_tuv,i2_tuv,mmk) 
C +
C +------------------------------------------------------------------------+
C | MAR TURBULENCE (ABL)                                   15-09-2001  MAR |
C |   SubRoutine TURgau_v uses the Gaussian Elimination Algorithm          | 
C |    (e.g. Pielke (1984), pp.302--303)                                   |
C |    which is needed to solve the implicit scheme developped for         |
C |    vertical diffusion                                                  |
C |   Vectorization is allowed along direction x (i=1,mx)                  |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
C +
      include 'MAR_WK.inc'
C +
      integer  i1_tuv,i2_tuv,mmk 
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  i ,k ,k1
C +
C +
C +--Forward  Sweep
C +  ==============
C +
        DO i=i1_tuv,i2_tuv
          WKxzp(i,1) =  WKxzb(i,1)
        END DO
        DO i=i1_tuv,i2_tuv
          WKxzq(i,1) = -WKxza(i,1) /WKxzp(i,1)
        END DO
      DO   k=2,mmk
        DO i=i1_tuv,i2_tuv
          WKxzp(i,k) =  WKxzc(i,k) *WKxzq(i,k-1) +WKxzb(i,k)
        END DO
        DO i=i1_tuv,i2_tuv
          WKxzq(i,k) = -WKxza(i,k) /WKxzp(i,k)
        END DO
      END DO
        DO i=i1_tuv,i2_tuv
          WKxzx(i,1) =  WKxzd(i,1) /WKxzp(i,1)
        END DO
      DO   k=2,mmk
        DO i=i1_tuv,i2_tuv
          WKxzx(i,k) = (WKxzd(i,k) -WKxzc(i,k) *WKxzx(i,k-1))/WKxzp(i,k)
        END DO
      END DO
C +
C +
C +--Backward Sweep
C +  ==============
C +
      DO   k1=2,mmk
           k=mmk-k1+1
        DO i=i1_tuv,i2_tuv
          WKxzx(i,k) =  WKxzq(i,k) *WKxzx(i,k+1) +WKxzx(i,k)
        END DO
      END DO
C +
      return
      end


      subroutine TUR_2m
 
C +------------------------------------------------------------------------+
C | MAR DYNAMICS                                       Fri 23-04-2010  MAR |
C |                                                                        |
C |   SubRoutine TUR_2m computes (max,min) 2 m air temperature             |
C |                               current  2 m air temperature             |
C |                               current  3 m air temperature, Wind Speed |
C |                               current 10 m                  Wind Speed |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT: tairDY: real temperature                                     |
C |    ^^^^^^ qvDY  : specific humidity                                    |
C |           gplvDY: geopotential                                         |
C |           SLuus : friction velocity                                    |
C |           SLuts : surface heat flux                                    |
C |           SLuqs : surface moisture flux                                |
C |           SLuqs : Blowing Snow     flux                                |
C |                                                                        |
C |   OUTPUT: Ta2mSL: interpolated  2 meter air temperature (manned)       |
C |   ^^^^^^^ TminSL: minimum       2 meter air temperature                |
C |           TmaxSL: maximum       2 meter air temperature                |
C |           Ta3mSL: interpolated  3 meter air temperature (AWS)          |
C |           V03mSL: interpolated  3 meter wind speed      (AWS)          |
C |           V10mSL: interpolated 10 meter wind speed      (manned)       |
C |                                                                        |
C +------------------------------------------------------------------------+
 
 
      IMPLICIT NONE
 
 
C +--Global Variables
C +  ================
 
      include 'MARCTR.inc'
      include 'MARphy.inc'
      include 'MARdim.inc'
 
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
 
      include 'MAR_DY.inc'
      include 'MAR_SL.inc'
 
 
C +--Local  Variables
C +  ================
 
      integer  n
      real     aux
      real     VV_SBL,zvvSBL,TT_SBL,zttSBL,sgnLMO
      real     zetv_i,zetT_i,Psim  ,Psih
      real     Psi__s,Psih_s,Psi__i,Psih_i
      real     xx2Psi,xx1Psi,yy2Psi,yy1Psi
      real     TT_AWS(2,mx,my,mw)
      real     FF_AWS(2,mx,my,mw)
 
      real     zttAWS(2)
      real     zvvAWS(2)
      data     zttAWS / 2.0, 3.0/
      data     zvvAWS / 3.0,10.0/
 
!     real     aux  ,za   ,z2m,thst,aL,zmax,qvst,psiha,psih2m,factor,
!    .         delth,delqv,T2m,q2m
 
 
C +----Transition hour for min./max. temp. computing
C +    =============================================
 
      real     hourTU
      DATA     hourTU  / 24  /
 
C +... Min./max. temperatures are computed according to the following
C +    time interval : [hourTU(day-1),hourTU(day)].
C +                     ^^^^ U.T.
 
 
C +----Initialisation
C +    ==============
 
      aux=60.*real(minuGE)+real(jsecGE)
      IF ((jhurGE.eq.0.and.aux.lt.dt) .or.
     .    (itexpe.le.1) )                                           THEN
        DO n=1,mw
        DO j=1,my
        DO i=1,mx
         TminSL(i,j,n)= 1000.
         TmaxSL(i,j,n)=-1000.
        ENDDO
        ENDDO
        ENDDO
      ENDIF
 
 
!      Interpolation of temperature and wind speed using
!      Monin-Obukhov similarity theory and
!      Businger      stability  fonctions.
!      =================================================
 
      DO   k=1,2
 
        DO n=1,mw
        DO j=1,my
        DO i=1,mx
 
          VV_SBL=              ssvSL(i,j,mz)                      ! Ref. Level
          zvvSBL=    grvinv * gplvDY(i,j,mz)-    sh(i,j)          ! Ref. Level
          TT_SBL=             tairDY(i,j,mz)                      ! Ref. Level
          zttSBL=    grvinv * gplvDY(i,j,mz)-    sh(i,j)          ! Ref. Level
 
 
        ! STABLE   Situation
          zetv_i= zvvAWS(k)               /max(epsi,SLlmol(i,j,n))!
          zetv_i=        zetv_i- zvvSBL   /max(epsi,SLlmol(i,j,n))!
          zetT_i= zttAWS(k)               /max(epsi,SLlmol(i,j,n))!
          zetT_i=        zetT_i- zttSBL   /max(epsi,SLlmol(i,j,n))!
          Psi__s=  -6.0* zetv_i                                   !
          Psih_s=  -6.0* zetT_i                                   !
 
        ! UNSTABLE Situation
          xx2Psi=sqrt(sqrt(1.-15.*zvvAWS(k)/min(-epsi,SLlmol(i,j,n))))
          xx1Psi=sqrt(sqrt(1.-15.*zvvSBL   /min(-epsi,SLlmol(i,j,n))))
          Psi__i=2. * log(0.5*(1.+xx2Psi))                        !
     .          +     log(0.5*(1.+xx2Psi*xx2Psi))                 !
     .          -2. *atan(        xx2Psi        )                 !
     .          -2. * log(0.5*(1.+xx1Psi))                        !
     .          -     log(0.5*(1.+xx1Psi*xx1Psi))                 !
     .          +2. *atan(        xx1Psi        )                 !
          yy2Psi=    sqrt(1.0- 9.*zttAWS(k)/min(-epsi,SLlmol(i,j,n)))
          yy1Psi=    sqrt(1.0- 9.*zttSBL   /min(-epsi,SLlmol(i,j,n)))
          Psih_i=     log(0.5*(1.+yy2Psi))                        !
     .          -     log(0.5*(1.+yy1Psi))                        !
 
        ! ACTUAL   Situation
          sgnLMO   = sign(1.0,SLlmol(i,j,n))
          Psim     =  max(0.0,sgnLMO)*Psi__s-min(0.0,sgnLMO)*Psi__i
          Psih     =  max(0.0,sgnLMO)*Psih_s-min(0.0,sgnLMO)*Psih_i
 
          FF_AWS(k,i,j,n)=               VV_SBL                   !Businger, 73
     .               +SLuusl(i,j,n)*(log(zvvAWS(k)/zvvSBL)  -Psim)!WkShop micro
     .                       / 0.4                                ! meteo (3.7)
          FF_AWS(k,i,j,n)= max(0.0      ,FF_AWS(k,i,j,n))         !
          TT_AWS(k,i,j,n)=               TT_SBL                   !Businger, 73
     .         + 0.74*SLutsl(i,j,n)*(log(zttAWS(k)/zttSBL)  -Psih)!WkShop micro
     .      /max(epsi,SLuusl(i,j,n))                              ! meteo (3.8)
 
 
!  OLD (Philippe Marbaix)
!  ----------------------
!       za  =(gplvDY(i,j,mz)-gplvDY(i,j,mzz))/9.81     ! first level height
!       z2m =2.                                        ! interpolation level
!       thst=SLuts(i,j)/SLuus(i,j)                     ! theta*
!       thst=AMAX1(thst,0.001)                         ! theta* not equal 0
!       qvst=SLuqs(i,j)/SLuus(i,j)                     ! qv*
!       aL  =75.*SLuus(i,j)**2./thst                   ! Monin-Obukhov lenght
!       zmax=AMAX1(z2m,za)
 
!       IF (aL.LE.0.) THEN                             ! unstable case
!         IF (ABS(aL).LT.0.2*zmax) aL=-0.2*zmax
!         psiha =2.*ALOG(0.5*(1.+sqrt(1.-16.*za/aL)))
!         psih2m=2.*ALOG(0.5*(1.+sqrt(1.-16.*z2m/aL)))
!       ELSE                                           ! stable case
!        IF (ABS(aL).LT.zmax) aL=zmax
!        psiha =-5.*za/aL
!        psih2m=-5.*z2m/aL
!       ENDIF
 
!       factor=ALOG(za/z2m)-psiha+psih2m
!       delth =thst*factor/0.4
!       delqv =qvst*factor/0.4
 
!       T2m=tairDY(i,j,mz)-delth             ! interpolated temperature
!       q2m=qvDY(i,j,mz)-delqv               ! interpolated specific humidity
 
!       Ta2mSL(i,j,n)=T2m
 
        ENDDO
        ENDDO
        ENDDO
      ENDDO
 
 
C +-----tÂ°(max,min)
C +     ===========
 
        DO n=1,mw
        DO j=1,my
        DO i=1,mx
          Ta2mSL(i,j,n)=  TT_AWS(1,i,j,n)
          Ta3mSL(i,j,n)=  TT_AWS(2,i,j,n)
          V03mSL(i,j,n)=  FF_AWS(1,i,j,n)
          V10mSL(i,j,n)=  FF_AWS(2,i,j,n)
          TminSL(i,j,n)=MIN(Ta2mSL(i,j,n),TminSL(i,j,n))
          TmaxSL(i,j,n)=MAX(Ta2mSL(i,j,n),TmaxSL(i,j,n))
        ENDDO
        ENDDO
        ENDDO
 
      return
      end


      subroutine CVAorg

C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         15-11-2004  MAR |
C |                                                                        |
C |   SubRoutine CVAorg     dispatches         THE CONVECTIVE ADJUSTMENT   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | INPUT (via common block)                                               |
C | ^^^^^^  itexpe: Iteration        Counter, since Experiment Beginning   |
C |         itConv: Adjustment Calls Counter                               |
C |         dt_Loc: Mass Flux convective Scheme: Time Step                 |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARdim.inc'
      include 'MARgrd.inc'


C +--Local  Variables
C +  ================

      logical CVA_FC,CVA_LA,CVA_KE


C +--DATA
C +  ====

           CVA_FC  =  .false.      ! Fritsch and Chappell scheme
           CVA_LA  =  .false.      ! Bechtold             scheme
           CVA_KE  =  .false.      ! Kerry Emanuel        Scheme
c #FC      CVA_FC  =  .true.
c #PB      CVA_LA  =  .true.
c #KE      CVA_KE  =  .true.


C +--Fritsch and Chappell convective adjustment scheme
C +  =================================================

C +                 ***************
c #FC IF  (CVA_FC)  call CVAgen_MAR
C +                 ***************


C +--Bechtold             convective adjustment scheme
C +  =================================================

C +                 ***************
c #PB IF  (CVA_LA)  call CVAgen_MNH
C +                 ***************


C +--Emanuel              convective adjustment scheme
C +  =================================================

C +                 ***************
c #KE IF  (CVA_KE)  call CVAgen_GCM
C +                 ***************

      return
      end


      subroutine CVAgen_MAR

C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         06-04-2004  MAR |
C |                                                                        |
C |   SubRoutine CVAgen_MAR contains .main. of the CONVECTIVE ADJUSTMENT   |
C |                     SCHEMES : - Fritsch and Chappell         (1980)    |
C |                                 improved by Kain and Fritsch (1990)    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | INPUT:  itexpe: Iteration        Counter, since Experiment Beginning   |
C | ^^^^^^  itConv: Adjustment Calls Counter                               |
C |         dt_Loc: Mass Flux convective Scheme: Time Step                 |
C |                                                                        |
C | INPUT / OUTPUT: The Vertical Profiles of :                             |
C | ^^^^^^^^^^^^^^                                                         |
C |   a) Potential Temperature   pktaDY(mx,my,mz)                      (K) |
C |   b) Specific Humidity       qvDY  (mx,my,mz)                  (kg/kg) |
C |                                                                        |
C | OUTPUT :  rainHY(mx,my) : rain                                     (m) |
C | ^^^^^^^^  adj_CA(mx,my) : number of time steps before the end of the   |
C |                           adjustment                                   |
C |           dpktCA(mx,my,mz) : Adjustment  of Potential Temperature      |
C |           dqv_CA(mx,my,mz) : Adjustment  of Specific  Humidity         |
C |           dqw_CA(mx,my,mz) : Detrainment of Cloud     Droplets         |
C |           dqi_CA(mx,my,mz) : Detrainment of Cloud     Ice Crystals     |
C |           drr_CA(mx,my,mz) : Convective               Precipitation    |
C |           dsn_CA(mx,my,mz) : Latent Heat absorbed in  Snow Melting     |
C |                                                                        |
C | REFER. :  Fritsch and Chappell, 1980, JAS vol. 37, pp. 1722 - 1733.    |
C | ^^^^^^^^  Zhang and Fritsch,    1986, JAS vol. 43, pp. 1913 - 1943.    |
C |           Kain  and Fritsch,    1990, JAS vol. 47, pp. 2784 - 2902.    |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
C +
C +--Fritsch and Chappell convective adjustment scheme
C +  =================================================
C +
C +       ****************
c #FC     call conv_adjust
C +       ****************
C +
      return
      end
      subroutine conv_adjust
C +
C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         19-09-2001  MAR |
C |                                                                        |
C |   SubRoutine conv_adjust includes the Mass Flux convective Scheme      |
C |                          developed by Fritsch and Chappell  (1980)     |
C |                         [improved  by Kain    and Fritsch   (1990)]    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | INPUT   (via common)                                                   |
C | ^^^^^    itexpe: Nb of Iterations                                      |
C |          itConv: Nb of Adjustment Calls                                |
C |          dt_Loc: Local Time Step                                   (s) |
C |                                                                        |
C | INPUT / OUTPUT: The Vertical Profiles of :                             |
C | ^^^^^^^^^^^^^^                                                         |
C |   a) Potential Temperature   pktaDY(mx,my,mz)                      (K) |
C |   b) Specific Humidity       qvDY  (mx,my,mz)                  (kg/kg) |
C |                                                                        |
C | OUTPUT :  rainHY(mx,my) : rain                                     (m) |
C | ^^^^^^^^  adj_CA(mx,my) : number of time steps before the end of the   |
C |                           adjustment                                   |
C |           dpktCA(mx,my,mz) : Adjustment  of Potential Temperature      |
C |           dqv_CA(mx,my,mz) : Adjustment  of Specific  Humidity         |
C |           dqw_CA(mx,my,mz) : Detrainment of Cloud     Droplets         |
C |           dqi_CA(mx,my,mz) : Detrainment of Cloud     Ice Crystals     |
C |           drr_CA(mx,my,mz) : Convective               Precipitation    |
C |           dsn_CA(mx,my,mz) : Latent Heat absorbed in  Snow Melting     |
C |                                                                        |
C | Some INTERNAL VARIABLES: labels contain 6 alphanum. characters, as:    |
C | ^^^^^^^^^^^^^^^^^^^^^^^                                                |
C |           Up and Updr, refering to   Updraft                           |
C |           Dw and Dwdr, refering to Downdraft                           |
C |                  Envr, refering to Environment                         |
C |           u_, v_, w_,  refering to Wind Velocity                       |
C |           T_           refering to                      Temperature    |
C |           Te           refering to Equivalent Potential Temperature    |
C |           Qt           refering to Total        Water Concentration    |
C |           Qv           refering to Specific   Humidity                 |
C |           Qw           refering to Cloud Droplets     Concentration    |
C |           Qi           refering to Cloud Ice Crystals Concentration    |
C |           Qr           refering to Precipitating Rain Concentration    |
C |           Qs           refering to Precipitating Snow Concentration    |
C |           Ev           refering to Evapored     Water Concentration    |
C |           mFlu         refering to Mass Flux                           |
C |           Area         refering to Updraft / Downdraft            Area |
C |           Frac         refering to Updraft / Downdraft Fractional Area |
C |                                                                        |
C | REFER. :  Fritsch and Chappell, 1980, JAS vol. 37, pp. 1722 - 1733.    |
C | ^^^^^^^^  Zhang and Fritsch,    1986, JAS vol. 43, pp. 1913 - 1943.    |
C |           Kain  and Fritsch,    1990, JAS vol. 47, pp. 2784 - 2902.    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |                                                                        |
C |    P A R A M E T E R I Z A T I O N    O F    C O N V E C T I O N       |
C |                                                                        |
C |    -------------------------------------------------------------       |
C |    --------------- FRITSCH  &  CHAPPELL (1980) -----------------       |
C |    ---------- Modified by Zhang and Fristch (1986) -------------       |
C |    -------------------------------------------------------------       |
C |                                                                        |
C | This cumulus parameterization is suitable                              |
C | for horizontal resolution between 20 and 50 km in general, and         |
C |                           between 10 and 20 km for specific situations |
C | (when deep convection is such that all stages of the convection        |
C |                                    are produced in the same grid box). |
C |                                                                        |
C | The formulation is based on the hypothesis that                        |
C | the buoyant energy available to a parcel, in combination with          |
C | a prescribed period of time for the convection to remove that energy,  |
C | can be used to regulate the amount of convection                       |
C |                         in a mesoscale numerical model grid element.   |
C |                                                                        |
C | Individual clouds are represented as                                   |
C |                   entraining moist updraft and downdraft plumes.       |
C | The fraction of updraft condensate evaporated in moist downdrafts      |
C | is determined from an empirical relationship                           |
C |               between the vertical shear of the horizontal wind        |
C |               and     precipitation efficiency.                        |
C | Vertical transports of warming by a compensating subsidence            |
C |                     are included in the parameterization.              |
C | Since updraft and downdraft areas are sometimes                        |
C |       a substantial fraction of mesoscale model grid-element areas,    |
C | grid-point temperatures (adjusted for convection) are                  |
C | an area-weighted mean of updraft,                                      |
C |                          downdraft and                                 |
C |                          environmental temperatures.                   |
C |                                                                        |
C | Significant modifications introduced in the standard scheme :          |
C | - Trigger Function of adjustment scheme,                               |
C | - Treatment of environmental subsidence,                               |
C | - Computation of precipitation,                                        |
C | - Conservation of moist enthalpy and equivalent water content.         |
C |                                                                        |
C | OPTIONS: #fc Specific Fritsch-Chappell (1980) Parameterizations        |
C | ^^^^^^   #zf Specific Zhang----Fritsch (1986) Parameterizations        |
C |          #1D Parameter Adjustment             in 1D Simulations        |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_TE.inc'
      include 'MAR_SL.inc'
C +
      include 'MAR_CA.inc'
      include 'MAR_HY.inc'
C +
      include 'MAR_IO.inc'
C +
      real                 fold_t,wthres,fr_2_3,frac_w
c #AN.                    ,rANA,hANA
      common  /conaju_loc/ fold_t,wthres,fr_2_3,frac_w
c #AN.                    ,rANA,hANA(mx,my)
C +
C +
C +---Local Variables
C +   ===============
C +
      integer kINI,kLCL,kLCL2,kETL,kCT,nCT,kLFS,
     .        NitTUp,NitMax,nitabe,NO_abe,LDtrai,
     .        iter  ,int_0 ,int_1 ,int_2 ,int_3 ,int_5 ,i5
C +
c #AN real    dANA,vANA,xANA,bANA
c _ZF real    stbLCL,ttmix1,ttmix2
C +
c #FC real    GlaCVA
C +
      real               TeUpdr(mz),TeDwdr(mz)
      real               AdiabT(mz),Adia2T(mz)
      real               T_Updr(mz),T_Dwdr(mz),T_Envr(mz),T_Ajst(mz)
      real    u_Envr(mz),v_Envr(mz),w_Envr(mz),p_Envr(mz),ExEnvr(mz),
     .        TeEnvr(mz),roEnvr(mz),
     .        QvEnvr(mz),QtEnvr(mz),PTEnvr(mz),H_Envr(mz),
     .        QvUpdr(mz),QdUpdr(mz),QwUpdr(mz),QiUpdr(mz),
     .        mFluUp(mz),AreaUp(mz),FracUp(mz),w_Updr(mz),
     .        QvDwdr(mz),QrDwdr(mz),QsDwdr(mz),EvDwdr(mz),
     .        mFluDw(mz),AreaDw(mz),FracDw(mz),w_Dwdr(mz),
     .                              QwDetr(mz),QiDetr(mz),
     .        T_Subs(mz),QvSubs(mz),FracEv(mz),w_Subs(mz),
     .        T__New(mz),Qv_New(mz),QvAjst(mz)
C +
      real    Rv,h2oLCp,h2oSCp,
     .        zANA,wANA,hPBL,
     .        zLCL,zETL,zCT,zLFS,zLFC,zLCL2,zLFC2,zETL2,plocal,
     .        buInit,dEnCin,diffBE,
     .        aBuoyE,aBEnew,BEneg2,aBE__0,aBEmin,
     .        pBuoyE,pBEnew,        qsLCL,
     .        W_Init,  wlow, wmLCL, wpLCL,  wLFC,  wup1,  wup2,w2_New,
     .        deltaz,   sdx,   sdy,dx_min,AreaMx,mf_max,mf_min 
C +
      real    RUpLCL,RDwLFS,lam_ZF,lam_KF,
     .        mUpLCL,mfUpMn,dFr_Up,mDwLFS,mfDwMn,NbDwdr,mfEnvr,mfTota,
     .        T0Updr,TnUpdr,TvUpdr,TvUpdk,
     .        T0Dwdr,TnDwdr,TvDwdr,TvEnvr,TvEnvk,
     .        Te_Min,QsEnvr,TsEnvr,dTvUpT,dTvDwT,dTvSgn,dTvAbs,
     .        QnUpdr,Q1Updr,              EvUpdr,
     .        QnDwdr,Q1Dwdr,Q2Dwdr,QdDwdr,QwDwdr,QiDwdr,
     .        rrUpdr,VpDwdr,drUpdr,dsUpdr,
     .        d_Tair,difftt,diffqv,pProdu,pUp165,
     .        zLCLkf,vShear,pEffic,Effic1,Effic2,c1KF90,
     .        RainCb,SnowCb,rrAnvl,drAnvl,AirMss,Q0Ajst,TnAjst
      real    T0Ajst
C +
      real    dtrain,Vol_Cb,CEWC_1,CEWC_2,d_CEWC,  qv_d,  qv_n,
     .        tau_up,tau_dw,taumin,taumax, rtime,snmelt,
     .        wSpeed,We_Max,FiltWe,cfl_up,cfl_dw,
     .        u__Min,u__Max,v__Min,v__Max,WindSp,dt_adv,
     .                      QdAjst,dQAjst,
     .        auxEnt,aux__A,auxEff,aux__w,aux_dt,auxmUp,auxmDw,
     .        eps01 ,eps02 , eps05,qsat0D,
     .        TeqCVA,Qs_CVA,GlacDg,mFluDn
C +
      real    mDtrUp(mz),mDtrDw(mz)
C +
      real    TeTrZo,T_TrZo,FrEnvC
c #kf real    mFluTr,FrEnvr,FrDraf,f_Entr,f_Detr,mEntUp,mEntDw,TvTrZo
c #kf.       ,T0TrZo,TnTrZo,Q1TrZo,QdTrZo,QvTrZo,QwTrZo,QiTrZo,EvTrZo
c #kf.       ,argexp,DetrUp
c #KF real           DetrDw
c #kf common  /conajuKF90/  FrDraf
c #CG real    rairdz
c #WR integer ni,nj
C +
      logical wricnv,TestCA
C +
C +
C +---General Data
C +   ============
C +
      data Rv      /  460.5e00  /
C +...Perfect Gas Law Constant for Water Vapor       (J/kg/K)
C +
      data h2oLCp / 2490.04e+0 /
C +      = Lv_H2O [Latent Heat of Vaporisation for Water (2.500d+6 J/kg)]
C +      / Cp     [Air Specific Heat                     (1.004d+3 J/kg/K)]
C +
      data h2oSCp / 2822.31e+0 /
C +      = Ls_H2O [Latent Heat of Sublimation  for Water (2.8336+6 J/kg)]
C +      / Cp     [Air Specific Heat                     (1.004d+3 J/kg/K)]
C +
      data dx_min  /   10.0e+3  /
C +...Minimum value authorized for the horizontal resolution
C +
      data hPBL    /    0.6e+3  /
C +...     hPBL    : Height of PBL for starting an Adiabatic 
C +
c #AN data xANA    /   10.0e+3  /
C +...     xANA    : Characteristic Mountain Width       Scale
C +
c #AN data vANA    /    4.0e+0  /
C +...     vANA    : Characteristic Mountain Breeze Wind Scale
C +
      data taumin  /  900.0e+0  /
      data taumax  / 3600.0e+0  /
C +...Thesholds (min and max) of the Characteristic Time Scale
C +                           of Convection
C +
      data W_Init  /    1.0e+0  /
C +...Initial value of vertical motion near the surface
C +
      data We_Max  /    0.5e+0  /
C +...Maximum wSpeed authorized for the environmental Subsidence
C +
      data lam_ZF  /    6.5e-5  /
C +...Entrainement                Rate (m-1)     (Zhang & Fritsch 1986)
C +
      data lam_KF  /    3.0e+1  /
C +...Entrainement                Rate (m.kPa-1) (Kain  & Fritsch 1990)
C +
      data c1KF90  /    1.0e-2  /
C +...Cloud Water Conversion half-Rate (s-1)     (Kain  & Fritsch 1990)
C +                                              (Lower Bound: 0.005/2)
C +                                              (Upper Bound: 0.02 /2)
c #kf data FrEnvr  /    1.0e-1  /
C +...     FrEnvr: Reference entrained Mass Fraction of Environmental Air
C +
c #WD data LDtrai  /    1       /
C +...Detrainment of Cloud Droplets is allowed if LDtrai = 1
C +        the Temperature from the Equivalent Potential Temperature
C +
      data NitMax  /  100       /
C +...Maximum number of iterations to determine
C +        the Temperature from the Equivalent Potential Temperature
C +
      data NO_abe /    25       /
C +...Maximum number of iterations to determine
C +        Updraft and Downdraft characteristics
C +        in order to suppress ABE
C +
      data wricnv /  .true.     /
C +...If true, write the vertical profiles of t and qv in MARphy.out
C +
      data eps01   / 5.e-1 /
      data eps02   / 1.e-2 /
      data eps05   / 1.e-5 /
      data int_0   /   0   /
      data int_1   /   1   /
      data int_2   /   2   /
      data int_3   /   3   /
      data int_5   /   5   /
C +
C +
C +---Initialisation
C +   ==============
C +
      sdx=max(dx_min,dx)
      sdy=max(dx_min,dy)
C +
       wANA  =0.00
       zANA  =0.00
C +
      IF (int_CA.eq.0)                                              THEN
C +
       int_CA=NINT( 5.*60./dt_Loc)
       int_CA= max(int_CA,    iun)
C +... ^^^ Number of iterations between two checks of unstability
C +
       fr_2_3=      2.0d+0/3.0d+0
       frac_w=      1.0d-2*(dx/25.d3)**2
C +... frac_w:Large Scale Vertical Speed    Normalization Factor:
C +                 1.0d-2: cm/s --> m/s
C +                        (dx/25.d3)**2: Renormalization to a 25km Grid
C +
C +
C +----Subgrid Mountain Breeze
C +    -----------------------
C +
c #AN    rANA      = 2.0d+0 * vANA / xANA
C +...   rANA      : Subgrid Mountain Breeze: Horizontal Divergence
C +                 (Factor 2 included  for 2 horizontal Directions)
c #AN  DO j=1,my
c #AN  DO i=1,mx
c #AN    dANA      = sh(i,j)
c #AN.        -0.25*(sh(im1(i),j)+sh(ip1(i),j)
c #AN.              +sh(i,jm1(j))+sh(i,jp1(j)))
c #AN    hANA(i,j) = abs(dANA)*max(zero,dx/xANA-unun)
C +...   hANA: D("Subgrid Mountain" Height - "Resolved Mountain" Height)
C +
c #AN    hANA(i,j) = sh(i,j) * 2.0d+0
c #AN  END DO
c #AN  END DO
C +
       wthres=     0.0d+0
c #th  fold_t=    -jhaRUN/3.00
c #th  fold_t= max(fold_t,argmin)
c #th  wthres=    (5.0e+2*exp(fold_t))/dx
C +... ^^^ Upward velocity threshold
C +
c #kf  FrDraf =    1.0d+0-FrEnvr
C +
       sdx=dx
       sdy=dy
C +
       IF ((mmx.gt.1.and.sdx.lt.dx_min) .or.
     .     (mmy.gt.1.and.sdy.lt.dx_min))                            THEN
         write(*,*) 'CAUTION : This convective Adjustment scheme'
         write(*,*) '=======   is inadequate to treat horizontal'
         write(*,*) '          resolutions lower than 10 km !!! '
         write(*,*) ' '
         write(*,*) 'Execution STOPPED.'
C +
C +      ++++
         STOP
C +      ++++
C +
       ENDIF
C +
       DO j=1,my
       DO i=1,mx
         adj_CA(i,j)=0
       ENDDO
       ENDDO
C +
       open(unit=70,status='unknown',file='CV_ADJ.out')
C +... ^^^^ Open output file
C +
       write(70,700)
       write(70,701)
       write(70,702)
       write(70,703)
       write(70,704)
       write(70,705)
       write(70,706)
       write(70,707)
       write(70,708)
       write(70,709)
       write(70,710)
       write(70,711)
       write(70,712)
       write(70,713)
C +
 700   format(/,11x,'CONVECTIVE ADJUSTMENT SCHEME   -   ',
     .              'FRITSCH AND CHAPPELL (1980)')
 701   format(  11x,'***********************************',
     .              '***************************',/,/)
 702   format('ABE  = Available buoyant energy                 [J]')
 703   format('PBE  = Potential buoyant energy                 [J]')
 704   format('LCL  = Lifting condensation level height        [m]')
 705   format('LFC  = Free convection level height             [m]')
 706   format('ETL  = Equilibrium Temperature level height     [m]')
 707   format('CT   = Cloud top height                         [m]')
 708   format('Tau  = Characteristic time scale of convection  [s]')
 709   format('Prec = Precipipation averaged over the grid box [mm]')
 710   format('P.loc= Local precipitation (below Downdraft)    [mm]')
 711   format('P.L/H= Hourly local precipitation               [mm]',
     .                                                           /,/)
 712   format(' DATE              |   I |   J |  IRUN | wmLCL |  wANA |'
     .       , ' zANA |  ABE |  PBE |  LCL  |  LFC  |   ETL  |    CT  |'
     .       ,  '  Tau |',                            ' Prec | PLoc |'
     .     ,/,' DD-MMM-YYYY HH.MM |     |     |       | [m/s] | [m/s] |'
     .       , ' [km] | [J/g]| [J/g]|  [m]  |  [m]  |   [m]  |   [m]  |'
     .       ,  '  [m] |',                            ' [mm] | [mm] |')
 713   format(' ------------------+-----+-----+-------+-------+-------+'
     .       , '------+------+------+-------+-------+--------+--------+'
     .       ,  '------+',                            '------+------+')
C +
      ENDIF
C +
C +
C +---Time interval between two checks of convective unstability
C +   ==========================================================
C +
      TestCA=((mod(itConv,   int_CA).eq.0 .or.
     .             itConv.lt.int_CA           )  .and.
     .             jhaRUN.ge.tim_HY                   )
C +
C +
C +   ##################################################################
C +
      IF (TestCA)                                                  THEN
        DO j=MIN0(int_2,mmy),MAX0(int_1,mmy)      !  Loop on horizontal
        DO i=MIN0(int_2,mmx),MAX0(int_1,mmx)      !         grid points
C +
C +   ##################################################################
C +
C +
          IF (adj_CA(i,j).eq.0)                                    THEN
C +
C +
C +----Vertical Analysis of the Atmosphere Structure
C +    =============================================
C +
C +----Determination of Clouds Levels
C +                    (Lifting Condensation, Melting, Freezing, Ice,
C +                     Free Convection and
C +                     Equilbrium Temperature                Levels)
C +----Determination of of Vertical profile of adiabatic Temperature
C +----Determination of Potential and available buoyant energy (CAPE)
C +    --------------------------------------------------------------
C +
            DO k=1,mz
              T_Envr(k)= tairDY(i,j,k)
              QvEnvr(k)=   qvDY(i,j,k)
              H_Envr(k)=(gplvDY(i,j,k)-gplvDY(i,j,mzz))*grvinv
C +
              AdiabT(k)= 0.0d+0                    ! {initialisation}
              Adia2T(k)= 0.0d+0
            ENDDO
C +
C +
C +----Examine Lower Troposphere, starting from the Surface
C +    ----------------------------------------------------
C +
            kINI = mz
 10         CONTINUE
C +
C +           ***********
              call CVAdia(kINI,kLCL,hPBL,zLCL,zLFC,zETL,
     .                    aBuoyE,pBuoyE,AdiabT,T_Envr,QvEnvr,H_Envr)
C +           ***********
C +
              kLCL=MAX0(kLCL,int_3)
              kLCL=MIN0(kLCL, mmz1)
C +
              aBE__0 =      aBuoyE
              aBEnew =      aBuoyE
              aBEmin =      aBuoyE
C +...        ^^^^ Available Buoyant Energy (between LCL and ETL)
C +
              capeCA(i,j) = aBuoyE        *  0.001 
C +
              diffBE =      pBuoyE-aBuoyE
              BEneg2 =  max(diffBE,zero)  *  2.000
C +...        ^^^^ Negative  Buoyancy        between LCL and LFC (X 2)
C +
C +
C +----Trigger Function of the Mass Flux convective Scheme
C +    ===================================================
C +
C +----1. Ability of a parcel to reach the LFC
C +    ---------------------------------------
C +
              wmLCL=     frac_w*wairDY(i,j,kLCL)
C +...        ^^^^ Mean vertical velocity at the LCL = W
c #1D         IF (mmx.eq.1.and.mmy.eq.1)
c #1D.        wmLCL=     1.0d+0
C +
C +----Contribution from Subgrid Mountain Breeze
C +    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AN             bANA=  min(zLCL,            zi__TE(i,j))
c #AN             zANA=      hANA(i,j)+2.0d+0*bANA
c #AN         IF (zLCL .le.  zANA.and.
c #AN.            TairSL(i,j)    .gt.         tairDY(i,j,mz))     THEN
c #AN             wANA=      rANA     *0.5d+0*bANA
C +...                         Half Integrated Horizontal Divergence
C +
c #AN            wmLCL=wmLCL+wANA
c #AN         ELSE
c #AN             wANA=      0.0
c #AN         END IF
C +
              wpLCL=sqrt(fr_2_3*ect_TE(i,j,kLCL))
C +...        ^^^^ Perturbation              induced by Turbulent Mixing
C +                approximately  sqrt(w'w')
C +
              wlow =sqrt(BEneg2)
C +...        ^^^^ Negative  Velocity        due to
C +                Negative  Buoyancy        between LCL and LFC
C +
              wLFC =(wmLCL+2.*wpLCL)-wlow
C +...        ^^^^ Estimated vertical velocity at the LFC
C +
C +----2. Stability at the LCL when a parcel is perturbated
C +    ----------------------------------------------------
C +
c _ZF             stbLCL=AdiabT(kLCL)-T_Envr(kLCL)
c _ZF.                             +exp(third*log(max(zero,wmLCL)))
C +
C +----3. Global Criterion to Trigger the C.A. Scheme
C +    ----------------------------------------------
C +
              IF (  wLFC.gt.0.                                     .and.
     .             wmLCL.gt.wthres                                 .and.
C +.................^ Ability of a parcel to reach the LFC
C +
c _ZF.            stbLCL.gt.0.                                     .and.
C +.................^ Unstability at the LCL if perturbation
C +
     .              zLCL.lt.(zETL-2000.)                           .and.
     .              zLFC.lt.(zETL- 500.)                           .and.
     .              zLFC.lt.      5000.                            .and.
C +.................^ Realizibility criterion based on LCL,LFC,ETL heights
C +
     .              zETL.gt.      3000.                            .and.
C +.................^ Eliminate shallow convection --> only deep convection
C +
     .            aBuoyE.gt.       300.                            .and.
C +.................^ Positive available buoyant energy (minimum threshold)
C +
     .            adj_CA(i,j).eq.0 )                              THEN
C +.................^ No check if the Adjustment is already running
C +
                  adj_CA(i,j)=9999
C +
c #IT         ELSE
c #IT           IF (kINI.gt.mzabso.and.H_Envr(kINI).lt.3500.)     THEN
C +...              Hmax_Start_Convec at 600-700 hPa,  3500m 
C +                (Fritsch and Chappel, 1980, and Pielke, 1984, p.251)
 20               CONTINUE
c #IT               kINI = kINI -1
c #IT             IF                  (H_Envr(kINI).lt.hPBL ) GO TO 20
c #IT           ELSE
c #IT               kINI =      -1
c #IT           END IF
              END IF
C +
c #IT       IF     (kINI.gt.     0.and.adj_CA(i,j) .eq.   0 ) GO TO 10
C +
          END IF                         ! {End of (adj_CA(i,j).eq.0)}
C +
C +
C +   ######################################################################
C +
          IF (adj_CA(i,j).eq.9999)                                THEN
C +
C +            {Begin convective Adjustment loop - CLOUD MODEL}
C +            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
C +   ######################################################################
C +
C +
C +----1D Cloud Model : Variable System
C +    ================================
C +
              DO k=1,mz
                T_Envr(k)=tairDY(i,j,k)
                QvEnvr(k)=  qvDY(i,j,k)
                QtEnvr(k)=  qvDY(i,j,k)
     .         +qwHY(i,j,k)+qrHY(i,j,k)+qiHY(i,j,k)+qsHY(i,j,k)
                roEnvr(k)=rolvDY(i,j,k)*1.0d+3
                PTEnvr(k)=pktaDY(i,j,k)*pcap
                u_Envr(k)=uairDY(i,j,k)
                v_Envr(k)=vairDY(i,j,k)
                w_Envr(k)=wairDY(i,j,k)*1.0d-2                      !  [m/s]
                p_Envr(k)=ptopDY+sigma(k)*pstDY(i,j)                !  [kPa]
                ExEnvr(k)=exp(cap*log(p_Envr(k)
     .                              /(ptopDY+sigma(mz)*pstDY(i,j))))
                H_Envr(k)=(gplvDY(i,j,k)-gplvDY(i,j,mz+1))*grvinv
C +
c #FC           GlacDg   =GlaCVA(T_Envr(k))
c #FC           TeEnvr(k)=TeqCVA(T_Envr(k),ExEnvr(k),QvEnvr(k),GlacDg)
C +....         Equivalent potential Temperature
C +
              ENDDO
C +
C +
C +----Initialisation Step
C +    ===================
C +
              mf_min  = eps02*sdx*sdy*W_Init*roEnvr(kLCL)
C +...        ^^^^ Minimum value accepted for Updraft mass flux (LCL)
              mf_max  =       sdx*sdy*1.0d+2*roEnvr(mz)
C +...        ^^^^ Maximum value accepted for         mass fluxes
C +
              RUpLCL  = 1.5d+3
C +...        RUpLCL  : Initial Updraft Radius 
C +                    (Kain and Fritsch, 1990, a. p.2786)
C +
              mUpLCL  = RUpLCL*RUpLCL*W_Init*roEnvr(kLCL)*pi
              mDwLFS  = mUpLCL
                 zCT  =   zETL
                 kCT  =      2
              nitabe  =      0
C +
 100          CONTINUE
C +...        Iteration until ABE=0
C +
                 nCT  =      0
              RainCb  =      0.0d+0
              SnowCb  =      0.0d+0
              dtrain  =      0.0d+0
              rrUpdr  =      0.0d+0
              VpDwdr  =      0.0d+0
              rrAnvl  =      0.0d+0
              buInit  =      0.0d+0
              u__Min  =   1000.0d+0
              v__Min  =   1000.0d+0
              u__Max  =  -1000.0d+0
              v__Max  =  -1000.0d+0
                kETL  =      2
                zETL  = H_Envr(kETL)
C +
C +
C +----Initialisation of Updraft and Downdraft Profiles
C +    ================================================
C +
c #FC           GlacDg    = GlaCVA(AdiabT(kLCL))
c #FC           qsLCL     = Qs_CVA(AdiabT(kLCL),pstDY(i,j),ptopDY,
c #FC.                              sigma(kLCL),GlacDg)
C +
              DO k=1,mz
C +
C +
C +----Updraft
C +    -------
C +
                mFluUp(k) = 0.
                w_Updr(k) = 0.
                AreaUp(k) = 0.
                T_Updr(k) =        AdiabT(k)
c #FC           GlacDg    = GlaCVA(T_Updr(k))
c #FC           TeUpdr(k) = TeqCVA(T_Updr(k),ExEnvr(k),qsLCL    ,GlacDg)
c #FC           QdUpdr(k) = Qs_CVA(T_Updr(k),pstDY(i,j),ptopDY,
c #FC.                              sigma(k),GlacDg)
C +
                QvUpdr(k) = QdUpdr(k)
                QwUpdr(k) = 0.
                QiUpdr(k) = 0.
c #kf           mDtrUp(k) = 0.
C +
C +
C +----Downdraft
C +    ---------
C +
                mFluDw(k) = 0.
                w_Dwdr(k) = 0.
                AreaDw(k) = 0.
                T_Dwdr(k) = T_Envr(k)
                TeDwdr(k) = TeEnvr(k)
                QvDwdr(k) = QtEnvr(k)
                EvDwdr(k) = 0.
                QrDwdr(k) = 0.
                QsDwdr(k) = 0.
c #kf           mDtrDw(k) = 0.
C +
C +
C +----Environmental Subsidence
C +    ------------------------
C +
                w_Subs(k) = 0.
                T__New(k) = 0.
                Qv_New(k) = 0.
C +
              ENDDO
C +
C +
C +----Buoyancy     below the LCL
C +    ==========================
C +
                 TvUpdk      = T_Updr(kLCL)
     .               *(1.+0.61*QvUpdr(kLCL)- QwUpdr(kLCL)-QiUpdr(kLCL))
                 TvEnvk      = T_Envr(kLCL)
     .               *(1.+0.61*QvEnvr(kLCL)-(QtEnvr(kLCL)-QvEnvr(kLCL)))
C +
              DO k=kLCL,mz-1
                 TvUpdr      = T_Updr(k+1)
     .               *(1.+0.61*QvUpdr(k+1)- QwUpdr(k+1)-QiUpdr(k+1))
                 TvEnvr      = T_Envr(k+1)
     .               *(1.+0.61*QvEnvr(k+1)-(QtEnvr(k+1)-QvEnvr(k+1)))
C +
                 deltaz = H_Envr(k)-H_Envr(k+1)
C +
                 buInit = buInit
     .         + gravit * deltaz *((TvUpdr-TvEnvr)/TvEnvr
     .                            +(TvUpdk-TvEnvk)/TvEnvk)
C +...           buInit increment contains an implicit factor 2. * 0.5     X
C +                     cfr. Pielke 1984, (9-29) p. 253                   /|\
C +                                                                      /_o_\
                 TvUpdk      = TvUpdr
                 TvEnvk      = TvEnvr
              ENDDO
C +
C +
C +----Vertical motion at the LCL
C +    ==========================
C +
                wup1         =          W_Init*W_Init
                wup2         =          W_Init*W_Init+buInit
                w_Updr(kLCL) = sqrt(max(wup1,wup2))
C +...          Pielke 1984, (9-29) p.253                                  X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                mFluUp(kLCL) = mUpLCL
C +...          Pielke 1984, (9-30) p.254                                  X
C +                                                                       /|\
C +                                                                      /_o_\
C +
c #kf           AreaUp(kLCL) = mFluUp(kLCL)
c #kf.        /(w_Updr(kLCL) * p_Envr(kLCL)*1.d3/(Ra*T_Updr(kLCL)))
C +
c #kf           RUpLCL  = sqrt(AreaUp(kLCL)/pi)
C +
              DO k=kLCL,3,-1
C +
C +
C +-----Updraft : Lift Parcel while Mixing
C +     ==================================
C +
c _ZF             mFluUp(k-1)=
c _ZF.            mUpLCL*(1.0+        (H_Envr(k-1)-zLCL)
c _ZF.                               /(zCT        -zLCL))
C +....           ^^^^ Mass Flux of Updraft (Fritsch and Chappell,1980)    X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                  mFluUp(k-1)=
     .            mUpLCL*(1.0 +lam_ZF*(H_Envr(k-1)-H_Envr(kLCL)))
C +....           ^^^^ Mass Flux of Updraft (Zhang   and Fritsch, 1986)    X
C +                                                                       /|\
C +                                                                      /_o_\
C +
C +----Kain-Fritsch Entraining-Detraining Plume Parameterization
C +    ---------------------------------------------------------
C +
c #kf             mFluTr =-mUpLCL*lam_KF*(p_Envr(k-1)-p_Envr(k))/RUpLCL
C +...            ^^^^ Mass Flux entering the Transition Region
C +                              ((1) p.2786 Kain    and Fritsch, 1990, KF90)
C +                                                                        X
C +                                                                       /|\
C +                                                                      /_o_\
C +
c #kf             TeTrZo = FrEnvr * TeEnvr(k) 
c #kf.                   + FrDraf * TeUpdr(k)
c #kf             Q1TrZo = FrEnvr * QtEnvr(k) 
c #kf.                   + FrDraf *(QvUpdr(k)+QwUpdr(k))
C +               ^^^^ Mixed Air Thermodynamics
C +
c #kf             T0TrZo = FrEnvr * T_Envr(k) 
c #kf.                   + FrDraf * T_Updr(k)
C +
C +               ***********
c #kf             call TQsCVA(TeTrZo   ,ExEnvr(k)  ,
c #kf.                         sigma(k), pstDY(i,j),ptopDY,
c #kf.                        T0TrZo,TnTrZo,T_TrZo,
c #kf.                        Q1TrZo,Q1TrZo,QdTrZo,QvTrZo,QwTrZo,QiTrZo,
c #kf.                                                    EvTrZo)
C +               ***********
C +
c #kf             TvUpdr      = T_Updr(k)
c #kf.                *(1.+0.61*QvUpdr(k)- QwUpdr(k)-QiUpdr(k))
c #kf             TvEnvr      = T_Envr(k)
c #kf.                *(1.+0.61*QvEnvr(k)-(QtEnvr(k)-QvEnvr(k)))
c #kf             TvTrZo      = T_TrZo
c #kf.                *(1.+0.61*QvTrZo   -(Q1TrZo   -QvTrZo   ))
c #kf             dTvUpT =            TvUpdr-TvTrZo
c #kf             dTvSgn =  sign(unun,dTvUpT)
c #kf             dTvAbs =   abs(     dTvUpT)
c #kf             dTvUpT =   max(epsi,dTvAbs)       * dTvSgn
c #kf             FrEnvC =    FrEnvr*(TvUpdr-TvEnvr)/ dTvUpT
c #kf             FrEnvC =max(FrEnvC,zero)
c #kf             FrEnvC =min(FrEnvC,unun)
C +
C +               ***********
c #kf             call CVATrZ(FrEnvC,f_Entr,f_Detr)
C +               ***********
C +
c #kf             mEntUp     =       f_Entr*mFluTr
c #kf             mDtrUp(k-1)=       f_Detr*mFluTr
c #kf             mFluUp(k-1)=mFluUp(k)    +mEntUp
C +
C +
                  mFluUp(k-1)=     max(mf_min     ,mFluUp(k-1))
C +
C +
C +----Impact of Mixing on   Updraft Properties
C +    ----------------------------------------
C +
C +
                  TeUpdr(k-1)=
C +....           ^^^^ Updraft Equivalent Potential Temperature
     .           (TeUpdr(k)  * mFluUp(k)+(mFluUp(k-1)-mFluUp(k))
     .                           *0.5d+0*(TeEnvr(k-1)+TeEnvr(k)))
     .                       / mFluUp(k-1)
C +...                 Pielke 1984, (9-25) p.251                           X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                  Q1Updr     =
C +....           ^^^^ Updraft mixing ratio due to entrainement
C +                    q_S_u^E in Pielke 1984, (9-31) p.251                X
C +                                                                       /|\
C +                                                                      /_o_\
     .           (QdUpdr(k)  * mFluUp(k)+(mFluUp(k-1)-mFluUp(k))
     .                           *0.5d+0*(QtEnvr(k-1)+QtEnvr(k)))
     .                       / mFluUp(k-1)
C +
C +
C +-----{Loop to determine the Updraft Temperature}
C +     -------------------------------------------
C +
                  T0Updr     = T_Updr(k) +(AdiabT(k-1)-AdiabT(k))
C +
C +
C +               ***********
                  call TQsCVA(TeUpdr(k-1),ExEnvr(k-1),
     .                         sigma(k-1), pstDY(i,j),ptopDY,
     .                        T0Updr,TnUpdr,            T_Updr(k-1),
     .                        Q1Updr,Q1Updr,QdUpdr(k-1),QvUpdr(k-1),
     .                                      QwUpdr(k-1),QiUpdr(k-1),
     .                                      EvUpdr)
C +               ***********
C +
C +
C +-----Vertical Motion in the Updraft
C +     ------------------------------
C +
                  deltaz      = H_Envr(k-1)-H_Envr(k)
                  TvUpdr      =(T_Updr(k-1)+T_Updr(k)  )*0.50
     .               *(1.+0.61*(QvUpdr(k-1)+QvUpdr(k)  )*0.50
     .                   -     (QwUpdr(k-1)+QwUpdr(k)
     .                         +QiUpdr(k-1)+QiUpdr(k)  )*0.50)
                  TvEnvr      =(T_Envr(k-1)+T_Envr(k)  )*0.50
     .               *(1.+0.61*(QvEnvr(k-1)+QvEnvr(k)  )*0.50
     .                   -     (QtEnvr(k-1)-QvEnvr(k-1)
     .                         +QtEnvr(k)  -QvEnvr(k)  )*0.50)
C +
                  dEnCin =      2.00*deltaz*gravit*(TvUpdr-TvEnvr)
     .                                            /(1.5d+0*TvEnvr)
C +...                 Zhang and Fritsch, 1986:     1.5 <= 1+beta          X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                  auxEnt = 1.00-2.00*deltaz*lam_ZF
C +               ^^^^ Zhang and Fritsch, 1986: Effect of Entrainement     X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                  w2_New      =   auxEnt*w_Updr(k)*w_Updr(k) + dEnCin
                  w_Updr(k-1) = sqrt(max(w2_New     ,zero))
C +...            ^^^^ Vertical Motion in Updraft, Pielke 1984 (9-29) p.253
C +                                                                        X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                IF (H_Envr(k-1).lt.zLFC)
     .            w_Updr(k-1) =      max(w_Updr(k-1),unun)
C +
C +
C +-----New Equilibrium Temperature Level
C +     =================================
C +
                IF (H_Envr(k-1).gt.zLFC                           .and.
     .              H_Envr(k-1).gt.zLCL                           .and.
     .              kETL       .eq.2   )                          THEN
C +
C +
C +-----Premature Abort of the Updraft
C +     ------------------------------
C +
c #kf            IF(mDtrUp(k-1).gt.mFluUp(k-1))                   THEN
c #kf               zETL=H_Envr(k-1)
c #kf               kETL=       k-1
c #kf            ELSE
c #kf               mFluUp(k-1)=mFluUp(k-1)-mDtrUp(k-1)
c #kf            END IF
C +
C +
C +-----Normal    Abort of the Updraft
C +     ------------------------------
C +
                 IF(dEnCin     .lt.0.0)                           THEN
                    zETL=H_Envr(k-1)
                    kETL=       k-1
                 END IF
C +
                END IF
C +
C +
C +-----Cloud Top
C +     =========
C +
                IF (w_Updr(k-1).le.0.01                           .and.
     .              w_Updr(k)  .gt.0.01                           .and.
     .                     nCT .eq.0                              .and.
     .              H_Envr(k-1).ge.zETL)                          THEN
                    zCT=H_Envr(k-1)
                    kCT=       k-1
                    nCT=         1
C +...              Pielke 1984, (9-27) p.253
C +                                                                        X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                END IF
C +
              ENDDO                                       !  { k=kLCL,3,-1 }
C +
              DO k=kLCL,2,-1
C + 
                IF (H_Envr(k).gt.zCT)                             THEN
                    mFluUp(k) = 0.0
c #kf               mDtrUp(k) = 0.0
                END IF
C +
C +
C +-----Updraft Area as a Function of Height
C +     ====================================
C +
                IF (w_Updr(k)  .gt.eps02)                         THEN
                    AreaUp(k) = mFluUp(k)
     .                        /(w_Updr(k)*p_Envr(k)*1.d3/(Ra*T_Updr(k)))
C +...              Pielke 1984, (9-30) p.254                              X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                ELSE
                    AreaUp(k) = 0.0d+0
                ENDIF
C +
C +
C +-----Min / Max Velocities over the Cloud Depth
C +     =========================================
C +
                IF (mFluUp(k).gt.0.) THEN
                    u__Min=min(u__Min,u_Envr(k))
                    v__Min=min(v__Min,v_Envr(k))
                    u__Max=max(u__Max,u_Envr(k))
                    v__Max=max(v__Max,v_Envr(k))
                ENDIF
C +
C +
              ENDDO                                       !  { k=kLCL,2,-1 }
C +
              kETL =    MAX(kETL,int_2)
              kETL =    MIN(kETL, mmz1)
              zETL = H_Envr(kETL)
C +
              kCT  =    MAX(kCT ,int_2)
              kCT  =    MIN(kCT , mmz1)
              zCT  = H_Envr(kCT )
C +
C +
C +----Precipitation Efficiency
C +    ========================
C +
C +----Precipitation Efficiency depending on Shear
C +    -------------------------------------------
C +
                vShear=sqrt((u__Max-u__Min)*(u__Max-u__Min)
     .                     +(v__Max-v__Min)*(v__Max-v__Min))
     .                /(zCT-zLCL)*1000.
C +...          ^^^^ Mean vertical wind shear
C +
              IF (vShear.lt.0.9)                                  THEN
                Effic1=0.9
              ELSE
                Effic1=1.591-0.639*vShear+0.0953*(vShear*vShear)
     .                           -0.00496*(vShear*vShear*vShear)
              ENDIF
C +...          ^^^^ Precipitation efficiency based on wind shear
C +                  (Fritsch and Chappell, 1980)                          X
C +                  (see also      Pielke, 1984, end of p.257)           /|\
C +                                                                      /_o_\
C +
                Effic1=max(zero,Effic1)
                Effic1=min(unun,Effic1)
C +
C +
C +----Precipitation Efficiency depending on Cloud Bottom
C +    --------------------------------------------------
C +
                zLCLkf=zLCL/(1000.*0.3048)
C +...          ^^^^ LCL height in units of thousands of feet
C +
                auxEff=0.967-0.700*zLCLkf+0.162*zLCLkf*zLCLkf
     .                          -0.01257*zLCLkf*zLCLkf*zLCLkf
C +
                Effic2=1./(1.+auxEff)
C +...          ^^^^ Precipitation efficiency based on LCL zLCLkf
C +                  (Zhang and Fritsch, 1986)                             X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                Effic2=max(zero,Effic2)
                Effic2=min(unun,Effic2)
C +
C +
C +----Global Precipitation Efficiency
C +    -------------------------------
C +
                pEffic=(Effic1+Effic2) *0.5d+0
C +...          ^^^^ Mean precipitation efficiency (Zhang and Fritsch, 1986)
C +                                                (end last full para,    X
C +                                                 1st column p. 1917)   /|\
C +                                                                      /_o_\
c _ZF           pEffic =Effic1
C +
C +
C +----Downdraft : Level of Free Sink
C +    ==============================
C +
              zLFS =   zLCL
              kLFS =   kLCL
C +
c _ZF         DO k=min(3,mz1),mz1
C +
c _ZF           IF   (H_Envr(k).lt.5500)                          THEN
C +
c _ZF                 ttmix1 =    (TeEnvr(k  )+TeUpdr(k  ))*0.50
c _ZF                 ttmix2 =    (TeEnvr(k-1)+TeUpdr(k-1))*0.50
C +
c _ZF             IF (ttmix1   .lt.TeEnvr(k)                      .and.
c _ZF.                ttmix2   .gt.TeEnvr(k-1)                    .and.
c _ZF.                H_Envr(k).gt.zLCL)                          THEN
c _ZF                 zLFS   =     H_Envr(k)
c _ZF                 kLFS   =            k
c _ZF             END IF
C +
c _ZF           ELSE
C +
c _ZF                 zLFS   =     H_Envr(k-1)
c _ZF                 kLFS   =            k-1
C +
c _ZF           END IF
C +
c _ZF         END DO                                         !  { k=3,mz-1 }
C +
                      Te_Min = 3000.
              DO k=min(3,mz1),mz1
                IF   (TeEnvr(k).lt.Te_min                         .and.
     .                H_Envr(k).le.zCT                            .and.
     .                H_Envr(k).ge.zLCL)                          THEN
                      Te_Min =     TeEnvr(k)
                      zLFS   =     H_Envr(k)
                      kLFS   =            k
                END IF
              END DO                                         !  { k=3,mz-1 }
C +
              kLFS =    MAX(kLFS,int_3)
              kLFS =    MIN(kLFS, mmz1)
              zLFS = H_Envr(kLFS)
C +
C +
C +----Case of    Downdraft
C +    ====================
C +
              IF (zLFS.gt.zLCL)                                   THEN
C +
C +
C +----Initialisation of Downdraft Variables
C +    -------------------------------------
C +
                      mFluDw(kLFS) =  mDwLFS
c #kf                 RDwLFS       =  RUpLCL      *sqrt(mDwLFS/mUpLCL)
C +
c _ZF                 w_Dwdr(kLFS) =  0.
c _ZF                 QvDwdr(kLFS) =  QvEnvr(kLFS)
c _ZF                 TeDwdr(kLFS) = (TeEnvr(kLFS)+TeUpdr(kLFS)) *0.50
C +
                      w_Dwdr(kLFS) =  w_Updr(kLCL)
C +
c #FC                 GlacDg = GlaCVA(T_Envr(kLFS))
c #FC                 QsEnvr = Qs_CVA(T_Envr(kLFS),pstDY(i,j),ptopDY,
c #FC.                                 sigma(kLFS),GlacDg)
c #FC                 TsEnvr = TeqCVA(T_Envr(kLFS),ExEnvr(kLFS),
c #FC.                                QsEnvr      ,GlacDg)
C +
                      dTvDwT =        TeUpdr(kLFS) -TeEnvr(kLFS)
                      dTvSgn =            sign(unun,dTvDwT)
                      dTvAbs =             abs(     dTvDwT)
                      dTvDwT =             max(epsi,dTvAbs) * dTvSgn
                      FrEnvC   =     (TeUpdr(kLFS) -TsEnvr) / dTvDwT
                      FrEnvC   =  max(FrEnvC,zero)
                      FrEnvC   =  min(FrEnvC,unun)
                      QvDwdr(kLFS) =  FrEnvC   *    QtEnvr(kLFS)
     .                      + (1.0d+0-FrEnvC)  *   (QvUpdr(kLFS)
     .                               +QwUpdr(kLFS) +QiUpdr(kLFS))
C +
                      TeDwdr(kLFS) =  TsEnvr  
c #CG.                 -(h2oSCp-h2oLCp) *
c #CG.                  (QvUpdr(kLCL)+QwUpdr(kLCL) +QiUpdr(kLCL)
c #CG.                  -QvUpdr(kCT )-QwUpdr(kCT ) -QiUpdr(kCT ))
C +...                ^^^^ Correction for Melting Effect
C +
              DO k=kLFS,mz-1
C +
C +
C +-----Downdraft : Lower Parcel to Surface while Mixing
C +     ------------------------------------------------
C +
                mFluDw(k+1)=mDwLFS*(1.0d+0+(H_Envr(kLFS)-H_Envr(k+1))
     .                            * lam_ZF)
C +....         ^^^^ Mass flux of Downdraft (Zhang   and Fritsch, 1986)    X
C +                                                                       /|\
C +                                                                      /_o_\
C +
c _ZF           mFluDw(k+1)=mDwLFS*(1.0d+0+(zLFS        -H_Envr(k+1))
c _ZF.                            / 5.5d+3)
C +....         ^^^^ Mass flux of Downdraft (Fritsch and Chappell,1980)    X
C +                                                                       /|\
C +                                                                      /_o_\
C +
C +
C +----Kain-Fritsch Entraining-Detraining Plume Parameterization
C +    ---------------------------------------------------------
C +
c #kf             mFluTr = mDwLFS*lam_KF*(p_Envr(k+1)-p_Envr(k))/RDwLFS
C +...            ^^^^ Mass Flux entering the Transition Region
C +                              ((1) p.2786 Kain    and Fritsch, 1990, KF90)
C +                                                                        X
C +                                                                       /|\
C +                                                                      /_o_\
C +
c #kf             f_Entr = 1.0d+0
c #kf             f_Detr = 0.0d+0
C +
c #KF             TeTrZo = FrEnvr *TeEnvr(k) + FrDraf *TeDwdr(k)
c #KF             Q1TrZo = FrEnvr *QtEnvr(k) + FrDraf *QvDwdr(k)
C +               ^^^^ Mixed Air Thermodynamics
C +
c #KF             T0TrZo = FrEnvr *T_Envr(k) + FrDraf *T_Dwdr(k)
C +
C +               ***********
c #KF             call TQsCVA(TeTrZo   ,ExEnvr(k)  ,
c #KF.                         sigma(k), pstDY(i,j),ptopDY,
c #KF.                        T0TrZo,TnTrZo,       T_TrZo,
c #KF.                        Q1TrZo,Q1TrZo,QdTrZo,QvTrZo,QwTrZo,QiTrZo,
c #KF.                                                    EvTrZo)
C +               ***********
C +
c #KF             TvDwdr      = T_Dwdr(k)
c #KF.                *(1.+0.61*QvDwdr(k)           )
c #KF             TvEnvr      = T_Envr(k)
c #KF.                *(1.+0.61*QvEnvr(k)-(QtEnvr(k)-QvEnvr(k)))
c #KF             TvTrZo      = T_TrZo
c #KF.                *(1.+0.61*QvTrZo   -(Q1TrZo   -QvTrZo   ))
c #KF             dTvDwT =            TvDwdr-TvTrZo
c #KF             dTvSgn =  sign(unun,dTvDwT)
c #KF             dTvAbs =   abs(     dTvDwT)
c #KF             dTvDwT =   max(epsi,dTvAbs)       *dTvSgn
c #KF             FrEnvC =    FrEnvr*(TvDwdr-TvEnvr)/dTvDwT
c #KF             FrEnvC =max(FrEnvC,zero)
c #KF             FrEnvC =min(FrEnvC,unun)
C +
C +               ***********
c #KF             call CVATrZ(FrEnvC,f_Entr,f_Detr)
C +               ***********
C +
c #kf             mEntDw     =       f_Entr*mFluTr
c #kf             mDtrDw(k+1)=       f_Detr*mFluTr
c #kf             mFluDw(k+1)=mFluDw(k)    +mEntDw
C +
C +
                  mFluDw(k+1)=max(mf_min,mFluDw(k+1))
C +
C +
C +----Impact of Mixing on Downdraft Properties
C +    ----------------------------------------
C +
                TeDwdr(k+1)=
C +....         ^^^^ Downdraft Equivalent Potential Temperature
C +                  (Pielke 1984, (9-36) p.255)                           X
C +                                                                       /|\
C +                                                                      /_o_\
     .         (TeDwdr(k)    * mFluDw(k)+(mFluDw(k+1)-mFluDw(k))
     .                           *0.5d+0*(TeEnvr(k+1)+TeEnvr(k)))
     .                       / mFluDw(k+1)
C +
C +
C +-----Entrainement Mixing Ratio
C +     -------------------------
C +
                Q2Dwdr      =
     .         (QvDwdr(k)    * mFluDw(k)+(mFluDw(k+1)-mFluDw(k))
     .                           *0.5d+0*(QvEnvr(k+1)+QvEnvr(k)))
     .                       / mFluDw(k+1)
C +....             ^^^^ Downdraft Mixing Ratio (without Evaporation Effect)
C +                      (Pielke 1984, (9-37) p.255)                       X
C +                                                                       /|\
C +                                                                      /_o_\
C +
C +
C +-----Downdraft Real Temperature:
C +     ---------------------------
C +
C +-----1. ABOVE LCL : Saturated Mixing Ratio
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                IF ((k+1).le.kLCL)                                THEN
C +
                  T0Dwdr = T_Dwdr(k)+(AdiabT(k+1)-AdiabT(k))
                  Q1Dwdr = 1.0d+9
C +...            Q1Dwdr : fictitious value supposed never reached
C +
C +
C +               ***********
                  call TQsCVA(TeDwdr(k+1),ExEnvr(k+1),
     .                         sigma(k+1), pstDY(i,j),ptopDY,
     .                        T0Dwdr,TnDwdr,       T_Dwdr(k+1),
     .                        Q1Dwdr,Q2Dwdr,QdDwdr,QvDwdr(k+1),
     .                                      QwDwdr,QiDwdr,EvDwdr(k+1))
C +               ***********
C +
C +
C +------Saturated Mixing Ratio at LCL
                  qsLCL         =                           QvDwdr(k+1)
C +
C +-----2. BELOW LCL : Mixing Ratio = 80 % of Qvsat(Upper Layer)       ! VER
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                ELSE
C +
                    QvDwdr(k+1) = 0.8*qsLCL
c #!!               QvDwdr(k+1) = 0.8*qsat0D(T_Dwdr(k)  ,sigma(k),
c #!!.                                        pstDY(i,j),ptopDY  ,int_1)
C +.....            ^^^^ Constant mixing ratio below LCL (80 % sat. LCL)
C +                      Pielke 1984, (9-38) p.256                     ! VER
C +                                                                    ! VER
                    T_Dwdr(k+1)=TeDwdr(k+1)*ExEnvr(k+1)
C +.....            ^^^^ Downdraft Temperature
     .               /exp(h2oLCp*QvDwdr(k+1)/TnDwdr)
C +
                    T_Dwdr(k+1)=T_Dwdr(k+1)-0.2*qsLCL*h2oLCp
C +.....            ^^^^ Correction on Temperature due to evaporation
C +
                    diffqv      =          QvDwdr(k+1)-Q2Dwdr
                    EvDwdr(k+1) = max(zero,diffqv)
C +.....            ^^^^ Evaporation in the Downdraft
C +
                END IF
C +
C +
C +-----Vertical Motion in the Downdraft
C +     --------------------------------
C +
                    deltaz      =  H_Envr(k)-H_Envr(k+1)
                    TvDwdr      = (T_Dwdr(k)+T_Dwdr(k+1)  )*0.5d+0
     .                  *(1.+0.61*(QvDwdr(k)+QvDwdr(k+1)  )*0.5d+0
     .                           -(QwUpdr(k)+QwUpdr(k+1)  
     .                            +QiUpdr(k)+QiUpdr(k+1)  )*0.5d+0)
C +...              ^^^^ Downdraft   Virtual Temperature
C +
                    TvEnvr      = (T_Envr(k+1)+T_Envr(k)  )*0.5d+0
     .                  *(1.+0.61*(QvEnvr(k+1)+QvEnvr(k)  )*0.5d+0
     .                      -     (QtEnvr(k+1)-QvEnvr(k+1)
     .                            +QtEnvr(k)  -QvEnvr(k)  )*0.5d+0)
C +...              ^^^^ Environment Virtual Temperature
C +
                    dEnCin      = 2.0*gravit*deltaz*(TvDwdr-TvEnvr)
C +...              ^^^^ Kinetic Energy Variation (Pielke 1984, (9-41) p.256)
C +                                                                        X
C +                                                                       /|\
C +                                                                      /_o_\
     .                                              /(1.5d+0*TvEnvr)
C +...                   Zhang and Fritsch, 1986:     1.5 <= 1+beta        X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                    auxEnt  =1.0-2.0*deltaz*lam_ZF
C +                 ^^^^ Effect of entrainement
C +                      Zhang and Fritsch, 1986                           X
C +                                                                       /|\
C +                                                                      /_o_\
C +
                    w2_New      =auxEnt*w_Dwdr(k)*w_Dwdr(k)-dEnCin
                    w_Dwdr(k+1) =sqrt(max(zero,w2_New))
C +
C +-----LFS Lowered if no Downward Vertical Velocity
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    mFluDn=       mFluDw(k+1)
c #kf               mFluDn=mFluDn-mDtrDw(k+1)
                IF (w_Dwdr(k+1).le.eps02 .or.
     .              mFluDn     .le.eps02.and.dEnCin.gt.0)         THEN
                  DO iter=1,k+1
                    mFluDw(iter)=0.
c #kf               mDtrDw(iter)=0.
                    w_Dwdr(iter)=0.
                    AreaDw(iter)=0.
                  ENDDO
                  IF (k.lt.(mz-1)) zLFS=H_Envr(k+2)
                ELSE
                    mFluDw(k+1) =mFluDn
                END IF
C +
                  IF ((k+1).eq.mz)  w_Dwdr(k+1)=0.
C +
C +
C +-----Downdraft Area as a Function of Height
C +     --------------------------------------
C +
                IF (w_Dwdr(k).gt.eps02)                           THEN
                    AreaDw(k)=mFluDw(k)
     .                      /(w_Dwdr(k)*p_Envr(k)*1000./(Ra*T_Dwdr(k)))
C +...              Pielke 1984, (9-41) p.256                              X
C +                                                                       /|\
C +                                                                      /_o_\
                ELSE
                    AreaDw(k)=0.
                ENDIF
C +
C +
              ENDDO                                       !  { k=kLFS,mz-1 }
C +
              END IF                              ! {END zLFS.gt.zLCL}
C +
C +
C +----Case of no Downdraft
C +    ====================
C +
              IF (zLFS.le.zLCL)                                   THEN
C +
                DO k=1,mz
                  mFluDw(k)   = 0.
                  w_Dwdr(k)   = 0.
                  AreaDw(k)   = 0.
                  TeDwdr(k)   = TeEnvr(k)
                  QvDwdr(k)   = QtEnvr(k)
                  EvDwdr(k)   = 0.
                ENDDO
C +
                  NbDwdr      = 0.
                  tau_CA(i,j) = taumin
C +
                DO k=1,mz
                  IF (AreaUp(k) .gt.   (0.95*sdx*sdy))            THEN
                      AreaUp(k) =       0.95*sdx*sdy
                  END IF
                      FracUp(k) =          AreaUp(k)/(sdx*sdy)
                      FracDw(k) =     0.
                      FracEv(k) =     unun-FracUp(k)
                      FracEv(k) = max(zero,FracEv(k))
                ENDDO
C +
              END IF
C +
C +
C +-----Convective Precipitation is not allowed in case of no Downdraft
C +     ---------------------------------------------------------------
C +
c #ND         IF (zLFS.le.zLCL)                              GO TO 300
C +
C +
C +----Normalization of Updraft and Downdraft Areas
C +    ============================================
C +
C +----Correction on Updraft/Downdraft area in order to conserve
C +    the mass flux profile ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +    ~~~~~~~~~~~~~~~~~~~~~
C +
              DO k=1,mz
C +
                      AreaMx = AreaUp(k)+AreaDw(k)
C +....               ^^^^ Maximum area of Updraft / Downdraft
C +
                      aux__A =  eps02*sdx*sdy
C +
                IF   (AreaMx.gt.(0.95*sdx*sdy))                   THEN
                  IF (AreaUp(k).gt.aux__A)                        THEN
                      AreaUp(k)=(0.95*sdx*sdy/AreaMx)*AreaUp(k)
                      AreaUp(k)=                  max(AreaUp(k),aux__A)
                  END IF
                  IF (AreaDw(k).gt.aux__A)                        THEN
                      AreaDw(k)=(0.95*sdx*sdy/AreaMx)*AreaDw(k)
                      AreaDw(k)=                  max(AreaDw(k),aux__A)
                  END IF
                END IF
C +
              END DO
C +
C +
C +----Relative area of Updraft, Downdraft and Environment
C +    ===================================================
C +
              DO k=1,mz
                FracUp(k)=AreaUp(k)/(sdx*sdy)
                FracDw(k)=AreaDw(k)/(sdx*sdy)
                FracEv(k)=    unun-FracUp(k)-FracDw(k)
                FracEv(k)=max(zero,FracEv(k))
              END DO
C +
C +
C +----Equivalent Water Content in the Updraft
C +    =======================================
C +
              IF (  zLFS.le.      zLCL)                           THEN
                  pUp165 = p_Envr(kLCL)
                  pEffic = 1.0d+0
              ELSE
                  pUp165 = p_Envr(kLCL) - 16.5
              END IF
C +
C +
C +-----Condensate Production
C +     ---------------------
C +
              DO k=kLCL,3,-1
                  drUpdr = roEnvr(k)* QwUpdr(k)
     .                   * AreaUp(k)*(H_Envr(k-1)-H_Envr(k+1))*0.5
                  dsUpdr = roEnvr(k)* QiUpdr(k)
     .                   * AreaUp(k)*(H_Envr(k-1)-H_Envr(k+1))*0.5
                  rrUpdr = rrUpdr   + drUpdr + dsUpdr
C +
C +
C +-----Condensate Lost in the Anvil ====> Returns to Environment
C +     ----------------------------
C +
                IF (H_Envr(k-1).gt.zETL)                          THEN
                    rrAnvl    = rrAnvl   +(drUpdr+dsUpdr) *(1-LDtrai)
                    QwUpdr(k) = QwUpdr(k)                 *   LDtrai
                    QiUpdr(k) = QiUpdr(k)                 *   LDtrai
C +
C +
C +-----Condensate Lost in the Updraft ==> Convective Precipitation
C +     ------------------------------
C +
                ELSE
                    pProdu    =                unun
C +
c #kf             IF                        (p_Envr(k).gt.pUp165) THEN
c #kf               argexp    =      c1KF90*(H_Envr(k-1)-H_Envr(k+1))
c #kf.                                     / max(W_Init ,w_Updr(k))
c #kf               argexp    =
c #kf.                          min( argexp, argmax)
c #kf               pProdu    =      (0.500*(QwUpdr(k+1)+QwUpdr(k  )
c #kf.                                      +QiUpdr(k+1)+QiUpdr(k  ))
c #kf.                               +0.250*(QwUpdr(k-1)+QwUpdr(k  )
c #kf.                                      +QiUpdr(k-1)+QiUpdr(k  )))
c #kf.                   *(1.00-exp(-argexp)) / max(epsi,QwUpdr(k  ) 
c #kf.                                                  +QiUpdr(k  ))
c #kf               pProdu    = min( pProdu,   unun)
C +...              Kain and Fritsch 1999, JAS 47(23), (9) p.2787
C +
c #kf             END IF
C +
C +
C +-----Precipitation Transported in the Downdraft
C +     ------------------------------------------
C +
                    QrDwdr(k) =        pEffic*pProdu* QwUpdr(k)
                    QsDwdr(k) =        pEffic*pProdu* QiUpdr(k)
                    RainCb    = RainCb+pEffic*pProdu* drUpdr
                    SnowCb    = SnowCb+pEffic*pProdu* dsUpdr
                END IF
C +
              END DO
C +
C +
C +----Equivalent Water Content in the Downdraft
C +    =========================================
C +
C +-----Condensate Lost in the Downdraft through Evaporation
C +     ----------------------------------------------------
C +
              DO k=kLFS,mz-1
                  VpDwdr = VpDwdr
     .                   + roEnvr(k)* EvDwdr(k)
     .                   * AreaDw(k)*(H_Envr(k-1)-H_Envr(k+1))*0.5d+0
              END DO
C +
C +
C +----Relationship of Downdraft Mass Flux to Updraft
C +    ==============================================
C +
                  NbDwdr=(rrUpdr-RainCb-SnowCb-rrAnvl)/max(eps05,VpDwdr)
C +...            ^^^^ Number of units of Downdraft per unit of Updraft
C +                    Downdraft  surface       is such     that
C +                    Condensate remaining     in the   Updraft
C +                               is evaporated in the Downdraft
C +                    (Fritsch  and Kain    1993, (15.13) p.162,          X
C +                     Emmanuel and Raymond 1993, AMS Meteo.Monograph)   /|\
C +                                                                      /_o_\
C +
C +
C +----Characteristic Time Scale of Convection
C +    =======================================
C +
                  tau_up = 0.
                  tau_dw = 0.
C +
              DO k=2,kLCL
                IF (w_Updr(k).gt.eps01)
     .            tau_up = tau_up   +(H_Envr(k-1)-H_Envr(k+1))*0.5d+0
     .                              / w_Updr(k)
C +....           ^^^^ Time scale for Updraft
              ENDDO
C +
              DO k=kLFS,mz-1
                IF (w_Dwdr(k).gt.eps01)
     .            tau_dw = tau_dw   +(H_Envr(k-1)-H_Envr(k+1))*0.5d+0
     .                              / w_Dwdr(k)
C +....           ^^^^ Time scale for Downdraft
              ENDDO
C +
                  tau_CA(i,j) =          tau_up+tau_dw
                  tau_CA(i,j) = max(zero,tau_CA(i,j))
C +...            ^^^^ Time scale of convection
C +
              DO k=kLCL,mz-1
                  WindSp      = u_Envr(k)*u_Envr(k) +v_Envr(k)*v_Envr(k)
                  tau_CA(i,j) = min(tau_CA(i,j),dx/WindSp)
C +....           ^^^^ Upper bound on characteristic time scale
C +                    in order to avoid the influence of advection
C +                                      during the Adjustment
              ENDDO
C +
                  tau_CA(i,j) = min(tau_CA(i,j),taumax)       !  Upper bound
                  tau_CA(i,j) = max(tau_CA(i,j),taumin)       !  Lower bound
C +
C +
C +-----Convective Precipitation is not allowed in case of no Downdraft
C +     ---------------------------------------------------------------
C +
 300          CONTINUE                            ! {END zLFS.le.zLCL}
C +
C +
C +-----Number of time step needed for the Adjustment
C +     ---------------------------------------------
C +
                  adj_CA(i,j) =NINT(tau_CA(i,j)/dt_Loc)
C +...            ^^^^ Number of time step needed for the Adjustment
C +
C +
C +----Environmental Subsidence : Vertical Motion
C +    ==========================================
C +
              DO k=1,mz
C +
                    mfTota    = sdx*sdy*roEnvr(k) *w_Envr(k)
                    mfEnvr    = mfTota -mFluUp(k) +mFluDw(k)
C +....             ^^^^ Mass flux         of environmental Subsidence
C +
                    w_Subs(k) = mfEnvr/(roEnvr(k)*FracEv(k)*sdx*sdy)
C +....             ^^^^ Vertical velocity of environmental Subsidence
C +                      Units = [m/s] !!!
C +
                IF      (H_Envr(k).ge.zETL)                       THEN
                    FiltWe     = 0.
                ELSE IF (H_Envr(k).le.zLCL)                       THEN
                    FiltWe     = We_Max*(     H_Envr(k) /      zLCL)
                ELSE
                    FiltWe     = We_Max*(zETL-H_Envr(k))/(zETL-zLCL)
                ENDIF
C +....             ^^^^ Filter for environmental Subsidence
C +
                    w_Subs(k)  = min( FiltWe,w_Subs(k))
                    w_Subs(k)  = max(-FiltWe,w_Subs(k))
C +
              ENDDO
C +
C +
C +----Environmental Subsidence : Modification on T and Qv
C +    ===================================================
C +
C +----Initialisation Step
C +    -------------------
C +
                  dt_adv    = dt_Loc
C +
              DO k=1,mz
                  T_Subs(k) = TeEnvr(k)
                  QvSubs(k) = QtEnvr(k)
              END DO
C +
              DO k=kp1(1),mz
                  deltaz    =         H_Envr(k-1)-H_Envr(k)
                  aux__w    =         deltaz     /dt_Loc
                  wSpeed    = max(ABS(w_Subs(k)) ,aux__w)
                  aux_dt    =    demi*deltaz     /wSpeed
                  dt_adv    = min(    dt_adv     ,aux_dt)
C +....           ^^^^ Upper bound on the local time step in order
C +                    to satisfy the stability criterion of explicit
C +                    numerical (temporal) scheme
              END DO
C +
                   NitTUp   =nint(    tau_CA(i,j)/dt_adv)
C +...             ^^^^ Number of iterations for the numerical method
C +
C +
C +----Resolution of the Advection Equation
C +    ------------------------------------
C +
              DO iter=1,NitTUp
                DO k=kp1(1),mz1
                  cfl_up    = max(zero,w_Subs(k))*dt_adv
     .                               /(H_Envr(k)-H_Envr(k+1))
                  cfl_dw    = min(zero,w_Subs(k))*dt_adv
     .                               /(H_Envr(k)-H_Envr(k-1))
                  T__New(k) = T_Subs(k)-cfl_up*(T_Subs(k)-T_Subs(k+1))
     .                                 -cfl_dw*(T_Subs(k)-T_Subs(k-1))
                  Qv_New(k) = QvSubs(k)-cfl_up*(QvSubs(k)-QvSubs(k+1))
     .                                 -cfl_dw*(QvSubs(k)-QvSubs(k-1))
C +.....          ^^^^ T, Qv computed with an upstream (spatial)
C +                                           explicit (temporal) scheme
                END DO
                DO k=kp1(1),mz1
                  T_Subs(k) = T__New(k)
                  QvSubs(k) = Qv_New(k)
                END DO
              END DO
C +
C +
C +----Environmental Equivalent Potential Temperature -> Temperature
C +    -------------------------------------------------------------
C +
              DO k=1,mz
                  PTEnvr(k) = T_Subs(k)*ExEnvr(k)
     .            /exp(h2oLCp*QvSubs(k)/T_Envr(k))
              ENDDO
C +
C +
C +----Adjusted Values of Temperature and Total Water Content
C +    ======================================================
C +
C +----In the Atmosphere ...
C +    -----------------
C +
              DO k=1,mz
                  QwDwdr    =QwUpdr(k)- QrDwdr(k)
                  QiDwdr    =QiUpdr(k)- QsDwdr(k)
                  QnUpdr    =QvUpdr(k)+(QwDwdr   +QiDwdr)*(1-LDTrai)
                  QnDwdr    =QvDwdr(k)- EvDwdr(k)
C +
c #kf             DetrUp    =mDtrUp(k)/max(mFluUp(k),epsi)
c #KF             DetrDw    =mDtrDw(k)/max(mFluDw(k),epsi)
C +...            Detrainment rates (KF90)
C +
c #WD             QwDetr(k) =FracUp(k)*(QwDwdr
c #WD.                                 +QwUpdr(k)*DetrUp)*   LDTrai
c #WD             QiDetr(k) =FracUp(k)*(QiDwdr
c #WD.                                 +QiUpdr(k)*DetrUp)*   LDTrai
C +
                  T_Ajst(k) =
     .            FracUp(k)*(T_Updr(k)
c #kf.          +(T_Updr(k)- PTEnvr(k))*DetrUp
C +...            Detrain/14B, KF90  (NO verif. of conservat. propert.)
     .                                                                )
     .          + FracDw(k)*(T_Dwdr(k)
c #KF.          +(T_Dwdr(k)- PTEnvr(k))*DetrDw
C +...            Detrain/14C, KF90  (NO verif. of conservat. propert.)
     .                                                                )
c #kf.          -(QwUpdr(k)* FracUp(k) *DetrUp * h2oLCp
c #kf.           +QiUpdr(k)* FracUp(k) *DetrUp * h2oSCp )*(1-LDTrai)
C +...            Detrain/14D, KF90  (NO verif. of conservat. propert.)
C +                (def. r_c = QwUpdr: mid of last para 1st col.p.2791)
C +
     .          + FracEv(k)* PTEnvr(k)
C +
                  QvAjst(k) =
     .            FracUp(k)*(QnUpdr
c #kf.          +(QnUpdr   - QvSubs(k))*DetrUp
C +...            Detrain/15B, KF90  (NO verif. of conservat. propert.)
     .                                                                )
     .          + FracDw(k)*(QnDwdr
c #KF.          +(QnDwdr   - QvSubs(k))*DetrDw
C +...            Detrain/15C, KF90  (NO verif. of conservat. propert.)
     .                                                                )
c #kf.          -(QwUpdr(k)+ QiUpdr(k))*DetrUp*FracUp(k)    *(1-LDTrai)
C +...            Detrain/15D, KF90  (NO verif. of conservat. propert.)
C +
     .          + FracEv(k)* QvSubs(k)
              ENDDO
C +
C +----... and the first Level (by Extrapolation)
C +        --------------------------------------
C +
                 T_Ajst(mz) = T_Ajst(mz-1)-(T_Ajst(mz-1)-T_Ajst(mz-2))
     .                      /(H_Envr(mz-1)- H_Envr(mz-2))
     .                      *(H_Envr(mz-1)- H_Envr(mz))
                 QvAjst(mz) = QvAjst(mz-1)-(QvAjst(mz-1)-QvAjst(mz-2))
     .                      /(H_Envr(mz-1)- H_Envr(mz-2))
     .                      *(H_Envr(mz-1)- H_Envr(mz))
C +
C +
C +----Detrainment of Cloud Species  to the Environment
C +    ================================================
C +
c #WD             dtrain=0.0d+0
c #WD         DO k=1,mz
c #WD             dtrain=dtrain   + roEnvr(k)    *(QwDetr(k)+QiDetr(k))
c #WD.                  *AreaUp(k)*(H_Envr(km1(k))-H_Envr(kp1(k)))*0.50
c #WD         ENDDO
C +
C +
C +----Moisture Loss by the Anvil (Pielke 1984, (9-35) p.255)
C +    ==========================
C +
              DO k=kCT,mz-1
                IF (rrAnvl.gt.0.0)                                THEN
                    AirMss    =     0.50*(H_Envr(k-1)-H_Envr(k+1))
     .                            *sdx*sdy*roEnvr(k)
                    T0Ajst    =      T_Ajst(k)
                    Q0Ajst    =      QvAjst(k)
                    TnAjst    =      T_Ajst(k)
                    difftt    =           1.
                    NitTUp    =           0
C +
C +
C +-----{Loop to determine the Anvil   Temperature}
C +     -------------------------------------------
C +
                  DO WHILE (difftt.gt.0.05.and.NitTUp.lt.NitMax)
c #FC               GlacDg    = GlaCVA(T_Ajst(k))
c #FC               QdAjst    = Qs_CVA(T_Ajst(k),pstDY(i,j),ptopDY,
c #FC.                                  sigma(k),GlacDg)
                    dQAjst    =    max(QdAjst-QvAjst(k),zero)
                    drAnvl    =        dQAjst*AirMss
                    drAnvl    =    min(drAnvl,rrAnvl)
                    dQAjst    =        drAnvl/AirMss
                    QvAjst(k) =            dQAjst+QvAjst(k)
                    T_Ajst(k) = T_Ajst(k) -dQAjst*h2oLCp
                    difftt    = abs(TnAjst-T_Ajst(k))
                    TnAjst    = 0.8*TnAjst+T_Ajst(k)*0.2
                    NitTUp      =     NitTUp+1
                    IF (difftt.gt.25.)NitTUp=NitMax
C +...                Patatra
                  END DO
C +
C +
C +-----If the iterative method has not converged ...
C +     ---------------------------------------------
C +
C +
                  IF (NitTUp.eq.NitMax.and.difftt.gt.0.5)         THEN
c #FC               GlacDg    = GlaCVA(T0Ajst)
c #FC               QdAjst    = Qs_CVA(T0Ajst,pstDY(i,j),ptopDY,
c #FC.                                  sigma(k),        GlacDg)
                    dQAjst    = max(zero,  QdAjst-Q0Ajst)
                    drAnvl    =            dQAjst*AirMss
                    drAnvl    = min(drAnvl,rrAnvl)
                    dQAjst    = drAnvl           /AirMss
                    QvAjst(k) =            dQAjst+Q0Ajst
                    T_Ajst(k) = T0Ajst    -dQAjst*h2oLCp
                  END IF
C +
                    rrAnvl    =     rrAnvl-drAnvl
                END IF
              END DO
C +
C +
C +----Moisture Conservation
C +    =====================
C +
                 CEWC_1    = 0.
                 CEWC_2    = 0.
C +
              DO k=kCT,mz-1
                 Vol_Cb    =     sdx*sdy*(H_Envr(k-1)-H_Envr(k+1))*0.5
                 CEWC_1    =     CEWC_1 + roEnvr(k)  *QtEnvr(k)  *Vol_Cb
C +....          ^^^^ Columnar Equivalent Water Content before Adjustment
                 CEWC_2    =     CEWC_2 + roEnvr(k)  *QvAjst(k)  *Vol_Cb
C +....          ^^^^ Columnar Equivalent Water Content after  Adjustment
              ENDDO
C +
                 CEWC_2    =     CEWC_2+dtrain +RainCb+SnowCb
C +...           ^^^^ CEWC after Adjustment including precipitation
C +
                 d_CEWC    = 1.-(CEWC_2-CEWC_1)
     .                         /(CEWC_2-dtrain -RainCb-SnowCb)
C +...           ^^^^ Factor for the correction on adjusted T and Qv
C +
              DO k=kCT,mz
                 QvAjst(k) =     d_CEWC*QvAjst(k)
C +....          ^^^^ Correction profile of specific humidity
              ENDDO
C +
C +
C +----Conservation of Moist Enthalpy
C +    ==============================
C +
                 d_Tair    =     0.0d+0
              DO k=kCT,mz-1
                 d_Tair    = d_Tair+(H_Envr(k-1)-H_Envr(k+1))*0.5
     .                             *(T_Envr(k)  -T_Ajst(k)
     .                      +h2oLCp*(QvEnvr(k)  -QvAjst(k)) )
C +....          ^^^^ Temperature Difference resulting   from the
C +                   Enthalpy    Difference before and after the Adjustment
              END DO
C +
                 d_Tair    = d_Tair/(H_Envr(kCT)  -H_Envr(mz-1)
     .                             +(H_Envr(kCT-1)-H_Envr(kCT))*0.5)
C +...           ^^^^ Mean Temperature Difference for the Troposphere
C +
              DO k=kCT,mz
                 T_Ajst(k) = T_Ajst(k) + d_Tair
C +....          ^^^^ Corrected Profile of Temperature
              END DO
C +
C +
C +----New Available / Potential Buoyant Energy
C +    ========================================
C +
C +----Retain the best values of flux mass
C +    (used if no convergence is reached for ABE)
C +    -------------------------------------------
C +
              IF (abs(aBEnew).lt.abs(aBEmin))                     THEN
                      mfUpMn  =      mUpLCL
                      mfDwMn  =      mDwLFS
                      aBEmin  =      aBEnew
              END IF
C +
C +           ***********
              call CVAdia(kINI,kLCL2,hPBL,zLCL2,zLFC2,zETL2,
     .                    aBEnew,pBEnew,Adia2T,T_Ajst,QvAjst,H_Envr)
C +           ***********
C +
C +
C +----Variation of ABE due to Adjustment and new Updraft /
C +    Downdraft mass fluxes ------------------------------
C +    ---------------------
C +
              IF (abs(aBEnew)       .gt.(0.05*aBE__0)             .and.
     .            abs(aBuoyE-aBEnew).gt. 0.0001)                  THEN
C +...            1st Condition: see Pielke            1984, (9.23) p.250  X
C +                              or  Fritsch and Kain, 1993,        p.161 /|\
C +                                                                      /_o_\
C +               2nd Condition  avoids a spurious division by 0
C +
                      nitabe=nitabe+1
C +
                IF   (nitabe.eq.NO_abe)                           THEN
                      mUpLCL=max(mfUpMn,mf_min)
                      mDwLFS=max(mfDwMn,mf_min)
                END IF
C +
                IF   (nitabe.lt.NO_abe)                           THEN
C +
                  IF (aBuoyE.ge.0.)                               THEN
                      dFr_Up=aBuoyE/abs(aBuoyE-aBEnew)
C +.....              ^^^^ Factor change for the Updraft area at LCL
C +                              see Pielke            1984, (9.22) p.250  X
C +                              or  Fritsch and Kain, 1993, (15.7) p.161 /|\
C +                                                                      /_o_\
C +
                  ELSE
                      dFr_Up=       abs(aBEnew-aBuoyE)/(-aBuoyE)
                  END IF
C +
                      auxmUp    =dFr_Up *mUpLCL
                      mUpLCL=max(mf_min,auxmUp)
                      auxmUp    =dFr_Up *mUpLCL
                      mUpLCL=min(mf_max,auxmUp)
C +.....              ^^^^ New Updraft   Mass Flux at  LCL
                      auxmDw    =NbDwdr*mUpLCL
                      mDwLFS=max(mf_min,auxmDw)
                      mDwLFS=min(mf_max,mDwLFS)
C +
                      mDwLFS=min(mDwLFS,dFr_Up*mFluUp(kLFS))
C +.....              ^^^^ New Downdraft Mass Flux at  LFS
C +
                  IF (zLCL.gt.(zETL-2000.) .or.
     .                zLFC.gt.(zETL- 500.) .or.
     .                zETL.lt.      3000.)  nitabe=NO_abe+1
C +
                END IF
C +
              END IF
C +
C +
C +
C +-----0. Output in      stdout  file
C +     ------------------------------
C +
c #WR                    ni = 1
c #WR                    nj = 1
c #WR         IF   (i.eq.ni.and.j.eq.nj)                          THEN
C +
c #WR                 write(6,400)
c #WR                 write(6,401)
c #WR                 write(6,402) i,j
c #WR                 write(6,403) explIO,
c #WR.                      GElatr(i,j),
c #WR.                      GElonh(i,j)
c #WR                 write(6,404) jdplus,mmplus,jhurGE,minuGE,jsecGE,
c #WR.                             itexpe
c #WR                 write(6,405) zCT
c #WR                 write(6,406) zETL
c #WR                 write(6,407) zLFC
c #WR                 write(6,408) zLFS
c #WR                 write(6,409) zLCL
c #WR                 write(6,410)(RainCb+SnowCb)/(sdx*sdy)
c #WR                 write(6,411) pEffic*100.
c #WR                 write(6,412) d_CEWC
c #WR                 write(6,413) d_Tair
c #WR                 write(6,414)
c #WR                 write(6,415)
c #WR                 write(6,416)
c #WR                 write(6,417)
C +
c #WR               DO k=1,mz
c #WR                 write(6,418) H_Envr(k),
c #WR.                             T_Envr(k),T_Ajst(k),dpktCA(i,j,k),
c #WR.                             QvEnvr(k),QvAjst(k),dqv_CA(i,j,k),
c #WR.                      1.0d-6*mFluUp(k),mDtrUp(k)*1.0d-6,
c #WR.                      1.0d-6*mFluDw(k),mDtrDw(k)*1.0d-6
c #WR               ENDDO
C +
c #WR                 write(6,420)
c #WR                 write(6,421)
c #WR                 write(6,422)
c #WR                 write(6,423)
C +
c #WR               DO k=1,mz
c #WR                 write(6,424) H_Envr(k),
c #WR.                             FracUp(k), FracDw(k), FracEv(k),
c #WR.                             w_Updr(k), w_Dwdr(k), w_Subs(k),
c #WR.                             T_Updr(k), T_Dwdr(k), PTEnvr(k),
c #WR.                             QvUpdr(k),(QvDwdr(k)+ EvDwdr(k)),
c #WR.                                                   QvSubs(k)
c #WR               ENDDO
C +
c #WR                 write(6,*)
c #WR                 write(6,*)
C +
c #WR         END IF
C +
C +
C +-----END of internal Iterations over ABE
C +     -----------------------------------
C +
              IF (abs(aBEnew)       .gt.(0.05*aBE__0) .and.
     .            abs(aBuoyE-aBEnew).gt. 0.0001       .and.
     .                nitabe        .le.NO_abe )             GO TO 100
C +...        ^^^^ New ABE iteration
C +
C +
C +----Final Decision to Trigger the Convective Scheme
C +    ===============================================
C +
              IF (zLCL.gt.(zETL-2000.) .or.
     .            zLFC.gt.(zETL- 500.) .or.
     .            zETL.lt.      3000.  .or.
     .             zCT.lt.      3000. )                           THEN
                  adj_CA(i,j) = 0
              END IF
C +
              IF (adj_CA(i,j).eq.0)                    THEN !  NO ADJUSTMENT
C +                                                            ~~~~~~~~~~~~~
                DO k=1,mz
                  dpktCA(i,j,k)=0.
                  dqv_CA(i,j,k)=0.
c #WD             dqw_CA(i,j,k)=0.
c #WD             dqi_CA(i,j,k)=0.
                  drr_CA(i,j)  =0.
c #CG             dsn_CA(i,j)  =0.
                ENDDO
C +
              ELSE                                   !  ADJUSTMENT TRIGGERED
C +                                                     ~~~~~~~~~~~~~~~~~~~~
C +
C +-----Temporal Derivative for the Adjustment of T, Qv and rainHY
C +     ==========================================================
C +
                DO k=1,mz
                  rtime        = dt_Loc/tau_CA(i,j)
                  dpktCA(i,j,k)= rtime*(T_Ajst(k)-T_Envr(k))
     .                                / p_Envr(k)**cap
                  dqv_CA(i,j,k)= rtime*(QvAjst(k)-QtEnvr(k))
c #WD             dqw_CA(i,j,k)= rtime* QwDetr(k)
c #WD             dqi_CA(i,j,k)= rtime* QiDetr(k)
                  drr_CA(i,j)  = rtime*(RainCb+SnowCb)/(sdx*sdy*1000.)
C +               .... Units :          [kg]          / [m2]  /[1000 kg/m3]
C +
c #CG             dsn_CA(i,j)  = rtime*(h2oSCp-h2oLCp)*SnowCb /(sdx*sdy)
C +               .... Units :          [K]            [kg]   / [m2] 
C +
c #!! MELTING IMPACT on TEMPERATURE must be INCLUDED !!#####################
                END DO
C +
C +
C +-----Output
C +     ======
C +
C +-----1. Output in 'cv_adj.out' file
C +     ------------------------------
C +
                IF (FracDw(mz-1).gt.0.001)                        THEN
                    plocal=1000*((RainCb+SnowCb)
     .                         /(sdx*sdy*1000.))/FracDw(mz-1)
                ELSE
                    plocal= -99.
                ENDIF
C +
                    write(70,714) jdarGE,labmGE(mmarGE),iyrrGE,
     .                            jhurGE,minuGE,
     .                            i,j,   itexpe,
     .                            wmLCL-wANA,wANA,1.d-3*zANA,
     .                            1.d-3*aBuoyE,   1.d-3*pBuoyE,
     .                             zLCL,zLFC,zETL,zCT,  tau_CA(i,j)/60.,
     .                            (RainCb+SnowCb)/(sdx*sdy),plocal
C +
 714                format(i3,'-',a3,'-',i4,i3,'.',i2,' |',2(i4,' |'),
     .                     i6,' |',2(f6.3,' |'),  f5.2,' |' ,
     .                             2(f5.2,' |'),2(f6.0,' |'),
     .                             2(f7.0,' |'),  f5.1,' |' ,
     .                             2(f5.1,' |'))
C +
C +
C +-----2. Output in 'MARphy.out' file
C +     ------------------------------
C +
                DO i5=1,MIN0(mx,int_5)
C +
                  IF (i.eq.igrdIO(i5).and.
     .                j.eq.jgrdIO(i5).and.wricnv)                 THEN
C +
C +                   ***********
                      call TIMcor 
C +                   ***********
C +
                      write(4,400)
                      write(4,401)
                      write(4,402) igrdIO(i5),jgrdIO(i5)
                      write(4,403) explIO,
     .                      GElatr(igrdIO(i5),jgrdIO(i5)),
     .                      GElonh(igrdIO(i5),jgrdIO(i5))
                      write(4,404) jdplus,mmplus,jhurGE,minuGE,jsecGE,
     .                             itexpe
                      write(4,405) zCT
                      write(4,406) zETL
                      write(4,407) zLFC
                      write(4,408) zLFS
                      write(4,409) zLCL
                      write(4,410)(RainCb+SnowCb)/(sdx*sdy)
                      write(4,411) pEffic*100.
                      write(4,412) d_CEWC
                      write(4,413) d_Tair
                      write(4,414)
                      write(4,415)
                      write(4,416)
                      write(4,417)
C +
                    DO k=1,mz
                      write(4,418) H_Envr(k),
     .                             T_Envr(k),T_Ajst(k),dpktCA(i,j,k),
     .                             QvEnvr(k),QvAjst(k),dqv_CA(i,j,k),
     .                      1.0d-6*mFluUp(k),mDtrUp(k)*1.0d-6,
     .                      1.0d-6*mFluDw(k),mDtrDw(k)*1.0d-6
                    ENDDO
C +
                      write(4,420)
                      write(4,421)
                      write(4,422)
                      write(4,423)
C +
                    DO k=1,mz
                      write(4,424) H_Envr(k),
     .                             FracUp(k), FracDw(k), FracEv(k),
     .                             w_Updr(k), w_Dwdr(k), w_Subs(k),
     .                             T_Updr(k), T_Dwdr(k), PTEnvr(k),
     .                             QvUpdr(k),(QvDwdr(k)+ EvDwdr(k)),
     .                                                   QvSubs(k)
                    ENDDO
C +
                      write(4,*)
                      write(4,*)
C +
 400        format(/,/,
     .             'CHARACTERISTICS OF ATMOSPHERE VERTICAL STRUCTURE')
 401        format('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~')
 402        format('MESH COORDINATES :  i =',i4,'  *  j =',i4,/)
 403        format('Exp. ',a3,'   Lat.=',f6.1,3x,'Long.=',f7.1,4x)
 404        format('Date :',i3,'-',i2,' / ',i2,' h.',i3,' min.',i3,
     .             ' sec.',/,'Iter. temp. ',i6,/,/)
 405        format('Cloud Top                         : ',f9.1,' m.')
 406        format('Equilibrium level Temperature     : ',f9.1,' m.')
 407        format('Level of Free Convection          : ',f9.1,' m.')
 408        format('Level of Free Sink                : ',f9.1,' m.')
 409        format('Lifting Condensation Level        : ',f9.1,' m.')
 410        format('Precipitation (total during adj.) : ',f9.3,' mm.')
 411        format('Precipitation efficiency          : ',f9.1,' %')
 412        format('Moisture conservation : factor    : ',f9.3)
 413        format('Enthalpy conservation : delta T   : ',f9.3,' K',/,/)
 414        format('Characteristic profiles of convection : ')
 415        format('~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   ',/)
 416        format('   Height    Temp.    T-CNV    dT/dt        ',
     .             ' Qv     Qv-CNV     dQv/dt',
     .             '     mFluUp     mDtrUp     mFluDw     mDtrDw')
 417        format('   ------    -----    -----    -----        ',
     .             ' --     ------     ------',
     .             '     ------     ------     ------     ------',/)
 418        format(f9.0,2f9.2,d9.1,3d11.2,4f11.3)
C +
 420        format(/,/,'Detailed vertical profiles of T and Qv :')
 421        format(    '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ',/)
 422        format('  Height    Au    Ad    Ae   Wupd   Wdwd   Wenv  ',
     .             '  Tupd    Tdwd    Tenv   Qvupd   Qvdwd   Qvenv')
 423        format('  ------    --    --    --   ----   ----   ----  ',
     .             '  ----    ----    ----   -----   -----   -----',/)
 424        format(f8.0,3f6.3,3f7.2,3f8.2,3f8.5)
C +
                  END IF
C +
                ENDDO                                !  { i5=1,MIN(mx,5) }
C +
              ENDIF                                  !  { adj_CA(i,j).eq.0 }
C +
C +   ######################################################################
C +
          ENDIF
C +
C +            {End   convective Adjustment loop - CLOUD MODEL}
C +            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
C +   ######################################################################
C +
C +   ######################################################################
C +
        ENDDO
        ENDDO
C +
C +            {End loop for each horizontal grid point}
C +            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ENDIF
C +
C +   ######################################################################
C +
C +
C +---CONVECTIVE ADJUSTMENT OF TEMPERATURE AND SPECIFIC HUMIDITY
C +   ==========================================================
C +
      DO j=MIN0(int_2,mmy),MAX0(int_1,mmy1)   !  Loop on horizontal grid pts
      DO i=MIN0(int_2,mmx),MAX0(int_1,mmx1)   !  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
        IF (adj_CA(i,j).gt.0)                                     THEN
C +
C +     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
            adj_CA(i,j)   = adj_CA(i,j)   - 1
C +...      ^^^^ Number of remaining time step before the end of convection
C +
C +----Temporal tendencies on pktaDY, qvDY and rainHY
C +    ----------------------------------------------
C +
c #CG       snmelt        =      dsn_CA(i,j)
          DO k=kp1(1),mz
            pktaDY(i,j,k) =      pktaDY(i,j,k) + dpktCA(i,j,k)
c #CG       tairDY(i,j,k) =      pktaDY(i,j,k) *   pkDY(i,j,k)
c #CG       IF (tairDY(i,j,k)  .gt.TfSnow.and.
c #CG.          tairDY(i,j,k-1).le.TfSnow.and.snmelt.gt.0.0d+0)   THEN
c #CG           rairdz          = gravit *2.d-3 /(rolvDY(i,j,k)
c #CG.                          *(gplvDY(i,j,k-1)-gplvDY(i,j,k+1)))
c #CG           tairDY(i,j,k)   = tairDY(i,j,k)  -snmelt        *rairdz
c #CG           tairDY(i,j,k)   = max(TfSnow,tairDY(i,j,k))
c #CG           snmelt          = max(TfSnow-tairDY(i,j,k),zero)/rairdz
c #CG       END IF
          ENDDO
              qv_d       =    zero
          DO k=kp1(1),mz
              qv_n       =         qvDY(i,j,k) + dqv_CA(i,j,k)  + qv_d
              qv_d       =max(zero,qv_n        - qvswDY(i,j,k))
              qvDY(i,j,k)=max(zero,qv_n        -   qv_d)
              qv_d       =    qv_d*  dsigm1(k) / dsigm1(kp1(k))
c #WD         qwHY(i,j,k)=         qwHY(i,j,k) + dqw_CA(i,j,k)
c #WD         qiHY(i,j,k)=         qiHY(i,j,k) + dqi_CA(i,j,k)
          ENDDO
C +
              qv_d       =    qv_d*  dsigm1(mz)* pstDYn(i,j)   *grvinv
            rainHY(i,j)  =       rainHY(i,j)   + drr_CA(i,j)    + qv_d
            rainCA(i,j)  =       rainCA(i,j)   + drr_CA(i,j)    + qv_d
C +
C +     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
        ENDIF          !  { adj_CA(i,j).gt. 0 }
C +
      ENDDO    !                                 Loop on horizontal grid pts
      ENDDO    !                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
C +
      return
      end
      subroutine CVAdia(kINI,kLCL,hPBL,zLCL,zLFC,zETL,
     .                  aBuoyE,pBuoyE,AdiabT,T_Envr,QvEnvr,H_Envr)
C +
C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         10-06-2002  MAR |
C |                                                                        |
C |   SubRoutine CVAdia includes an thermodynamical Analysis               |
C |                              of the Cumulus Cloud.                     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | INPUT  : T_Envr: vertical sounding of (real) Temperature           (K) |
C | ^^^^^^^^ QvEnvr: vertical sounding of specific humidity        (kg/kg) |
C |          H_Envr: height of model levels for this sounding          (m) |
C |                                                                        |
C | OUTPUT : kLCL  : lifting condensation level                            |
C | ^^^^^^^^ zLCL  : height of the lifting condensation level          (m) |
C |          zLFC  : height of the level of free convection            (m) |
C |          zETL  : height of the equilibrium Temperature level       (m) |
C |          aBuoyE: available buoyant energy                      (m2/s2) |
C |          pBuoyE: potential buoyant energy                      (m2/s2) |
C |          AdiabT: adiabatic Temperature                                 |
C |                                                                        |
C | REFER. : K. Emanuel, 'Atmospheric Convection', 1994.                   |
C | ^^^^^^^^                                                               |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_DY.inc'
C +
      integer  kINI,kLCL
      real     hPBL,zLCL,zLFC,zETL,aBuoyE,pBuoyE
      real     AdiabT(mz),T_Envr(mz)
      real     QvEnvr(mz),H_Envr(mz)
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  lsf,int_3
C +
c #vT real      AdiabQ(mz)
      real      AdiavT(mz),TvEnvr(mz)
C +
      real      aux,tLCL,rw_Sat,rLiqid,T__Sat,qsat0D,Qv_Sat
     .         ,deltaz1,deltaz2,dEnCin,T__PBL,Qv_PBL,H__PBL
     .         ,Rd,Rv,Cpd,Cpv,Cl,r__PBL,dT__dz,Height,delz,diffqv,Tstrat
C +
C +
C +---Constants
C +   =========
C +
      data Rd      / 287.04    /
      data Rv      / 461.5     /
      data Cpd     / 1005.7    /
      data Cpv     / 1870.     /
      data Cl      / 4190.     /
      data Tstrat  /  180.     /
C +...     Tstrat  : Stratospheric Temperature, 
C +                  in order to avoid irrealistic adiabatic temperatures
      data int_3   /  3        /
C +
C +
C +---Computation of Adiabatic Temperature Profile
C +   ============================================
C +
C +
C +---Mean Temperature and moisture of the air in the lower levels
C +   ------------------------------------------------------------
C +
          T__PBL=0.
          Qv_PBL=0.
          H__PBL=0.
          Height=0.
C +
c #vT DO k=1,mz
c #vT   AdiabQ(k) = 0.
c #vT ENDDO
C +
      DO k=2,kINI
C +
        IF (H_Envr(k) .lt.  hPBL)                                 THEN
C +...  ^^^^ Lower levels = 600 m from the surface
          delz  =H_Envr(k-1)-H_Envr(k)
          Height=Height+          delz
          T__PBL=T__PBL+T_Envr(k)*delz
          Qv_PBL=Qv_PBL+QvEnvr(k)*delz
          H__PBL=H__PBL+H_Envr(k)*delz
        END IF
C +
      ENDDO
C +
        IF (Height    .gt.  0.0)                                  THEN
          T__PBL=T__PBL/Height
          H__PBL=H__PBL/Height
          Qv_PBL=Qv_PBL/Height
C +...    ^^^^ Specific humidity
        ELSE
          T__PBL=       T_Envr(kINI)
          Qv_PBL=       QvEnvr(kINI)
          H__PBL=       H_Envr(kINI)
        END IF
          r__PBL=Qv_PBL/(1.-Qv_PBL)
C +...    ^^^^ Mixing ratio
C +
C +---Lift a parcel from bottom to top
C +   --------------------------------
C +
          kLCL=0
          lsf =1
C +
C +---Vertical Gradient of Temperature : Unsaturated Case
C +   ---------------------------------------------------
C +
C +...Dry adiabatic Temperature gradient (K. Emanuel, 1994)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            dT__dz    =-(gravit/Cpd)*(1.+r__PBL)/(1.+r__PBL*Cpv/Cpd)
      DO k=mz,kINI    ,-1
            AdiabT(k)=  T__PBL      + dT__dz*(H_Envr(k)-H__PBL
     .                                                 -H_Envr(mz))
c #vT       AdiabQ(k)=  Qv_PBL
      END DO
C +
      DO k=   kINI-1,1,-1
C +
            Qv_Sat     = qsat0D(AdiabT(k+1),sigma(k+1),pstDY,ptopDY,lsf)
c #vT       AdiabQ(k+1)=    min(AdiabQ(k+1),Qv_Sat)
C +
        IF (kLCL.eq.0.and.k.lt.(mz-1).and.Qv_PBL.ge.Qv_Sat)       THEN
            kLCL  =        k+1                               !  LCL detected
            tLCL  = AdiabT(k+1)                              !  ------------
            zLCL  = H_Envr(k+1)
        END IF
C +
        IF (kLCL.ne.0)                                      THEN ! Above LCL
C +                                                              ! ---------
C +.... Moist adiabatic Temperature gradient (K. Emanuel, 1994)
C +     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            T__Sat = AdiabT(k+1)
            rw_Sat = Qv_Sat/(1.-Qv_Sat)
            diffqv = r__PBL-rw_Sat
            rLiqid = max(zero,diffqv)
            dT__dz =-(gravit/Cpd)
     .           *(1.+              r__PBL)/        (1.0+rw_Sat*Cpv/Cpd)
     .           *(1.+Lv_H2O/Rd    *rw_Sat /         T__Sat)
     .           /(1.+              rLiqid * Cl/    (Cpd+rw_Sat*Cpv)
     .               +Lv_H2O*Lv_H2O*rw_Sat /(Rv  *T__Sat*T__Sat)
     .           *(1.+              rw_Sat * Rv/Rd)/(Cpd+rw_Sat*Cpv))
C +
        ENDIF
C +
            AdiabT(k) = AdiabT(k+1) + dT__dz*(H_Envr(k)-H_Envr(k+1))
            AdiabT(k) = max(AdiabT(k),Tstrat)
C +
      ENDDO
C +
      DO k=1,mz
            TvEnvr(k) = T_Envr(k) 
c #vT.        *(1.+0.61*QvEnvr(k))
            AdiavT(k) = AdiabT(k) 
c #vT.        *(1.+0.61*AdiabQ(k))
      ENDDO
C +
      kLCL=MAX0(kLCL,int_3)
      kLCL=MIN0(kLCL, mmz1)
C +
C +   ----------------------------------------------------------------------
C +
C +---Equilibrium Temperature and Free Convection Levels
C +   ==================================================
C +
C +---Initialisation of search
C +   ------------------------
C +
      zETL=zLCL
      zLFC=zLCL
C +
      DO k=kLCL,1,-1
C +
C +
C +----Equilibrium Temperature level
C +    -----------------------------
C +
        IF (TvEnvr(k+1).le.AdiavT(k+1)                            .and.
     .      TvEnvr(k)  .ge.AdiavT(k)  )                           THEN
C +
                  aux=(TvEnvr(k+1)-AdiavT(k+1)+AdiavT(k)-TvEnvr(k))
C +
          IF (abs(aux).gt.1.e-3)                         THEN ! ETL detected
                 zETL=(H_Envr(k  )*(TvEnvr(k+1)-AdiavT(k+1))
     .                +H_Envr(k+1)*(AdiavT(k  )-TvEnvr(k  )) ) / aux
          ELSE
                 zETL=(H_Envr(k)+H_Envr(k+1))*0.5d+0
          ENDIF
C +
        ENDIF
C +
C +
C +----Level of free convection
C +    ------------------------
C +
        IF (TvEnvr(k+1).ge.AdiavT(k+1)                            .and.
     .      TvEnvr(k)  .le.AdiavT(k)  )                           THEN
C +
                  aux=(TvEnvr(k+1)-AdiavT(k+1)+AdiavT(k)-TvEnvr(k))
C +
          IF (abs(aux).gt.1.e-3)                         THEN ! LFC detected
                 zLFC=(H_Envr(k  )*(TvEnvr(k+1)-AdiavT(k+1))
     .                +H_Envr(k+1)*(AdiavT(k  )-TvEnvr(k  )) ) / aux
          ELSE
                 zLFC=(H_Envr(k)+H_Envr(k+1))*0.5d+0
          ENDIF
C +
        ENDIF
C +
C +
      ENDDO    !  { k=1,mz-1 }
C +
C +   ----------------------------------------------------------------------
C +
C +---Available / Potential Buoyant Energy
C +   ====================================
C +
            aBuoyE = 0.
            pBuoyE = 0.
C +
      DO k=kLCL+1,2,-1
C +
            aux    =min(zETL,H_Envr(k-1))-max(zLCL,H_Envr(k))
            deltaz1=max(zero,aux)
            deltaz2=0.
        IF (H_Envr(k-1).gt.zLFC)                                  THEN
            aux    =min(zETL,H_Envr(k-1))-max(zLFC,H_Envr(k))
            deltaz2=max(zero,aux)
        END IF
C +
C +
C +----Kinetic energy variation (k+1/2)
C +    --------------------------------
C +
            dEnCin=9.81*((AdiavT(k  )-TvEnvr(k  ))/TvEnvr(k  )
     .                  +(AdiavT(k-1)-TvEnvr(k-1))/TvEnvr(k-1) ) *0.5
        IF (H_Envr(k-1).gt.zLFC)
     .      dEnCin=max(zero,dEnCin)
C +
C +
C +----Available buoyant energy
C +    ------------------------
C +
       aBuoyE=aBuoyE+dEnCin*deltaz1
C +
C +
C +----Potential buoyant energy
C +    ------------------------
C +
       pBuoyE=pBuoyE+dEnCin*deltaz2
C +
      ENDDO
C +
      return
      end
      subroutine TQsCVA(TeDraf,ExnerP, sigma,p_star,p__top,
     .                  T0Draf,TnDraf,T_Draf,
     .                  Q1Draf,Q2Draf,QdDraf,QvDraf,QwDraf,QiDraf,
     .                                              EvDraf)
C +
C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         21-11-1999  MAR |
C |                                                                        |
C |   SubRoutine TQsCVA computes Temperature and Saturated Mixig Ratio     |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      real     sigma,p_star,p__top,T_Draf,TnDraf
C +
      real     TeDraf,ExnerP
      real     T0Draf,Q1Draf,Q2Draf,QdDraf,QvDraf,QcDraf
      real     QwDraf,QiDraf,EvDraf
      real     Qs_CVA,qsat0D
c #CG real     GlaCVA
C +
C +
C +--Local  Variables
C +  ================
C +
      real     H2oLCp,difftt,diffqv,GlacDg,Glac00,Qsat_i,Qsat_w
c #CG real     h2oMCp,argexp
      integer  int_0 ,int_1 ,NitTUp,NitMax
      logical  GlaCld
C +
C +
C +--DATA
C +  ====
C +
      data    Glac00 /    0.0     /
      data    h2oLCp / 2490.04e+0 /
C +         = Lv_H2O [Latent Heat of Vaporisation for Water (2.500d+6 J/kg)]
C +         / Cp     [Air Specific Heat                     (1.004d+3 J/kg/K)]
C +
      data  int_1  /    1       /
      data  int_0  /    0       /
C +
      data NitMax  /  100       /
C +...Maximum number of iterations to determine
C +        the Temperature from the Equivalent Potential Temperature
C +
c #CG data GlaCld  / .true.     /
C +
C +--Loop to determine the Temperature of the (Up/Down-)Draft(-Lateral Zone)
C +  =======================================================================
C +
C +
        TnDraf = T0Draf
        difftt = 1.
        NitTUp = 0
C +
      DO WHILE (difftt.gt.0.05.and.NitTUp.lt.NitMax)
C +
C +
C +--Cloud Glaciation
C +  ----------------
C +
c #CG   IF (GlaCld)                                               THEN
c #CG       GlacDg     = GlaCVA(TnDraf)
c #CG       QdDraf     = Qs_CVA(TnDraf,p_star,p__top,sigma,GlacDg)
C +...      ^^^^ Saturation Mixing Ratio
C +
c #CG       QvDraf     =  min(QdDraf,Q1Draf)
C +
c #CG       h2oMCp     =(Ls_H2O *GlacDg + Lv_H2O*(1.0-GlacDg))/Cp
c #CG       argexp     = 1.0273         * h2oMCp*(1.0+0.81*QdDraf)
C +
c #CG       T_Draf     =      TeDraf*ExnerP*exp(-argexp*QvDraf/TnDraf)
C +...      ^^^^ (Up/Down-)Draft(-Lateral Zone) Temperature
C +
c #CG    ELSE
c #FC       QdDraf     = Qs_CVA(TnDraf,p_star,p__top,sigma,Glac00)
            QvDraf     =    min(QdDraf,Q1Draf)
            T_Draf     =        TeDraf*ExnerP*exp(-H2oLCp*QvDraf/TnDraf)
c #CG    END IF
C +
C +
C +--Convergence
C +  -----------
C +
            difftt     = abs(    TnDraf -     T_Draf)
            TnDraf     =     0.8*TnDraf + 0.2*T_Draf
            NitTUp     =         NitTUp + 1
            IF (difftt.gt.25.)   NitTUp = NitMax
C +...          Patatra
C +
      ENDDO
C +
C +
C +--If the iterative method has not converged ...
C +  =============================================
C +
      IF (NitTUp.eq.NitMax.and.difftt.gt.0.5)                     THEN
        T_Draf     =        T0Draf
        QdDraf     = qsat0D(T_Draf,sigma,p_star,p__top,int_1)
        QvDraf     =    min(QdDraf,Q1Draf)
C +
      END IF
C +
C +
C +--Condensation
C +  ============
C +
        QcDraf      =     Q2Draf     -QdDraf
        QcDraf      = max(zero       ,QcDraf)
C +
        QwDraf      = (1.0d+0-GlacDg)*QcDraf
C +.... ^^^^ Condensate: Liquid water mixing ratio
C +
        QiDraf      =         GlacDg *QcDraf
C +.... ^^^^ Condensate: Solid  water mixing ratio
C +
C +
C +--Evaporation
C +  ===========
C +
        EvDraf      =     QvDraf     -Q2Draf
        EvDraf      = max(zero       ,EvDraf)
C +
      return
      end
      subroutine CVATrZ(FrEnvC,f_Entr,f_Detr)
C +
C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         14-11-1999  MAR |
C |                                                                        |
C |   SubRoutine CVATrZ computes the Entrained/Detrained Mass Fractions    |
C |                      in/from the Transition Region                     |
C |                     (Variables   f_Entr   ,f_Detr   )                  |
C |                                                                        |
C |   The Mass Fraction Distribution F is assumed as (X for FrEnvr)        |
C |       F(X) = 4    X  : 0   < X < 0.5                                   |
C |              4 (1-X) : 0.5 < X < 1                                     |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      real     FrEnvC,f_Entr,f_Detr
C +
C +
C +--Local  Variables
C +  ================
C +
      real     UnDiv3,UnDiv6,FrEnC2,FrEnC3,CFEnvC,CFEnC2,CFEnC3
C +
      DATA     UnDiv3/ 0.333333e+0 /
C +...         UnDiv3: 1/3
C +
      DATA     UnDiv6/ 0.166667e+0 /
C +...         UnDiv6: 1/6
C +
C +
C +--Analytical Integration
C +  ======================
C +
               FrEnC2 =  2.0d+0 * FrEnvC * FrEnvC
               FrEnC3 =  2.0d+0 * FrEnvC * FrEnC2 * UnDiv3
C +
               CFEnvC =  1.0d+0 - FrEnvC
               CFEnC2 =  2.0d+0 * CFEnvC * CFEnvC
               CFEnC3 =  2.0d+0 * CFEnvC * CFEnC2 * UnDiv3
C +
      IF      (FrEnvC.lt.0.5d+0)                                  THEN
               f_Entr =           FrEnC3
               f_Detr =  CFEnC2 - CFEnC3          - UnDiv6
      ELSE
               f_Entr =  FrEnC2 - FrEnC3          - UnDiv6
               f_Detr =           CFEnC3
      END IF
C +
      return
      end
      function Qs_CVA(T_Draf,p_star,p__top,sigma,GlacDg)
C +
C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         25-11-1999  MAR |
C |                                                                        |
C |   Function Qs_CVA computes the Saturation Specific Humidity            |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      real     Qs_CVA,GlacDg
      real     T_Draf,p_star,sigma ,p__top
C +
C +
C +--Local  Variables
C +  ================
C +
c #FC real     Qsat_i,Qsat_w
      real     qsat0D
      integer  int_0 ,int_1
      logical  GlaCld
C +
      data int_0   /   0   /
      data int_1   /   1   /
C +
c #CG data GlaCld / .true.     /
C +
C +
C +--Saturation Specific  Humidity
C +  =============================
C +
c #CG IF      (GlaCld)                                            THEN
c #CG          Qsat_i     = qsat0D(T_Draf,sigma,p_star,p__top,int_1)
C +...         ^^^^ Saturation Mixing Ratio over Ice
C +
c #CG          Qsat_w     = qsat0D(T_Draf,sigma,p_star,p__top,int_0)
C +...         ^^^^ Saturation Mixing Ratio over Liquid Water
C +
c #CG          Qs_CVA     = Qsat_i*GlacDg + Qsat_w*(1.0d+0-GlacDg)
C +...         ^^^^ Saturation Mixing Ratio
C +
c #CG ELSE
               Qs_CVA     = qsat0D(T_Draf,sigma,p_star,p__top,int_1)
c #CG END IF
C +
      return
      end
      function TeqCVA(T_Draf,ExDraf,QvDraf,GlacDg)
C +
C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         25-11-1999  MAR |
C |                                                                        |
C |   Function TeqCVA computes the Equivalent Potential Temperture         |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      real     TeqCVA,T_Draf,ExDraf,QvDraf,GlacDg
C +
C +
C +--Local  Variables
C +  ================
C +
      real     h2oLCp,h2oSCp,h2oMCp,argexp
      logical  GlaCld
C +
      data h2oLCp / 2490.04e+0 /
C +      = Lv_H2O [Latent Heat of Vaporisation for Water (2.500d+6 J/kg)]
C +      / Cp     [Air Specific Heat                     (1.004d+3 J/kg/K)]
C +
      data h2oSCp / 2822.31e+0 /
C +      = Ls_H2O [Latent Heat of Vaporisation for Water (2.8336+6 J/kg)]
C +      / Cp     [Air Specific Heat                     (1.004d+3 J/kg/K)]
C +
c #CG data GlaCld / .true.     /
C +
C +
C +--Equivalent Potential Temperature
C +  ================================
C +
c #CG IF      (GlaCld)                                            THEN
c #CG          h2oMCp=h2oSCp*GlacDg+h2oLCp*(1.0d+0 -GlacDg)
c #CG          argexp=1.0273*h2oMCp*(1.0+0.810*QvDraf)
c #CG ELSE
               argexp=       h2oLCp
c #CG END IF
C +
               TeqCVA=T_Draf/ExDraf
     .                        *exp(QvDraf*argexp/T_Draf)
C +
      return
      end
      function GlaCVA(T)
C +
C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         25-11-1999  MAR |
C |                                                                        |
C |   Function GlaCVA computes Glaciation Degree in the Convective Cloud   |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      real     GlaCVA
      real     T
C +
C +
C +--Glaciation Degree
C +  =================
C =
               GlaCVA = (268. -T)/ 20.
C +...         GlaCVA = (T2     -T)/(T2-T1)  
C +           (Kain and Fritsch 1990, JAS p.2788)
C +
               GlaCVA = max(GlaCVA,zero)
               GlaCVA = min(GlaCVA,unun)
C +
      return
      end


      subroutine CVAgen_MNH

C +------------------------------------------------------------------------+
C | MAR CONVECTION                                     Mon  7-06-2010  MAR |
C |   SubRoutine CVAgen links MAR to a CONVECTIVE ADJUSMENT procedure      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT (via common block)                                             |
C |   ^^^^^         itexpe           : Experiment Iteration Counter        |
C |                 itConv           : Adjustment Calls     Counter        |
C |                 dt_Loc           : Mass Flux  Scheme:   Time Step      |
C |                                                                        |
C |                     dx           : grid  spacing                   (m) |
C |                     dy           : grid  spacing                   (m) |
C |                 tairDY(mx,my,mz) : air   temperature               (K) |
C |                   qiHY(mx,my,mz) : air   cloud crystals conc.  (kg/kg) |
C |                   qsHY(mx,my,mz) : air   snow  flakes   conc.  (kg/kg) |
C |                   qwHY(mx,my,mz) : air   cloud droplets conc.  (kg/kg) |
C |                   qrHY(mx,my,mz) : air   rain  drops    conc.  (kg/kg) |
C |                                                                        |
C |   INPUT / OUTPUT:   dx           : grid  spacing                   (m) |
C |   ^^^^^^^^^^^^^^^   dy           : grid  spacing                   (m) |
C |                 pktaDY(mx,my,mz) : air   temperature               (K) |
C |                   qvDY(mx,my,mz) : air   specific humidity     (kg/kg) |
C |                 rainHY(mx,my)    : rain  Precipitation             (m) |
C |                 rainCA(mx,my)    : rain  Precipitation             (m) |
C |                                                                        |
C |   REFER. : 1) MesoNH CONVECTIVE ADJUSMENT Routine                      |
C |   ^^^^^^^^ 2) cfr.  head of SubRoutine CONVECTION                      |
C |                                                                        |
C | # OPTIONS: #pb  Limited Scalar Operations ==>   NO vectorization       |
C | # ^^^^^^^^ #EW  Energy and Water ?Conservation                         |
C | #          #AN  Anabatic Wind Parameterization                         |
C | #          #GU  Gust Front    Parameterization                         |
C | #          #gu  Gust Front    Parameterization (NO vectorization)      |
C | #          #GW  Gust Front    Parameterization (OUTPUT)                |
C |                                                                        |
C |   MODIF. HGall?e: 18-11-2004: Adaptation to CVAmnh.f90.laurent         |
C |   ^^^^^^                      (Argument kensbl of CONVECTION removed)  |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_TE.inc'

      include 'MAR_HY.inc'
      include 'MAR_CA.inc'
      include 'MAR_PB.inc'
c #EW include 'MAR_EW.inc'

      include 'MAR_SL.inc'

c #AN real                    rANA,hANA(mx,my)
c #AN common  /CVAgen_MNH_ANA/rANA,hANA

c #GW integer                    i_Gmax,k_Gmax,i_Gmin,k_Gmin
c #GW real                       waGmax       ,TaGmin
c #GU real                       waGust(mx,my,mzz)
c #GU real                       TaGust(mx,my,mz),    dtxLoc
c #GU common  /CVAgen_MNHgust/   TaGust          ,    dtxLoc

      logical                Odeep ,Oshal
      common  /CVAgen_MNH_lt/Odeep ,Oshal
      REAL                   pdtCVx,pdtCV ,PTdcv ,PTscv
      integer                nntCV0,jjtCV0,iitCV0
      common  /CVAgen_MNH_rt/pdtCVx,pdtCV ,PTdcv ,PTscv
      common  /CVAgen_MNH_nt/nntCV0,jjtCV0,iitCV0

      integer   KLON_0,KLEV_0
      parameter(KLON_0=KLON,KLEV_0=KLEV)


C +--Local  Variables
C +  ================

      character*3 vectcv
      integer     klcvOK
      integer     iklon ,klc

      logical  Odeep0,Oshal0,Orset0,Odown0,OsetA0,OCvTC0
      integer  kidia0,kfdia0,kbdia0,ktdia0,kIce_0,kensbl

      REAL     pdtCV0,PTdcv0,PTscv0
      REAL     Pdxdy0(KLON)
      REAL     P_pa_0(KLON,KLEV)
      REAL     P_za_0(KLON,KLEV)
      REAL     P_Ta_0(KLON,KLEV)
      REAL     P_Qa_0(KLON,KLEV)
      REAL     P_Qw_0(KLON,KLEV)
      REAL     P_Qi_0(KLON,KLEV)
      REAL     P_Ua_0(KLON,KLEV)
      REAL     P_Va_0(KLON,KLEV)
      REAL     P_Wa_0(KLON,KLEV)

      integer locCVA
      real    OK_CVA,MAX_TT(mx,my),min_TT_off

c #AN real    bANA,zANA,wANA(mx,my,mz),zlev
c #AN real    dANA,vANA,xANA


C +--Diagnostic Variables
C +  --------------------

c #EW integer irmx  ,jrmx  ,iter_0
c #EW real    rr_max,temp_r,energ0,water0,waterb


C +--Mass Flux convective Scheme: Set Up DATA
C +  ========================================

      data kidia0  /     1  /
C +...     kidia0  :  value of the first point in x

      data kbdia0  /     1  /
C +...     kbdia0  :  vertical computations: lowest                 level

      data ktdia0  /     1  /
C +...     ktdia0  :  vertical computations: over KLEV + 1 - ktdia0 levels

      data pdtCV0  /  1200. /
C +...     pdtCV0  :  time interval between 2 CALLs of deep convection

      data Odeep0  / .true. /
C +...     Odeep0  :  Deep    Convection Switch

      data Oshal0  / .true. /
C +...     Oshal0  :  Shallow Convection Switch

      data Orset0  / .true. /
C +...     Orset0  :  refresh or not all tendencies at every call

      data Odown0  / .true. /
C +...     Odown0  :  take or not convective downdrafts into account

      data kIce_0  /     1  /
C +...     kIce_0  :  flag for ice ( 1 = yes,
C +                                  0 = no ice )
      data OsetA0  / .false. /
C +...     OsetA0  :  logical to set convective adjustment time by user

      data PTdcv0  /  1800. /
C +...     PTdcv0  :  user defined deep    adjustment time

      data PTscv0  /  1800. /
C +...     PTscv0  :  user defined shallow adjustment time

      data kensbl  /     3  /
C +...     kensbl  :  value for a "climate" run

      data OCvTC0  / .false. /
C +...     OCvTC0  :  flag to compute convective transport
C +                                   for  chemical tracer

c XF
      data min_TT_off /267.15/
C +        min_TT_off : temperature min for switching on the convect. adjust.

C +--Anabatic Breeze Parameterization
C +  --------------------------------

c #AN data xANA    /   10.0e+3  /
C +...     xANA    : Characteristic Mountain Width       Scale

c #AN data vANA    /    4.0e+0  /
C +...     vANA    : Characteristic Mountain Breeze Wind Scale


C +--SET UP CONVECTION SWITCHES
C +  ==========================

      IF   (iterun.EQ.0)                                            THEN

        IF (MFLX_d)                                                 THEN
            Odeep  = MFLX_d
        ELSE
            Odeep  = Odeep0
            write(6,*) 'Deep    Convection Switch     set to ',Odeep
        END IF
        IF (MFLX_s)                                                 THEN
            Oshal  = MFLX_s
        ELSE
            Oshal  = Oshal0
            write(6,*) 'Shallow Convection Switch     set to ',Oshal
        END IF

        IF (tMFLXd.GT.0.)                                           THEN
            pdtCVx = tMFLXd
        ELSE
            pdtCVx = pdtCV0
            write(6,*) 'Interv. Convection CALL       set to ',pdtCVx
        END IF

        IF (aMFLXd.GT.0.)                                           THEN
            PTdcv  = aMFLXd
        ELSE
            PTdcv  = PTdcv0
            write(6,*) 'Deep    Convection Time Scale set to ',PTdcv
        END IF
        IF (aMFLXs.GT.0.)                                           THEN
            PTscv  = aMFLXs
        ELSE
            PTscv  = PTscv0
            write(6,*) 'Shallow Convection Time Scale set to ',PTscv
        END IF

      END IF


C +--Set UP Anabatic Breeze Parameterization
C +  =======================================

      IF (itexpe.EQ.0)                                              THEN

c #GU   open(unit=70,status='new',file='W_GUST.out')
c #GU   rewind    70

c #GU     dtxLoc    = dt_Loc / dx

c #AN     rANA      = 2.0d+0 * vANA / xANA
C +...    rANA      : Subgrid Mountain Breeze: Horizontal Divergence
C +                  (Factor 2 included  for 2 horizontal Directions)
c #AN   DO j=1,my
c #AN   DO i=1,mx
c #AN     dANA      = sh(i,j)
c #AN.         -0.25*(sh(im1(i),j)+sh(ip1(i),j)
c #AN.               +sh(i,jm1(j))+sh(i,jp1(j)))
c #AN     hANA(i,j) = abs(dANA)*max(zero,dx/xANA-unun)
C +...    hANA: D("Subgrid Mountain" Height - "Resolved Mountain" Height)

c #AN     hANA(i,j) = sh(i,j) * 2.0d+0
c #AN   END DO
c #AN   END DO

c #GU   DO k=1,mz
c #GU   DO j=1,my
c #GU   DO i=1,mx
c #GU     TaGust(i,j,k) = 0.
c #GU   END DO
c #GU   END DO
c #GU   END DO


C +--Set UP Verification
C +  ===================

                  klcvOK = mx2*my2
c #pb             klcvOK =       1
            IF   (klon.ne. klcvOK)                                THEN
              IF (klon.gt.1)                                      THEN
                  vectcv = 'NON'
              ELSE
                  vectcv = '   '
              END IF
                write(6,6000) klon,klcvOK,vectcv
 6000           format(/,'++++++++ klon (MARdim.inc) =',i6,' .NE.',i6,
     .                       ' ++++++++++++++',
     .                 /,'++++++++ NOT adapted to a ',a3,' vectorized ',
     .                   'code ++++++++++++++',
     .                 /,'++++++++ BAD SET UP of #pb or klon parameter',
     .                      '  ++++++++++++++',
     .                 /,'     ==> !?%@&* Emergency EXIT in CVAgen_MNH')
                STOP
            END IF


C +--Mass Flux convective Scheme: Set Up Energy/Water Verification
C +  =============================================================

c #EW     energ0      = 0.0
c #EW     water0      = 0.0
c #EW     iter_0      = 0
c #EW     write(6,600)
 600      format(/,' CVAgen_MNH: Energy/Water Verification Set UP')
      END IF


C +--Mass Flux Scheme: Set Up Time Stepping
C +  ======================================

      IF (iterun.EQ.0)                                            THEN
            pdtCV=           pdtCVx
c #xx       pdtCV=min(dt_Loc,pdtCVx)
        if (pdtCV .lt.dt_Loc)                                     then
            pdtCV  =  dt_Loc
            jjtCV0 =   1
        else
            jjtCV0 =  pdtCV  / dt_Loc
C +...      jjtCV0 :  Number of  Diffusion Steps for 1 Convective Step

            pdtCV  =  dt_Loc * jjtCV0
C +...      pdtCV  :  Calibrated Convection                  Time Step

        end if
            iitCV0 =  0
      END IF


C +--Update Convective Mass Flux
C +  ===========================

      IF (mod(iitCV0,jjtCV0).EQ.0)                                THEN


C +--Contribution from Subgrid Mountain Breeze
C +  -----------------------------------------

c #AN   DO k=1,mz
c #AN   DO j=1,my
c #AN   DO i=1,mx
c #AN             zlev=      gplvDY(i,j,k)     *grvinv
c #AN             bANA=    min(zlev,            zi__TE(i,j))
c #AN             zANA=        hANA(i,j) + 2.0 *bANA
c #AN         IF (zlev   .LE.  zANA   .AND.
c #AN.            TairSL(i,j)         .GT.      tairDY(i,j,mz))   THEN
c #AN             wANA(i,j,k)= rANA      * 0.5 *bANA
C +...                         Half Integrated Horizontal Divergence

c #AN         ELSE
c #AN             wANA(i,j,k)= 0.0
c #AN         END IF
c #AN   END DO
c #AN   END DO
c #AN   END DO


C +--Contribution from the Cold Air Pool
C +  -----------------------------------

c #GW     waGmax        =    0.
c #GW     TaGmin        =    0.

c #GU   DO k=     mz,2,-1
c #GU   DO j=jp11,my1
c #GU   DO i=ip11,mx1
c #GU     waGust(i,j,k) =(  (4.0                 *TaGust(i,j     ,k)
c #GU.                      -TaGust(ip1(i),j,k)  -TaGust(i,jp1(j),k)
c #GU.                      -TaGust(im1(i),j,k)  -TaGust(i,jm1(j),k))
c #GU.                    * (0.50e6              /dx                )
c #GU.                    * (gpmiDY(i     ,j,k)  -gpmiDY(i,j     ,k+1))
c #GU.                   +   waGust(i     ,j,k+1)*gplvDY(i,j     ,k+1))
c #GU.                  /    gplvDY(i     ,j,k)
c #GU.                  *max(zero,    sign(unun,zi__TE(i,j)
c #GU.                                         -gplvDY(i,j,k)*grvinv))
c #GU     waGust(i,j,k) =max(zero,              waGust(i,j,k))

c #GW     IF (TaGmin.lt.TaGust(i,j,k))                            THEN
c #GW         TaGmin  = TaGust(i,j,k)
c #GW         i_Gmin  = i
c #GW         k_Gmin  = k
c #GW     END IF
c #GW     IF (waGmax.lt.waGust(i,j,k))                            THEN
c #GW         waGmax  = waGust(i,j,k)
c #GW         i_Gmax  = i
c #GW         k_Gmax  = k
c #GW     END IF

c #GU   END DO
c #GU   END DO
c #GU   END DO

c #GW   i_Gmax=max(  2,i_Gmax)
c #GW   i_Gmax=min(mx1,i_Gmax)
c #GW   k_Gmax=max(  1,k_Gmax)
c #GW   k_Gmax=min(mz ,k_Gmax)
c #GW   write(70,700) itexpe,
c #GW.         i_Gmax,k_Gmax,(waGust(i,1,k_Gmax), i=i_Gmax-1,i_Gmax+1),
c #GW.         i_Gmin,k_Gmin,(TaGust(i,1,k_Gmax), i=i_Gmax-1,i_Gmax+1),
c #GW.                grvinv* gplvDY(i_Gmax,1,k_Gmax),zi__TE(i_Gmax,1)
 700    format(2i6,i4,3f9.3,i6,i4,3f9.3,2f12.0)


C +--Mass Flux convective Scheme: Set Up Vertical Profiles
C +  -----------------------------------------------------

            kfdia0  =    klon
C +...      kfdia0  :   value of the last  point in x

            iklon = 0

cXF
            max_TT=-273.15

!$OMP PARALLEL DO
!$OMP.firstprivate(i,k,klc,iklon,OK_CVA,
!$OMP.             kidia0, kfdia0, kbdia0, ktdia0,
!$OMP.             pdtCV , Odeep , Oshal , Orset0, Odown0, kIce_0,
!$OMP.             OsetA0, PTdcv , PTscv ,
!$OMP.             kensbl,
!$OMP.     P_pa_0, P_za_0, Pdxdy0,
!$OMP.     P_Ta_0, P_Qa_0, P_Qw_0, P_Qi_0, P_Ua_0, P_Va_0, P_Wa_0,
!$OMP.     Kstep1, PdTa_1, PdQa_1, PdQw_1, PdQi_1,
!$OMP.                     Pdrr_1, Pdss_1,
!$OMP.     PuMF_1, PdMF_1, Pfrr_1, Pfss_1, Pcape1, K_CbT1, K_CbB1,
!$OMP.     OCvTC0, P_CH_0, PdCH_1)
        DO j = jp11,my1
        DO i = ip11,mx1
            iklon = 1 + iklon
c #pb       iklon = 1

             Pdxdy0(iklon)    = dx * dy
C +...       Pdxdy0           : grid area                            [m2]

          DO klc= 1,klev
             k = mzz-klc
             P_pa_0(iklon,klc) = (pstDY(i,j)*sigma( k)   + ptopDY) *1.e3
C +...       P_pa_0            : pressure     in layer               [Pa]

             P_za_0(iklon,klc) = gplvDY(i,j,k) * grvinv
C +...       P_za_0            : height of model layer                [m]

             P_Ta_0(iklon,klc) = tairDY(i,j,k)
C +...       P_Ta_0            : grid scale T           at time t     [K]

cXF
             max_TT(i,j)       = max(max_TT(i,j),tairDY(i,j,k))
cXF
             P_Qa_0(iklon,klc) =   qvDY(i,j,k)
C +...       P_Qa_0            : grid scale water vapor at time t [kg/kg]

             P_Qw_0(iklon,klc) =   qwHY(i,j,k) / (1.0-qwHY(i,j,k))
C +...       P_Qw_0            : grid scale Cloud drops at time t [kg/kg]

             P_Qi_0(iklon,klc) =   qiHY(i,j,k) / (1.0-qiHY(i,j,k))
C +...       P_Qi_0            : grid scale Cloud ice   at time t [kg/kg]

             P_Ua_0(iklon,klc) = uairDY(i,j,k)
C +...       P_Ua_0            : grid scale hor. wind u at time t   [m/s]

             P_Va_0(iklon,klc) = vairDY(i,j,k)
C +...       P_Va_0            : grid scale hor. wind v at time t   [m/s]

             P_Wa_0(iklon,klc) = wairDY(i,j,k) *0.01
c #TW.                  +sqrt(2.*ect_TE(i,j,k) /3.)
c #AN.                         +   wANA(i,j,k)
c #GU.                         + waGust(i,j,k)
C +...       P_Wa_0            : grid scale vertic.wind at time t   [m/s]

          END DO


C +--Mass Flux convective Scheme: iteration, in case of no vectorization
C +  -------------------------------------------------------------------

c #pb     if(MAX_TT(i,j)>=min_tt_off) then 
C +       ***************
c #pb     call CONVECTION( 
c #pb.             KLON_0, KLEV_0, kidia0, kfdia0, kbdia0, ktdia0,
c #pb.             pdtCV , Odeep , Oshal , Orset0, Odown0, kIce_0,
c #pb.             OsetA0, PTdcv , PTscv ,
c #pb.             kensbl,
c #pb.     P_pa_0, P_za_0, Pdxdy0,
c #pb.     P_Ta_0, P_Qa_0, P_Qw_0, P_Qi_0, P_Ua_0, P_Va_0, P_Wa_0,
c #pb.     Kstep1, PdTa_1, PdQa_1, PdQw_1, PdQi_1,
c #pb.                     Pdrr_1, Pdss_1,
c #pb.     PuMF_1, PdMF_1, Pfrr_1, Pfss_1, Pcape1, K_CbT1, K_CbB1,
c #pb.     OCvTC0, KTCCH0, P_CH_0, PdCH_1)
C +       ***************
c #pb     endif

C +--Mass Flux convective Scheme: products,  in case of no vectorization
C +  -------------------------------------------------------------------

c #pb        capeCA(i,j)   = Pcape1(iklon)
c #pb        adj_CA(i,j)   = Kstep1(iklon)
c #pb        drr_CA(i,j)   = Pdrr_1(iklon)    * dt_Loc
c #pb        dss_CA(i,j)   = Pdss_1(iklon)    * dt_Loc

c #pb                               OK_CVA=1
c #pb        if(isnan(capeCA(i,j))) OK_CVA=0
c #pb        if(isnan(drr_CA(i,j))) OK_CVA=0
c #pb        if(isnan(dss_CA(i,j))) OK_CVA=0
c #pb        if(drr_CA(i,j)>0.1)    OK_CVA=0
c #pb        if(dss_CA(i,j)>0.1)    OK_CVA=0

c #pb     DO klc= 1,klev
c #pb        k = mzz-klc

c #pb        dpktCA(i,j,k) = PdTa_1(iklon,klc) * dt_Loc /pkDY(i,j,k)
c #pb        dqv_CA(i,j,k) = PdQa_1(iklon,klc) * dt_Loc
c #pb        dqw_CA(i,j,k) = PdQw_1(iklon,klc) * dt_Loc
c #pb        dqi_CA(i,j,k) = PdQi_1(iklon,klc) * dt_Loc

c #gu        TaGust(i,j,k) = TaGust(i,j,k)*exp(-dtxLoc*ssvSL(i,j,k))
c #gu.                     + PdTa_1(iklon,klc) * dt_Loc
c #gu        TaGust(i,j,k) = min(TaGust(i,j,k),zero)

c #pb        if(isnan(dpktCA(i,j,k))) OK_CVA=0
c #pb        if(isnan(dqv_CA(i,j,k))) OK_CVA=0
c #pb        if(isnan(dqw_CA(i,j,k))) OK_CVA=0
c #pb        if(isnan(dqi_CA(i,j,k))) OK_CVA=0
c #pb     END DO

c #pb     if(OK_CVA==0.or.MAX_TT(i,j)<min_tt_off) then
c #pb        drr_CA(i,j)=0.
c #pb        adj_CA(i,j)=0.
c #pb        dss_CA(i,j)=0.
c #pb        DO klc= 1,klev
c #pb         k = mzz-klc
c #pb         dpktCA(i,j,k)=0.
c #pb         dqv_CA(i,j,k)=0.
c #pb         dqw_CA(i,j,k)=0.
c #pb         dqi_CA(i,j,k)=0.
c #pb        ENDDO
c #pb     endif

        END DO
        END DO
!$OMP END PARALLEL DO

C +--Mass Flux convective Scheme: iteration, in case of    vectorization
C +  -------------------------------------------------------------------

c #pb   IF (klon.gt.1)                                            THEN

C +       ***************
          call CONVECTION( 
     .             KLON_0, KLEV_0, kidia0, kfdia0, kbdia0, ktdia0,
     .             pdtCV , Odeep , Oshal , Orset0, Odown0, kIce_0,
     .             OsetA0, PTdcv , PTscv ,
     .             kensbl,
     .     P_pa_0, P_za_0, Pdxdy0,
     .     P_Ta_0, P_Qa_0, P_Qw_0, P_Qi_0, P_Ua_0, P_Va_0, P_Wa_0,
     .     Kstep1, PdTa_1, PdQa_1, PdQw_1, PdQi_1,
     .                     Pdrr_1, Pdss_1,
     .     PuMF_1, PdMF_1, Pfrr_1, Pfss_1, Pcape1, K_CbT1, K_CbB1,
     .     OCvTC0, KTCCH0, P_CH_0, PdCH_1)
C +       ***************


C +--Mass Flux convective Scheme: products,  in case of    vectorization
C +  -------------------------------------------------------------------

             iklon = 0
          DO j = jp11,my1
          DO i = ip11,mx1
             iklon = 1 + iklon

              capeCA(i,j)   = Pcape1(iklon)
              adj_CA(i,j)   = Kstep1(iklon)
              drr_CA(i,j)   = Pdrr_1(iklon)    * dt_Loc
              dss_CA(i,j)   = Pdss_1(iklon)    * dt_Loc

            DO klc= 1,klev
               k = mzz-klc

              dpktCA(i,j,k) = PdTa_1(iklon,klc) * dt_Loc /pkDY(i,j,k)
              dqv_CA(i,j,k) = PdQa_1(iklon,klc) * dt_Loc
              dqw_CA(i,j,k) = PdQw_1(iklon,klc) * dt_Loc
              dqi_CA(i,j,k) = PdQi_1(iklon,klc) * dt_Loc

c #GU         TaGust(i,j,k) = TaGust(i,j,k)*exp(-dtxLoc*ssvSL(i,j,k))
c #GU.                      + PdTa_1(iklon,klc) * dt_Loc
c #GU         TaGust(i,j,k) = min(TaGust(i,j,k),zero)
            END DO
          END DO
          END DO

c #pb   END IF
      END IF

C +--Vertical Integrated Energy and Water Content
C +  ============================================

c #EW DO   j=jp11,my1
c #EW DO   i=ip11,mx1
c #EW     enr0EW(i,j) = 0.0
c #EW     wat0EW(i,j) = 0.0

c #EW   DO k=1,mz
c #EW     temp_r      = pktaDY(i,j,k)*pkDY(i,j,k)
c #EW     enr0EW(i,j) = enr0EW(i,j)
c #EW.                +(temp_r
c #EW.                  -(qwHY(i,j,k)+qrHY(i,j,k)) *r_LvCp
c #EW.                  -(qiHY(i,j,k)+qsHY(i,j,k)) *r_LsCp   )*dsigm1(k)
c #EW     wat0EW(i,j) = wat0EW(i,j)
c #EW.                +  (qvDY(i,j,k)
c #EW.                +   qwHY(i,j,k)+qrHY(i,j,k)
c #EW.                +   qiHY(i,j,k)+qsHY(i,j,k)            )*dsigm1(k)
c #EW   END DO

c #EW     enr0EW(i,j) = enr0EW(i,j) * pstDYn(i,j) * grvinv
c #EW     wat0EW(i,j) = wat0EW(i,j) * pstDYn(i,j) * grvinv
C +...    wat0EW [m]    contains implicit factor 1.d3 [kPa-->Pa] /ro_Wat

c #EW     energ0      = energ0 - enr0EW(i,j)
c #EW     water0      = water0 - wat0EW(i,j)
c #EW END DO
c #EW END DO


C +--Mass Flux convective Scheme
C +  ===========================

      DO j = jp11,my1
      DO i = ip11,mx1

C +     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

            locCVA        = min(adj_CA(i,j),1)
            OK_CVA        = max(locCVA     ,0)
c #pb   IF (adj_CA(i,j).gt.0)                                     THEN
c #pb       OK_CVA        =     1.0
            adj_CA(i,j)   =     adj_CA(i,j)-1
C +...      ^^^^ Number of remaining time step before the end of convection

            adj_CA(i,j)   = max(adj_CA(i,j),0)

C +----Temporal tendencies on pktaDY, qvDY and rainHY
C +    ----------------------------------------------

          DO k=1,mz
            pktaDY(i,j,k) =      pktaDY(i,j,k) + dpktCA(i,j,k) * OK_CVA
              qvDY(i,j,k) = max(   qvDY(i,j,k) + dqv_CA(i,j,k) * OK_CVA
     .                         ,   epsq                                )
          ENDDO

            rainHY(i,j)   =      rainHY(i,j)   + drr_CA(i,j)   * OK_CVA
            rainCA(i,j)   =      rainCA(i,j)   + drr_CA(i,j)   * OK_CVA

            snowHY(i,j)   =      snowHY(i,j)   + dss_CA(i,j)   * OK_CVA
            snowCA(i,j)   =      snowCA(i,j)   + dss_CA(i,j)   * OK_CVA
            snohSL(i,j)   =      snohSL(i,j)   + dss_CA(i,j)   * OK_CVA

c #pb   ENDIF          !  { adj_CA(i,j).gt. 0 }

C +     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      END DO
      END DO


C +--Vertical Integrated Energy and Water Content
C +  ============================================

c #EW DO   j=jp11,my1
c #EW DO   i=ip11,mx1
c #EW     enr1EW(i,j) = 0.0
c #EW     wat1EW(i,j) = 0.0
c #EW     watfEW(i,j) =-drr_CA(i,j)

c #EW   DO k=1,mz
c #EW     temp_r      = pktaDY(i,j,k)*pkDY(i,j,k)
c #EW     enr1EW(i,j) = enr1EW(i,j)
c #EW.                +(temp_r
c #EW.                  -(qwHY(i,j,k)+qrHY(i,j,k)) *r_LvCp
c #EW.                  -(qiHY(i,j,k)+qsHY(i,j,k)) *r_LsCp   )*dsigm1(k)
c #EW     wat1EW(i,j) = wat1EW(i,j)
c #EW.                +  (qvDY(i,j,k)
c #EW.                +   qwHY(i,j,k)+qrHY(i,j,k)
c #EW.                +   qiHY(i,j,k)+qsHY(i,j,k)            )*dsigm1(k)
c #EW   END DO

c #EW     enr1EW(i,j) = enr1EW(i,j) * pstDYn(i,j)  *grvinv
c #EW.                - drr_CA(i,j)                *r_LvCp
c #EW     wat1EW(i,j) = wat1EW(i,j) * pstDYn(i,j)  *grvinv
C +...    wat1EW [m]    contains implicit factor 1.d3 [kPa-->Pa] /ro_Wat

c #EW     energ0      = energ0 + enr1EW(i,j)
c #EW     water0      = water0 + wat1EW(i,j)
c #EW     iter_0      = iter_0 + 1
c #EW END DO
c #EW END DO


C +--Vertical Integrated Energy and Water Content: OUTPUT
C +  ====================================================

c #EW       irmx   =       imez
c #EW       jrmx   =       jmez
c #EW       rr_max =       0.0
c #EW DO  j=jp11,my1
c #EW DO  i=ip11,mx1
c #EW   IF (drr_CA(i,j).gt.rr_max)                                THEN
c #EW       rr_max =       drr_CA(i,j)
c #EW       irmx   =              i
c #EW       jrmx   =                j
c #EW   END IF
c #EW END DO
c #EW END DO
c #EW   waterb = wat1EW(irmx,jrmx)-wat0EW(irmx,jrmx)-watfEW(irmx,jrmx)
c #EW   write(6,606) itexpe,enr0EW(irmx,jrmx),1.d3*wat0EW(irmx,jrmx),
c #EW.            irmx,jrmx,enr1EW(irmx,jrmx),1.d3*wat1EW(irmx,jrmx),
c #EW.                                        1.d3*watfEW(irmx,jrmx),
c #EW.                                        1.d3*waterb           ,
c #EW.                     energ0/iter_0    ,     water0/iter_0
 606    format(i9,'  Before CVAj:  E0 =',f12.6,'  W0 = ',f9.6,
     .    /,i5,i4,'  After  CVAj:  E1 =',f12.6,'  W1 = ',f9.6,
     .                                         '  W Flux =',f9.6,
     .                                         '  Div(W) =',e9.3,
     .       /,9x,'         Mean   dE =',f12.9,'  dW = ',e9.3)

      iitCV0 = iitCV0 + 1

      return
      end


      subroutine CVAgen_GCM

C +------------------------------------------------------------------------+
C | MAR CONVECTION                                         19-09-2001  MAR |
C |                                                                        |
C |   SubRoutine CVAgen_GCM contains .main. of the CONVECTIVE ADJUSTMENT   |
C |                     SCHEME of   Kerry Emanuel                (1991)    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C | REFER. :  Kerry Emanuel,              1991, JAS 48 (21), 2313--2335.   |
C | ^^^^^^^^  Emanuel & Zivkovic-Rothman, 1999, JAS 56       1766--1782.   |
C |                                                                        |
C | INPUT / OUTPUT: The Vertical Profiles of :                             |
C | ^^^^^^^^^^^^^^                                                         |
C |   a) Potential Temperature   pktaDY(mx,my,mz)                      (K) |
C |   b) Specific Humidity         qvDY(mx,my,mz)                  (kg/kg) |
C |                                                                        |
C | OUTPUT :  rainHY(mx,my) : rain                                     (m) |
C | ^^^^^^^^  adj_CA(mx,my) : number of time steps before the end of the   |
C |                           adjustment                                   |
C |           dpktCA(mx,my,mz) : Adjustment  of Potential Temperature      |
C |           dqv_CA(mx,my,mz) : Adjustment  of Specific  Humidity         |
C |           dqw_CA(mx,my,mz) : Detrainment of Cloud     Droplets         |
C |           dqi_CA(mx,my,mz) : Detrainment of Cloud     Ice Crystals     |
C |           drr_CA(mx,my,mz) : Convective               Precipitation    |
C |           dsn_CA(mx,my,mz) : Latent Heat absorbed in  Snow Melting     |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
      include 'MAR_HY.inc'
C +
      include 'MAR_TE.inc'
      include 'MAR_TU.inc'
      include 'MAR_SL.inc'
      include 'MAR_CA.inc'
C +
      include 'MAR_IO.inc'
      include 'MAR_GE.inc'
C +
      integer il,kl
C +
C +
C +--Local Variables
C +  ===============
C +
      integer   ND    ,NL            ,klonc  ,NTRA  ,nt
      parameter(ND=mz ,NL=mz-mzabso+1,klonc=1,NTRA=1)
C +
      REAL T(  klonc,ND)
      REAL Q(  klonc,ND)     ,QS(klonc,ND)
      REAL U(  klonc,ND)     ,V( klonc,ND)
      REAL TRA(klonc,ND,NTRA)
      REAL P(  klonc,ND)     ,PH(klonc,ND+1)
C +
      REAL DELT
C +
      REAL                  CBMFIJ(mx,my)   ,CBMF(klonc)
      common/CVAgen_GCM_Loc/CBMFIJ
C +
      integer  IFLAG(klonc)
      integer IFLAIJ(mx,my)
C +
      REAL FT(    klonc,ND)
      REAL FQ(    klonc,ND)
      REAL FU(    klonc,ND)     ,FV( klonc,ND)
      REAL FTRA(  klonc,ND,NTRA)
C +
      REAL PRECIP(klonc)
      REAL     WD(klonc),TPRIME(klonc),QPRIME(klonc)
      REAL CVA_WD(mx,my)
C +
C +
C +--DATA
C +  ====
C +
      DATA DELT /300.0/
C +
C +
C +--Initialisation
C +  ==============
C +
      IF (int_CA.eq.0)                                            THEN
C +
        int_CA=NINT(DELT  /dt_Loc)
        int_CA= max(int_CA,   iun)
C +...  ^^^ Number of iterations between two checks of unstability
C +
        write(21,211)    DELT  ,dt_Loc,int_CA
 211    format(/,'   --- Convective adjustment of Kerry Emanuel',
     .         /,'       DELT   =',f8.1,
     .         /,'       dt_Loc =',f8.1,
     .         /,'       int_CA =',i8)
C +
        DO j=jp11,my1
        DO i=ip11,mx1
           CBMFIJ(i,j) = 0.0
        END DO
        END DO
C +
        open(unit=90,status='unknown',file='CVA_KE.out')
        rewind    90
      END IF
C +
C +
C +--From 3D to 2D arrays
C +  ====================
C +
      IF (mod(itConv,int_CA).eq.0)                                THEN
C +
        DO j=jp11,my1
        DO i=ip11,mx1
                     adj_CA(i,j) = 0
        END DO
        END DO
C +
c _ke        il =      0
        DO j=jp11,my1
        DO i=ip11,mx1
c _ke        il = il + 1
             il =      1
C +
             CBMF(il)  = CBMFIJ(i,j)
             WD(  il)  = CVA_WD(i,j)
          DO k  =  1, mz
             kl = mzz-k
             T( il,kl) = tairDY(i,j,k)
             Q( il,kl) =   qvDY(i,j,k)
             QS(il,kl) = qvswDY(i,j,k)
             U( il,kl) = uairDY(i,j,k)
             V( il,kl) = vairDY(i,j,k)
             P( il,kl) =(pstDYn(i,j)*sigma( k)+ptopDY) *10.0
          END DO
          DO k  =  1, mzz
             kl = mzz-k+1
             PH(il,kl) =(pstDYn(i,j)*sigmid(k)+ptopDY) *10.0
          END DO
C +
          DO nt =  1,ntra
          DO kl =  1, mz
             TRA(il,kl,nt) = 0.0
          END DO
          END DO
C +
C +
C +--Emanuel convective adjustment scheme (without vectorization)
C +  ============================================================
C +
c #KE     CALL CONVECT
c #KE*      (T,   Q,    QS,     U,    V,      TRA,    P,    PH,
c #KE*       ND,  NL,   NTRA,   DELT, IFLAG,  FT,     FQ,   FU,
c #KE*       FV,  FTRA, PRECIP, WD,   TPRIME, QPRIME, CBMF    )
C +
c #WR     IF  (IFLAG(il).eq.1)  write(6,6001)           i,j,itexpe
c #WR.       ,(FT(il,kl),kl=1,mz)
 6001     format(/,' Kerry Emanuel  Mass Flux convective Scheme:',
     .             ' ACTIVED:        ',4x,' (pt.',2i4,' / it.',i6,')',
     .           /,' FT: ',11e10.2, /,(5x,11e10.2))
c #WR     IF  (IFLAG(il).gt.1)  write(6,6002) IFLAG(il),i,j,itexpe
 6002     format(/,' Kerry Emanuel  Mass Flux convective Scheme:',
     .             ' CAUTION: IFLAG =',i4,' (pt.',2i4,' / it.',i6,')')
c #WR     IF  (IFLAG(il).eq.4)  write(6,6004)
 6004     format(  ' Chooses a higher Lowest Convectively ',
     .             ' active Level MINORIG')
C +
C +
C +--From 2D to 3D arrays, in case of NO Vectorization
C +  =================================================
C +
              CBMFIJ(i,j)   =   CBMF(il)
              IFLAIJ(i,j)   =  IFLAG(il)
              CVA_WD(i,j)   =     WD(il)
              drr_CA(i,j)   = PRECIP(il)   *dt_Loc/86400.e3
            DO k  =  1, mz
               kl = mzz-k
              dpktCA(i,j,k) =     FT(il,kl)*dt_Loc/pkDY(i,j,k)
              dqv_CA(i,j,k) =     FQ(il,kl)*dt_Loc
              adj_CA(i,j)   =               int_CA
            END DO
C +
        END DO
        END DO
c #KE   IF (my.eq.1) write(90,6000)itexpe,(IFLAIJ(i,1),i=1,mx)
 6000                format(i5,1x,120i1,/,6x,120i1)
C +
C +
C +--Emanuel convective adjustment scheme (with    vectorization)
C +  ============================================================
C +
c _ke   IF (klonc.gt.1)                                           THEN
C +
c _ke     CALL CONVECT
c _ke*      (T,   Q,    QS,     U,    V,      TRA,    P,    PH,
c _ke*       ND,  NL,   NTRA,   DELT, IFLAG,  FT,     FQ,   FU,
c _ke*       FV,  FTRA, PRECIP, WD,   TPRIME, QPRIME, CBMF    )
C +
C +
C +--From 2D to 3D arrays, in case of    Vectorization
C +  =================================================
C +
c _ke          il =      0
c _ke     DO   j=jp11,my1
c _ke     DO   i=ip11,mx1
c _ke          il = il + 1
c _ke         CBMFIJ(i,j)   =   CBMF(il)
c _ke         CVA_WD(i,j)   =     WD(il)
c _ke         drr_CA(i,j)   = PRECIP(il)   *dt_Loc/86400.e3
c _ke       DO k  =  1, mz
c _ke          kl = mzz-k
c _ke         dpktCA(i,j,k) =     FT(il,kl)*dt_Loc/pkDY(i,j,k)
c _ke         dqv_CA(i,j,k) =     FQ(il,kl)*dt_Loc
c _ke         adj_CA(i,j)   =               int_CA
c _ke       END DO
c _ke     END DO
c _ke     END DO
C +
c _ke   END IF
C +
      END IF
C +
C +
C +--Emanuel convective adjustment scheme: contribution to resolved scale
C +  ====================================================================
C +
        DO   j=jp11,my1
        DO   i=ip11,mx1
          DO k  =  2, mz
            pktaDY(i,j,k) = pktaDY(i,j,k) + dpktCA(i,j,k)
              qvDY(i,j,k) =   qvDY(i,j,k) + dqv_CA(i,j,k)
          END DO
            rainHY(i,j)   = rainHY(i,j)   + drr_CA(i,j)
            rainCA(i,j)   = rainCA(i,j)   + drr_CA(i,j)
        END DO
        END DO
C +
      return
      end
***************************************************************************
*****                       SUBROUTINE CONVECT                        *****
*****                          VERSION 4.3b                           *****
*****                         20 August, 2000                         *****
*****                          Kerry Emanuel                          *****
***************************************************************************
C
        SUBROUTINE CONVECT
     *    (T,   Q,    QS,     U,    V,      TRA,    P,    PH,
     *     ND,  NL,   NTRA,   DELT, IFLAG,  FT,     FQ,   FU,
     *     FV,  FTRA, PRECIP, WD,   TPRIME, QPRIME, CBMF    )
C
C-----------------------------------------------------------------------------
C    *** On input:      ***
C
C     T:   Array of absolute temperature (K) of dimension ND, with first
C           index corresponding to lowest model level. Note that this array
C           will be altered by the SubRoutine if dry convective adjustment
C           occurs and if IPBL is not equal to 0.
C
C     Q:   Array of specific humidity (gm/gm) of dimension ND, with first
C            index corresponding to lowest model level. Must be defined
C            at same grid levels as T. Note that this array will be altered
C            if dry convective adjustment occurs and if IPBL is not equal to 0.
C
C     QS:  Array of saturation specific humidity of dimension ND, with first
C            index corresponding to lowest model level. Must be defined
C            at same grid levels as T. Note that this array will be altered
C            if dry convective adjustment occurs and if IPBL is not equal to 0.
C
C     U:   Array of zonal wind velocity (m/s) of dimension ND, witth first
C            index corresponding with the lowest model level. Defined at
C            same levels as T. Note that this array will be altered if
C            dry convective adjustment occurs and if IPBL is not equal to 0.
C
C     V:   Same as U but for meridional velocity.
C
C     TRA: Array of passive tracer mixing ratio, of dimensions (ND,NTRA),
C            where NTRA is the number of different tracers. If no
C            convective tracer transport is needed, define a dummy
C            input array of dimension (ND,1). Tracers are defined at
C            same vertical levels as T. Note that this array will be altered
C            if dry convective adjustment occurs and if IPBL is not equal to 0.
C
C     P:   Array of pressure (mb) of dimension ND, with first
C            index corresponding to lowest model level. Must be defined
C            at same grid levels as T.
C
C     PH:  Array of pressure (mb) of dimension ND+1, with first index
C            corresponding to lowest level. These pressures are defined at
C            levels intermediate between those of P, T, Q and QS. The first
C            value of PH should be greater than (i.e. at a lower level than)
C            the first value of the array P.
C
C     ND:  The dimension of the arrays T,Q,QS,P,PH,FT and FQ
C
C     NL:  The maximum number of levels to which convection can
C            penetrate, plus 1.
C            NL MUST be less than or equal to ND-1.
C
C     NTRA:The number of different tracers. If no tracer transport
C            is needed, set this equal to 1. (On most compilers, setting
C            NTRA to 0 will bypass tracer calculation, saving some CPU.)  
C
C     DELT: The model time step (sec) between CALLs to CONVECT
C
C----------------------------------------------------------------------------
C    ***   On Output:         ***
C
C     IFLAG: An output integer whose value denotes the following:
C
C                VALUE                        INTERPRETATION
C                -----                        --------------
C                  0               No moist convection; atmosphere is not
C                                  unstable, or surface temperature is less
C                                  than 250 K or surface specific humidity
C                                  is non-positive.
C
C                  1               Moist convection occurs.
C
C                  2               No moist convection: lifted condensation
C                                  level is above the 200 mb level.
C
C                  3               No moist convection: cloud base is higher
C                                  then the level NL-1.
C
C                  4               Moist convection occurs, but a CFL condition
C                                  on the subsidence warming is violated. This
C                                  does not cause the scheme to terminate.
C
C     FT:   Array of temperature tendency (K/s) of dimension ND, 
C             defined at same grid levels as T, Q, QS and P.
C
C     FQ:   Array of specific humidity tendencies ((gm/gm)/s) of dimension ND,
C             defined at same grid levels as T, Q, QS and P.
C
C     FU:   Array of forcing of zonal velocity (m/s^2) of dimension ND,
C             defined at same grid levels as T.
C
C     FV:   Same as FU, but for forcing of meridional velocity.
C
C     FTRA: Array of forcing of tracer content, in tracer mixing ratio per
C             second, defined at same levels as T. Dimensioned (ND,NTRA).
C
C     PRECIP: Scalar convective precipitation rate (mm/day).
C
C     WD:    A convective downdraft velocity scale. For use in surface
C             flux parameterizations. See convect.ps file for details.
C
C     TPRIME: A convective downdraft temperature perturbation scale (K).
C              For use in surface flux parameterizations. See convect.ps
C              file for details.
C
C     QPRIME: A convective downdraft specific humidity
C              perturbation scale (gm/gm).
C              For use in surface flux parameterizations. See convect.ps
C              file for details.
C
C     CBMF:   The cloud base mass flux ((kg/m**2)/s). THIS SCALAR VALUE MUST
C              BE STORED BY THE CALLING PROGRAM AND RETURNED TO CONVECT AT
C              ITS NEXT CALL. That is, the value of CBMF must be "remembered"
C              by the CALLing program between CALLs to CONVECT.
C
C------------------------------------------------------------------------------
C
C    ***  THE PARAMETER NA SHOULD IN GENERAL BE GREATER THAN   ***
C    ***                OR EQUAL TO  ND + 1                    ***
C
      PARAMETER (NA=70)           
C
      INTEGER NENT(NA)
      REAL T(ND),Q(ND),QS(ND),U(ND),V(ND),TRA(ND,NTRA),P(ND),PH(ND)
      REAL FT(ND),FQ(ND),FU(ND),FV(ND),FTRA(ND,NTRA)
      REAL UENT(NA,NA),VENT(NA,NA),TRAENT(NA,NA,NTRA),TRATM(NA)
      REAL UP(NA),VP(NA),TRAP(NA,NTRA)
      REAL M(NA),MP(NA),MENT(NA,NA),QENT(NA,NA),ELIJ(NA,NA)
      REAL SIJ(NA,NA),TVP(NA),TV(NA),WATER(NA)
      REAL QP(NA),EP(NA),TH(NA),WT(NA),EVAP(NA),CLW(NA)
      REAL SIGP(NA),TP(NA),TOLD(NA),CPN(NA)
      REAL LV(NA),LVCP(NA),LV0,H(NA),HP(NA),GZ(NA),HM(NA)
C
C -----------------------------------------------------------------------
C
C   ***                     Specify Switches                         ***
C
C   ***   IPBL: Set to zero to bypass dry adiabatic adjustment       ***
C   ***    Any other value results in dry adiabatic adjustment       ***
C   ***     (Zero value recommended for use in models with           ***
C   ***                   boundary layer schemes)                    ***
C
C   ***   MINORIG: Lowest level from which convection may originate  ***
C   ***     (Should be first model level at which T is defined       ***
C   ***      for models using bulk PBL schemes; otherwise, it should ***
C   ***      be the first model level at which T is defined above    ***
C   ***                      the surface layer)                      ***
C
        IPBL=0
        MINORIG=2
	include 'CVA_KE.inc'  ! This line replaces the preceding one !
C
C------------------------------------------------------------------------------
C
C   ***                    SPECIFY PARAMETERS                        ***
C
C   *** ELCRIT IS THE AUTOCONVERSION THERSHOLD WATER CONTENT (gm/gm) ***
C   ***  TLCRIT IS CRITICAL TEMPERATURE BELOW WHICH THE AUTO-        ***
C   ***       CONVERSION THRESHOLD IS ASSUMED TO BE ZERO             ***
C   ***     (THE AUTOCONVERSION THRESHOLD VARIES LINEARLY            ***
C   ***               BETWEEN 0 C AND TLCRIT)                        ***
C   ***   ENTP IS THE COEFFICIENT OF MIXING IN THE ENTRAINMENT       ***
C   ***                       FORMULATION                            ***
C   ***  SIGD IS THE FRACTIONAL AREA COVERED BY UNSATURATED DNDRAFT  ***
C   ***  SIGS IS THE FRACTION OF PRECIPITATION FALLING OUTSIDE       ***
C   ***                        OF CLOUD                              ***
C   ***        OMTRAIN IS THE ASSUMED FALL SPEED (P/s) OF RAIN       ***
C   ***     OMTSNOW IS THE ASSUMED FALL SPEED (P/s) OF SNOW          ***
C   ***  COEFFR IS A COEFFICIENT GOVERNING THE RATE OF EVAPORATION   ***
C   ***                          OF RAIN                             ***
C   ***  COEFFS IS A COEFFICIENT GOVERNING THE RATE OF EVAPORATION   ***
C   ***                          OF SNOW                             ***
C   ***     CU IS THE COEFFICIENT GOVERNING CONVECTIVE MOMENTUM      ***
C   ***                         TRANSPORT                            ***
C   ***    DTMAX IS THE MAXIMUM NEGATIVE TEMPERATURE PERTURBATION    ***
C   ***        A LIFTED PARCEL IS ALLOWED TO HAVE BELOW ITS LFC      ***
C   ***    ALPHA AND DAMP ARE PARAMETERS THAT CONTROL THE RATE OF    ***
C   ***                 APPROACH TO QUASI-EQUILIBRIUM                ***
C   ***   (THEIR STANDARD VALUES ARE  0.20 AND 0.1, RESPECTIVELY)    ***
C   ***                   (DAMP MUST BE LESS THAN 1)                 ***
C
        ELCRIT=.0011
        TLCRIT=-55.0
        ENTP=1.5
        SIGD=0.05
        SIGS=0.12
        OMTRAIN=50.0
        OMTSNOW=5.5 
        COEFFR=1.0
        COEFFS=0.8
        CU=0.7
        BETA=10.0
        DTMAX=0.9 
        ALPHA=0.2   
        DAMP=0.01
C
C   ***        ASSIGN VALUES OF THERMODYNAMIC CONSTANTS,        ***
C   ***            GRAVITY, AND LIQUID WATER DENSITY.           ***
C   ***             THESE SHOULD BE CONSISTENT WITH             ***
C   ***              THOSE USED IN CALLING PROGRAM              ***
C   ***     NOTE: THESE ARE ALSO SPECIFIED IN SUBROUTINE TLIFT  ***
C
      CPD=1005.7
      CPV=1870.0
      CL=4190.0 
      RV=461.5
      RD=287.04
      LV0=2.501E6
      G=9.8  
      ROWL=1000.0
C
      CPVMCL=CL-CPV 
      EPS=RD/RV
      EPSI=1./EPS
      GINV=1.0/G
      DELTI=1.0/DELT
C
C           ***  INITIALIZE OUTPUT ARRAYS AND PARAMETERS  ***
C
        DO 5 I=1,ND
         FT(I)=0.0
         FQ(I)=0.0
         FU(I)=0.0
         FV(I)=0.0
         DO 4 J=1,NTRA
          FTRA(I,J)=0.0
    4    CONTINUE
    5   CONTINUE
        DO 7 I=1,NL+1
         RDCP=(RD*(1.-Q(I))+Q(I)*RV)/
     1    (CPD*(1.-Q(I))+Q(I)*CPV)
         TH(I)=T(I)*(1000.0/P(I))**RDCP
    7   CONTINUE
        PRECIP=0.0
        WD=0.0
        TPRIME=0.0
        QPRIME=0.0
        IFLAG=0
C
        IF(IPBL.NE.0)THEN
C
C     ***            PERFORM DRY ADIABATIC ADJUSTMENT            ***
C
        JC=0
        DO 30 I=NL-1,1,-1
         JN=0
          SUM=TH(I)*(1.+Q(I)*EPSI-Q(I))
         DO 10 J=I+1,NL
          SUM=SUM+TH(J)*(1.+Q(J)*EPSI-Q(J))
          THBAR=SUM/FLOAT(J+1-I)
          IF((TH(J)*(1.+Q(J)*EPSI-Q(J))).LT.THBAR)JN=J
   10    CONTINUE
         IF(I.EQ.1)JN=MAX(JN,2)
         IF(JN.EQ.0)GOTO 30
   12    CONTINUE
         AHM=0.0
         RM=0.0
         UM=0.0
         VM=0.0
         DO K=1,NTRA
          TRATM(K)=0.0
         END DO
         DO 15 J=I,JN
          AHM=AHM+(CPD*(1.-Q(J))+Q(J)*CPV)*T(J)*(PH(J)-PH(J+1))
          RM=RM+Q(J)*(PH(J)-PH(J+1))
          UM=UM+U(J)*(PH(J)-PH(J+1))
          VM=VM+V(J)*(PH(J)-PH(J+1))
          DO K=1,NTRA
           TRATM(K)=TRATM(K)+TRA(J,K)*(PH(J)-PH(J+1))
          END DO
   15    CONTINUE
         DPHINV=1./(PH(I)-PH(JN+1))
         RM=RM*DPHINV
         UM=UM*DPHINV
         VM=VM*DPHINV
         DO K=1,NTRA
          TRATM(K)=TRATM(K)*DPHINV
         END DO
         A2=0.0
         DO 20 J=I,JN
          Q(J)=RM
          U(J)=UM
          V(J)=VM
          DO K=1,NTRA
           TRA(J,K)=TRATM(K)
          END DO
          RDCP=(RD*(1.-Q(J))+Q(J)*RV)/
     1     (CPD*(1.-Q(J))+Q(J)*CPV)  
          X=(0.001*P(J))**RDCP
          TOLD(J)=T(J)
          T(J)=X
          A2=A2+(CPD*(1.-Q(J))+Q(J)*CPV)*X*(PH(J)-PH(J+1))
   20    CONTINUE
         DO 25 J=I,JN
          TH(J)=AHM/A2
          T(J)=T(J)*TH(J)
          TC=TOLD(J)-273.15
          ALV=LV0-CPVMCL*TC
          QS(J)=QS(J)+QS(J)*(1.+QS(J)*(EPSI-1.))*ALV*(T(J)-
     1     TOLD(J))/(RV*TOLD(J)*TOLD(J))
   25    CONTINUE
         IF((TH(JN+1)*(1.+Q(JN+1)*EPSI-Q(JN+1))).LT.
     1    (TH(JN)*(1.+Q(JN)*EPSI-Q(JN))))THEN
          JN=JN+1
          GOTO 12
         END IF
         IF(I.EQ.1)JC=JN 
   30   CONTINUE
C
C   ***   Remove any supersaturation that results from adjustment ***
C
      IF(JC.GT.1)THEN
       DO 38 J=1,JC
          IF(QS(J).LT.Q(J))THEN 
           ALV=LV0-CPVMCL*(T(J)-273.15)  
           TNEW=T(J)+ALV*(Q(J)-QS(J))/(CPD*(1.-Q(J))+
     1      CL*Q(J)+QS(J)*(CPV-CL+ALV*ALV/(RV*T(J)*T(J))))
           ALVNEW=LV0-CPVMCL*(TNEW-273.15)
           QNEW=(ALV*Q(J)-(TNEW-T(J))*(CPD*(1.-Q(J))+CL*Q(J)))/ALVNEW
           PRECIP=PRECIP+24.*3600.*1.0E5*(PH(J)-PH(J+1))*
     1      (Q(J)-QNEW)/(G*DELT*ROWL)
           T(J)=TNEW
           Q(J)=QNEW
           QS(J)=QNEW
          END IF     
   38  CONTINUE  
      END IF
C
      END IF
C
C  *** CALCULATE ARRAYS OF GEOPOTENTIAL, HEAT CAPACITY AND STATIC ENERGY
C  
        GZ(1)=0.0
        CPN(1)=CPD*(1.-Q(1))+Q(1)*CPV
        H(1)=T(1)*CPN(1)
        LV(1)=LV0-CPVMCL*(T(1)-273.15)
        HM(1)=LV(1)*Q(1)
        TV(1)=T(1)*(1.+Q(1)*EPSI-Q(1))
        AHMIN=1.0E12
        IHMIN=NL
        DO 40 I=2,NL+1
          TVX=T(I)*(1.+Q(I)*EPSI-Q(I))
          TVY=T(I-1)*(1.+Q(I-1)*EPSI-Q(I-1))
          GZ(I)=GZ(I-1)+0.5*RD*(TVX+TVY)*(P(I-1)-P(I))/PH(I)
          CPN(I)=CPD*(1.-Q(I))+CPV*Q(I)
          H(I)=T(I)*CPN(I)+GZ(I)
          LV(I)=LV0-CPVMCL*(T(I)-273.15)
          HM(I)=(CPD*(1.-Q(I))+CL*Q(I))*(T(I)-T(1))+
     1     LV(I)*Q(I)+GZ(I)
          TV(I)=T(I)*(1.+Q(I)*EPSI-Q(I))
C
C  ***  Find level of minimum moist static energy    ***
C
          IF(I.GE.MINORIG.AND.HM(I).LT.AHMIN.AND.HM(I).LT.HM(I-1))THEN
           AHMIN=HM(I)
           IHMIN=I
          END IF
   40   CONTINUE
        IHMIN=MIN(IHMIN, NL-1)
C
C  ***     Find that model level below the level of minimum moist       ***
C  ***  static energy that has the maximum value of moist static energy ***
C
        AHMAX=0.0
        DO 42 I=MINORIG,IHMIN
         IF(HM(I).GT.AHMAX)THEN
          NK=I
          AHMAX=HM(I)
         END IF
   42   CONTINUE
C
C  ***  CHECK WHETHER PARCEL LEVEL TEMPERATURE AND SPECIFIC HUMIDITY   ***
C  ***                          ARE REASONABLE                         ***
C  ***      Skip convection if HM increases monotoniCALLy upward       ***
C
        IF(T(NK).LT.250.0.OR.Q(NK).LE.0.0.OR.IHMIN.EQ.(NL-1))THEN
         IFLAG=0
         CBMF=0.0
         RETURN
        END IF
C
C   ***  CALCULATE LIFTED CONDENSATION LEVEL OF AIR AT PARCEL ORIGIN LEVEL ***
C   ***       (WITHIN 0.2% OF FORMULA OF BOLTON, MON. WEA. REV.,1980)      ***
C
        RH=Q(NK)/QS(NK)
        CHI=T(NK)/(1669.0-122.0*RH-T(NK))
        PLCL=P(NK)*(RH**CHI)
        IF(PLCL.LT.200.0.OR.PLCL.GE.2000.0)THEN
         IFLAG=2
         CBMF=0.0
         RETURN
        END IF
C
C   ***  CALCULATE FIRST LEVEL ABOVE LCL (=ICB)  ***
C
        ICB=NL-1
        DO 50 I=NK+1,NL
         IF(P(I).LT.PLCL)THEN
          ICB=MIN(ICB,I)
         END IF
   50   CONTINUE
        IF(ICB.GE.(NL-1))THEN
         IFLAG=3
         CBMF=0.0
         RETURN
        END IF
C
C   *** FIND TEMPERATURE UP THROUGH ICB AND TEST FOR INSTABILITY           ***
C
C   *** SUBROUTINE TLIFT CALCULATES PART OF THE LIFTED PARCEL VIRTUAL      ***
C   ***  TEMPERATURE, THE ACTUAL TEMPERATURE AND THE ADIABATIC             ***
C   ***                   LIQUID WATER CONTENT                             ***
C
c #KE   CALL TLIFT(P,T,Q,QS,GZ,ICB,NK,TVP,TP,CLW,ND,NL,1)
        DO 54 I=NK,ICB
         TVP(I)=TVP(I)-TP(I)*Q(NK)
   54   CONTINUE
C
C   ***  If there was no convection at last time step and parcel    ***
C   ***       is stable at ICB then skip rest of calculation        ***
C
        IF(CBMF.EQ.0.0.AND.TVP(ICB).LE.(TV(ICB)-DTMAX))THEN
         IFLAG=0
         RETURN
        END IF
C
C   ***  IF THIS POINT IS REACHED, MOIST CONVECTIVE ADJUSTMENT IS NECESSARY ***
C
        IF(IFLAG.NE.4)IFLAG=1
C
C   ***  FIND THE REST OF THE LIFTED PARCEL TEMPERATURES          ***
C
c #KE   CALL TLIFT(P,T,Q,QS,GZ,ICB,NK,TVP,TP,CLW,ND,NL,2)
C
C   ***  SET THE PRECIPITATION EFFICIENCIES AND THE FRACTION OF   ***
C   ***          PRECIPITATION FALLING OUTSIDE OF CLOUD           ***
C   ***      THESE MAY BE FUNCTIONS OF TP(I), P(I) AND CLW(I)     ***
C                 
        DO 57 I=1,NK
         EP(I)=0.0
         SIGP(I)=SIGS
   57   CONTINUE
        DO 60 I=NK+1,NL
         TCA=TP(I)-273.15
         IF(TCA.GE.0.0)THEN
          ELACRIT=ELCRIT
         ELSE
          ELACRIT=ELCRIT*(1.0-TCA/TLCRIT)
         END IF
         ELACRIT=MAX(ELACRIT,0.0)
	   EPMAX=0.999
         EP(I)=EPMAX*(1.0-ELACRIT/MAX(CLW(I),1.0E-8))
         EP(I)=MAX(EP(I),0.0)
         EP(I)=MIN(EP(I),EPMAX)
         SIGP(I)=SIGS
   60   CONTINUE
C
C   ***       CALCULATE VIRTUAL TEMPERATURE AND LIFTED PARCEL     ***
C   ***                    VIRTUAL TEMPERATURE                    ***
C
        DO 64 I=ICB+1,NL
         TVP(I)=TVP(I)*(1.-Q(NK)+EP(I)*CLW(I))
   64   CONTINUE
        TVP(NL+1)=TVP(NL)-(GZ(NL+1)-GZ(NL))/CPD
C
C   ***        NOW INITIALIZE VARIOUS ARRAYS USED IN THE COMPUTATIONS       ***
C
        DO 70 I=1,NL+1
         HP(I)=H(I)
         NENT(I)=0
         WATER(I)=0.0
         EVAP(I)=0.0
         WT(I)=OMTSNOW
         MP(I)=0.0
         M(I)=0.0
         LVCP(I)=LV(I)/CPN(I)
         DO 70 J=1,NL+1
          QENT(I,J)=Q(J)
          ELIJ(I,J)=0.0
          MENT(I,J)=0.0
          SIJ(I,J)=0.0
          UENT(I,J)=U(J)
          VENT(I,J)=V(J)
          DO 70 K=1,NTRA
           TRAENT(I,J,K)=TRA(J,K)
   70   CONTINUE
        QP(1)=Q(1)
        UP(1)=U(1)
        VP(1)=V(1)
        DO 71 I=1,NTRA
         TRAP(1,I)=TRA(1,I)
   71	CONTINUE
        DO 72 I=2,NL+1
         QP(I)=Q(I-1)
         UP(I)=U(I-1)
         VP(I)=V(I-1)
         DO 72 J=1,NTRA
          TRAP(I,J)=TRA(I-1,J)
   72	   CONTINUE
C
C  ***  FIND THE FIRST MODEL LEVEL (INB1) ABOVE THE PARCEL'S      ***
C  ***          HIGHEST LEVEL OF NEUTRAL BUOYANCY                 ***
C  ***     AND THE HIGHEST LEVEL OF POSITIVE CAPE (INB)           ***
C
        CAPE=0.0
        CAPEM=0.0
        INB=ICB+1
        INB1=INB
	  BYP=0.0
        DO 82 I=ICB+1,NL-1
         BY=(TVP(I)-TV(I))*(PH(I)-PH(I+1))/P(I)
         CAPE=CAPE+BY
         IF(BY.GE.0.0)INB1=I+1
         IF(CAPE.GT.0.0)THEN
          INB=I+1
          BYP=(TVP(I+1)-TV(I+1))*(PH(I+1)-PH(I+2))/P(I+1)
          CAPEM=CAPE
         END IF
   82 	CONTINUE
        INB=MAX(INB,INB1)
        CAPE=CAPEM+BYP
        DEFRAC=CAPEM-CAPE
        DEFRAC=MAX(DEFRAC,0.001)
        FRAC=-CAPE/DEFRAC
        FRAC=MIN(FRAC,1.0)
        FRAC=MAX(FRAC,0.0)
C
C   ***   CALCULATE LIQUID WATER STATIC ENERGY OF LIFTED PARCEL   ***
C
        DO 95 I=ICB,INB
         HP(I)=H(NK)+(LV(I)+(CPD-CPV)*T(I))*EP(I)*CLW(I)
   95   CONTINUE                  
C
C   ***  CALCULATE CLOUD BASE MASS FLUX AND RATES OF MIXING, M(I),  ***
c   ***                   AT EACH MODEL LEVEL                       ***
C
        DBOSUM=0.0
C   
C   ***     INTERPOLATE DIFFERENCE BETWEEN LIFTED PARCEL AND      ***
C   ***  ENVIRONMENTAL TEMPERATURES TO LIFTED CONDENSATION LEVEL  ***
C	
        TVPPLCL=TVP(ICB-1)-RD*TVP(ICB-1)*(P(ICB-1)-PLCL)/
     1    (CPN(ICB-1)*P(ICB-1))
        TVAPLCL=TV(ICB)+(TVP(ICB)-TVP(ICB+1))*(PLCL-P(ICB))/
     1    (P(ICB)-P(ICB+1))
        DTPBL=0.0
        DO 96 I=NK,ICB-1
         DTPBL=DTPBL+(TVP(I)-TV(I))*(PH(I)-PH(I+1))
   96   CONTINUE
        DTPBL=DTPBL/(PH(NK)-PH(ICB))
        DTMIN=TVPPLCL-TVAPLCL+DTMAX+DTPBL
        DTMA=DTMIN
C
C   ***  ADJUST CLOUD BASE MASS FLUX   ***
C
      CBMFOLD=CBMF
	DELT0=300.0
      DAMPS=DAMP*DELT/DELT0 
      CBMF=(1.-DAMPS)*CBMF+0.1*ALPHA*DTMA 
      CBMF=MAX(CBMF,0.0)
C
C   *** If cloud base mass flux is zero, skip rest of calculation  ***
C
      IF(CBMF.EQ.0.0.AND.CBMFOLD.EQ.0.0)THEN
       RETURN
      END IF
C
C   ***   CALCULATE RATES OF MIXING,  M(I)   ***
C
      M(ICB)=0.0
      DO 103 I=ICB+1,INB
       K=MIN(I,INB1)
       DBO=ABS(TV(K+1)-TVP(K+1)-TV(K-1)+TVP(K-1))+
     1  ENTP*0.04*(PH(K)-PH(K+1))
       DBOSUM=DBOSUM+DBO
       M(I)=CBMF*DBO
  103 CONTINUE
      DO 110 I=ICB+1,INB
       M(I)=M(I)/DBOSUM  
  110 CONTINUE     
C
C   ***  CALCULATE ENTRAINED AIR MASS FLUX (MENT), TOTAL WATER MIXING  ***
C   ***     RATIO (QENT), TOTAL CONDENSED WATER (ELIJ), AND MIXING     ***
C   ***                        FRACTION (SIJ)                          ***
C
        DO 170 I=ICB+1,INB
         QTI=Q(NK)-EP(I)*CLW(I)
         DO 160 J=ICB,INB
          BF2=1.+LV(J)*LV(J)*QS(J)/(RV*T(J)*T(J)*CPD)
          ANUM=H(J)-HP(I)+(CPV-CPD)*T(J)*(QTI-Q(J))
          DENOM=H(I)-HP(I)+(CPD-CPV)*(Q(I)-QTI)*T(J)
          DEI=DENOM
          IF(ABS(DEI).LT.0.01)DEI=0.01
          SIJ(I,J)=ANUM/DEI
          SIJ(I,I)=1.0
          ALTEM=SIJ(I,J)*Q(I)+(1.-SIJ(I,J))*QTI-QS(J)
          ALTEM=ALTEM/BF2
          CWAT=CLW(J)*(1.-EP(J))
          STEMP=SIJ(I,J)
          IF((STEMP.LT.0.0.OR.STEMP.GT.1.0.OR.
     1      ALTEM.GT.CWAT).AND.J.GT.I)THEN
           ANUM=ANUM-LV(J)*(QTI-QS(J)-CWAT*BF2)
           DENOM=DENOM+LV(J)*(Q(I)-QTI)
           IF(ABS(DENOM).LT.0.01)DENOM=0.01
           SIJ(I,J)=ANUM/DENOM
           ALTEM=SIJ(I,J)*Q(I)+(1.-SIJ(I,J))*QTI-QS(J)
           ALTEM=ALTEM-(BF2-1.)*CWAT
          END IF
          IF(SIJ(I,J).GT.0.0.AND.SIJ(I,J).LT.0.9)THEN
           QENT(I,J)=SIJ(I,J)*Q(I)+(1.-SIJ(I,J))*QTI
           UENT(I,J)=SIJ(I,J)*U(I)+(1.-SIJ(I,J))*U(NK)
           VENT(I,J)=SIJ(I,J)*V(I)+(1.-SIJ(I,J))*V(NK)
           DO K=1,NTRA
            TRAENT(I,J,K)=SIJ(I,J)*TRA(I,K)+(1.-SIJ(I,J))*
     1       TRA(NK,K)
           END DO
           ELIJ(I,J)=ALTEM
           ELIJ(I,J)=MAX(0.0,ELIJ(I,J))
           MENT(I,J)=M(I)/(1.-SIJ(I,J))
           NENT(I)=NENT(I)+1
          END IF
          SIJ(I,J)=MAX(0.0,SIJ(I,J))
          SIJ(I,J)=MIN(1.0,SIJ(I,J))
  160    CONTINUE
C
C   ***   IF NO AIR CAN ENTRAIN AT LEVEL I ASSUME THAT UPDRAFT DETRAINS  ***
C   ***   AT THAT LEVEL AND CALCULATE DETRAINED AIR FLUX AND PROPERTIES  ***
C
         IF(NENT(I).EQ.0)THEN
          MENT(I,I)=M(I)
          QENT(I,I)=Q(NK)-EP(I)*CLW(I)
          UENT(I,I)=U(NK)
          VENT(I,I)=V(NK)
          DO J=1,NTRA
           TRAENT(I,I,J)=TRA(NK,J)
          END DO
          ELIJ(I,I)=CLW(I)
          SIJ(I,I)=1.0
         END IF 
  170   CONTINUE
        SIJ(INB,INB)=1.0
C
C   ***  NORMALIZE ENTRAINED AIR MASS FLUXES TO REPRESENT EQUAL  ***
C   ***              PROBABILITIES OF MIXING                     ***
C
        DO 200 I=ICB+1,INB
        IF(NENT(I).NE.0)THEN
         QP1=Q(NK)-EP(I)*CLW(I)
         ANUM=H(I)-HP(I)-LV(I)*(QP1-QS(I))
         DENOM=H(I)-HP(I)+LV(I)*(Q(I)-QP1)
         IF(ABS(DENOM).LT.0.01)DENOM=0.01
         SCRIT=ANUM/DENOM
         ALT=QP1-QS(I)+SCRIT*(Q(I)-QP1)
         IF(ALT.LT.0.0)SCRIT=1.0
	   SCRIT=MAX(SCRIT,0.0)
         ASIJ=0.0
         SMIN=1.0
         DO 175 J=ICB,INB
          IF(SIJ(I,J).GT.0.0.AND.SIJ(I,J).LT.0.9)THEN
           IF(J.GT.I)THEN
            SMID=MIN(SIJ(I,J),SCRIT)
            SJMAX=SMID
            SJMIN=SMID
            IF(SMID.LT.SMIN.AND.SIJ(I,J+1).LT.SMID)THEN
             SMIN=SMID
             SJMAX=MIN(SIJ(I,J+1),SIJ(I,J),SCRIT)
             SJMIN=MAX(SIJ(I,J-1),SIJ(I,J))
             SJMIN=MIN(SJMIN,SCRIT)
            END IF
           ELSE
            SJMAX=MAX(SIJ(I,J+1),SCRIT)
            SMID=MAX(SIJ(I,J),SCRIT)
            SJMIN=0.0
            IF(J.GT.1)SJMIN=SIJ(I,J-1)
            SJMIN=MAX(SJMIN,SCRIT)
           END IF
           DELP=ABS(SJMAX-SMID)
           DELM=ABS(SJMIN-SMID)
           ASIJ=ASIJ+(DELP+DELM)*(PH(J)-PH(J+1))
           MENT(I,J)=MENT(I,J)*(DELP+DELM)*(PH(J)-PH(J+1))
          END IF
  175    CONTINUE
         ASIJ=MAX(1.0E-21,ASIJ)
         ASIJ=1.0/ASIJ
         DO 180 J=ICB,INB
          MENT(I,J)=MENT(I,J)*ASIJ
  180    CONTINUE
         BSUM=0.0
         DO 190 J=ICB,INB
          BSUM=BSUM+MENT(I,J)
  190    CONTINUE
         IF(BSUM.LT.1.0E-18)THEN
          NENT(I)=0
          MENT(I,I)=M(I)
          QENT(I,I)=Q(NK)-EP(I)*CLW(I)
          UENT(I,I)=U(NK)
          VENT(I,I)=V(NK)
          DO J=1,NTRA
           TRAENT(I,I,J)=TRA(NK,J)
          END DO
          ELIJ(I,I)=CLW(I)
          SIJ(I,I)=1.0
         END IF
        END IF
  200   CONTINUE
C
C   ***  CHECK WHETHER EP(INB)=0, IF SO, SKIP PRECIPITATING    ***
C   ***             DOWNDRAFT CALCULATION                      ***
C
        IF(EP(INB).LT.0.0001)GOTO 405
C
C   ***  INTEGRATE LIQUID WATER EQUATION TO FIND CONDENSED WATER   ***
C   ***                AND CONDENSED WATER FLUX                    ***
C
        JTT=2
C
C    ***                    BEGIN DOWNDRAFT LOOP                    ***
C
        DO 400 I=INB,1,-1
C
C    ***              CALCULATE DETRAINED PRECIPITATION             ***
C
        WDTRAIN=G*EP(I)*M(I)*CLW(I)
        IF(I.GT.1)THEN
         DO 320 J=1,I-1
         AWAT=ELIJ(J,I)-(1.-EP(I))*CLW(I)
         AWAT=MAX(0.0,AWAT)
  320    WDTRAIN=WDTRAIN+G*AWAT*MENT(J,I)
        END IF
C
C    ***    FIND RAIN WATER AND EVAPORATION USING PROVISIONAL   ***
C    ***              ESTIMATES OF QP(I)AND QP(I-1)             ***
C     
c
c  *** Value of terminal velocity and coefficient of evaporation for snow ***
c 
        COEFF=COEFFS
        WT(I)=OMTSNOW
c      
c  *** Value of terminal velocity and coefficient of evaporation for rain ***
c
        IF(T(I).GT.273.0)THEN
         COEFF=COEFFR
         WT(I)=OMTRAIN
        END IF
        QSM=0.5*(Q(I)+QP(I+1))
        AFAC=COEFF*PH(I)*(QS(I)-QSM)/(1.0E4+2.0E3*PH(I)*QS(I))
        AFAC=MAX(AFAC,0.0)
        SIGT=SIGP(I)
        SIGT=MAX(0.0,SIGT)
        SIGT=MIN(1.0,SIGT)
        B6=100.*(PH(I)-PH(I+1))*SIGT*AFAC/WT(I)
        C6=(WATER(I+1)*WT(I+1)+WDTRAIN/SIGD)/WT(I)
        REVAP=0.5*(-B6+SQRT(B6*B6+4.*C6))
        EVAP(I)=SIGT*AFAC*REVAP
        WATER(I)=REVAP*REVAP
C
C    ***  CALCULATE PRECIPITATING DOWNDRAFT MASS FLUX UNDER     ***
C    ***              HYDROSTATIC APPROXIMATION                 ***
C   
        IF(I.EQ.1)GOTO 360
        DHDP=(H(I)-H(I-1))/(P(I-1)-P(I))
        DHDP=MAX(DHDP,10.0)
        MP(I)=100.*GINV*LV(I)*SIGD*EVAP(I)/DHDP
        MP(I)=MAX(MP(I),0.0)
C
C   ***   ADD SMALL AMOUNT OF INERTIA TO DOWNDRAFT              ***
C
        FAC=20.0/(PH(I-1)-PH(I))
        MP(I)=(FAC*MP(I+1)+MP(I))/(1.+FAC)
C   
C    ***      FORCE MP TO DECREASE LINEARLY TO ZERO                 ***
C    ***      BETWEEN ABOUT 950 MB AND THE SURFACE                  ***
C
          IF(P(I).GT.(0.949*P(1)))THEN
           JTT=MAX(JTT,I)
           MP(I)=MP(JTT)*(P(1)-P(I))/(P(1)-P(JTT))
          END IF              
  360   CONTINUE
C
C    ***       FIND MIXING RATIO OF PRECIPITATING DOWNDRAFT     ***
C
        IF(I.EQ.INB)GOTO 400
        IF(I.EQ.1)THEN
         QSTM=QS(1)
        ELSE
         QSTM=QS(I-1)
        END IF
        IF(MP(I).GT.MP(I+1))THEN
          RAT=MP(I+1)/MP(I)
          QP(I)=QP(I+1)*RAT+Q(I)*(1.0-RAT)+100.*GINV*
     1       SIGD*(PH(I)-PH(I+1))*(EVAP(I)/MP(I))
          UP(I)=UP(I+1)*RAT+U(I)*(1.-RAT)
          VP(I)=VP(I+1)*RAT+V(I)*(1.-RAT)
          DO J=1,NTRA
           TRAP(I,J)=TRAP(I+1,J)*RAT+TRAP(I,J)*(1.-RAT)
          END DO
         ELSE
          IF(MP(I+1).GT.0.0)THEN
            QP(I)=(GZ(I+1)-GZ(I)+QP(I+1)*(LV(I+1)+T(I+1)*(
     1        CL-CPD))+CPD*(T(I+1)-T(I)))/(LV(I)+T(I)*(CL-CPD))
            UP(I)=UP(I+1)
            VP(I)=VP(I+1)
            DO J=1,NTRA
             TRAP(I,J)=TRAP(I+1,J)
            END DO
          END IF
        END IF
        QP(I)=MIN(QP(I),QSTM)
        QP(I)=MAX(QP(I),0.0)
  400   CONTINUE
C
C   ***  CALCULATE SURFACE PRECIPITATION IN MM/DAY     ***
C
        PRECIP=PRECIP+WT(1)*SIGD*WATER(1)*3600.*24000./(ROWL*G)
C
  405   CONTINUE
C
C   ***  CALCULATE DOWNDRAFT VELOCITY SCALE AND SURFACE TEMPERATURE AND  ***
c   ***                    WATER VAPOR FLUCTUATIONS                      ***
C
      WD=BETA*ABS(MP(ICB))*0.01*RD*T(ICB)/(SIGD*P(ICB))
      QPRIME=0.5*(QP(1)-Q(1))
      TPRIME=LV0*QPRIME/CPD
C
C   ***  CALCULATE TENDENCIES OF LOWEST LEVEL POTENTIAL TEMPERATURE  ***
C   ***                      AND MIXING RATIO                        ***
C
        DPINV=0.01/(PH(1)-PH(2))
        AM=0.0
        IF(NK.EQ.1)THEN
         DO 410 K=2,INB
  410    AM=AM+M(K)
        END IF
        IF((2.*G*DPINV*AM).GE.DELTI)IFLAG=4
        FT(1)=FT(1)+G*DPINV*AM*(T(2)-T(1)+(GZ(2)-GZ(1))/CPN(1))
        FT(1)=FT(1)-LVCP(1)*SIGD*EVAP(1)
        FT(1)=FT(1)+SIGD*WT(2)*(CL-CPD)*WATER(2)*(T(2)-
     1   T(1))*DPINV/CPN(1)
        FQ(1)=FQ(1)+G*MP(2)*(QP(2)-Q(1))*
     1    DPINV+SIGD*EVAP(1)
        FQ(1)=FQ(1)+G*AM*(Q(2)-Q(1))*DPINV
        FU(1)=FU(1)+G*DPINV*(MP(2)*(UP(2)-U(1))+AM*(U(2)-U(1)))
        FV(1)=FV(1)+G*DPINV*(MP(2)*(VP(2)-V(1))+AM*(V(2)-V(1)))
        DO J=1,NTRA
         FTRA(1,J)=FTRA(1,J)+G*DPINV*(MP(2)*(TRAP(2,J)-TRA(1,J))+
     1    AM*(TRA(2,J)-TRA(1,J)))
        END DO
        AMDE=0.0
        DO 415 J=2,INB
         FQ(1)=FQ(1)+G*DPINV*MENT(J,1)*(QENT(J,1)-Q(1))
         FU(1)=FU(1)+G*DPINV*MENT(J,1)*(UENT(J,1)-U(1))
         FV(1)=FV(1)+G*DPINV*MENT(J,1)*(VENT(J,1)-V(1))
         DO K=1,NTRA
          FTRA(1,K)=FTRA(1,K)+G*DPINV*MENT(J,1)*(TRAENT(J,1,K)-
     1     TRA(1,K))
         END DO
  415   CONTINUE
C
C   ***  CALCULATE TENDENCIES OF POTENTIAL TEMPERATURE AND MIXING RATIO  ***
C   ***               AT LEVELS ABOVE THE LOWEST LEVEL                   ***
C
C   ***  FIRST FIND THE NET SATURATED UPDRAFT AND DOWNDRAFT MASS FLUXES  ***
C   ***                      THROUGH EACH LEVEL                          ***
C
        DO 500 I=2,INB
        DPINV=0.01/(PH(I)-PH(I+1))
        CPINV=1.0/CPN(I)
        AMP1=0.0
        AD=0.0
        IF(I.GE.NK)THEN
         DO 440 K=I+1,INB+1
  440    AMP1=AMP1+M(K)
        END IF
        DO 450 K=1,I
        DO 450 J=I+1,INB+1
         AMP1=AMP1+MENT(K,J)
  450   CONTINUE
        IF((2.*G*DPINV*AMP1).GE.DELTI)IFLAG=4
        DO 470 K=1,I-1
        DO 470 J=I,INB
         AD=AD+MENT(J,K)
  470   CONTINUE
        FT(I)=FT(I)+G*DPINV*(AMP1*(T(I+1)-T(I)+(GZ(I+1)-GZ(I))*
     1   CPINV)-AD*(T(I)-T(I-1)+(GZ(I)-GZ(I-1))*CPINV))
     2   -SIGD*LVCP(I)*EVAP(I)
        FT(I)=FT(I)+G*DPINV*MENT(I,I)*(HP(I)-H(I)+
     1    T(I)*(CPV-CPD)*(Q(I)-QENT(I,I)))*CPINV
        FT(I)=FT(I)+SIGD*WT(I+1)*(CL-CPD)*WATER(I+1)*
     1    (T(I+1)-T(I))*DPINV*CPINV
        FQ(I)=FQ(I)+G*DPINV*(AMP1*(Q(I+1)-Q(I))-
     1    AD*(Q(I)-Q(I-1)))
        FU(I)=FU(I)+G*DPINV*(AMP1*(U(I+1)-U(I))-
     1    AD*(U(I)-U(I-1)))
        FV(I)=FV(I)+G*DPINV*(AMP1*(V(I+1)-V(I))-
     1    AD*(V(I)-V(I-1)))
        DO K=1,NTRA
         FTRA(I,K)=FTRA(I,K)+G*DPINV*(AMP1*(TRA(I+1,K)-
     1    TRA(I,K))-AD*(TRA(I,K)-TRA(I-1,K)))
        END DO
        DO 480 K=1,I-1
         AWAT=ELIJ(K,I)-(1.-EP(I))*CLW(I)
         AWAT=MAX(AWAT,0.0)
         FQ(I)=FQ(I)+G*DPINV*MENT(K,I)*(QENT(K,I)-AWAT-Q(I))
         FU(I)=FU(I)+G*DPINV*MENT(K,I)*(UENT(K,I)-U(I))
         FV(I)=FV(I)+G*DPINV*MENT(K,I)*(VENT(K,I)-V(I))
         DO J=1,NTRA
          FTRA(I,J)=FTRA(I,J)+G*DPINV*MENT(K,I)*(TRAENT(K,I,J)-
     1     TRA(I,J))
         END DO
  480   CONTINUE
        DO 490 K=I,INB
         FQ(I)=FQ(I)+G*DPINV*MENT(K,I)*(QENT(K,I)-Q(I))
         FU(I)=FU(I)+G*DPINV*MENT(K,I)*(UENT(K,I)-U(I))
         FV(I)=FV(I)+G*DPINV*MENT(K,I)*(VENT(K,I)-V(I))
         DO J=1,NTRA
          FTRA(I,J)=FTRA(I,J)+G*DPINV*MENT(K,I)*(TRAENT(K,I,J)-
     1     TRA(I,J))
         END DO
  490   CONTINUE
        FQ(I)=FQ(I)+SIGD*EVAP(I)+G*(MP(I+1)*
     1    (QP(I+1)-Q(I))-MP(I)*(QP(I)-Q(I-1)))*DPINV
        FU(I)=FU(I)+G*(MP(I+1)*(UP(I+1)-U(I))-MP(I)*
     1    (UP(I)-U(I-1)))*DPINV
        FV(I)=FV(I)+G*(MP(I+1)*(VP(I+1)-V(I))-MP(I)*
     1    (VP(I)-V(I-1)))*DPINV
        DO J=1,NTRA
         FTRA(I,J)=FTRA(I,J)+G*DPINV*(MP(I+1)*(TRAP(I+1,J)-TRA(I,J))-
     1    MP(I)*(TRAP(I,J)-TRAP(I-1,J)))
        END DO
  500   CONTINUE
C
C   *** Adjust tendencies at top of convection layer to reflect  ***
C   ***       actual position of the level zero CAPE             ***
C
        FQOLD=FQ(INB)
        FQ(INB)=FQ(INB)*(1.-FRAC)
        FQ(INB-1)=FQ(INB-1)+FRAC*FQOLD*((PH(INB)-PH(INB+1))/
     1   (PH(INB-1)-PH(INB)))*LV(INB)/LV(INB-1)
        FTOLD=FT(INB)
        FT(INB)=FT(INB)*(1.-FRAC)
        FT(INB-1)=FT(INB-1)+FRAC*FTOLD*((PH(INB)-PH(INB+1))/
     1   (PH(INB-1)-PH(INB)))*CPN(INB)/CPN(INB-1)
        FUOLD=FU(INB)
        FU(INB)=FU(INB)*(1.-FRAC)
        FU(INB-1)=FU(INB-1)+FRAC*FUOLD*((PH(INB)-PH(INB+1))/
     1   (PH(INB-1)-PH(INB)))
        FVOLD=FV(INB)
        FV(INB)=FV(INB)*(1.-FRAC)
        FV(INB-1)=FV(INB-1)+FRAC*FVOLD*((PH(INB)-PH(INB+1))/
     1   (PH(INB-1)-PH(INB)))
        DO K=1,NTRA
         FTRAOLD=FTRA(INB,K)
         FTRA(INB,K)=FTRA(INB,K)*(1.-FRAC)
         FTRA(INB-1,K)=FTRA(INB-1,K)+FRAC*FTRAOLD*(PH(INB)-PH(INB+1))/
     1    (PH(INB-1)-PH(INB))
        END DO
C
C   ***   Very slightly adjust tendencies to force exact   ***
C   ***     enthalpy, momentum and tracer conservation     ***
C
        ENTS=0.0
        UAV=0.0
        VAV=0.0
        DO 680 I=1,INB
         ENTS=ENTS+(CPN(I)*FT(I)+LV(I)*FQ(I))*(PH(I)-PH(I+1))	
         UAV=UAV+FU(I)*(PH(I)-PH(I+1))
         VAV=VAV+FV(I)*(PH(I)-PH(I+1))
  680	CONTINUE
        ENTS=ENTS/(PH(1)-PH(INB+1))
        UAV=UAV/(PH(1)-PH(INB+1))
        VAV=VAV/(PH(1)-PH(INB+1))
        DO 640 I=1,INB
         FT(I)=FT(I)-ENTS/CPN(I)
         FU(I)=(1.-CU)*(FU(I)-UAV)
         FV(I)=(1.-CU)*(FV(I)-VAV)
  640	CONTINUE
        DO 700 K=1,NTRA
         TRAAV=0.0
         DO 690 I=1,INB
          TRAAV=TRAAV+FTRA(I,K)*(PH(I)-PH(I+1))
  690    CONTINUE
         TRAAV=TRAAV/(PH(1)-PH(INB+1))
         DO 695 I=1,INB
          FTRA(I,K)=FTRA(I,K)-TRAAV
  695    CONTINUE
  700	CONTINUE
C
C   ***           RETURN           ***
C
        RETURN
C
        END
C
C ---------------------------------------------------------------------------
C
        SUBROUTINE TLIFT(P,T,Q,QS,GZ,ICB,NK,TVP,TPK,CLW,ND,NL,KK)
        REAL GZ(ND),TPK(ND),CLW(ND),P(ND)
        REAL T(ND),Q(ND),QS(ND),TVP(ND),LV0
C
C   ***   ASSIGN VALUES OF THERMODYNAMIC CONSTANTS     ***
C
        CPD=1005.7
        CPV=1870.0
        CL=4190.0
        RV=461.5
        RD=287.04
        LV0=2.501E6
C
        CPVMCL=CL-CPV
        EPS=RD/RV
        EPSI=1./EPS
C
C   ***  CALCULATE CERTAIN PARCEL QUANTITIES, INCLUDING STATIC ENERGY   ***
C
        AH0=(CPD*(1.-Q(NK))+CL*Q(NK))*T(NK)+Q(NK)*(LV0-CPVMCL*(
     1   T(NK)-273.15))+GZ(NK)
        CPP=CPD*(1.-Q(NK))+Q(NK)*CPV
        CPINV=1./CPP
C
        IF(KK.EQ.1)THEN
C
C   ***   CALCULATE LIFTED PARCEL QUANTITIES BELOW CLOUD BASE   ***
C
        DO 50 I=1,ICB-1
         CLW(I)=0.0
   50   CONTINUE
        DO 100 I=NK,ICB-1
         TPK(I)=T(NK)-(GZ(I)-GZ(NK))*CPINV
         TVP(I)=TPK(I)*(1.+Q(NK)*EPSI)
  100   CONTINUE
        END IF
C
C    ***  FIND LIFTED PARCEL QUANTITIES ABOVE CLOUD BASE    ***
C
        NST=ICB
        NSB=ICB
        IF(KK.EQ.2)THEN  
         NST=NL
         NSB=ICB+1
        END IF
        DO 300 I=NSB,NST
         TG=T(I)
         QG=QS(I)
         ALV=LV0-CPVMCL*(T(I)-273.15)
         DO 200 J=1,2
          S=CPD+ALV*ALV*QG/(RV*T(I)*T(I))
          S=1./S
          AHG=CPD*TG+(CL-CPD)*Q(NK)*T(I)+ALV*QG+GZ(I)
          TG=TG+S*(AH0-AHG)
          TG=MAX(TG,35.0)
          TC=TG-273.15
          DENOM=243.5+TC
          IF(TC.GE.0.0)THEN  
           ES=6.112*EXP(17.67*TC/DENOM)
          ELSE  
           ES=EXP(23.33086-6111.72784/TG+0.15215*LOG(TG))
          END IF  
          QG=EPS*ES/(P(I)-ES*(1.-EPS))
  200    CONTINUE
         ALV=LV0-CPVMCL*(T(I)-273.15)
         TPK(I)=(AH0-(CL-CPD)*Q(NK)*T(I)-GZ(I)-ALV*QG)/CPD
         CLW(I)=Q(NK)-QG
         CLW(I)=MAX(0.0,CLW(I))
         RG=QG/(1.-Q(NK))
         TVP(I)=TPK(I)*(1.+RG*EPSI)
  300   CONTINUE
        RETURN
        END


      subroutine HYDgen

C +------------------------------------------------------------------------+
C | MAR HYDROLOGIC CYCLE                               Fri 23-10-2009  MAR |
C |   SubRoutine HYDgen contains .main. of the EXPLICIT HYDROLOGICAL CYCLE |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT / OUTPUT: qvDY(mx,my,mz) : air   specific humidity     (kg/kg) |
C |   ^^^^^^^^^^^^^^^ qwHY(mx,my,mz) : cloud drops                 (kg/kg) |
C |                   qrHY(mx,my,mz) : rain  drops                 (kg/kg) |
C |                   qiHY(mx,my,mz) : ice   crystals concentration(kg/kg) |
C |                   qsHY(mx,my,mz) : snow  flakes                (kg/kg) |
C |                 rainHY(mx,my)    : rain  Precipitation             (m) |
C |                 snowHY(mx,my)    : snow  Precipitation         (m w.e) |
C |                 crysHY(mx,my)    : ice   Precipitation         (m w.e) |
C |                 hlatHY(mx,my,mz) : Latent Heat Release           (K/s) |
C |                                                                        |
C |   OUTPUT:                                                              |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   REFER. : 1) Ntezimana, unpubl.thes.LLN, 115 pp,     1993             |
C |   ^^^^^^^^ 2) Lin et al.       JCAM   22, 1065--1092, 1983             |
C |               (very similar, except that graupels are represented)     |
C |            3) Emde and Kahlig, An.Geo. 7,  405-- 414, 1989             |
C |                                                                        |
C | # OPTIONS: #WH  Additional Output (Each Process  is detailed)          |
C | # ^^^^^^^^ #EW  Additional Output (Energy and Water Conservation)      |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
      include 'MAR_HY.inc'
c #CA include 'MAR_CA.inc'

      include 'MAR_2D.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'
      include 'MAR_SL.inc'

      include 'MAR_WK.inc'

      include 'MAR_IO.inc'
      include 'MAR_SV.inc'
      include 'MAR_TV.inc'
c #EW include 'MAR_EW.inc'

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx integer                iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1
! #wx common  /SISVAT_EV/    iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1

      character*3 vecthy
      integer  klhyOK,io    ,io___1,io___5,iklon,itPhys
      integer  il_mmc,il__mm,i___mm,j___mm,il_mez
c #wH integer         i_fvv(klon),j_fvv(klon),klfvv,i0fvv,j0fvv,k0fvv
c #wH common/DebuggHy/i_fvv      ,j_fvv      ,klfvv,i0fvv,j0fvv,k0fvv

      real     qs99  ,hrelmx,erosmx,facLHR
      real     uq1   ,uq2   ,vq1   ,vq2   ,sq1   ,sq2
      real     uInFlw,uOutFl,pp    ,pkt0  ,ta_MAR
      real     vInFlw,vOutFl

C +--DATA
C +  ====

      data i___mm/0/
      data j___mm/0/
      data qs99  /0.99e+0/

c #wH i0fvv = 26                     ! i ccordinate (detailled output)
c #wH j0fvv = 17                     ! j ccordinate (detailled output)
c #wH k0fvv = 24                     ! k ccordinate (detailled output)


C +--Set UP Verification
C +  ===================

c #wH write(6,6020) itexpe,jdarGE,mmarGE,iyrrGE,jhurGE,minuGE,jsecGE
 6020 format(/,'Clouds Microphysics',2i6,'-',i2,'-',i4,i6,'h',i2,':',i2)

      IF (itexpe.eq.0)                                            THEN

                  klhyOK = mx2*my2
c #hy             klhyOK =       1
            IF   (klon.ne. klhyOK)                                THEN
              IF (klon.gt.1)                                      THEN
                  vecthy = 'NON'
              ELSE
                  vecthy = '   '
              END IF
                write(6,6000) klon,klhyOK,vecthy
 6000           format(/,'++++++++ klon (MARdim.inc) =',i6,' .NE.',i6,
     .                       ' ++++++++++++++',
     .                 /,'++++++++ NOT adapted to a ',a3,' vectorized ',
     .                   'code ++++++++++++++',
     .                 /,'++++++++ BAD SET UP of #hy or klon parameter',
     .                   '  ++++++++++++++',
     .                 /,'     ==> !?%@&* Emergency EXIT in HYDgen'    )
                STOP
            END IF


C +--Cloud Microphysics Initialization
C +  =================================

         DO j=1,my
         DO i=1,mx
           rai0HY(i,j)   = 0.
           rainHY(i,j)   = 0.
           sno0HY(i,j)   = 0.
           sfa0HY(i,j)   = 0.
           snowHY(i,j)   = 0.
           crysHY(i,j)   = 0.
         END DO
         END DO
         DO k=1,mz
         DO j=1,my
         DO i=1,mx
           ccniHY(i,j,k) = 0.
             qiHY(i,j,k) = 0.
             qsHY(i,j,k) = 0.
             qwHY(i,j,k) = 0.
             qrHY(i,j,k) = 0.
         END DO
         END DO
         END DO

      END IF

cXF (not cumulated precip because in real*4) !!!!
      IF (iterun.eq.0)                                            THEN
         DO j=1,my
         DO i=1,mx
           rai0HY(i,j)   = 0.
           rainHY(i,j)   = 0.
c #CA      rainCA(i,j)   = 0.
           sno0HY(i,j)   = 0.
           sfa0HY(i,j)   = 0.
           snowHY(i,j)   = 0.
c #CA      snowCA(i,j)   = 0.
           crysHY(i,j)   = 0.
           runoTV(i,j)   = 0.
           draiTV(i,j)   = 0.
           evapTV(i,j)   = 0.
         END DO
         END DO
      END IF
cXF
C +--Cloud Microphysics OFF ==> Reset of the Air Relative Humidity
C +  =============================================================

      IF (jhaRUN.lt.tim_HY)                                       THEN
C +...Hydrological cycle is inhibited until jhaRUN = tim_HY

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          tairDY(i,j,k)=pktaDY(i,j,k) *pkDY(i,j,k)
        END DO
        END DO
        END DO

C +     ***********
        call qsat3D
C +     ***********

        DO k=1,mz
        DO j=1,my
        DO i=1,mx
          qvDY(i,j,k)=qvsiDY(i,j,k)*min(qs99,qvDY(i,j,k)/qvsiDY(i,j,k))
        END DO
        END DO
        END DO

        turnHY = .true.

      END IF


C +--Decide to set ON Cloud Microphysics  if Air Relative Humidity > Crit.
C +  =====================================================================
       
      IF (.not.turnHY)                                            THEN
c #BS      erosmx=-1.0

C +        ***********
           call qsat3D
C +        ***********

        hrelmx= 0.0
        DO j=1,my
        DO i=1,mx
        DO k=1,mz
           hrelmx=max(hrelmx,qvDY(i,j,k)/qvsiDY(i,j,k))
           hrelmx=max(hrelmx,qvDY(i,j,k)/qvswDY(i,j,k))

c #BS      erosmx=max(erosmx,SLuusl(i,j,1)-SaltSL(i,j))
        END DO
        END DO
        END DO

           if        (hrelmx.gt.rhcrHY)
     .     turnHY = .true.

c #BS      if        (erosmx.gt.0.0)
c #BS.     turnHY = .true.

      END IF


C +--Hydrological Cycle Initialization
C +  =================================

      IF  (turnHY)                                                THEN


C +----From 3D to 2D arrays
C +    --------------------

        DO io=1,5
             ioutIO(io)=igrdIO(io)+mx*(jgrdIO(io)-1)
        END DO
c #WH   IF (il__mm.eq.0)                                            THEN
c #WH       i___mm = imez 
c #WH       j___mm = jmez 
c #WH       il__mm = imez + (jmez-1)*mx2
c #WH   END IF
c #EW       il_mez = imez + (jmez-1)*mx2
C +
             iklon  =         0


!$OMP PARALLEL DO
!$OMP.private(i,j,k,iklon,
!$OMP.        io___1,io___5,il__mm,i___mm,j___mm,il_mez,
!$OMP.     ccni2D,ccnw2D,cfra2D,crys2D,
!$OMP.      dqi2D, dqw2D,ect_2D,enr01D,
!$OMP.     enr11D,enr21D,gplv2D,
!$OMP.     gpmi2D,hlat2D,jhlr2D,mphy2D,
!$OMP.       pk2D,pkta2D,prec2D, pst2D,
!$OMP.     pst2Dn,  qg2D,  qi2D,  qr2D,
!$OMP.       qs2D,  qv2D,qvsi2D,qvsw2D,
!$OMP.       qw2D,rain2D,rolv2D,snoh2D,
!$OMP.     snow2D,tair2D,tsrf2D,TUkv2D,
!$OMP.     uair2D,vair2D,wair2D,wat01D,
!$OMP.     wat11D,wat21D,watf1D)
        DO   j = jp11,my1
        DO   i = ip11,mx1
              WKxy1(i,j)    =     0.
              WKxy2(i,j)    =     0.
              WKxy3(i,j)    =     0.
              WKxy4(i,j)    =     0.
              WKxy5(i,j)    =     0.
              WKxy6(i,j)    =     0.
c        END DO
c        END DO

c        DO   j = jp11,my1
c        DO   i = ip11,mx1
             iklon  = iklon + 1
c #hy        iklon  =         1

c #wH         i_fvv(iklon)  =       i
c #wH         j_fvv(iklon)  =         j

          DO k = 1,klev
               pk2D(iklon,k)=  pkDY(i,j,k)
             pkta2D(iklon,k)=pktaDY(i,j,k)
             tair2D(iklon,k)=tairDY(i,j,k)
             uair2D(iklon,k)=uairDY(i,j,k)
             vair2D(iklon,k)=vairDY(i,j,k)
             wair2D(iklon,k)=wairDY(i,j,k)*.01+sqrt(2.*ect_TE(i,j,k)/3.)
             rolv2D(iklon,k)=rolvDY(i,j,k)
! #kk          qv2D(iklon,k)=
! #kk.                     max(qvDY(i,j,k),epsq)
               qv2D(iklon,k)=
     .                     max(qvDY(i,j,k),epsi)
               qw2D(iklon,k)=  qwHY(i,j,k)
               qr2D(iklon,k)=  qrHY(i,j,k)
               qi2D(iklon,k)=  qiHY(i,j,k)
               qs2D(iklon,k)= 
     .                     max(qsHY(i,j,k),zero)
! #qg          qg2D(iklon,k)=  qgHY(i,j,k)
             cfra2D(iklon,k)=cfraHY(i,j,k)
             ccnw2D(iklon,k)=ccnwHY(i,j,k)
             ccni2D(iklon,k)=ccniHY(i,j,k)
              dqi2D(iklon,k)=0.
              dqw2D(iklon,k)=0.
             hlat2D(iklon,k)=hlatHY(i,j,k)
             ect_2D(iklon,k)=ect_TE(i,j,k)
             TUkv2D(iklon,k)=TUkvh (i,j,k)
          END DO
          DO k = 1,klev+1
             gplv2D(iklon,k)=gplvDY(i,j,k)
             gpmi2D(iklon,k)=gpmiDY(i,j,k)
             qvsw2D(iklon,k)=qvswDY(i,j,k)
             qvsi2D(iklon,k)=qvsiDY(i,j,k)
          END DO

             pst2D (iklon)  =pstDY (i,j)
             pst2Dn(iklon)  =pstDYn(i,j)
             rain2D(iklon)  =rainHY(i,j)
             snow2D(iklon)  =snowHY(i,j)
             crys2D(iklon)  =crysHY(i,j)
             prec2D(iklon)  =precSL(i,j)
             snoh2D(iklon)  =snohSL(i,j)
             tsrf2D(iklon)  =TairSL(i,j)
c #EW        wat01D(iklon)  =wat0EW(i,j)
c #EW        wat11D(iklon)  =wat1EW(i,j)
c #EW        wat21D(iklon)  =wat2EW(i,j)
c #EW        watf1D(iklon)  =watfEW(i,j)
c #EW        enr01D(iklon)  =enr0EW(i,j)
c #EW        enr11D(iklon)  =enr1EW(i,j)
c #EW        enr21D(iklon)  =enr2EW(i,j)
c #EW        mphy2D(iklon)  =mphyEW(i,j)
             jhlr2D(iklon)  =jhlrGE(i,j)


C +----Call Cloud Microphysics, in case of NO vectorization
C +    ----------------------------------------------------

c #hy              io___1 =  0
c #hy              io___5 =  0
c #hy        DO    io  =  1,5
c #hy          IF (ioutIO(io).eq.iklon)                           THEN
c #hy              io___1 =  io
c #hy              io___5 =  io
c #hy          END IF
c #hy        END DO
c #hy          IF (i.eq.i___mm .and.j.eq.j___mm )                 THEN
c #hy              il__mm = 1
c #hy          ELSE
c #hy              il__mm = 0
c #hy          END IF
c #hy          IF (i.eq.imez   .and.j.eq.jmez)                    THEN
c #hy              il_mez= 1
c #hy          ELSE
c #hy              il_mez= 0
c #hy          END IF

c #hy      DO      itPhys=1,max(1,ntHyd)
C +        ***********
c #hy      call HYDmic(io___1,io___5,il__mm,i___mm,j___mm,il_mez,
c #hy.     ccni2D,ccnw2D,cfra2D,crys2D,
c #hy.      dqi2D, dqw2D,ect_2D,enr01D,
c #hy.     enr11D,enr21D,gplv2D,
c #hy.     gpmi2D,hlat2D,jhlr2D,mphy2D,
c #hy.       pk2D,pkta2D,prec2D, pst2D,
c #hy.     pst2Dn,  qg2D,  qi2D,  qr2D,
c #hy.       qs2D,  qv2D,qvsi2D,qvsw2D,
c #hy.       qw2D,rain2D,rolv2D,snoh2D,
c #hy.     snow2D,tair2D,tsrf2D,TUkv2D,
c #hy.     uair2D,vair2D,wair2D,wat01D,
c #hy.     wat11D,wat21D,watf1D)
C +        ***********
c #hy      ENDDO

C +----From 2D to 3D arrays,    in case of NO vectorization
C +    ----------------------------------------------------

c #hy     DO k=1,klev
c #hy        pktaDY(i,j,k)=pkta2D(iklon,k)
c #hy        tairDY(i,j,k)=tair2D(iklon,k)
c #hy        rolvDY(i,j,k)=rolv2D(iklon,k)
c #hy        qvsiDY(i,j,k)=qvsi2D(iklon,k)
c #hy        qvswDY(i,j,k)=qvsw2D(iklon,k)
c #hy          qvDY(i,j,k)=  qv2D(iklon,k)
c #hy          qwHY(i,j,k)=  qw2D(iklon,k)
c #hy          qrHY(i,j,k)=  qr2D(iklon,k)
c #hy          qiHY(i,j,k)=  qi2D(iklon,k)
c #hy          qsHY(i,j,k)=  qs2D(iklon,k)
! #qg          qgHY(i,j,k)=  qg2D(iklon,k)
c #hy        cfraHY(i,j,k)=cfra2D(iklon,k)
c #hy        ccnwHY(i,j,k)=ccnw2D(iklon,k)
c #hy        ccniHY(i,j,k)=ccni2D(iklon,k)
c #hy         dqiHY(i,j,k)= dqi2D(iklon,k)*dsigm1(k)*pstDYn(i,j)
c #hy         dqwHY(i,j,k)= dqw2D(iklon,k)*dsigm1(k)*pstDYn(i,j)
c #hy        hlatHY(i,j,k)=hlat2D(iklon,k)
c #hy     END DO

c #hy        rainHY(i,j)  =rain2D(iklon)
c #hy        snowHY(i,j)  =snow2D(iklon)
c #hy        crysHY(i,j)  =crys2D(iklon)
c #hy        precSL(i,j)  =prec2D(iklon)
c #hy        snohSL(i,j)  =snoh2D(iklon)
c #ew        wat0EW(i,j)  =wat01D(iklon)
c #ew        wat1EW(i,j)  =wat11D(iklon)
c #ew        wat2EW(i,j)  =wat21D(iklon)
c #ew        watfEW(i,j)  =watf1D(iklon)
c #ew        enr0EW(i,j)  =enr01D(iklon)
c #ew        enr1EW(i,j)  =enr11D(iklon)
c #ew        enr2EW(i,j)  =enr21D(iklon)
c #ew        mphyEW(i,j)  =mphy2D(iklon)
        END DO
        END DO
!$OMP END PARALLEL DO

C +----Call Cloud Microphysics, in case of    vectorization
C +    ----------------------------------------------------

c #hy   IF (klon.gt.1)                                            THEN

            io___1  =  1
            io___5  =  5

C +        ***********
           call HYDmic(io___1,io___5,il__mm,i___mm,j___mm,il_mez)
C +        ***********

c #WH         il_mmc = il__mm
c #WH         j___mm =      0
 1000     CONTINUE
c #WH         il_mmc = il_mmc-(my2-jp11+1)
c #WH         j___mm = j___mm  + 1
c #WH     IF (il_mmc.gt.0)                                  GO TO 1000
c #WH         i___mm = il_mmc+(my2-jp11+1) + ip11


C +----From 2D to 3D arrays,    in case of    vectorization
C +    ----------------------------------------------------

             iklon  =         0
          DO j = jp11,my1
          DO i = ip11,mx1
             iklon  = iklon + 1

            DO k=1,klev
             pktaDY(i,j,k)=pkta2D(iklon,k)
             tairDY(i,j,k)=tair2D(iklon,k)
             rolvDY(i,j,k)=rolv2D(iklon,k)
             qvsiDY(i,j,k)=qvsi2D(iklon,k)
             qvswDY(i,j,k)=qvsw2D(iklon,k)
               qvDY(i,j,k)=  qv2D(iklon,k)
               qwHY(i,j,k)=  qw2D(iklon,k)
               qrHY(i,j,k)=  qr2D(iklon,k)
               qiHY(i,j,k)=  qi2D(iklon,k)
               qsHY(i,j,k)=  qs2D(iklon,k)
! #qg          qgHY(i,j,k)=  qg2D(iklon,k)
             cfraHY(i,j,k)=cfra2D(iklon,k)
             ccnwHY(i,j,k)=ccnw2D(iklon,k)
             ccniHY(i,j,k)=ccni2D(iklon,k)
              dqiHY(i,j,k)= dqi2D(iklon,k)*dsigm1(k)*pstDYn(i,j)
              dqwHY(i,j,k)= dqw2D(iklon,k)*dsigm1(k)*pstDYn(i,j)
             hlatHY(i,j,k)=hlat2D(iklon,k)
            END DO

             rainHY(i,j)  =rain2D(iklon)
             snowHY(i,j)  =snow2D(iklon)
             crysHY(i,j)  =crys2D(iklon)
             precSL(i,j)  =prec2D(iklon)
             snohSL(i,j)  =snoh2D(iklon)
c #EW        wat0EW(i,j)  =wat01D(iklon)
c #EW        wat1EW(i,j)  =wat11D(iklon)
c #EW        wat2EW(i,j)  =wat21D(iklon)
c #EW        watfEW(i,j)  =watf1D(iklon)
c #EW        enr0EW(i,j)  =enr01D(iklon)
c #EW        enr1EW(i,j)  =enr11D(iklon)
c #EW        enr2EW(i,j)  =enr21D(iklon)
c #EW        mphyEW(i,j)  =mphy2D(iklon)
          END DO
          END DO

c #hy   END IF


C +--Isotopes Proxies: Diagnostics
C +  =============================

              icntHY      = icntHY     + 1
!$OMP PARALLEL DO private(i,j,k,facLHR)
        DO   j = jp11,my1
        DO   i = ip11,mx1
            DO k=2,klev
              WKxy1(i,j)  =               WKxy1(i,j) 
     .                    +dsigm1(k)*max(hlatHY(i,j,k),0.)
              WKxy2(i,j)  =               WKxy2(i,j) 
     .                    -dsigm1(k)*min(hlatHY(i,j,k),0.)
              WKxy3(i,j)  =               WKxy3(i,j) 
     .                    +dsigm1(k)*max(hlatHY(i,j,k),0.)*tairDY(i,j,k)
              WKxy4(i,j)  =               WKxy4(i,j) 
     .                    -dsigm1(k)*min(hlatHY(i,j,k),0.)*tairDY(i,j,k)
              WKxy5(i,j)  =               WKxy5(i,j) 
     .                    +dsigm1(k)*max(hlatHY(i,j,k),0.)*gplvDY(i,j,k)
              WKxy6(i,j)  =               WKxy6(i,j) 
     .                    -dsigm1(k)*min(hlatHY(i,j,k),0.)*gplvDY(i,j,k)
            END DO
              facLHR      =(cp /Ls_H2O)*pstDYn(i,j)  *1.e3*grvinv*dt
             Hcd_HY(i,j)  =Hcd_HY(i,j)  + WKxy1(i,j)      * facLHR    
             Hsb_HY(i,j)  =Hsb_HY(i,j)  + WKxy2(i,j)      * facLHR    
             Tcd_HY(i,j)  =Tcd_HY(i,j)  + WKxy3(i,j)      * facLHR     
             Tsb_HY(i,j)  =Tsb_HY(i,j)  + WKxy4(i,j)      * facLHR     
             zcd_HY(i,j)  =zcd_HY(i,j)  + WKxy5(i,j)      * facLHR     
             zsb_HY(i,j)  =zsb_HY(i,j)  + WKxy6(i,j)      * facLHR     
              WKxy1(i,j)  =     0.
              WKxy2(i,j)  =     0.
              WKxy3(i,j)  =     0.
              WKxy4(i,j)  =     0.
              WKxy5(i,j)  =     0.
              WKxy6(i,j)  =     0.
        END DO
        END DO
!$OMP END PARALLEL DO

      END IF


C +--Hydrological Cycle Lateral Boundary Conditions
C +  ==============================================

      IF  (mmx.gt.1)                                              THEN
        DO k=mzhyd,mz
        DO j=1,my
            WKxyz1( 1,j,k) =   max(0.,sign(1.,uairDY( 1,j,k)))  ! u_In_Flow
            WKxyz2( 1,j,k) =               1.-WKxyz1( 1,j,k)    ! u_OutFlow
            WKxyz3( 1,j,k) = (sigma(k)*pstDY( 1,j)+ptopDY)**cap ! pp
            WKxyz4( 1,j,k) =                  pktaDY( 1,j,k)

            WKxyz1(mx,j,k) =   max(0.,sign(1.,uairDY(mx,j,k)))
            WKxyz2(mx,j,k) =               1.-WKxyz1(mx,j,k)
            WKxyz3(mx,j,k) = (sigma(k)*pstDY(mx,j)+ptopDY)**cap
            WKxyz4(mx,j,k) =                  pktaDY(mx,j,k)
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO j=1,my
              qwHY( 1,j,k) =    qwHY( 1,j,k) *WKxyz2( 1,j,k)
              qiHY( 1,j,k) =    qiHY( 1,j,k) *WKxyz2( 1,j,k)
              qrHY( 1,j,k) =    qrHY( 1,j,k) *WKxyz2( 1,j,k)
              qsHY( 1,j,k) =    qsHY( 1,j,k) *WKxyz2( 1,j,k)
            WKxyz5( 1,j,k) =  tairDY( 1,j,k) *WKxyz2( 1,j,k)

              qwHY(mx,j,k) =    qwHY(mx,j,k) *WKxyz1(mx,j,k)
              qiHY(mx,j,k) =    qiHY(mx,j,k) *WKxyz1(mx,j,k)
              qrHY(mx,j,k) =    qrHY(mx,j,k) *WKxyz1(mx,j,k)
              qsHY(mx,j,k) =    qsHY(mx,j,k) *WKxyz1(mx,j,k)
            WKxyz5(mx,j,k) =  tairDY(mx,j,k) *WKxyz1(mx,j,k)
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO j=1,my
            pktaDY( 1,j,k) =  pktaDY( 1,j,k) *WKxyz1( 1,j,k)
     .                     +  WKxyz5( 1,j,k) /WKxyz3( 1,j,k)

            pktaDY(mx,j,k) =  pktaDY(mx,j,k) *WKxyz2(mx,j,k)
     .                     +  WKxyz5(mx,j,k) /WKxyz3(mx,j,k)
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO j=1,my
            hlatHY( 1,j,k) =  WKxyz5( 1,j,k)
     .                  *(1.0-WKxyz4( 1,j,k) /pktaDY( 1,j,k)) /dt

            hlatHY(mx,j,k) =  WKxyz5(mx,j,k)
     .                  *(1.0-WKxyz4(mx,j,k) /pktaDY(mx,j,k)) /dt
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO j=1,my
            WKxyz1( 1,j,k) = 0.
            WKxyz2( 1,j,k) = 0.
            WKxyz3( 1,j,k) = 0.
            WKxyz4( 1,j,k) = 0.
            WKxyz5( 1,j,k) = 0.
            WKxyz1(mx,j,k) = 0.
            WKxyz2(mx,j,k) = 0.
            WKxyz3(mx,j,k) = 0.
            WKxyz4(mx,j,k) = 0.
            WKxyz5(mx,j,k) = 0.
        ENDDO
        ENDDO
      END IF

      IF (mmy.gt.1)                                               THEN
        DO k=mzhyd,mz
        DO i=1,mx
            WKxyz1(i, 1,k) =   max(0.,sign(1.,vairDY(i, 1,k)))  ! v_In_Flow
            WKxyz2(i, 1,k) =               1.-WKxyz1(i, 1,k)    ! v_OutFlow
            WKxyz3(i, 1,k) = (sigma(k)*pstDY(i, 1)+ptopDY)**cap ! pp
            WKxyz4(i, 1,k) =                  pktaDY(i, 1,k)

            WKxyz1(i,my,k) =   max(0.,sign(1.,vairDY(i,my,k)))
            WKxyz2(i,my,k) =               1.-WKxyz1(i,my,k)
            WKxyz3(i,my,k) = (sigma(k)*pstDY(i,my)+ptopDY)**cap
            WKxyz4(i,my,k) =                  pktaDY(i,my,k)
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO i=1,mx
              qwHY(i, 1,k) =    qwHY(i, 1,k) *WKxyz2(i, 1,k)
              qiHY(i, 1,k) =    qiHY(i, 1,k) *WKxyz2(i, 1,k)
              qrHY(i, 1,k) =    qrHY(i, 1,k) *WKxyz2(i, 1,k)
              qsHY(i, 1,k) =    qsHY(i, 1,k) *WKxyz2(i, 1,k)
            WKxyz5(i, 1,k) =  tairDY(i, 1,k) *WKxyz2(i, 1,k)

              qwHY(i,my,k) =    qwHY(i,my,k) *WKxyz1(i,my,k)
              qiHY(i,my,k) =    qiHY(i,my,k) *WKxyz1(i,my,k)
              qrHY(i,my,k) =    qrHY(i,my,k) *WKxyz1(i,my,k)
              qsHY(i,my,k) =    qsHY(i,my,k) *WKxyz1(i,my,k)
            WKxyz5(i,my,k) =  tairDY(i,my,k) *WKxyz1(i,my,k)
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO i=1,mx
            pktaDY(i, 1,k) =  pktaDY(i, 1,k) *WKxyz1(i, 1,k)
     .                     +  WKxyz5(i, 1,k) /WKxyz3(i, 1,k)

            pktaDY(i,my,k) =  pktaDY(i,my,k) *WKxyz2(i,my,k)
     .                     +  WKxyz5(i,my,k) /WKxyz3(i,my,k)
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO i=1,mx
            hlatHY(i, 1,k) =  WKxyz5(i, 1,k)
     .                  *(1.0-WKxyz4(i, 1,k) /pktaDY(i, 1,k)) /dt

            hlatHY(i,my,k) =  WKxyz5(i,my,k)
     .                  *(1.0-WKxyz4(i,my,k) /pktaDY(i,my,k)) /dt
c #vL   ENDDO
c #vL   ENDDO

c #vL   DO k=mzhyd,mz
c #vL   DO i=1,mx
            WKxyz1(i, 1,k) = 0.
            WKxyz2(i, 1,k) = 0.
            WKxyz3(i, 1,k) = 0.
            WKxyz4(i, 1,k) = 0.
            WKxyz5(i, 1,k) = 0.
            WKxyz1(i,my,k) = 0.
            WKxyz2(i,my,k) = 0.
            WKxyz3(i,my,k) = 0.
            WKxyz4(i,my,k) = 0.
            WKxyz5(i,my,k) = 0.
        ENDDO
        ENDDO
      END IF

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx IF (lSV_v1.GT.0  .AND.  lSV_v1.LE.2)                          THEN
! #wx   write(6,6010)   (qsHY(iSV_v1,jSV_v1,k)*1.e3,k=mz,mz-4,-1)
 6010   format(10x,'After HYDmic   : q   [g/kg] =',5f9.6)
! #wx END IF

      return
      end


      block data HYDdat

C +------------------------------------------------------------------------+
C | MAR HYDROLOGIC CYCLE                                   19-10-2006  MAR |
C |   Block Data HYDdat is used to define microphysical constants of   MAR |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARdim.inc'

c #HY include 'MAR_HY.inc'

c #HY data cminHY/1.0e-3/
C +...     cminHY:Cloud Fraction under which no Autoconversion occurs

      end


      subroutine HYDmic(io1,io5,ilmm,imm,jmm,ilmez,
     .     ccni2D,ccnw2D,cfra2D,crys2D,
     .      dqi2D, dqw2D,ect_2D,enr01D,
     .     enr11D,enr21D,gplv2D,
     .     gpmi2D,hlat2D,jhlr2D,mphy2D,
     .       pk2D,pkta2D,prec2D, pst2D,
     .     pst2Dn,  qg2D,  qi2D,  qr2D,
     .       qs2D,  qv2D,qvsi2D,qvsw2D,
     .       qw2D,rain2D,rolv2D,snoh2D,
     .     snow2D,tair2D,tsrf2D,TUkv2D,
     .     uair2D,vair2D,wair2D,wat01D,
     .     wat11D,wat21D,watf1D)

!------------------------------------------------------------------------+
! MAR HYDROLOGIC CYCLE                              Wed 10-Feb-2012  MAR |
!   SubRoutine HYDmic computes Cloud Microphysical Processes             |
!                                                                        |
!------------------------------------------------------------------------+
!                                                                        |
!   INPUT / OUTPUT: qv2D(klon,klev): air   specific humidity     (kg/kg) |
!   ^^^^^^^^^^^^^^  qw2D(klon,klev): cloud drops                 (kg/kg) |
!                   qr2D(klon,klev): rain  drops                 (kg/kg) |
!                   qi2D(klon,klev): ice   crystals concentration(kg/kg) |
!                   qs2D(klon,klev): snow  flakes                (kg/kg) |
!   (to be added)   qg2D(klon,klev): graupels                    (kg/kg) |
!                 ccnw2D(klon,klev): cloud droplets number       (Nb/m3) |
!                 ccni2D(klon,klev): ice   crystals number       (Nb/m3) |
!                                                                        |
!                 cfra2D(klon,klev): cloud fraction                      |
!                                                                        |
!                 rain2D(klon)     : rain  Precipitation        (m w.e.) |
!                 snow2D(klon)     : snow  Precipitation        (m w.e.) |
!                 crys2D(klon)     : ice   Precipitation        (m w.e.) |
!                                                                        |
!                 hlat2D(klon,klev): Latent Heat Release           (K/s) |
!                  dqi2D(klon,klev): Ice    Water Formation      (kg/kg) |
!                  dqw2D(klon,klev): Liquid Water Formation      (kg/kg) |
!                 qvsi2D(klon,klev+1): Saturation Specific Humid.(kg/kg) |
!                 qvsw2D(klon,klev+1): Saturation Specific Humid.(kg/kg) |
!                                                                        |
!   REFER. : 1) Ntezimana, unpubl.thes.LLN,          115 pp,     1993    |
!   ^^^^^    2) Lin et al.       JCAM            22, 1065--1092, 1983    |
!               (very similar, except that graupels are represented)     |
!            3) Emde and Kahlig, Annal.Geophys.   7,  405-- 414, 1989    |
!            4) Levkov et al.,   Contr.Atm.Phys. 65,   35--  57, 1992    |
!            5) Meyers et al.,   JAM             31,  708-- 731, 1992    |
!               (Primary Ice-Nucleation Parameterization)                |
!            6) Delobbe and Gallee, BLM          89,   75-- 107  1998    |
!               (Partial Condensation Scheme)                            |
!                                                                        |
!   CAUTION:     Partial Condensation Scheme NOT validated               |
!   ^^^^^^^      for SCu -- Cu Transition                                |
!                erf fonction is erroneous on HP                         |
!                                                                        |
! # OPTIONS: #HM  Hallet-Mossop Theory (for Convective Updraft)          |
! # ^^^^^^^  #hm  idem                 (non vectorized code)             |
! #        ! #qf  Cloud Droplets Heterogeneous Freezing (not included)   |
! #        ! #qg  Graupel Conservation Equation         (to  include)    |
! #          #hb  Snow particles distrib. parameter cnos set to BS value |
! #          #hs  Emde & Kahlig Homogeneous Sublimation (not in Levkov)  |
! #        ! #pp  Emde & Kahlig Ice Crystal Deposition  (not included)   |
!                                                                        |
! #          #VW  Duynkerke et al. 1995, JAS 52, p.2763 Dropplets Fall   |
! #          #LI  Lin  et  al (1983,JCAM 22, p.1076(50) Autoconv. Scheme |
! #          #LO  Liou and Ou (1989, JGR 94, p.8599)    Autoconv. Scheme |
!                                                                        |
! #          #up  Snow Particles: Unrimed Side Planes                    |
! #          #ur  Snow Particles: Aggregates of unrimed radiat. assembl. |
!                                                                        |
! # DEBUG:   #WH  Additional Output (Each Process  is detailed)          |
! # ^^^^^    #WQ  FULL       Output (Each Process  is detailed)          |
! #          #EW  Additional Output (Energy and Water Conservation)      |
!                                                                        |
!   REMARK : the sign '~' indicates that reference must be verified      |
!   ^^^^^^^^                                                             |
!------------------------------------------------------------------------+


      IMPLICIT NONE


!  Global Variables
!  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
      include 'MAR_IO.inc'

      include 'MAR_DY.inc'
      include 'MAR_HY.inc'
c #EW include 'MAR_EW.inc'


!  Input / Output
!  ==============

      include 'MAR_2D.inc'

      integer           io1 ,io5 ,ilmm,imm,jmm,ilmez

!  Debug Variables
!  ~~~~~~~~~~~~~~~
c #wH integer         i_fvv(klon),j_fvv(klon),klfvv,i0fvv,j0fvv,k0fvv
c #wH common/DebuggHy/i_fvv      ,j_fvv      ,klfvv,i0fvv,j0fvv,k0fvv
c #wH character*70    debugH
c #wH character*10    proc_1,proc_2,proc_3,proc_4
c #wH real            procv1,procv2,procv3,procv4
c #wH integer         kv    ,nl
c #wH real            debugV(16,klev)


!  Local  Variables
!  ================

      integer il,kl,itc,itmx,it,ii,io,ilmmi

      real    thir5,eps1,cnor,cnos,cnog,ui50,ri50,
     .        beta,C1_EkM,C2_EkM,tsfo,WatIce,ExpWat,
     .        ExpWa2,qsd0,qi00,qg00,sigmaw,rcrilo,qw00L,
     .        qw00,camart,csud,typww,cc1,cc2,dd0,SSImax

      REAL    argerf,erf,xt
      real    signQw,signQr,signQi,signQs,signCi,signVR,
     .        signVS,signHN,Qw0_OK,Qr0_OK,Qi0_OK,Qs0_OK,
     .        Qi0qOK,Ci0cOK,Ci0_OK,vr__OK,vs__OK,qHoNuc,
     .        qwOK,dpv,dqv,qHeNu1,qHeNu2,qHeNu3,qHeNuc,
     .        qicnd1,qisign,qi1_OK,qicnd2,qicnd,qBerge,
     .        a1,a2,am0,qidep,qvdfci,qSubl1,qSubl2,qSubli,
     .        demde,sat,ab1,ab2,amf,pisub,qisub,qMelt1,
     .        qMelt2,qMelt,qxmlt,qimlt,cimlt,qt,tl,pa_hPa,
     .        es_hPa,qsl,dqt,wqt,ww,coefC2,sig2rh,sigqt,
     .        err,alpha,t1,t2,signFR,cfraOK,SCuLim,
     .        qw_new,dqw,signdq,fac_qv,updatw,dpw,signAU,
     .        AutoOK,signFC,ClouOK,praut,qraut,signCC,qiOK,
     .        qid,a1saut,c1saut,xtsaut,qsaut,cnsaut,ex1,psaut,
     .        sign_W,WbyR_w,sign_R,WbyR_r,WbyROK,pracw,
     .        qracw,WbyS_w,sign_S,WbyS_s,WbySOK,qsacw,
     .        sign_T,Fact_R,SnoA,sign_C,CbyS_c,CbyS_T,
     .        CbySOK,efc,psaci,qsaci,cnsaci,CbyR_c,CbyR_r,
     .        CbyR_T,CbyROK,praci,qraci,CbyS_s,cnraci,
     .        piacr,qiacr,qsacr,RbyS_r,RbyS_s,RbySOK,flR,
     .        SbyR_r,SbyR_s,SbyROK,flS,pracs,qracs,qsacrS,
     .        qracsS,Evap_r,EvapOK,sr,sign_Q,Evap_q,
     .        qsacrR,almr,ab,prevp,qrevp,Evap_s,alms,si,
     .        pssub,qssub,dqamx,Depo_s,SnoM_s,SnoM_T,
     .        SnoMOK,qsmlt,xCoef,ACoef,BCoef,Tc,
     .        Freezr,FreezT,FrerOK,psfr,akps,psmlt,
     .        qsfr,Sedi_c,Sedicc,SediOK,vrmx,vsmx,vimx,
     .        dzmn,xtmn,dwat,dsno,qcloud,pp,pkt0,vmmx,vmmi,
     .        connw,qwclou,dmed0,dmedv,dmede,dmed5,waterb,
     .        dmed,dmed2,dw0,dw4,rwbar,signHV,heavi,vwmx

      real     dqi,dqi1,dqi2,dqi3,qi0S
      real    relhum,argexp,qvs_wi,relCri

      logical  Meyers
      logical  LevkovAUTO,LevkovAUTX
      logical  EmdeKa
      logical  fracSC                       ! SCu Fractional Cloudiness Delobbe
      logical  fraCEP                       ! SCu Fractional Cloudiness ECMWF 

      real    vi(klon,klev)
c #VW real    vw(klon,klev)
      real    vr(klon,klev)
      real    vs(klon,klev)
! #qg real    vh(klon,klev)
      real    psacw(klon,klev),psacr(klon,klev)

c #WH real    wihm1(klev),wihm2(klev),wicnd(klev)
c #WH real    widep(klev),wisub(klev),wimlt(klev)
c #WH real    wwevp(klev)
c #WH real    wraut(klev),wsaut(klev)
c #WH real    wracw(klev),wsacw(klev)
c #WH real    wsaci(klev),wraci(klev),wiacr(klev)
c #WH real    wsacr(klev),wracs(klev),wrevp(klev)
c #WH real    wssub(klev),wsmlt(klev),wsfre(klev)
c #WH real    qiold(klev),qwold(klev)

      real    aM_Nid,bM_Nid,TM_Nid               ! Meyers et al. 1992 JAM
      real    aM_Nic,bM_Nic,TM_Nic,rad_ww        ! Meyers et al. 1992 JAM
c #HM real    TmnNhm,TmxNhm,w_svrl,SplinJ,SplinP ! Levkov et al. 1992 CAM

      real    aa1(31),aa2(31)


!  DATA
!  ====

      data Meyers    /.true./
      data LevkovAUTO/.true./
      data LevkovAUTX/.true./   !  .TRUE. => Levkov      paramet. Bergeron Proc.
!                               ! .FALSE. => Emde&Kahlig paramet. Bergeron Proc.
      data EmdeKa    /.false./
      data fracSC    /.false./ 
         ! fracSC   = .true. 
         !          => Delobbe SCu Fractional Cloudiness Scheme
         !                     may be set up if fracld = .true.
      data fraCEP    /.false./ 

      data thir5 /1.66e0/
!          thir5 = 5 / 3

      data eps1  /1.e-01/

      data cnor/8.0e06/     ! intercept parameter / rain    distribution 
c #LA data cnor/3.0e06/     ! intercept parameter / rain    distribution ! Tun
c #AC data cnos/3.0e06/     ! intercept parameter / snow    distribution
c #XF data cnos/5.0e07/     ! intercept parameter / snow    distribution
      data cnos/3.0e06/     ! intercept parameter / snow    distribution
c #LA data cnos/4.0e06/     ! intercept parameter / snow    distribution ! Tun
      data cnog/4.0e04/     ! intercept parameter / graupel distribution
!                           ! Lin et al.   1983, JCAM 22, p.1068 (1,2 and 3)

      data ui50/0.1e0/
      data ri50/5.e-5/
      data beta/0.5e0/

      data C1_EkM /0.14e-3/ ! Partial Condensation Scheme 
      data C2_EkM /9.75e+0/ ! 
!                           ! Ek and Mahrt 1991, An.Geoph. 9, 716--724

      data tsfo/-35.e0/     ! Levkov et al.1992, C.Atm.Ph.65, p.39
!          tsfo: minimum temperature (deg.C)
!                before instantaneous cloud dropplets freezing
!      
      data WatIce/273.16e0/
      data ExpWat/5.138e0/
      data ExpWa2/6827.e0/
!          Saturation pressure over Water (Dudhia (1989) JAS)

!     data aM_Nid/-0.639 /  !(Meyers et al. 1992, p.713)
!     data bM_Nid/ 0.1296/
cXF
      data aM_Nid/-1.488 / 
      data bM_Nid/ 0.0187/  !(Prenni et al. 2007, p.545, BAMS)
      data TM_Nid/-5.    /
!          Deposition and Condensation-Freezing Nucleation Parameters 
!                               (Meyers et al. 1992, p.713)
      data aM_Nic/-2.80  /
      data bM_Nic/ 0.262 /
      data TM_Nic/-2.    /
!          Contact Freezing Nucleation                     Parameters 
!                               (Meyers et al. 1992, p.713)
c #HM data TmnNhm/-8.    /
c #HM data TmxNhm/-3.    /
c #HM data w_svrl/ 1.    /
!          Hallet-Mossop Theory (see Levkov et al., 1992, 
!                                Contr.Atm.Phy. 65, p.40)
      data qsd0/2.00e-4/
!          qsd0: Smallest Diameter of Particles in the snow Class
!          Ref.: Levkov et al. 1992, Contr. Atm. Phys. 65, p.41, para 1

      data qi00/0.001e0/
!          qi00: maximum ice   crystals concentration
!                before autoconversion of snow flakes occurs
!          Ref.: Lin et al.      1983, JCAM      22, p.1070 (21)

! _hl data qi00/0.0008/
!               0.0008 : compromise when graupels are not included
!          Ref.: Emde and Kahlig 1989, Ann.Geoph. 7, p.408  (18)

      data qg00/0.0006e0/
!          qg00: maximum ice   crystals concentration
!                before autoconversion of graupels occurs
!          Ref.: Lin et al.      1983, JCAM      22, p.1074 (37)

        data sigmaw/0.27e+0/
!            sigmaw=1/3 ln(1/k), where k=0.8d+0 (dispersion parameter)
!           (Martin et al., 1994, JAS 51, p.1823)

c #LO   data rcrilo/10.0e-6/
!            rcrilo:Autoconversion Critical Radius (Liou and Ou, 1989)

c #LI data qw00L/0.002e0/
!          qw00L: maximum cloud droplets concentration
!                before autoconversion occurs
!          Ref.: Lin et al.      1983, JCAM      22, p.1076 (50)

      data qi0S/0.10e-3/ ! critical  solid water mixing ratio (tuned Dome C)
!                                                             (FacFIk >   1)
!          qi0S=0.30e-3  ! critical  solid water mixing ratio (standard)
      data qw00/0.10e-3/
!          qw00 0.30e-3  ! critical liquid water mixing ratio
!          Reference.    ! Sundqvist (1988) : Physically-Based Modelling and
!                          Simulation of Climate and Climatic Change,
!                          M.E. Schlesinger, Ed., Reidel, 433-461.

c #SC data camart/0.8e0/
c #SC data connw /1.2e8/
!          connw : droplets number concentration (m-3)

      data csud/1.0e-4/
!          csud : 1/characteristic time scale for autoconversion (SUND)
!          Ref. : Sundqvist (1988)

      data typww /18.e-15/
!          typww: Typical Cloud Droplet Weight [Ton] (typ. diam.: 32.5 mim)
!                (used with air Density rolv2D [Ton/m3])

      data  cc1/1.200e-04/
      data  cc2/1.569e-12/
      data  dd0/0.15e0/
!           cc1, cc2, dd0: cloud droplets autoconversion parameters


!     ======================================================================
!     Bergeron Process Data (given by Koenig, 1971, J.A.S. 28,p235) ========

      data aa1/0.7939e-07 , 0.7841e-06 , 0.3369e-05 , 0.4336e-05 ,
     .         0.5285e-05 , 0.3728e-05 , 0.1852e-05 , 0.2991e-06 ,
     .         0.4248e-06 , 0.7434e-06 , 0.1812e-05 , 0.4394e-05 ,
     .         0.9145e-05 , 0.1725e-06 , 0.3348e-04 , 0.1725e-04 ,
     .         0.9175e-05 , 0.4412e-05 , 0.2252e-05 , 0.9115e-06 ,
     .         0.4876e-06 , 0.3473e-06 , 0.4758e-06 , 0.6306e-06 ,
     .         0.8573e-06 , 0.7868e-06 , 0.7192e-06 , 0.6513e-06 ,
     .         0.5956e-06 , 0.5333e-06 , 0.4834e-06 /
      data aa2/0.4006e0,  0.4831e0,  0.5320e0,  0.5307e0,  0.5319e0,
     .         0.5249e0,  0.4888e0,  0.3894e0,  0.4047e0,  0.4318e0,
     .         0.4771e0,  0.5183e0,  0.5463e0,  0.5651e0,  0.5813e0,
     .         0.5655e0,  0.5478e0,  0.5203e0,  0.4906e0,  0.4447e0,
     .         0.4126e0,  0.3960e0,  0.4149e0,  0.4320e0,  0.4506e0,
     .         0.4483e0,  0.4460e0,  0.4433e0,  0.4413e0,  0.4382e0,
     .         0.4361e0/

!     Bergeron Process Data (given by Koenig, 1971, J.A.S. 28,p235) ========
!     ======================================================================


!  Upper Limit for specific Humidity
!  =================================

! #kk data SSImax  /  900.0   /
      data SSImax  /  101.0   /
!          SSImax: Maximum Sursaturation % ICE (900 ==> RH=1000%)

      data relCri  /    1.0   /
c #rc      relCri=0.90+0.08*sqrt(max(0.,100.-dx*0.001)/95.)


!  Cloud Droplets Autoconversion Threshold
!  =======================================

c #LI qw00  = qw00L


!  For Blown Snow Particles
!  ========================
c #hb cnos  = 0.1d18
C +...        DO NOT USE unless for specific sensivity experiments
c #hb IF (itexpe.eq.0) write(6,6000)
 6000 format(/,' ****************************************************',
     .       /,' * cnos  = 0.1d18 for PURE BLOWING SNOW EXPERIMENTS *',
     .       /,' *             DO not USE  OTHERWISE                *',
     .       /,' ****************************************************',
     .       /)


!  Update of Temperature
!  =====================

       xt=min(dt,dtHyd)

        DO kl=mzhyd,klev
        DO il=1,klon
          tair2D(il,kl)= pkta2D(il,kl)*pk2D(il,kl)

!  Debug
!  ~~~~~
c #wH     debugH( 1:35) = 'HYDmic: Debugged Variables: Initial'
c #wH     debugH(36:70) = '                                   '
c #wH     proc_1        = 'R.Hum W[%]'
c #wH     procv1        =  0.1*qv2D(il,kl)/(rhcrHY * qvsw2D(il,kl))
c #wH     proc_2        = 'R.Hum I[%]'
c #wH     procv2        =  0.1*qv2D(il,kl)/(rhcrHY * qvsi2D(il,kl))
c #wH     proc_3        = '          '
c #wH     procv3        =  0.
c #wH     proc_4        = '          '
c #wH     procv4        =  0.
c #wh     include 'MAR_HY.Debug'

c #wH     DO kv=1,16
c #wH     debugV(kv,kl) =  0.
c #wH     ENDDO

 6020                format(/,a70
     .                     ,/,13x,'Tc'
     .                       ,10x,'Qv'
     .                       ,10x,'Qw'
     .                       ,10x,'Qi'
     .                        ,9x,'CLD'
     .                       ,10x,'Qs'
     .                       ,10x,'Qr'
     .                        ,2x,a10
     .                        ,2x,a10
     .                        ,2x,a10
     .                        ,2x,a10)
 6021                format(i3,12f12.6)

        END DO
        END DO


!  Vertical Integrated Energy and Water Content
!  ============================================

c #EW   DO il=1,klon
c #EW     enr01D(il ) = 0.0
c #EW     wat01D(il ) = 0.0

c #EW   DO kl=1,klev
c #EW     enr01D(il ) = enr01D(il )
c #EW.                +(tair2D(il,kl)
c #EW.                  -(qw2D(il,kl)+qr2D(il,kl))*r_LvCp
c #EW.                  -(qi2D(il,kl)+qs2D(il,kl))*r_LsCp)
c #EW.                  *  dsigm1(kl)
c #EW     wat01D(il ) = wat01D(il )
c #EW.                +  (qv2D(il,kl)
c #EW.                +   qw2D(il,kl)+qr2D(il,kl)
c #EW.                +   qi2D(il,kl)+qs2D(il,kl)        )
c #EW.                  *  dsigm1(kl)
c #EW   END DO

c #EW     mphy2D(il ) ='                    '
C +...    mphy2D -->   '12345678901234567890'

c #ew     enr01D(il ) = enr01D(il ) * pst2Dn(il ) * grvinv
c #EW     wat01D(il ) = wat01D(il ) * pst2Dn(il ) * grvinv
C +...    wat01D [m]    contains an implicit factor 1.d3 [kPa-->Pa] /ro_Wat

c #EW   END DO

c #WH   vmmx = 0.0


!  Set lower limit on Hydrometeor Concentration
!  ============================================

c #hy   IF (no_vec)                                               THEN

c #hy     DO kl=mzhyd,klev
c #hy     DO il=1,klon

c #hy       IF (qw2D(il,kl).lt.eps9)                              THEN
c #hy           qv2D(il,kl) =  qv2D(il,kl)+qw2D(il,kl)
c #hy         tair2D(il,kl) =tair2D(il,kl)-qw2D(il,kl)*r_LvCp
c #hy          dqw2D(il,kl) = dqw2D(il,kl)-qw2D(il,kl)
c #hy           qw2D(il,kl) =  0.0
c #hy       END IF

c #hy       IF (qr2D(il,kl).lt.eps9)                              THEN
c #hy           qv2D(il,kl) =  qv2D(il,kl)+qr2D(il,kl)
c #hy         tair2D(il,kl) =tair2D(il,kl)-qr2D(il,kl)*r_LvCp
c #hy          dqw2D(il,kl) = dqw2D(il,kl)-qr2D(il,kl)
c #hy           qr2D(il,kl) =  0.0
c #hy       END IF

c #hy       IF (qi2D(il,kl).lt.eps9.or.ccni2D(il,kl).lt.unun)     THEN
c #hy           qv2D(il,kl) =  qv2D(il,kl)+qi2D(il,kl)
c #hy         tair2D(il,kl) =tair2D(il,kl)-qi2D(il,kl)*r_LsCp
c #hy          dqi2D(il,kl) = dqi2D(il,kl)-qi2D(il,kl)
c #hy           qi2D(il,kl) =  0.0
c #hy         ccni2D(il,kl) =  0.0
c #hy       END IF

c #hy       IF (qs2D(il,kl).lt.eps9)                              THEN
c #hy           qv2D(il,kl) =  qv2D(il,kl)+qs2D(il,kl)
c #hy         tair2D(il,kl) =tair2D(il,kl)-qs2D(il,kl)*r_LsCp
c #hy          dqi2D(il,kl) = dqi2D(il,kl)-qs2D(il,kl)
c #hy           qs2D(il,kl) =  0.0
c #hy       END IF
c #hy     END DO
c #hy     END DO

c #hy   ELSE

          DO kl=mzhyd,klev
          DO il=1,klon

            signQw           = sign(unun,  eps9  -     qw2D(il,kl))
            Qw0_OK           =  max(zero,signQw) *     qw2D(il,kl)
              qw2D(il,kl) =      qw2D(il,kl)  -     Qw0_OK
             dqw2D(il,kl) =     dqw2D(il,kl)  -     Qw0_OK
              qv2D(il,kl) =      qv2D(il,kl)  +     Qw0_OK
            tair2D(il,kl) =    tair2D(il,kl)  -     Qw0_OK*r_LvCp

            signQr           = sign(unun,  eps9  -     qr2D(il,kl))
            Qr0_OK           =  max(zero,signQr) *     qr2D(il,kl)
              qr2D(il,kl) =      qr2D(il,kl)  -     Qr0_OK
             dqw2D(il,kl) =     dqw2D(il,kl)  -     Qr0_OK
              qv2D(il,kl) =      qv2D(il,kl)  +     Qr0_OK
            tair2D(il,kl) =    tair2D(il,kl)  -     Qr0_OK*r_LvCp

            signQi           = sign(unun,  eps9  -     qi2D(il,kl))
            Qi0qOK           =  max(zero,signQi)
            signCi           = sign(unun,  unun  -   ccni2D(il,kl))
            Ci0cOK           =  max(zero,signCi)

            Ci0_OK           =  max(     Ci0cOK  ,   Qi0qOK)
            Qi0_OK           =           Ci0_OK  *     qi2D(il,kl)

            ccni2D(il,kl) =    ccni2D(il,kl)  *     Ci0_OK
              qi2D(il,kl) =      qi2D(il,kl)  -     Qi0_OK
             dqi2D(il,kl) =     dqi2D(il,kl)  -     Qi0_OK
              qv2D(il,kl) =      qv2D(il,kl)  +     Qi0_OK
            tair2D(il,kl) =    tair2D(il,kl)  -     Qi0_OK*r_LsCp

            signQs           = sign(unun,  eps9  -     qs2D(il,kl))
            Qs0_OK           =  max(zero,signQs) *     qs2D(il,kl)
              qs2D(il,kl) =      qs2D(il,kl)  -     Qs0_OK
             dqi2D(il,kl) =     dqi2D(il,kl)  -     Qs0_OK
              qv2D(il,kl) =      qv2D(il,kl)  +     Qs0_OK
            tair2D(il,kl) =    tair2D(il,kl)  -     Qs0_OK*r_LsCp

          END DO
          END DO

c #hy   END IF


!  Update of dummy Variables
!  =========================

        DO kl=mzhyd,klev
        DO il=1,klon
          W2xyz1(il,kl)= tair2D(il,kl)-TfSnow
          W2xyz2(il,kl)= 1.e-2*exp(-0.6*W2xyz1(il,kl))
!         W2xyz2       : Ice Crystals Number (Fletcher, 1962)

          W2xyz3(il,kl)= qr2D(il,kl)
          W2xyz4(il,kl)= qs2D(il,kl)
! #qg     W2xyz0(il,kl)= qg2D(il,kl)

c #WH     IF (il.eq.ilmm)                                         THEN
c #WH       qwold(kl) = qw2D(il,kl)
c #WH       qiold(kl) = qi2D(il,kl)
c #WH     END IF
!         old values

        END DO
        END DO


!  Saturation Specific Humidity
!  ============================

!       ***********
        call qsat2D(tair2D,pst2D,tsrf2D,qvsi2D,qvsw2D)
!       ***********

        DO kl=mzhyd,klev
        DO il=1,klon

          W2xyz5(il,kl) = rhcrHY * qvsi2D(il,kl)
!         W2xyz5:  Saturation Specific Humidity over Ice

          W2xyz6(il,kl) = sqrt((pst2Dn(il)+ptopDY)
     .                        /(rolv2D(il,kl)*RDryAi
     .                        * tair2D(il,klev)))


!  Cloud Droplets Fall Velocity (Calcul de la Vitesse Terminale Moyenne)
!  ----------------------------

c #VW     IF (qw2D(il,kl).ge.eps9)                               THEN

c #VW       ccnw2D(il,kl) = 1.2d+8
C +...      ccnw2D: ASTEX case (Duynkerke et al. 1995, JAS 52, p.2763)

c #VW       qwclou        =  qw2D(il,kl) / max(cminHY ,cfra2D(il,kl))
c #VW       dmed0         = 4.5       *sigmaw         *sigmaw
c #VW       dmedv         =12.5       *sigmaw         *sigmaw
c #VW       dmede         = qwclou    *rolv2D(il,kl)
c #VW.                    * 6.0d+0/(pi*ccnw2D(il,kl)*exp(dmed0))
c #VW       dmed5         = exp(thir5*log(dmede))
C +...      dmed          = exp(third*log(dmede))
C +
c #VW       vw(il,kl)  = 1.19d8* pi*ccnw2D(il,kl)*dmed5
c #VW.                    * exp(dmedv)/(24.0*rolv2D(il,kl)*qwclou)
c #VW     ELSE
c #VW       vw(il,kl)  = 0.00
c #VW     END IF


!  Rain           Fall Velocity
!  ----------------------------

            W2xyz7(il,kl) = exp(0.25*log((pi*cnor)
     .                       / (rolv2D(il,kl)*max(eps9,qr2D(il,kl)))))
!           W2xyz7(il,kl) : lambda_r : Marshall-Palmer Distribution Parameter
!                                      for Rain
!                        Note that a simplification occurs
!                        between the 1000. factor of rho, and rho_water=1000.
!           Reference  : Emde and Kahlig 1989, Ann.Geoph. 7, p.407 (3)
!     
c #hy     IF                          (qr2D(il,kl).gt.eps9)       THEN

            signVR      =  sign(unun,  qr2D(il,kl)  - eps9)
            vr__OK      =   max(zero,signVR)
!           vr__OK      =   1.0 if     qr2D(il,kl)  > eps9
!                       =   0.0 otherwise

            vr(il,kl)   = vr__OK*392. *W2xyz6(il,kl)
     .                  / exp(0.8 *log(W2xyz7(il,kl)))
!           vr          : Terminal Fall Velocity for Rain
!                                392  = a Gamma[4+b] / 6
!                                where  a = 842.  and b = 0.8

c #hy     ELSE
c #hy       vr(il,kl)=   0.0
c #hy     END IF


!  Snow Fall Velocity
!  ------------------

c #cn       cnos          = min(2.e8
c #cn.                         ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
            W2xyz8(il,kl) = exp(0.25*log((0.50*pi*cnos)
     .                       / (rolv2D(il,kl)*max(eps9,qs2D(il,kl)))))
!           W2xyz8(il,kl) : lambda_s : Marshall-Palmer distribution parameter
!                                      for Snow Flakes
!                        Note that a partial simplification occurs
!                        between the 1000. factor of rho, and rho_snow=500.
!           Reference  : Emde and Kahlig 1989, Ann.Geoph.      7,  p.407 (3)
!           (rho_snow)   Levkov et al.   1992, Cont.Atm.Phys. 65(1) p.37 (5)

c #hy     IF                          (qs2D(il,kl).gt.eps9)       THEN

            signVS      =  sign(unun,  qs2D(il,kl)  - eps9)
            vs__OK      =   max(zero,signVS)
!           vs__OK      =   1.0 if     qs2D(il,kl)  > eps9
!                       =   0.0 otherwise

            vs(il,kl)   =  vs__OK*2.19 *W2xyz6(il,kl)
     .                   / exp(0.25*log(W2xyz8(il,kl)))
!           vs          : Terminal Fall Velocity for Snow Flakes
!                                 2.19 = c Gamma[4+d] / 6
!                                 where  c = 4.836 = 0.86 *1000.**0.25
!                                              and d = 0.25
!                     (Locatelli and Hobbs, 1974, JGR: table 1 p.2188:
!                      Graupellike Snow Flakes of Hexagonal Type)

c #up       vs(il,kl)   =  vs__OK*2976.*W2xyz6(il,kl)
c #up.                   / exp(0.99*log(W2xyz8(il,kl)))
!                  OR             2976.= c Gamma[4+d] / 6
!                                 where  c = 755.9 = 0.81 *1000.**0.99
!                                              and d = 0.99
!                     (Locatelli and Hobbs, 1974, JGR: table 1 p.2188:
!                      Unrimed Side Planes)

c #ur       vs(il,kl)   =  vs__OK*20.06*W2xyz6(il,kl)
c #ur.                   / exp(0.41*log(W2xyz8(il,kl)))
!                  OR             2976.= c Gamma[4+d] / 6
!                                 where  c = 755.9 = 0.69 *1000.**0.41
!                                              and d = 0.41
!                     (Locatelli and Hobbs, 1974, JGR: table 1 p.2188:
!                      Aggregates of unrimed radiating assemblages)

c #hy     ELSE
c #hy       vs(il,kl)   =   0.0
c #hy     END IF


!  Graupel Fall Velocity
!  ---------------------

! #qg     IF (qg2D(il,kl).ge.eps9)                                THEN
!         Do'nt forget "#hy" option !
! #qg       W2xyz9(il,kl) =exp(0.250*log((pi*cnog)
! #qg.                    /(rolv2D(il,kl)*max(eps9,qg2D(il,kl)))))
!           W2xyz9(il,kl) : lambda_g : Marshall-Palmer distribution parameter
!                                      for Graupel
!                        Note that a simplification occurs
!                        between the 1000. factor of rho, and rho_ice=1000.
! #qg           vh(il,kl) = 25.1 *W2xyz6(il,kl)
! #qg.             / exp(0.57*log(W2xyz9(il,kl)))
!           vh         : Terminal Fall Velocity for Graupels
!                        25.1 = c Gamma[4+d] / 6
!                        where  c = 4.836 = 1.10 *1000.**0.57 and d = 0.57
!                        (Locatelli and Hobbs, 1974, JGR: table 1 p.2188:
!                         Hexagonal Graupel)

! #qg     ELSE
! #qg           vh(il,kl) =   0.0
! #qg       W2xyz9(il,kl) =   0.0
! #qg     END IF

        END DO
        END DO


!===============================================================================

!  Microphysical Processes affecting non Precipitating Cloud Particles
!  ===================================================================

!  Homogeneous Nucleation by Cloud Dropplets Solidification  ! BFREWI
!  Reference: Emde and Kahlig 1989, Ann.Geoph. 7, p.407 (11) ! Levkov (24) p.40
!  ---------------------------------------------------------

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH         qHoNuc      =  0.
c #wH         qHeNuc      =  0.
c #wH         qwOK        =  0.

c #hy       IF                        (W2xyz1(il,kl).lt.tsfo)     THEN

              signHN      = -sign(unun,W2xyz1(il,kl)  - tsfo)
              qHoNuc      =   max(zero,signHN)
!             qHoNuc      =   1.0 if   W2xyz1(il,kl)  < tsfo
!                         =   0.0 otherwise

c #EW        IF(qHoNuc.gt.epsi)                                   THEN ! ctr
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(01:01) = 'i'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF                                                    ! ctr

                qwOK        =   qw2D(il,kl) *                qHoNuc
                qi2D(il,kl) =   qi2D(il,kl) +                qwOK
              ccni2D(il,kl) = ccni2D(il,kl) + rolv2D(il,kl) *qwOK/typww
              tair2D(il,kl) = tair2D(il,kl) + r_LcCp        *qwOK
c #WQ         write(6,*) 'Qihm1',  qw2D(il,kl),
c #WQ.                  ' Qi'   ,  qi2D(il,kl),
c #WQ.                  ' CcnI' ,ccni2D(il,kl),itexpe,il,kl
c #WH         IF (il.eq.ilmm) wihm1(kl) =   qwOK

                qw2D(il,kl) = qw2D(il,kl) - qwOK

c #hy       END IF


!  Heterogeneous Freezing of Cloud Droplets                  ! BNUFWI
!  Reference: Levkov et al., 1992 (21) p.40                  ! Levkov (21) p.40
!  ----------------------------------------   

! #qf #hy   IF                        (W2xyz1(il,kl).lt.0.00)     THEN

! #qf         signHN      = -sign(unun,W2xyz1(il,kl)  - 0.00)
! #qf         qHeNuc      =   max(zero,signHN)
!             qHeNuc      =   1.0 if   W2xyz1(il,kl)  < 0.00dgC
!                         =   0.0 otherwise

! #qf         argexp      = min(max(argmin,-W2xyz1(il,kl)),argmax)
! #qf         qHeNuc      =         qHeNuc*(exp(argexp)   -  1.  ) 
! #qf.                                     *  qw2D(il,kl) * 100.0 *typww
! #qf         qHeNuc      = min(    qHeNuc ,  qw2D(il,kl)        )
              
! #qf           qi2D(il,kl) =   qi2D(il,kl) +               qHeNuc
! #qf         ccni2D(il,kl) = ccni2D(il,kl) + rolv2D(il,kl)*qHeNuc/typww
! #qf         tair2D(il,kl) = tair2D(il,kl) + r_LcCp       *qHeNuc
! #qf           qw2D(il,kl) = qw2D(il,kl)   -               qHeNuc


!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Homo+Hetero Nucleation by Droplets '
c #wH         debugH(36:70)   = 'Solidification (BFREWI+BNUFWI)     '
c #wH         proc_1          = 'BFREWI    '
c #wH         procv1          =  qHoNuc
c #wH         proc_2          = 'BNUFWI    '
c #wH         procv2          =  qHeNuc
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(01,kl)   =  qwOK+qHeNuc

! #qf #hy   END IF


!===============================================================================

!  Homogeneous Sublimation                                   ! XXXXXX
!  Reference: Emde and Kahlig 1989, Ann.Geoph. 7, p.407 (12) ! Levkov
!  ---------------------------------------------------------

c #EW        IF(qHoNuc.gt.epsi)                                   THEN ! ctr
c #EW          mauxEW        =  mphy2D(il )
c #EW          mauxEW(02:02) = 'I'
c #EW          mphy2D(il )   =  mauxEW
c #EW        END IF                                                    ! ctr

c #hs          dpv = (qv2D(il,kl)-W2xyz5(il,kl))
c #hs.             /(1.00+1.733e7*W2xyz5(il,kl)
c #hs.                          /(tair2D(il,kl)*tair2D(il,kl)))
!                         1.733e7=Ls*Ls*0.622/Cpa/Ra with Ls = 2833600 J/kg

c #hs          dpv = qHoNuc*max(zero,dpv)
c #hs          dqv =                 dpv

c #hs           qi2D(il,kl) =   qi2D(il,kl) +                   dqv
c #hs          dqi2D(il,kl) =  dqi2D(il,kl) +                   dqv
!             ccni2D(il,kl) : NO VARIATION
c #hs           qv2D(il,kl) =   qv2D(il,kl) -                   dqv
c #hs         tair2D(il,kl) = tair2D(il,kl) +       r_LsCp    * dqv

!  Full Debug
!  ~~~~~~~~~~
c #WQ         write(6,*) 'Qihm2',   dqv,
c #WQ.                  ' Qi'   ,  qi2D(il,kl),
c #WQ.                  ' CcnI' ,ccni2D(il,kl),itexpe,il,kl
c #WH         if (il.eq.ilmm) wihm2(kl) = dqv

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Emde and Kahlig: Homogeneous Sublim'
c #wH         debugH(36:70)   = 'ation                              '
c #wH         proc_1          = 'dQv   g/kg'
c #wH         procv1          =  dqv
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = 'CCNI/1.e15'
c #wH         procv4          =  ccni2D(il,kl)*1.e-18
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(01,kl)   =  dqv + debugV(01,kl)

          END DO
          END DO


!===============================================================================

!  Nucleation  I: Deposition & Condensation-Freezing Nucleat.
!  Source       : Water Vapor                                ! BNUCVI
!  Reference: Meyers et al., 1992, JAM 31, (2.4) p.712       ! Levkov (20) p.40
!  -----------------------------------------------------------

        IF (Meyers)                                               THEN
          DO kl=mzhyd,klev
          DO il=1,klon

c #wH             qHeNuc        =  0.
c #wH             qicnd1        =  0.
c #wH             dqi1          =  0.
c #wH             dqi2          =  0.
c #wH             dqi3          =  0.

c #hy       IF   (W2xyz1(il,kl).lt.TM_Nid)                        THEN
                  signHN        = -sign(unun,W2xyz1(il,kl) - TM_Nid)
                  qHeNu1        =   max(zero,signHN)
!                 qHeNu1        =   1.0 if   W2xyz1(il,kl) < TM_Nid
!                               =   0.0 otherwise

                  dqv           =                qv2D(il,kl) 
     .                                        -W2xyz5(il,kl)    ! Sursaturat.
                  dqv           =          max(zero   , dqv)

c #hy         IF (dqv.gt.0.)                                      THEN
                  signHN        =  sign(unun,dqv   )
                  qHeNu3        =   max(zero,signHN)
!                 qHeNu3        =   1.0 if     qv2D(il,kl) > W2xyz5(il,kl)
!                               =   0.0 otherwise

                  qHeNuc        =   qHeNu1   * qHeNu3

                  qicnd1        =  1.0e2 * dqv/W2xyz5(il,kl)    ! Sursaturat.%I
                  qicnd1        =          min(qicnd1       ,SSImax )
                  qicnd1        =  1.0e3 * exp(aM_Nid           ! Meyers et al.
     .                                        +bM_Nid * qicnd1) ! 1992 JAM, 2.4
                  qicnd1        =          max(qicnd1
     .                                        -ccni2D(il,kl),zero  )
     .                                      *  qHeNuc
                  ccni2D(il,kl) =              ccni2D(il,kl)
     .                                      +  qicnd1
                  dqi           =   1.e-15  *  qicnd1
     .                                      /  rolv2D(il,kl)
!                                   1.e-15  =  0.001 * Initial Ice Crystal Mass
                  dqi           =          min(dqi    , dqv)
                   qi2D(il,kl) =                qi2D(il,kl) + dqi
                  dqi2D(il,kl) =               dqi2D(il,kl) + dqi
                   qv2D(il,kl) =                qv2D(il,kl) - dqi
                 tair2D(il,kl) =              tair2D(il,kl) + dqi*r_LsCp
                   dqi1         =                             dqi

c #hy         END IF
c #hy       END IF


!  Nucleation  I:              Contact     -Freezing Nucleat.
!  Source       : Cloud Dropplets                            ! BSPRWI
!  Reference: Meyers et al., 1992, JAM 31, (2.6) p.713       ! Levkov (20) p.40
!  -----------------------------------------------------------

c #wH             qicnd1        =  0.
c #wH             qicnd2        =  0.
c #wH             dqi           =  0.

c #hy       IF   (  qw2D(il,kl).gt.0.)                            THEN
                  signHN        =  sign(unun,  qw2D(il,kl))
                  qHeNu3        =   max(zero,signHN)
C +...            qHeNu3        =   1.0 if     qw2D(il,kl) > 0.
C +                             =   0.0 otherwise

c #hy         IF (W2xyz1(il,kl).lt.TM_Nic)                        THEN
                  signHN        = -sign(unun,W2xyz1(il,kl) - TM_Nic)
                  qHeNu2        =   max(zero,signHN)
!                 qHeNu2        =   1.0 if   W2xyz1(il,kl) < TM_Nic
!                               =   0.0 otherwise

                  qHeNuc        =   qHeNu1   * qHeNu3

                  qicnd1        =   1.e3 *     qHeNuc           ! Contact-Freez
     .                                   * exp(aM_Nic           ! Potent.Nuclei
     .                                        -bM_Nic           ! Meyers et al.
     .                                        *W2xyz1(il,kl))   ! 1992 JAM, 2.6
                  rad_ww        =  (1.e3     * rolv2D(il,kl)    ! Drop.  Radius
     .                                       *   qw2D(il,kl)
     .                                       * .2e-11       ) ** 0.33
!                 .2e-11        =   1. / (1.2e+8         * 1.e3 * 4.19)
!                                         ccnw2D (ASTEX)   ro_w   4 pi /3
                  qicnd2        = 603.2e+3  *  qicnd1 * rad_ww  ! Levkov et al.
     .                                      *  rolv2D(il,kl)    ! 1992 CAM,(23)
!                 603.2e3       =   4.0e-7  *  4 pi   * 1.2e+8  * 1.e3
!                                   DFar                ccnw2D    fact(rolv)
                  ccni2D(il,kl) =              ccni2D(il,kl)
     .                                      +  qicnd2
                  dqi           =   1.e-15  *  qicnd2
     .                                      /  rolv2D(il,kl)
!                                   1.e-15  =  1.0e-3 * Ice Crystal Mass
                  dqi           =          min( qw2D(il,kl) , dqi)
                   qi2D(il,kl)  =               qi2D(il,kl) + dqi    
                   qw2D(il,kl)  =               qw2D(il,kl) - dqi
                 tair2D(il,kl)  =             tair2D(il,kl) + dqi*r_LcCp
                   dqi2         =                             dqi

c #hy         END IF
c #hy       END IF


!  Nucleation II: Hallett-Mossop Ice-Multiplication Process  ! BSPRWI
!  Reference: Levkov et al., 1992, Contr.Atm.Ph.65,(25) p.40 ! Levkov (25) p.40
!  -----------------------------------------------------------

c #hm       IF   (W2xyz1(il,kl).lt.TmxNhm.AND.
c #hm.            W2xyz1(il,kl).gt.TmnNhm.AND.
c #hm.            wair2D(il,kl).gt.w_svrl    )                      THEN
c #HM             signHN        = -sign(unun,W2xyz1(il,kl) - TmxNhm)
c #HM             qHeNu1        =   max(zero,signHN)
!                 qHeNu1        =   1.0 if   W2xyz1(il,kl) < TmxNhm
!                               =   0.0 otherwise

c #HM             signHN        =  sign(unun,W2xyz1(il,kl) - TmnNhm)
c #HM             qHeNu2        =   max(zero,signHN)
!                 qHeNu2        =   1.0 if   W2xyz1(il,kl) > TmnNhm
!                               =   0.0 otherwise

c #HM             signHN        =  sign(unun,wair2D(il,kl) - w_svrl)
c #HM             qHeNu3        =   max(zero,signHN)
!                 qHeNu3        =   1.0 if   wair2D(il,kl) > w_svrl
!                               =   0.0 otherwise

c #cn             cnos    = min(2.e8
c #cn.                         ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
c #HM             SplinJ = 1.358e12 *qw2D(il,kl) *cnos 
c #HM.                   /        (W2xyz8(il,kl)**.33)
!                 1.358e12=pi   *Gamma(3.5) *g   *ro_s /(3 *Cd  *4.19e-12)
!                        [=3.14 *3.3233625  *9.81*0.1  /(3 *0.6 *4.19e-12)]
c #HM             SplinP = 0.003 * (1. - 0.05 *SplinJ) * qHeNu1 *qHeNu2
c #HM.                                                 * qHeNu3
c #HM             SplinP =      max(zero,      SplinP)

c #HM             dqi    =          1.e-15  *  SplinP
c #HM.                                      /  rolv2D(il,kl)
!                                   1.e-15  =  1.0e-3 * Ice Crystal Mass
c #HM             SplinP = (min(1.0,qs2D(il,kl)/max(dqi,eps9))) *SplinP
c #HM             ccni2D(il,kl) =              ccni2D(il,kl)
c #HM.                                      +  SplinP
c #HM             dqi    =      min(qs2D(il,kl),  dqi)
c #HM              qi2D(il,kl)  =   qi2D(il,kl) + dqi    
c #HM             dqi2D(il,kl)  =  dqi2D(il,kl) + dqi    
c #HM              qs2D(il,kl)  =   qs2D(il,kl) - dqi
c #HM              dqi3         =                 dqi
c #hm       END IF


!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Meyers: Nucl. I, Depot & Cond-Freez'
c #wH         debugH(36:70)   = 'Nucl. / Freez / Nucl. II / Bergeron'
c #wH         proc_1          = 'dQi1 Meyer'
c #wH         procv1          =  dqi1
c #wH         proc_2          = 'dQi2 Meyer'
c #wH         procv2          =  dqi2
c #wH         proc_3          = 'dQi Ha-Mos'
c #wH         procv3          =  dqi3
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(02,kl)   =  dqi1 + dqi2 + dqi3

          END DO
          END DO


!===============================================================================

        ELSE

!===============================================================================

!  Ice Crystals Nucleation Process between 0.C and -35.C
!  (each crystal has a mass equal or less than 10d-12 kg)
!  Reference: Emde and Kahlig 1989, Ann.Geoph. 7, p.408 (13)
!  ---------------------------------------------------------

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH         qicnd1        =  0.
c #wH         qicnd2        =  0.
c #wH         qicnd         =  0.

c #hy       IF                          (W2xyz1(il,kl).gt.tsfo)   THEN

              signHN        =  sign(unun,W2xyz1(il,kl)  - tsfo)
              qHeNu1        =   max(zero,signHN)
!             qHeNu1        =   1.0 if   W2xyz1(il,kl)  > tsfo
!                           =   0.0 otherwise

c #hy       IF                          (W2xyz1(il,kl).lt.0.e0)   THEN

              signHN        = -sign(unun,W2xyz1(il,kl)        )
              qHeNu2        =   max(zero,signHN)
!             qHeNu2        =   1.0 if   W2xyz1(il,kl)  < 0.e0
!                           =   0.0 otherwise

c #hy       IF                            (qv2D(il,kl).gt.W2xyz5(il,kl))
c #hy.                                                            THEN

              signHN        =  sign(unun,  qv2D(il,kl)  - W2xyz5(il,kl))
              qHeNu3        =   max(zero,signHN)
!             qHeNu3        =   1.0 if     qv2D(il,kl)  > W2xyz5(il,kl)
!                           =   0.0 otherwise

              qHeNuc        =   qHeNu1 * qHeNu2 * qHeNu3

c #EW        IF(qHeNuc.gt.epsi)                                   THEN ! ctr
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(03:03) = 'I'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF                                                    ! ctr

              qicnd1 = qHeNuc * 1.d-15 * W2xyz2(il,kl) / rolv2D(il,kl)
!             qicnd1 : amount of nucleated ice crystals (first  condition)

              qisign = sign(unun,qicnd1-qi2D(il,kl))
              qi1_OK =  max(zero,qisign)
              qicnd1 =           qicnd1*qi1_OK

              qicnd2 = (  qv2D(il,kl)-W2xyz5(il,kl))
     .                /(1.0d0+1.733d7*W2xyz5(il,kl)
     .                /(tair2D(il,kl)*tair2D(il,kl)))
              qicnd2 =  qHeNuc*max(zero,qicnd2)
!             qicnd2 : amount of nucleated ice crystals (second condition)

              qicnd  = min(qicnd1,qicnd2)

               qi2D(il,kl) =   qi2D(il,kl) +                qicnd
              dqi2D(il,kl) =  dqi2D(il,kl) +                qicnd
             ccni2D(il,kl) = ccni2D(il,kl) + rolv2D(il,kl) *qicnd 
     .                                                     *1.e15
               qv2D(il,kl) =   qv2D(il,kl) -                qicnd
             tair2D(il,kl) = tair2D(il,kl) + r_LsCp        *qicnd

!  Full Debug
!  ~~~~~~~~~~
c #WQ        write(6,*) 'QiCnd', qicnd,
c #WQ.                 ' Qi'   ,  qi2D(il,kl),
c #WQ.                 ' CcnI' ,ccni2D(il,kl),itexpe,il,kl
c #WH        IF (il.eq.ilmm) wicnd(kl) = qicnd

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Emde and Kahlig: Ice Crystals Nucle'
c #wH         debugH(36:70)   = 'ation Process between 0.C and -35.C'
c #wH         proc_1          = 'Qicnd1    '
c #wH         procv1          =  qicnd1
c #wH         proc_2          = 'Qicnd2    '
c #wH         procv2          =  qicnd2
c #wH         proc_3          = 'Qicnd g/kg'
c #wH         procv3          =  qicnd
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(02,kl)   =  qicnd


c #hy       END IF
c #hy       END IF
c #hy       END IF


          END DO
          END DO

        END IF


!==============================================================================

!  Bergeron Process (water vapor diffusion-deposition on ice crystals)
!  Reference: Koenig          1971, J.A.S.    28, p.235
!             Emde and Kahlig 1989, Ann.Geoph. 7, p.408 (14)
!  ---------------------------------------------------------

        IF (.NOT.LevkovAUTX)                                        THEN

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH         qBerge        =  0.
c #wH         qidep         =  0.
c #wH         qicnd         =  0.

c #hy       IF                          (  qi2D(il,kl).gt.eps9
c #hy.         .AND.                     W2xyz1(il,kl).lt.0.e0)   THEN

              signHN        =  sign(unun,  qi2D(il,kl)  - eps9)
              qBerge        =   max(zero,signHN)
!             qBerge        =   1.0 if     qi2D(il,kl)  > eps9
!                           =   0.0 otherwise

              signHN        = -sign(unun,W2xyz1(il,kl)        )
              qHeNuc        =   max(zero,signHN)
!             qHeNuc        =   1.0 if   W2xyz1(il,kl)  < 0.e0
!                           =   0.0 otherwise

              qBerge        =   qHeNuc * qBerge

c #EW        IF(qBerge.gt.epsi)                                   THEN ! ctr
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(04:04) = 'i'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF                                                    ! ctr

              itc   = abs(W2xyz1(il,kl)-unun)
              itc   = min(itc,31)
              itc   = max(itc, 1)
              a1    = aa1(itc)
              a2    = aa2(itc)

              am0   =  1.d+3*rolv2D(il,kl)*qi2D(il,kl)/W2xyz2(il,kl)
              amf   = (a1*(1.0-a2)*xt+am0**(1.0-a2))**(1.0/(1.0-a2))
!             amf   :  analytical integration of
!                    (14) p.408 Emde and Kahlig 1989, Ann.Geoph. 7
              qidep = (1.d-3*W2xyz2(il,kl)/rolv2D(il,kl))*(amf-am0)
              qidep =  max(zero,qidep)

              qicnd =  max(zero,qw2D(il,kl))
!             qicnd :  to avoid the use of qw2D < 0.

              qidep      =  qBerge*min(qicnd,    qidep)
              qi2D(il,kl)=  qi2D(il,kl)         +qidep
!           ccni2D(il,kl):NO VARIATION

              qw2D(il,kl)=  qw2D(il,kl)         -qidep
            tair2D(il,kl)=tair2D(il,kl)+r_LcCp  *qidep

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'QiDep', qidep,
c #WQ.                ' Qi'   ,  qi2D(il,kl),
c #WQ.                ' CcnI' ,ccni2D(il,kl),itexpe,il,kl
c #WH       if (il.eq.ilmm) widep(kl)= qidep

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Bergeron Process (water vapor diffu'
c #wH         debugH(36:70)   = 'sion-deposition on ice crystals)   '
c #wH         proc_1          = 'qBerge ICE'
c #wH         procv1          =  qBerge
c #wH         proc_2          = 'Qicnd g/kg'
c #wH         procv2          =  qicnd
c #wH         proc_3          = 'Qidep g/kg'
c #wH         procv3          =  qidep
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(02,kl)   =  qidep + debugV(02,kl)


c #hy       END IF

          END DO
          END DO

        END IF


!===============================================================================

!  Ice Crystals Sublimation                                  ! BDEPVI
!  Reference: Emde and Kahlig, 1989 p.408 (15)               ! Levkov (27) p.40
!  -------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qisub           =  0.

c #hy     IF                          (W2xyz5(il,kl).gt.qv2D(il,kl))
c #hy.                                                            THEN

            qvdfci        =            W2xyz5(il,kl) -  qv2D(il,kl)
! #pp       signHN        =  sign(unun,qvdfci)
! #pp       qSubl1        =   max(zero,signHN)
!           qSubl1        =   1.0 if   W2xyz5(il,kl) >  qv2D(il,kl)
!                         =   0.0 otherwise

c #hy     IF                            (qi2D(il,kl).gt.eps9)     THEN

            signHN        =  sign(unun,  qi2D(il,kl)  - eps9)
            qSubl2        =   max(zero,signHN)
!           qSubl2        =   1.0 if     qi2D(il,kl)  > eps9
!                         =   0.0 otherwise

            qSubli        =            qSubl2
! #pp.                    *   qSubl1

c #EW      IF(qSubli.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(05:05) = 'V'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

            demde = 1.1d+4
            sat   = qv2D(il,kl) /     W2xyz5(il,kl)
            ab1   = 6.959d+11   /    (tair2D(il,kl)*tair2D(il,kl))
!                   6.959e+11
!                 = [Ls=2833600J/kg] * Ls / [kT=0.025W/m/K] / [Rv=461.J/kg/K]
!                                            kT: Air thermal Conductivity
            ab2   = 1.0d0 / (1.875d-2*rolv2D(il,kl)*W2xyz5(il,kl))
!                            1.875d-5: Water Vapor Diffusivity in Air
            pisub = (1-sat) *4.d0 *demde *W2xyz2(il,kl) /(ab1+ab2)
            qisub = pisub *xt
            qisub = max(qisub, -qv2D(il,kl))  ! H2O deposit.limit = H2O content
            qisub = min(qisub,  qi2D(il,kl))  ! qi  sublim. limit = qi  content
            qisub = min(qisub,  qvdfci     )  ! qi  sublim. limit = Saturation
     .                * qSubli

                qi2D(il,kl) =   qi2D(il,kl) -           qisub
               dqi2D(il,kl) =  dqi2D(il,kl) -           qisub
                qv2D(il,kl) =   qv2D(il,kl) +           qisub
              tair2D(il,kl) = tair2D(il,kl) - r_LsCp   *qisub

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'QiSub', qisub,
c #WQ.                ' Qi'   ,  qi2D(il,kl),
c #WQ.                ' CcnI' ,ccni2D(il,kl),itexpe,il,kl
c #WH       IF (il.eq.ilmm) wisub(kl) = qisub

c #hy     END IF
c #hy     END IF

C +--Debug
C +  ~~~~~
c #wH         debugH( 1:35)   = 'Emde and Kahlig: Ice Crystals Subli'
c #wH         debugH(36:70)   = 'mation                             '
c #wH         proc_1          = 'Qisub g/kg'
c #wH         procv1          =  qisub
c #wH         proc_2          = 'R.Hum I[%]'
c #wH         procv2          =  0.1 * sat
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(03,kl)   = -qisub

        END DO
        END DO

        DO kl=mzhyd,klev
        DO il=1,klon
            IF (qi2D(il,kl).le.0.e0)                              THEN
                qi2D(il,kl) =  0.e0
              ccni2D(il,kl) =  0.e0
            END IF
        END DO
        END DO


!===============================================================================

!  Ice Crystals Instantaneous Melting
!  ----------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qimlt           =  0.
c #wH       cimlt           =  0.

c #hy     IF                          (W2xyz1(il,kl).gt.0.e0)     THEN

            signHN        =  sign(unun,W2xyz1(il,kl)        )
            qMelt1        =   max(zero,signHN)
!           qMelt1        =   1.0 if   W2xyz1(il,kl) >  0.e0
!                         =   0.0 otherwise

c #hy     IF                            (qi2D(il,kl).gt.eps9)     THEN

            signHN        =  sign(unun,  qi2D(il,kl) -  eps9)
            qMelt2        =   max(zero,signHN)
!           qMelt2        =   1.0 if     qi2D(il,kl) >  eps9
!                         =   0.0 otherwise

            qMelt         =   qMelt1 * qMelt2

c #EW      IF(qMelt .gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(06:06) = 'w'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

            qxmlt =        W2xyz1(il,kl) / r_LcCp
            qimlt =    min(  qi2D(il,kl) ,          qxmlt) *qMelt
            cimlt         =ccni2D(il,kl) *          qimlt
     .                  /max(qi2D(il,kl) , eps9)
              qi2D(il,kl) =  qi2D(il,kl) -          qimlt
            ccni2D(il,kl) =ccni2D(il,kl) -          cimlt
              qw2D(il,kl) =  qw2D(il,kl) +          qimlt
            tair2D(il,kl) =tair2D(il,kl) - r_LcCp  *qimlt

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'QiMlt', qimlt,
c #WQ.                ' Qi'   ,  qi2D(il,kl),
c #WQ.                ' CcnI' ,ccni2D(il,kl),itexpe,il,kl
c #WH       IF (il.eq.ilmm) wimlt(kl) = qimlt

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Emde and Kahlig: Ice Crystals Insta'
c #wH         debugH(36:70)   = 'ntaneous Melting                   '
c #wH         proc_1          = 'Qimlt g/kg'
c #wH         procv1          =  qimlt
c #wH         proc_2          = 'cimlt /e15'
c #wH         procv2          =  cimlt*1.e-18
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(04,kl)   = -qimlt

        END DO
        END DO


!===============================================================================

!  Water Vapor Condensation / Evaporation (Fractional Cloudiness)
!  Reference: Laurent Delobbe Thesis (Ek&Mahrt91)
!  --------------------------------------------------------------

          DO kl=mzhyd,klev             ! Zeroing needed since
          DO il=1,klon                 ! cfra2D  build  from
            cfra2D(il,kl) =  0.0       ! a maximization process
!           cfra2D: Cloud Fraction     !

          END DO
          END DO

        IF (fracld.AND.fracSC)                                    THEN

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH         dqw           =  0.

c #hy       IF (W2xyz1(il,kl).ge.tsfo)                            THEN

c #EW        IF(W2xyz1(il,kl).ge.tsfo)                            THEN ! ctr
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(07:07) = 'W'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF                                                    ! ctr

              signHN        =  sign(unun,W2xyz1(il,kl) - tsfo)
              qHeNu1        =   max(zero,signHN)
!             qHeNu1        =   1.0 if   W2xyz1(il,kl) > tsfo
!                           =   0.0 otherwise

              qt =   qv2D(il,kl) +              qw2D(il,kl)
!             qt : Total Water Mixing Ratio

              tl = tair2D(il,kl) -  r_LvCp    * qw2D(il,kl)
!             tl : Liquid Temperature

!  Saturation specific humidity over water,
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ corresponding to liquid temperature
!                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              pa_hPa =(pst2Dn(il)  * sigma(kl) + ptopDY) * 10.0d0
              es_hPa = 6.1078d0 * exp (ExpWat*  log(WatIce     /tl))
     .                          * exp (ExpWa2*(unun/WatIce-unun/tl))
!             Dudhia (1989) JAS, (B1) and (B2) p.3103
!             See also Pielke (1984), p.234 and Stull (1988), p.276

              qsl    = .622d0*es_hPa /(pa_hPa - .378d0*es_hPa)
!             Saturation Vapor Specific Concentration over Water
!             (even for temperatures less than freezing point)

!  Partial Condensation/Scheme
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
              dqt = qv2D(il ,MIN(kl+1,klev))-qv2D(il,kl)
     .            + qw2D(il ,MIN(kl+1,klev))-qw2D(il,kl)
              wqt = TUkv2D(il,kl)*dqt
     .           /(gplv2D(il,kl+1)-gplv2D(il,kl))*gravit

              ww  = 0.66d+0 * ect_2D(il,kl)
!             ww  : Vertical Velocity Variance

              coefC2 = wqt/(sqrt(ww)*qsl)
              sig2rh = C1_EkM + C2_EkM * coefC2 * coefC2
!             sig2rh : Relative Humidity Variance
!                     (Ek and Mahrt, 1991, An. Geoph., 9, 716--724)

              sigqt  = sqrt(sig2rh) *qsl
!             sigqt  : Total Water       Variance

              argerf = (qt-qsl)/(1.414d+0*sigqt)
              err    = erf(argerf)

              cfra2D(il,kl) = 0.5d+0 * (1.d+0 + err)
!             cfra2D: Cloud Fraction

              alpha  = 1.d+0/(1.d+0+1.349d7*qsl/(tl*tl))
              t1     = sigqt/sqrt(pi+pi)* exp(-min(argerf*argerf
     .                                            ,argmax       ))
              t2     = cfra2D(il,kl)*(qt-qsl)

              signFR = sign(unun,cfra2D(il,kl) - cminHY)
              cfraOK =  max(zero,signFR)
!             cfraOK =   1.0 if  cfra2D(il,kl) > cminHY
!                    =   0.0 otherwise

              cfra2D(il,kl) =    cfra2D(il,kl) * cfraOK * qHeNu1
              qw_new        =  alpha * (t1+t2) * cfraOK
!             qw_new        :  Mesh Averaged Liquid Water Mixing Ratio

              dqw           =    qw_new   -  qw2D(il,kl)

!  Vectorisation of the Atmospheric Water Update
!  ~~~~~~~~~~~~~+-------------------------------------------+
!               |       if (dqw.gt.0.d0)             then   |
!               |        dqw = min(qv2D(il,kl), dqw)        |
!               |       else                                |
!               |        dqw =-min(qw2D(il,kl),-dqw)        |
!               |       end if                              |
!               +-------------------------------------------+

              signdq        =    sign(unun,dqw)
              fac_qv        =     max(zero,signdq)
              updatw        =    fac_qv *    qv2D(il,kl)
     .                  + (1.d0 -fac_qv)*    qw2D(il,kl)
! #kk         SCuLim        =        exp(min(0.,300.-tair2D(il,kl))) ! SCu Lim.
              dqw           =    signdq *min(updatw,signdq*dqw)
     .                          *qHeNu1            
! #kk.                                             *SCuLim           ! SCu
! #kk         cfra2D(il,kl) =    cfra2D(il,kl)                       !
! #kk.                                             *SCuLim           ! Limitor

!  Update of qv2D, qw2D and tair2D
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                qw2D(il,kl) =   qw2D(il,kl) +             dqw
               dqw2D(il,kl) =  dqw2D(il,kl) +             dqw
                qv2D(il,kl) =   qv2D(il,kl) -             dqw
              tair2D(il,kl) = tair2D(il,kl) + r_LvCp    * dqw

!  Full Debug
!  ~~~~~~~~~~
c #WQ         write(6,*) 'QwEvp',dqw,itexpe,il,kl
c #WH         if (il.eq.ilmm) wwevp(kl)     = dqw

c #hy       END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Delobbe: Condensation              '
c #wH         debugH(36:70)   = '                                   '
c #wH         proc_1          = 'dQw   g/kg'
c #wH         procv1          =  dqw
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(05,kl)   =  dqw

          END DO
          END DO


!===============================================================================

!  Water Vapor Condensation / Evaporation
!  Reference: Emde and Kahlig 1989, Ann.Geoph. 7, p.407 (7)
!  --------------------------------------------------------

        ELSE

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH         dqw           =  0.

c #hy       IF (W2xyz1(il,kl).ge.tsfo)                            THEN

c #EW        IF(W2xyz1(il,kl).ge.tsfo)                            THEN ! ctr
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(07:07) = 'W'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF                                                    ! ctr
C +
              signHN        =  sign(unun,W2xyz1(il,kl) - tsfo)
              qHeNu1        =   max(zero,signHN)
!             qHeNu1        =   1.0 if   W2xyz1(il,kl) > tsfo
!                           =   0.0 otherwise

              dpw = (qv2D(il,kl)  -qvsw2D(il,kl)*rhcrHY)
     .            / (1.0d0+1.349d7*qvsw2D(il,kl)
     .                           /(tair2D(il,kl)*tair2D(il,kl)))
!                          1.349e7=Lv*Lv*0.622/Cpa/Ra with Lv = 2500000 J/kg

              dqw = dpw

!  Vectorisation of the Atmospheric Water Update
!  ~~~~~~~~~~~~~+-------------------------------------------+
!               |       if (dqw.gt.0.d0)             then   |
!               |        dqw = min(qv2D(il,kl), dqw)        |
!               |       else                                |
!               |        dqw =-min(qw2D(il,kl),-dqw)        |
!               |       end if                              |
!               +-------------------------------------------+

              signdq        =    sign(unun,dqw)
              fac_qv        =     max(zero,signdq)
              updatw        =    fac_qv *    qv2D(il,kl)
     .                  + (1.d0 -fac_qv)*    qw2D(il,kl)
              dqw           =    signdq *min(updatw,signdq*dqw)
     .                          *qHeNu1

!  Update of qv2D, qw2D and tair2D
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                qw2D(il,kl) =   qw2D(il,kl) +             dqw
               dqw2D(il,kl) =  dqw2D(il,kl) +             dqw
                qv2D(il,kl) =   qv2D(il,kl) -             dqw
              tair2D(il,kl) = tair2D(il,kl) + r_LvCp    * dqw
!            [Ls=2500000J/kg]/[Cp=1004J/kg/K]=2490.04

!  Full Debug
!  ~~~~~~~~~~
c #WQ         write(6,*) 'QwEvp',dqw,itexpe,il,kl
c #WH         if (il.eq.ilmm) wwevp(kl) = dqw

c #hy       END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Emde and Kahlig: Water Vapor Conden'
c #wH         debugH(36:70)   = 'sation / Evaporation               '
c #wH         proc_1          = 'dQw   g/kg'
c #wH         procv1          =  dqw
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(05,kl)   =  dqw

          END DO
          END DO

        END IF


!===============================================================================

!  Fractional  Cloudiness ! Guess may be computed (Ek&Mahrt91 fracSC=.T.)
!  ====================== ! Final value  computed  below

! #sc   IF (fracld.AND..NOT.fracSC)                                 THEN
        IF (fracld)                                                 THEN
         IF(fraCEP) THEN ! ECMWF Large Scale Cloudiness
                         ! ----------------------------
          DO kl=mzhyd,klev
          DO il=1,klon
              cfra2D(il,kl) =             (qi2D(il,kl) +   qw2D(il,kl)
     .                                    +qs2D(il,kl) *  0.33
     .                 * (1.-min(1.,exp((tair2D(il,kl) -258.15)*0.1))))
     .                 / (0.02     *     qvsw2D(il,kl)                )
              cfra2D(il,kl) =min(1.000 , cfra2D(il,kl))
              cfra2D(il,kl) =max(0.001 , cfra2D(il,kl))
     .                     *max(0.,sign(1.,qi2D(il,kl) +   qw2D(il,kl)
     .                                    +qs2D(il,kl) -3.E-9         ))
          END DO
          END DO
         ELSE            ! XU and Randall  1996, JAS 21, p.3099 (4)
                         ! ----------------------------
          DO kl=mzhyd,klev
          DO il=1,klon
              qvs_wi=                                    qvsw2D(il,kl)
c #wi         qvs_wi=max(eps9,((qi2D(il,kl)+qs2D(il,kl))*qvsi2D(il,kl)
c #wi.                         +qw2D(il,kl)             *qvsw2D(il,kl))
c #wi.                /max(eps9,qi2D(il,kl)+qs2D(il,kl) +  qw2D(il,kl)))
              relhum=  min(relCri,      max(qv2D(il,kl) ,qv_MIN)
     .                                                 / qvs_wi)
              argexp=  (  (relCri  -relhum)            * qvs_wi)
     .                         **   0.49
              argexp        =   min(100.* (qi2D(il,kl) +   qw2D(il,kl)
     .                                    +qs2D(il,kl) *  0.33
     .                 * (1.-min(1.,exp((tair2D(il,kl) -258.15)*0.1))))
     .                                /max(eps9        , argexp       )
     .                             ,argmax                             )
 
              cfra2D(il,kl) =      (     relhum       ** 0.25         )
     .                         *   (1.  -   exp(-argexp)              )
          END DO
          END DO
         END IF

        ELSE
! #sc   ELSE IF (      .NOT.fracld)                                 THEN
! #sc     IF               (fracSC) stop 'fracSC set up when fracld NOT'
          DO kl=mzhyd,klev
          DO il=1,klon
              qcloud        =              qi2D(il,kl) +   qw2D(il,kl)
c #hy       IF                            (qcloud     .gt.eps9)     THEN

              signQW        =  sign(unun,  qcloud       - eps9)
              cfra2D(il,kl) =   max(zero,signQW)
!             cfra2D(il,kl) =   1.0 if     qcloud       > eps9
!                           =   0.0 otherwise

c #hy       END IF
          END DO
          END DO

        END IF


!  Debug
!  ~~~~~
c #wH     DO kl=mzhyd,klev
c #wH     DO il=1,klon
c #wH         debugH( 1:35) = 'Fractional Cloudiness (XU .OR. CEP)'
c #wH         debugH(36:70) = '                                   '
c #wH         proc_1        = '          '
c #wH         procv1        =  0.
c #wH         proc_2        = '          '
c #wH         procv2        =  0.
c #wH         proc_3        = '          '
c #wH         procv3        =  0.
c #wH         proc_4        = '          '
c #wH         procv4        =  0.     
c #wh         include 'MAR_HY.Debug'
c #wH     END DO
c #wH     END DO


!===============================================================================

!  Autoconversion Processes (i.e., generation of precipitating particles)
!  ======================================================================

!  Cloud Droplets Autoconversion
!  Reference: Lin et al.      1983, JCAM      22, p.1076 (50)
!  ----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qraut         =   0.0

c #hy     IF                            (qw2D(il,kl).gt.eps9)     THEN

            signAU        =  sign(unun,  qw2D(il,kl)  - eps9)
            AutoOK        =   max(zero,signAU)
!           AutoOK        =   1.0 if     qw2D(il,kl)  > eps9
!                         =   0.0 otherwise

c #hy     IF                          (cfra2D(il,kl).gt.cminHY)   THEN

            signFC        =  sign(unun,cfra2D(il,kl)  - cminHY)
            ClouOK        =   max(zero,signFC)
!           ClouOK        =   1.0 if   cfra2D(il,kl)  > cminHY
!                         =   0.0 otherwise

            AutoOK        =  AutoOK  * ClouOK

c #EW        IF(AutoOK.gt.epsi)                                   THEN ! ctr
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(08:08) = 'r'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF                                                    ! ctr

!  Sundqvist      (1988, Schlesinger, Reidel, p.  433) Autoconversion Scheme
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            dqw    = AutoOK *qw2D(il,kl)/qw00/max(cminHY,cfra2D(il,kl))
            praut  = AutoOK *qw2D(il,kl)*csud*   (1.-exp(-min(dqw*dqw
     .                                                       ,argmax)))
     .                                       /max(cminHY,cfra2D(il,kl))

!  Liou and Ou    (1989, JGR  94, p. 8599) Autoconversion Scheme
!  Boucher et al. (1995, JGR 100, p.16395) ~~~~~~~~~~~~~~~~~~~~~
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #LO       ccnw2D(il,kl) = 1.2e+8 ! ASTEX (Duynkerke&al.1995, JAS 52, p.2763)
! #LO       ccnw2D(il,kl) = 1.e+11 !       (polluted air, Rogers&Yau 89, p.90)
      
c #LO       qwclou        =  qw2D(il,kl) / cfra2D(il,kl)
c #LO       dmed0         = 4.5d0        *sigmaw         *sigmaw
c #LO       dmede         = qwclou       *rolv2D(il,kl)
c #LO.                    *  6.d+0/pi    /ccnw2D(il,kl)  /exp(dmed0)
c #LO       dmed          = exp(third*log(dmede))
c #LO       dmed2         =               dmed           *dmed
c #LO       dw0           = 8.0d+0       *sigmaw         *sigmaw
c #LO       dw4           = exp(dw0)     *dmed2          *dmed2
c #LO       rwbar         = 0.5d+0       *sqrt(sqrt(dw4))

c #LO       signHV        = sign(unun, rwbar-rcrilo)
c #LO       heavi         =  max(zero,signHV       )
!           heavi         : Heaviside Function

c #LO       praut         = AutoOK *cfra2D(il,kl) * heavi *4.09d6 *pi
c #LO.                             *ccnw2D(il,kl) * dw4   *qwclou

!  Lin et al.(1983) Autoconversion Scheme
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #LI       dqw       = AutoOK * (qw2D(il,kl)-qw00)
c #LI       praut     =          dqw*dqw*dqw/(cc1*dqw+1000.d0*cc2/dd0)

            qraut     = praut * xt
            qraut     = min(qraut,qw2D(il,kl))
            qw2D(il,kl) = qw2D(il,kl) - qraut
            qr2D(il,kl) = qr2D(il,kl) + qraut

c #WQ       write(6,*) 'QrAut',qraut,itexpe,il,kl
c #WH       if (il.eq.ilmm) wraut(kl) = qraut

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983) Autoconversion Sch'
c #wH         debugH(36:70)   = 'eme                                '
c #wH         proc_1          = 'Qraut g/kg'
c #wH         procv1          =  qraut
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(06,kl)   =  qraut

        END DO
        END DO


!  Conversion from Cloud Ice Crystals to Snow Flakes
!  Reference: Levkov et al.   1992, Contr.Atm.Phys. 65, p.41
!  ---------------------------------------------------------

        IF (LevkovAUTO)                                           THEN


!  Depositional Growth: Ice Crystals  => Snow Flakes     (BDEPIS)
!  Reference: Levkov et al.   1992, Contr.Atm.Phys. 65, p.41 (28)
!  --------------------------------------------------------------

         IF(LevkovAUTX)                                           THEN

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH         qsaut       =   0.0

c #hy       IF                          (qi2D(il,kl).gt.eps9)     THEN

              signAU      =  sign(unun,  qi2D(il,kl)  - eps9)
              AutoOK      =   max(zero,signAU)
!             AutoOK      =   1.0 if     qi2D(il,kl)  > eps9
!                         =   0.0 otherwise

c #hy       IF                        (ccni2D(il,kl).gt.1.e0)     THEN

              signCC      =  sign(unun,ccni2D(il,kl)  - 1.e0)
              ClouOK      =   max(zero,signCC)
!             ClouOK      =   1.0 if   ccni2D(il,kl)  > 1.e0
!                         =   0.0 otherwise

              AutoOK      =  AutoOK  * ClouOK
                qiOK      =  AutoOK  *   qi2D(il,kl)

!  Pristine Ice Crystals Diameter
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              qid   = 0.156 *exp(third*log(thous*rolv2D(il,kl)
     .                                *max(eps9 ,  qi2D(il,kl))
     .                                /max(unun ,ccni2D(il,kl))))
!             qid   : Pristine Ice Crystals Diameter
!                     Levkov et al. 1992, Contr. Atm. Phys. 65, (5) p.37
!                     where 6/(pi*ro_I)**1/3 ~ 0.156

!  Deposition Time Scale
!  ~~~~~~~~~~~~~~~~~~~~~
              sat   = max(epsq, qv2D(il,kl))   / W2xyz5(il,kl)
c #a1         a1saut= max(eps9, sat-1.)
c #a1.              /(0.702e12/(tair2D(il,kl)*tair2D(il,kl))
!                     0.702e12 ~ 0.701987755e12 = (2.8345e+6)**2/0.0248/461.5
!                                                  Ls_H2O    **2/Ka    /Rw
c #a1.               +1.0     /(2.36e-2 *rolv2D(il,kl)*qv2D(il,kl)*sat))
!                               2.36e-2= 2.36e-5      *1.e3
!                                        Dv

              xtsaut= 0.125   *(qsd0*qsd0-qid*qid)
     .              *(0.702e12/(tair2D(il,kl)*tair2D(il,kl))
!                     0.702e12 ~ 0.701987755e12 = (2.8345e+6)**2/0.0248/461.5
!                                                  Ls_H2O    **2/Ka    /Rw
     .               +1.0     /(2.36e-2 *rolv2D(il,kl)
     .                           *max(epsq,qv2D(il,kl))*sat))
!                               2.36e-2= 2.36e-5       *1.e3
!                                        Dv

!  Deposition
!  ~~~~~~~~~~
               qsaut =    xt *qiOK*(sat-1.)/xtsaut
               qsaut =   min( qi2D(il,kl)  , qsaut)
               qsaut =   max(-qs2D(il,kl)  , qsaut)
                qi2D(il,kl) = qi2D(il,kl)  - qsaut
                qs2D(il,kl) = qs2D(il,kl)  + qsaut

c #hy       END IF
c #hy       END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983) Depositional Growt'
c #wH         debugH(36:70)   = 'h                                  '
c #wH         proc_1          = 'Qsaut g/kg'
c #wH         procv1          =  qsaut
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(07,kl)   =  qsaut

          END DO
          END DO

         END IF


!  Ice Crystals Aggregation           => Snow Flakes     (BAGRIS)
!  Reference: Levkov et al.   1992, Contr.Atm.Phys. 65, p.41 (31)
!  --------------------------------------------------------------

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH          qsaut      =   0.0
c #wH         xtsaut      =   0.0

c #hy       IF                          (qi2D(il,kl).gt.eps9)     THEN

              signAU      =  sign(unun,  qi2D(il,kl)  - eps9)
              AutoOK      =   max(zero,signAU)
!             AutoOK      =   1.0 if     qi2D(il,kl)  > eps9
!                         =   0.0 otherwise

c #hy       IF                        (ccni2D(il,kl).gt.1.e0)     THEN

              signCC      =  sign(unun,ccni2D(il,kl)  - 1.e0)
              ClouOK      =   max(zero,signCC)
!             ClouOK      =   1.0 if   ccni2D(il,kl)  > 1.e0
!                         =   0.0 otherwise

              AutoOK      =  AutoOK  * ClouOK
                qiOK      =  AutoOK  *   qi2D(il,kl)

c #EW        IF(AutoOK.gt.epsi)                                   THEN
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(09:09) = 's'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF

!  Pristine Ice Crystals Diameter
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              qid   = 0.156 *exp(third*log(thous*rolv2D(il,kl)
     .                                 *max(eps9,  qi2D(il,kl))
     .                                 /max(unun,ccni2D(il,kl))))
!             qid   : Pristine Ice Crystals Diameter
!                     Levkov et al. 1992, Contr. Atm. Phys. 65, (5) p.37
!                     where [6/(pi*ro_I)]**1/3 ~ 0.156

!  Time needed for Ice Crystals Diameter to reach Snow Diameter Threshold
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              c1saut = max(eps9,qiOK)*rolv2D(il,kl) *35.0
     .                *exp(third *log(rolv2D(il,klev)/rolv2D(il,kl)))

              xtsaut =-6.d0*log(qid/qsd0) /c1saut
              xtsaut = max(xt,             xtsaut) ! qi fully used if xtsaut<xt

!  Time needed for Ice Crystals Diameter to reach Snow Diameter Threshold
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(ALTERNATE PARAMETERIZATION)~
! #nt         xtsaut =-2.0 * (3.0*log(    qid        /qsd0)  
! #nt.                       +    log(max(qi2D(il,kl),eps9))) /c1saut
! #nt         xtsaut = max(eps9,xtsaut)

!  Aggregation
!  ~~~~~~~~~~~
               qsaut =     xt*qiOK        /xtsaut
               qsaut =   min( qi2D(il,kl) , qsaut)
               qsaut =   max(-qs2D(il,kl) , qsaut)
                qi2D(il,kl) = qi2D(il,kl) - qsaut
                qs2D(il,kl) = qs2D(il,kl) + qsaut


!  Decrease of Ice Crystals Number                       (BAGRII)
!  Reference: Levkov et al.   1992, Contr.Atm.Phys. 65, p.41 (34)
!  --------------------------------------------------------------

              ccni2D(il,kl) = ccni2D(il,kl) * exp(-0.5*c1saut*xt)

c #WQ          write(6,*) 'QsAut', qsaut,
c #WQ.                   ' Qi'   ,  qi2D(il,kl),
c #WQ.                   ' CcnI' ,ccni2D(il,kl),itexpe,il,kl
c #WH         if (il.eq.ilmm) wsaut(kl) = qsaut

c #hy       END IF
c #hy       END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983) Ice Crystals Aggre'
c #wH         debugH(36:70)   = 'gation                             '
c #wH         proc_1          = 'xtsaut sec'
c #wH         procv1          =  xtsaut
c #wH         proc_2          = 'Qsaut g/kg'
c #wH         procv2          =  qsaut
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(07,kl)   =  qsaut + debugV(07,kl)

          END DO
          END DO


!===============================================================================

!  Ice Crystals Autoconversion => Snow Flakes
!  Reference: Lin et al.      1983, JCAM      22, p.1070 (21)
!             Lin et al.      1983, JCAM      22, p.1074 (38)
!             Emde and Kahlig 1989, Ann.Geoph. 7, p. 408 (18)
!  ----------------------------------------------------------

        ELSE IF (EmdeKa)                                          THEN

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH            qsaut      =  0.0
c #wH           cnsaut      =  0.0

c #hy       IF (qi2D(il,kl) .ge. qi00)                            THEN

c #EW        IF(qi2D(il,kl) .ge. qi00)                            THEN
c #EW         mauxEW        =  mphy2D(il )
c #EW         mauxEW(09:09) = 's'
c #EW         mphy2D(il )   =  mauxEW
c #EW        END IF

               ex1          = 0.025d0* W2xyz1(il,kl)      ! W2 = t?[K]
               psaut        = 0.001d0*(  qi2D(il,kl)-qi00)*exp(ex1)
               qsaut        =     psaut  * xt
               qsaut        = max(qsaut, zero       )
               qsaut        = min(qsaut, qi2D(il,kl))
              cnsaut        = ccni2D(il,kl) * qsaut
     .                       /max(qi00 , qi2D(il,kl))
              ccni2D(il,kl) = ccni2D(il,kl) -cnsaut
                qi2D(il,kl) =   qi2D(il,kl) - qsaut
                qs2D(il,kl) =   qs2D(il,kl) + qsaut
c #WQ         write(6,*) 'QsAut',qsaut,itexpe,il,kl
c #WH         IF (il.eq.ilmm) wsaut(kl)=qsaut
c #hy       END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Emde and Kahlig  Ice Crystals Autoc'
c #wH         debugH(36:70)   = 'onversion                          '
c #wH         proc_1          = 'Qsaut g/kg'
c #wH         procv1          =  qsaut
c #wH         proc_2          = 'cnsaut/e15'
c #wH         procv2          =  cnsaut*1.e-18
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(07,kl)   =  qsaut

          END DO
          END DO


!  Sundqvist      (1988, Schlesinger, Reidel, p.  433) Autoconversion Scheme
!  -------------------------------------------------------------------------

        ELSE

          DO kl=mzhyd,klev
          DO il=1,klon

c #wH            qsaut      =  0.0
c #wH           cnsaut      =  0.0

c #hy       IF                          (qi2D(il,kl).gt.eps9)     THEN

              signAU      =  sign(unun,  qi2D(il,kl)  - eps9)
              AutoOK      =   max(zero,signAU)
!             AutoOK      =   1.0 if     qi2D(il,kl)  > eps9
!                         =   0.0 otherwise

              dqi   = AutoOK *qi2D(il,kl)/qi0S
! #mf.                                        /max(cminHY,cfra2D(il,kl))
              psaut = AutoOK *qi2D(il,kl)*csud  
     .                       *(1.-exp(-dqi*dqi))
! #mf.                                        *max(cminHY,cfra2D(il,kl))
              qsaut =                       psaut * xt
              qsaut =   min(  qi2D(il,kl) , qsaut)
              qsaut =   max(  zero        , qsaut)
             cnsaut =       ccni2D(il,kl) * qsaut 
     .                                  /max(qi2D(il,kl),eps9)
             ccni2D(il,kl) = ccni2D(il,kl) -cnsaut
               qi2D(il,kl) =   qi2D(il,kl) - qsaut
               qs2D(il,kl) =   qs2D(il,kl) + qsaut

c #hy       END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Sundqvist (1988) Ice Crystals Autoc'
c #wH         debugH(36:70)   = 'onversion                          '
c #wH         proc_1          = 'Qsaut g/kg'
c #wH         procv1          =  qsaut
c #wH         proc_2          = 'cnsaut/e15'
c #wH         procv2          =  cnsaut*1.e-18
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(07,kl)   =  qsaut

          END DO
          END DO
        END IF


!  Ice Crystals Autoconversion => Graupels
!  ---------------------------------------

! #qg   DO kl=mzhyd,klev
! #qg   DO il=1,klon

! #qg     IF (qi2D(il,kl) .ge. qg00)                              THEN

! #qg       ex1       = 0.090*  W2xyz1(il,kl)
! #qg       pgaut     = 0.001*(   qi2D(il,kl)-qg00)*exp(ex1)
! #qg       qgaut     =     pgaut * xt
! #qg       qgaut     = max(qgaut,zero       )
! #qg       qgaut     = min(qgaut,qi2D(il,kl))
! #qg       qi2D(il,kl) = qi2D(il,kl) - qgaut
! #qg       qg2D(il,kl) = qg2D(il,kl) + qgaut

! #qg     END IF

! #qg   END DO
! #qg   END DO


!===============================================================================

!  Accretion Processes (i.e. increase in size of precipitating particles
!  ====================      through a collision-coalescence process)===
!                      ==============================================

!  Accretion of Cloud Droplets by Rain
!  Reference: Lin et al.      1983, JCAM      22, p.1076 (51)
!             Emde and Kahlig 1989, Ann.Geoph. 7, p. 407 (10)
!  ----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qracw       =   0.0

c #hy     IF                          (qw2D(il,kl).gt.eps9)       THEN

            sign_W      =  sign(unun,  qw2D(il,kl)  - eps9)
            WbyR_w      =   max(zero,sign_W)
!           WbyR_w      =   1.0 if     qw2D(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (W2xyz3(il,kl).gt.eps9)       THEN

            sign_R      =  sign(unun,W2xyz3(il,kl)  - eps9)
            WbyR_r      =   max(zero,sign_R)
!           WbyR_r      =   1.0 if   W2xyz3(il,kl)  > eps9
!                       =   0.0 otherwise

            WbyROK      =  WbyR_w *  WbyR_r

c #EW      IF(WbyROK.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(10:10) = 'r'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

            pracw = 3104.28d0  * cnor * W2xyz6(il,kl)
     .       *qw2D(il,kl)/exp(3.8d0*log(W2xyz7(il,kl)))
!                   3104.28 = a pi Gamma[3+b] / 4
!                      where  a = 842. and b = 0.8
            qracw =     pracw * xt    * WbyROK
            qracw = min(qracw,qw2D(il,kl))

            qw2D(il,kl) = qw2D(il,kl) - qracw
            qr2D(il,kl) = qr2D(il,kl) + qracw

c #WQ       write(6,*) 'Qracw',qracw,itexpe,il,kl
c #WH       if (il.eq.ilmm) wracw(kl) = qracw

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Accretion of Clou'
c #wH         debugH(36:70)   = 'd Droplets by Rain                 '
c #wH         proc_1          = 'Qracw g/kg'
c #wH         procv1          =  qracw
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(08,kl)   =  qracw

        END DO
        END DO


!  Accretion of Cloud Droplets by Snow Flakes
!  Reference: Lin et al.      1983, JCAM      22, p.1070 (24)
!  ----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       snoA        =   0.0

c #hy     IF                          (qw2D(il,kl).gt.eps9)       THEN

            sign_W      =  sign(unun,  qw2D(il,kl)  - eps9)
            WbyS_w      =   max(zero,sign_W)
!           WbyS_w      =   1.0 if     qw2D(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (W2xyz4(il,kl).gt.eps9)       THEN

            sign_S      =  sign(unun,W2xyz4(il,kl)  - eps9)
            WbyS_s      =   max(zero,sign_S)
!           WbyS_s      =   1.0 if   W2xyz4(il,kl)  > eps9
!                       =   0.0 otherwise

            WbySOK      =  WbyS_w *  WbyS_s

c #EW      IF(WbySOK.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(11:11) = 's'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

c #cn       cnos        = min(2.e8
c #cn.                       ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
            psacw(il,kl)= 9.682d0 * cnos * W2xyz6(il,kl)
     .         *qw2D(il,kl)/exp(3.25d0*log(W2xyz8(il,kl)))
!           psacw         : taken into account in the snow melting process
!                           (if positive temperatures)
!                           9.682 = c pi  Gamma[3+d] / 4
!                           where   c = 4.836 and d = 0.25
!                     (Locatelli and Hobbs, 1974, JGR: table 1 p.2188:
!                      Graupellike Snow Flakes of Hexagonal Type)

c #up       psacw(il,kl)= 3517.   * cnos * W2xyz6(il,kl)
c #up.         *qw2D(il,kl)/exp(3.99d0*log(W2xyz8(il,kl)))
!           psacw         : taken into account in the snow melting process
!                           (if positive temperatures)
!                           3517. = c pi  Gamma[3+d] / 4
!                           where   c = 755.9 and d = 0.99
!                     (Locatelli and Hobbs, 1974, JGR: table 1 p.2188:
!                      Unrimed Side Planes)

c #ur       psacw(il,kl)= 27.73   * cnos * W2xyz6(il,kl)
c #ur.         *qw2D(il,kl)/exp(3.41d0*log(W2xyz8(il,kl)))
!           psacw         : taken into account in the snow melting process
!                           (if positive temperatures)
!                           27.73 = c pi  Gamma[3+d] / 4
!                           where   c = 11.718and d = 0.41
!                     (Locatelli and Hobbs, 1974, JGR: table 1 p.2188:
!                      Aggregates of unrimed radiating assemblages)

            qsacw       =     psacw(il,kl) *xt * WbySOK
            qsacw       = min(qsacw,qw2D(il,kl))

            sign_T      =  sign(unun,tair2D(il,kl) - TfSnow)
            Fact_R      =   max(zero,sign_T)
!           Fact_R      =   1.0 if   tair2D(il,kl) > TfSnow
!                       =   0.0 otherwise

              qw2D(il,kl) =   qw2D(il,kl) -                   qsacw
              qr2D(il,kl) =   qr2D(il,kl) +         Fact_R  * qsacw
              SnoA        =                 (1.d0 - Fact_R) * qsacw
              qs2D(il,kl) =   qs2D(il,kl) +                   SnoA
            tair2D(il,kl) = tair2D(il,kl) +  r_LcCp         * SnoA
!           Negative Temperatures => Latent Heat is released by Freezing

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'Qsacw',qsacw,itexpe,il,kl
c #WH       if (il.eq.ilmm) wsacw(kl) = qsacw

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Accretion of Clou'
c #wH         debugH(36:70)   = 'd Droplets by Snow Particles       '
c #wH         proc_1          = 'Qsacw g/kg'
c #wH         procv1          =  SnoA
c #wH         proc_3          = '          '
c #wH         procv2          =  0.
c #wH         proc_2          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(09,kl)   =  SnoA

        END DO
        END DO


!  Accretion of Cloud Droplets by Graupels (Dry Growth Mode)
!  Reference: Lin et al.      1983, JCAM      22, p.1075 (40)
!             Emde and Kahlig 1989, Ann.Geoph. 7, p. 407 (~20)
!  -----------------------------------------------------------

! #qg   DO kl=mzhyd,klev
! #qg   DO il=1,klon

! #qg     IF                          (qw2D(il,kl).gt.eps9)       THEN

! #qg       sign_W      =  sign(unun,  qw2D(il,kl)  - eps9)
! #qg       WbyG_w      =   max(zero,sign_W)
!           WbyG_w      =   1.0 if     qw2D(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg     IF                          (qg2D(il,kl).gt.eps9)       THEN

! #qg       sign_G      =  sign(unun,  qg2D(il,kl)  - eps9)
! #qg       WbyG_g      =   max(zero,sign_G)
!           WbyG_g      =   1.0 if     qg2D(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg       WbyGOK      =  WbyG_w *  WbyG_g

! #qg     IF                        (tair2D(il,kl).lt.TfSnow)     THEN

! #qg       sign_T      = -sign(unun,tair2D(il,kl)  - TfSnow)
! #qg       Fact_G      =   max(zero,sign_T)
!           Fact_G      =   1.0 if   tair2D(il,kl)  > TfSnow
!                       =   0.0 otherwise

! #qg        pgacw      = ???
! #qg        qgacw      =     pgacw * xt * WbyGOK
! #qg        qgacw      = min(qgacw,qw2D(il,kl))

! #qg         qw2D(il,kl) =   qw2D(il,kl) -       qgacw
! #qg         qg2D(il,kl) =   qg2D(il,kl) +       qgacw
! #qg       tair2D(il,kl) = tair2D(il,kl) +r_LcCp  gacw

! #qg     END IF
! #qg     END IF
! #qg     END IF

! #qg   END DO
! #qg   END DO


!  Accretion of Cloud Ice      by Snow Particles
!  Reference: Lin et al.      1983, JCAM      22, p.1070 (22)
!  ----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qsaci       =   0.0 
c #wH       cnsaci      =   0.0

c #hy     IF                          (qi2D(il,kl).gt.eps9)       THEN

            sign_C      =  sign(unun,  qi2D(il,kl)  - eps9)
            CbyS_c      =   max(zero,sign_C)
!           CbyS_c      =   1.0 if     qi2D(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (W2xyz4(il,kl).gt.eps9)       THEN

            sign_S      =  sign(unun,W2xyz4(il,kl)  - eps9)
            CbyS_s      =   max(zero,sign_S)
!           CbyS_s      =   1.0 if   W2xyz4(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (tair2D(il,kl).lt.TfSnow)     THEN

            sign_T      = -sign(unun,tair2D(il,kl)  - TfSnow)
            CbyS_T      =   max(zero,sign_T)
!           CbyS_T      =   1.0 if   tair2D(il,kl)  < TfSnow
!                       =   0.0 otherwise

            CbySOK      =  CbyS_c *  CbyS_s        * CbyS_T

c #EW      IF(CbySOK.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(12:12) = 's'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

            efc   =  exp(0.025d0*W2xyz1(il,kl))
!           efc   : Collection Efficiency
!                   Lin et al. 1983 JCAM 22 p.1070 (23)

c #cn       cnos  = min(2.e8
c #cn.                 ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
            psaci = efc * 9.682d0 * cnos * W2xyz6(il,kl)
     .         *qi2D(il,kl)/exp(3.25d0*log(W2xyz8(il,kl)))

c #up       psaci = efc * 3517.d0 * cnos * W2xyz6(il,kl)
c #up.         *qi2D(il,kl)/exp(3.99d0*log(W2xyz8(il,kl)))

c #ur       psaci = efc * 27.73d0 * cnos * W2xyz6(il,kl)
c #ur.         *qi2D(il,kl)/exp(3.41d0*log(W2xyz8(il,kl)))

            qsaci =     psaci * xt * CbySOK
            qsaci = min(qsaci,qi2D(il,kl))

            cnsaci        = ccni2D(il,kl) * qsaci /max(qi2D(il,kl),eps9)
            ccni2D(il,kl) = ccni2D(il,kl) -cnsaci
              qi2D(il,kl) =   qi2D(il,kl) - qsaci
              qs2D(il,kl) =   qs2D(il,kl) + qsaci

c #WQ       write(6,*) 'Qsaci',qsaci,itexpe,il,kl
c #WH       if (il.eq.ilmm) wsaci(kl) = qsaci

c #hy     END IF
c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Accretion of Clou'
c #wH         debugH(36:70)   = 'd Ice by Snow Particles            '
c #wH         proc_1          = 'Qsaci g/kg'
c #wH         procv1          =  qsaci
c #wH         proc_2          = 'CNsaci/e15'
c #wH         procv2          =  cnsaci*1.e-18
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(10,kl)   =  qsaci

        END DO
        END DO


!  Accretion of Cloud Ice      by Graupel (Cloud Ice Sink)
!  Reference: Lin et al.      1983, JCAM      22, p.1075 (41)
!             Emde and Kahlig 1989, Ann.Geoph. 7, p. 407 (~19)
!  -----------------------------------------------------------

! #qg   DO kl=mzhyd,klev
! #qg   DO il=1,klon

! #qg     IF                          (qw2D(il,kl).gt.eps9)       THEN

! #qg       sign_C      =  sign(unun,  qi2D(il,kl)  - eps9)
! #qg       CbyG_c      =   max(zero,sign_C)
!           CbyG_c      =   1.0 if     qi2D(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg     IF                          (qg2D(il,kl).gt.eps9)       THEN

! #qg       sign_G      =  sign(unun,  qg2D(il,kl)  - eps9)
! #qg       CbyG_g      =   max(zero,sign_G)
!           CbyG_g      =   1.0 if     qg2D(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg     IF                        (tair2D(il,kl).lt.TfSnow)     THEN

! #qg       sign_T      = -sign(unun,tair2D(il,kl)  - TfSnow)
! #qg       Fact_G      =   max(zero,sign_T)
!           Fact_G      =   1.0 if   tair2D(il,kl)  < TfSnow
!                       =   0.0 otherwise

! #qg       CbyGOK      =  CbyG_c *  CbyG_g        * Fact_G

! #qg       pgaci = ???
! #qg       qgaci =     pgaci *xt *CbyGOK
! #qg       qgaci = min(qgaci,qi2D(il,kl))

! #qg       qi2D(il,kl) = qi2D(il,kl) - qgaci
! #qg       qg2D(il,kl) = qg2D(il,kl) + qgaci

! #qg     END IF
! #qg     END IF
! #qg     END IF

! #qg   END DO
! #qg   END DO


!  Accretion of Cloud Ice      by Rain (Cloud Ice Sink)
!  Reference: Lin et al.      1983, JCAM      22, p.1071 (25)
!  ----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qraci       =   0.0 
c #wH       qiacr       =   0.0 

c #hy     IF                          (qi2D(il,kl).gt.eps9)       THEN

            sign_C      =  sign(unun,  qi2D(il,kl)  - eps9)
            CbyR_c      =   max(zero,sign_C)
!           CbyR_c      =   1.0 if     qi2D(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (W2xyz3(il,kl).gt.eps9)       THEN

            sign_R      =  sign(unun,W2xyz3(il,kl)  - eps9)
            CbyR_r      =   max(zero,sign_R)
!           CbyR_r      =   1.0 if   W2xyz3(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (tair2D(il,kl).lt.TfSnow)     THEN

            sign_T      = -sign(unun,tair2D(il,kl)  - TfSnow)
            CbyR_T      =   max(zero,sign_T)
!           CbyR_T      =   1.0 if   tair2D(il,kl)  < TfSnow
!                       =   0.0 otherwise

            CbyROK      =  CbyR_c *  CbyR_r         * CbyR_T

c #EW      IF(CbyROK.gt.epsi)                                     THEN ! ctr
c #EW            mauxEW        =  mphy2D(il )
c #EW        if (mauxEW(13:13).eq.'s'.or.mauxEW(13:13).eq.'A')    then ! ctr
c #EW            mauxEW(13:13) =  'A'
c #EW        else                                                      ! ctr
c #EW            mauxEW(13:13) =  'r'
c #EW        end if                                                    ! ctr
c #EW            mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

              praci = 3104.28d0  * cnor * W2xyz6(il,kl)
     .         *qi2D(il,kl)/exp(3.8d0*log(W2xyz7(il,kl)))
              qraci =     praci * xt    * CbyROK
              qraci = min(qraci,qi2D(il,kl))
             cnraci         = ccni2D(il,kl)* qraci/max(qi2D(il,kl),eps9)
             ccni2D(il,kl)  = ccni2D(il,kl)-cnraci
               qi2D(il,kl)  =   qi2D(il,kl)- qraci

! #qg       IF(qr2D(il,kl) .gt. 1.e-4 )                           then ! ctr
! #qg          qg2D(il,kl) =   qg2D(il,kl) + qraci
!              CAUTION : Graupels Formation is not taken into account  !
!                        This could be a reasonable assumption for Antarctica

! #qg       ELSE                                                       ! ctr
              qs2D(il,kl)  =   qs2D(il,kl) + qraci
! #qg       END IF                                                     ! ctr

c #WQ       write(6,*) 'Qraci',qraci,itexpe,il,kl
c #WH       if (il.eq.ilmm) wraci(kl) = qraci


!  Accretion of Rain           by Cloud Ice (Rain Sink)
!  Reference: Lin et al.      1983, JCAM      22, p.1071 (26)
!  ----------------------------------------------------------

c #EW      IF(CbyROK.gt.epsi)                                     THEN ! ctr
c #EW           mauxEW        =  mphy2D(il )
c #EW       if (mauxEW(13:13).eq.'r'.or.mauxEW(13:13).eq.'A')     then ! ctr
c #EW           mauxEW(13:13) =  'A'
c #EW       else                                                       ! ctr
c #EW           mauxEW(13:13) =  's'
c #EW       end if                                                     ! ctr
c #EW           mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

               piacr =     4.1d20 * cnor * W2xyz6(il,kl)
     .          *qi2D(il,kl)/exp(6.8d0*log(W2xyz7(il,kl)))
!                          4.1e20 = a pi**2 rhow/mi Gamma[6+b] / 24
!                          where    a=842., rhow=1000, mi=4.19e-13
!                                                      and b = 0.8
!               Lin et al, 1983, JAM,p1071: mi:Ice Crystal Mass
               qiacr =     piacr * xt    * CbyROK
               qiacr = min(qiacr,qr2D(il,kl))
                qr2D(il,kl) =   qr2D(il,kl) -          qiacr
              tair2D(il,kl) = tair2D(il,kl) + r_LcCp  *qiacr

! #qg        if(qr2D(il,kl) .gt. 1.e-4 )                          then ! ctr
! #qg           qg2D(il,kl) =   qg2D(il,kl) +          qiacr
!             CAUTION : Graupels Formation is not taken into account   !
!                       This could be a reasonable assumption for Antarctica

! #qg        else                                                      ! ctr
                qs2D(il,kl) =   qs2D(il,kl) +          qiacr
! #qg        end if                                                    ! ctr

!  Full Debug
!  ~~~~~~~~~~
c #WQ         write(6,*) 'Qiacr',qiacr,itexpe,il,kl
c #WH         if (il.eq.ilmm) wiacr(kl) = qiacr

c #hy     END IF
c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Accretion of Clou'
c #wH         debugH(36:70)   = 'd Ice by Rain                      '
c #wH         proc_1          = 'Qraci g/kg'
c #wH         procv1          =  qraci
c #wH         proc_2          = 'qiacr g/kg'
c #wH         procv2          =  qiacr
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(11,kl)   =  qiacr

        END DO
        END DO


!  Accretion of Rain           by Snow Flakes
!  Accretion of Snow Flakes    by Rain
!  Reference: Lin et al.      1983, JCAM      22, p.1071 (27)
!             Lin et al.      1983, JCAM      22, p.1071 (28)
!             Emde and Kahlig 1989, Ann.Geoph. 7, p. 408 (~21)
!  -----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

            psacr(il,kl)=   0.d0
            qsacr       =   0.d0
c #wH       qraci       =   0.0 
c #wH       qracsS      =   0.0 
c #wH       qsacrR      =   0.0 

c #hy     IF                        (W2xyz3(il,kl).gt.eps9)         THEN

            sign_R      =  sign(unun,W2xyz3(il,kl)  - eps9) ! W2xyz3: Qr
            RbyS_r      =   max(zero,sign_R)
!           RbyS_r      =   1.0 if   W2xyz3(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (W2xyz4(il,kl).gt.eps9)         THEN

            sign_S      =  sign(unun,W2xyz4(il,kl)  - eps9) ! W2xyz4: Qs
            RbyS_s      =   max(zero,sign_S)
!           RbyS_s      =   1.0 if   W2xyz4(il,kl)  > eps9
!                       =   0.0 otherwise

            RbySOK      =  RbyS_r *  RbyS_s

c #EW      IF(CbyROK.gt.epsi)                                       THEN
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(14:14) = 'A'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF

!  Accretion of Rain by Snow --> Snow           | W2xyz7 : lambda_r
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~           | W2xyz8 : lambda_s
            flS=(5.0d0/(W2xyz8(il,kl)*W2xyz8(il,kl)*W2xyz7(il,kl))
     .          +2.0d0/(W2xyz8(il,kl)*W2xyz7(il,kl)*W2xyz7(il,kl))
     .          +0.5d0/(W2xyz7(il,kl)*W2xyz7(il,kl)*W2xyz7(il,kl)))
     .  /(W2xyz8(il,kl)*W2xyz8(il,kl)*W2xyz8(il,kl)*W2xyz8(il,kl))

c #cn       cnos        = min(2.e8
c #cn.                       ,2.e6*exp(-.12 *min(0.,W2xyz1(il,kl))))
            pracs       = 986.96d-3*(cnor*cnos/rolv2D(il,kl))
     .                             * abs(vr(il,kl)-vs(il,kl))*flS
!                         986.96: pi**2 * rhos
!                        (snow    density assumed equal to  100 kg/m3)
            qracs       =     pracs * xt * RbySOK
            qracs       = min(qracs,qr2D(il,kl))

c #WQ       write(6,*) 'Qracs',qracs,itexpe,il,kl
c #WH       if (il.eq.ilmm) wracs(kl) = qracs

!  Accretion of Snow by Rain --> Rain
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            sign_R      =  sign(unun,W2xyz3(il,kl)  - 1.e-4)
            SbyR_r      =   max(zero,sign_R)
!           SbyR_r      =   1.0 if   W2xyz3(il,kl)  > 1.e-4
!                       =   0.0 otherwise

            sign_S      =  sign(unun,W2xyz4(il,kl)  - 1.e-4)
            SbyR_s      =   max(zero,sign_S)
!           SbyR_s      =   1.0 if   W2xyz4(il,kl)  > 1.e-4
!                       =   0.0 otherwise

            SbyROK      =   max(SbyR_r,SbyR_s)

c #hy      IF (SbyROK.gt.epsi)                                    THEN
            flR=(5.0d0/(W2xyz7(il,kl)*W2xyz7(il,kl)*W2xyz8(il,kl))
     .          +2.0d0/(W2xyz7(il,kl)*W2xyz8(il,kl)*W2xyz8(il,kl))
     .          +0.5d0/(W2xyz8(il,kl)*W2xyz8(il,kl)*W2xyz8(il,kl)))
     .  /(W2xyz7(il,kl)*W2xyz7(il,kl)*W2xyz7(il,kl)*W2xyz7(il,kl))

            psacr(il,kl)= 9869.6d-3*(cnor*cnos/rolv2D(il,kl))
     .                             * abs(vr(il,kl)-vs(il,kl))*flR
!                         9869.6: pi**2 * rhow
!                        (water   density assumed equal to 1000 kg/m3)
            qsacr       =     psacr(il,kl) * xt * RbySOK  * SbyROK
            qsacr       = min(qsacr,qs2D(il,kl))

c #WQ       write(6,*) 'Qsacr',qsacr,itexpe,il,kl
c #WH       if (il.eq.ilmm) wsacr(kl) = qsacr
c #hy      ELSE
c #hy       psacr(il,kl) =  0.d0
c #hy       qsacr        =  0.d0
c #hy      END IF

            sign_T      = -sign(unun,tair2D(il,kl)  - TfSnow)
            CbyR_T      =   max(zero,sign_T)
!           CbyR_T      =   1.0 if   tair2D(il,kl)  < TfSnow
!                       =   0.0 otherwise

            qracsS      =                     qracs *      CbyR_T
            qsacrR      =                     qsacr *(1.d0-CbyR_T)

               qr2D(il,kl)  =   qr2D(il,kl) - qracsS
! #qg       if (W2xyz3(il,kl).lt.1.e-4 .and. W2xyz4(il,kl).lt.1.e-4) then
!              CAUTION  : Graupel Formation is not taken into Account
               qs2D(il,kl)  =   qs2D(il,kl) + qracsS
! #qg       else
! #qg          qs2D(il,kl)  =   qs2D(il,kl) - qracsS
! #qg          qg2D(il,kl)  =   qg2D(il,kl) + qsacrS + qracsS
! #qg       end if
             tair2D(il,kl)  = tair2D(il,kl) + qracsS * r_LcCp

               qr2D(il,kl)  =   qr2D(il,kl) + qsacrR
               qs2D(il,kl)  =   qs2D(il,kl) - qsacrR
             tair2D(il,kl)  = tair2D(il,kl) - qsacrR * r_LcCp

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Accretion of Snow'
c #wH         debugH(36:70)   = '(Rain) by Rain(Snow)               '
c #wH         proc_1          = 'Qracs g/kg'
c #wH         procv1          =  qracsS
c #wH         proc_2          = 'Qsacr g/kg'
c #wH         procv2          =  qsacrR
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(12,kl)   =  qracsS - qsacrR

        END DO
        END DO


!  Accretion of Snow           by Graupels
!  Reference: Lin et al.      1983, JCAM      22, p.1071 (29)
!  ----------------------------------------------------------

! #qg   DO kl=mzhyd,klev
! #qg   DO il=1,klon

! #qg     IF                        (W2xyz0(il,kl).gt.eps9)       THEN

! #qg       sign_G      =  sign(unun,W2xyz0(il,kl)  - eps9)
! #qg       SbyG_g      =   max(zero,sign_G)
!           SbyG_g      =   1.0 if   W2xyz0(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg     IF                        (W2xyz4(il,kl).gt.eps9)       THEN

! #qg       sign_S      =  sign(unun,W2xyz4(il,kl)  - eps9)
! #qg       SbyG_s      =   max(zero,sign_S)
!           SbyG_s      =   1.0 if   W2xyz4(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg       SbyGOK      =  SbyG_g *  SbyG_s

! #qg       efc   =  exp(0.090*W2xyz1(il,kl))
!           efc   : Collection Efficiency
!                   Lin et al. 1983 JCAM 22 p.1072 (30)

! #qg       flg=exp(-6.0d0*log(W2xyz8(il,kl))
! #qg.         *(5.0/W2xyz9(il,kl)
! #qg.          +2.0*W2xyz8(il,kl)/(W2xyz9(il,kl)*W2xyz9(il,kl))
! #qg.          +0.5*W2xyz8(il,kl)* W2xyz8(il,kl)
! #qg.               /exp(3.0d0*log(W2xyz9(il,kl))))
c #cn       cnos       = min(2.e8
c #cn.                      ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
! #qg       pgacs      = 986.96d-3*(cnog*cnos/rolv2D(il,kl))
! #qg.                            * abs(vg(il,kl)-vs(il,kl))*flg*efc
!                        986.96: pi**2 * rhog
!                       (graupel densitity assumed equal to snow density)
! #qg       qgacs      =     pgacs * xt       * SbyGOK
! #qg       qgacs      = min(qgacs,qs2D(il,kl))
! #qg       qg2D(il,kl)  = qg2D(il,kl) +        qgacs
! #qg       qs2D(il,kl)  = qs2D(il,kl) -        qgacs

! #qg     END IF
! #qg     END IF

! #qg   END DO
! #qg   END DO


!  Accretion of Rain           by Graupels (Dry Growth Mode)
!  Reference: Lin et al.      1983, JCAM      22, p.1075 (42)
!  ----------------------------------------------------------

! #qg   DO kl=mzhyd,klev
! #qg   DO il=1,klon

! #qg     IF                        (W2xyz0(il,kl).gt.eps9)       THEN

! #qg       sign_G      =  sign(unun,W2xyz0(il,kl)  - eps9)
! #qg       RbyG_g      =   max(zero,sign_G)
!           RbyG_g      =   1.0 if   W2xyz0(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg     IF                        (W2xyz3(il,kl).gt.eps9)       THEN

! #qg       sign_R      =  sign(unun,W2xyz3(il,kl)  - eps9)
! #qg       RbyG_r      =   max(zero,sign_R)
!           RbyG_r      =   1.0 if   W2xyz3(il,kl)  > eps9
!                       =   0.0 otherwise

! #qg     IF                        (tair2D(il,kl).lt.TfSnow)     THEN

! #qg       sign_T      = -sign(unun,tair2D(il,kl)  - TfSnow)
! #qg       Fact_G      =   max(zero,sign_T)
!           Fact_G      =   1.0 if   tair2D(il,kl)  < TfSnow
!                       =   0.0 otherwise

! #qg       RbyGOK      =  RbyG_g *  RbyG_s         * Fact_G

! #qg       flg=exp(-6.0d0*log(W2xyz8(il,kl))
! #qg.         *(5.0/W2xyz9(il,kl)
! #qg.          +2.0*W2xyz8(il,kl)/(W2xyz9(il,kl)*W2xyz9(il,kl))
! #qg.          +0.5*W2xyz8(il,kl)* W2xyz8(il,kl)
! #qg.               /exp(3.0d0*log(W2xyz9(il,kl))))
c #cn       cnos         = min(2.e8
c #cn.                        ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
! #qg       pgacr        = 986.96d-3*(cnog*cnos/rolv2D(il,kl))
! #qg.                              * abs(vg(i,kl) - vr(il,kl))*flg
! #qg       qgacr        =     pgacr * xt  *        RbyGOK
! #qg       qgacr        = min(qgacr,qr2D(il,kl))
! #qg         qg2D(il,kl)  =   qg2D(il,kl) +        qgacr
! #qg         qr2D(il,kl)  =   qr2D(il,kl) -        qgacr
! #qg       tair2D(il,kl)  = tair2D(il,kl) + r_LcCp*qgacr

! #qg     END IF
! #qg     END IF
! #qg     END IF

! #qg   END DO
! #qg   END DO


!  Graupels Wet Growth Mode
!  Reference: Lin et al.      1983, JCAM      22, p.1075 (43)
!  ----------------------------------------------------------

! #qg   ! TO BE ADDED !


!  Microphysical Processes affecting     Precipitating Cloud Particles
!  ===================================================================


!  Rain Drops Evaporation                                    ============
!  Reference: Lin et al.      1983, JCAM      22, p.1077 (52)
!  ----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qrevp       =   0.0

c #hy     IF                        (W2xyz3(il,kl).gt.eps9)       THEN
!                                    W2xyz3 : old Rain    Concentration

            sign_R      =  sign(unun,W2xyz3(il,kl)  - eps9)
            Evap_r      =   max(zero,sign_R)
!           Evap_r      =   1.0 if   W2xyz3(il,kl)  > eps9
!                       =   0.0 otherwise

            EvapOK      =  Evap_r

c #EW      IF(EvapOK.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(15:15) = 'v'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

            sr          =  qv2D(il,kl)/(rhcrHY*qvsw2D(il,kl))
!           sr          :  grid scale saturation humidity

c #hy     IF                        (sr           .lt.unun)       THEN
            sign_Q      = -sign(unun,sr             - unun)
            Evap_q      =   max(zero,sign_Q)
!           Evap_q      =   1.0 if   sr             < unun
!                       =   0.0 otherwise

            EvapOK      =  EvapOK                   * Evap_q

            almr  = 0.78d0  /(W2xyz7(il,kl) *W2xyz7(il,kl))
     .            + 3940.d0 *           sqrt(W2xyz6(il,kl))
!                   3940.: 0.31 Sc**(1/3) *(a/nu)**(1/2) * Gamma[(b+5)/2]
!                   where       Sc=0.8(Schm.) nu=1.5e-5
!                                            (Air Kinematic Viscosity)
     .                      /exp(2.9d0  *log(W2xyz7(il,kl)))
            ab    = 5.423d11/(tair2D(il,kl) *tair2D(il,kl))
!                   5.423e11
!                 = [Lv=2500000J/kg] * Lv / [kT=0.025W/m/K] / [Rv=461.J/kg/K]
!                                            kT:  Air Thermal Conductivity
     .            + 1.d0       /(1.875d-2 *rolv2D(il,kl) *qvsw2D(il,kl))


            prevp = 2*pi*(1.d0-sr)*cnor*almr/ab
            qrevp =     prevp * xt
            qrevp = min(qrevp,  qr2D(il,kl))

            qrevp = min(qrevp,rhcrHY*qvsw2D(il,kl)-qv2D(il,kl))
!           supersaturation is not allowed to occur

            qrevp = max(qrevp,zero)       *           EvapOK
!           condensation    is not allowed to occur

              qr2D(il,kl) =   qr2D(il,kl) -           qrevp
             dqw2D(il,kl) =  dqw2D(il,kl) -           qrevp
              qv2D(il,kl) =   qv2D(il,kl) +           qrevp
            tair2D(il,kl) = tair2D(il,kl) - r_LvCp   *qrevp

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'Qrevp',qrevp,itexpe,il,kl
c #WH       if (il.eq.ilmm) wrevp(kl) = qrevp

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Rain Drops Evapor'
c #wH         debugH(36:70)   = 'ation                              '
c #wH         proc_1          = 'Qrevp g/kg'
c #wH         procv1          =  qrevp
c #wH         proc_2          = 'R.Hum  [%]'
c #wH         procv2          =  sr*0.1
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(13,kl)   = -qrevp

        END DO
        END DO


!  (Deposition on) Snow Flakes (Sublimation)
!   Reference: Lin et al.      1983, JCAM      22, p.1072 (31)
!   ----------------------------------------------------------

c #BS   DO il=1,klon
c #BS     hlat2D(il,1) = 0.d0
c #BS   END DO

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qssub       =   0.0

c #hy     IF                        (W2xyz4(il,kl).gt.eps9)       THEN
!                                    W2xyz4 : old Snow F. Concentration

            sign_S      =  sign(unun,W2xyz4(il,kl)  - eps9)
            Evap_s      =   max(zero,sign_S)
!           Evap_s      =   1.0 if   W2xyz4(il,kl)  > eps9
!                       =   0.0 otherwise

c #EW      IF(Evap_s.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(16:16) = 'V'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

           si    =             qv2D(il,kl)/W2xyz5(il,kl)

           alms  = 0.78d0  /(W2xyz8(il,kl)*W2xyz8(il,kl))
     .           +  238.d0 *          sqrt(W2xyz6(il,kl))
!                   238.: 0.31 Sc**(1/3) *(c/nu)**(1/2) * Gamma[(d+5)/2]
!                   where      Sc=0.8(Schm.) nu=1.5e-5
!                                           (Air Kinematic Viscosity)
     .                    /exp(2.625d0*log(W2xyz8(il,kl)))
           ab    = 6.959d11/(tair2D(il,kl)*tair2D(il,kl))
!                  6.959e11
!                = [Ls=2833600J/kg]*Ls /[kT=0.025W/m/K] /[Rv=461.J/kg/K]
!                                        kT: Air Thermal   Conductivity
     .           + 1.d0       /(1.875d-2*rolv2D(il,kl)*W2xyz5(il,kl))

c #cn       cnos  = min(2.e8
c #cn.                 ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
            pssub = 2*pi*(1.d0-si)*cnos*alms/(1.d3*rolv2D(il,kl)*ab)
            qssub = pssub * xt

            dqamx = W2xyz5(il,kl) - qv2D(il,kl)

            sign_S      =  sign(unun,si             - unun)
            Depo_s      =   max(zero,sign_S)
!           Depo_s      =   1.0 if   si             > unun
!                       =   0.0 otherwise

            qssub       =   max(qssub             ,dqamx)*       Depo_s
     .              +   min(min(qssub,qs2D(il,kl)),dqamx)*(1.0d0-Depo_s)
!           qssub < 0       ... Deposition
!                 > 0       ... Sublimation

            qssub       =       qssub                    *       Evap_s

              qs2D(il,kl) =   qs2D(il,kl)-          qssub
             dqi2D(il,kl) =  dqi2D(il,kl)-          qssub
              qv2D(il,kl) =   qv2D(il,kl)+          qssub
            tair2D(il,kl) = tair2D(il,kl)-r_LsCp   *qssub
c #BS       hlat2D(il ,1) = hlat2D(il ,1)+          qssub *rolv2D(il,kl)
c #BS.                    *(gpmi2D(il,kl)-gpmi2D(il,kl+1))*grvinv
!           hlat2D(il ,1) : Vertical Integrated Blowing Snow Sublimation
!                          [m w.e.]

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'Qssub',qssub,itexpe,il,kl
c #WH       if (il.eq.ilmm) wssub(kl) =-qssub

c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): (Deposition on) S'
c #wH         debugH(36:70)   = 'now Particles (Sublimation)        '
c #wH         proc_1          = 'Qssub g/kg'
c #wH         procv1          =  qssub
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(14,kl)   = -qssub

        END DO
        END DO


!  Graupels Sublimation
!  Reference: Lin et al.      1983, JCAM      22, p.1076 (46)
!  ----------------------------------------------------------

! #qg   ! TO BE ADDED !


!  Snow Flakes Melting        PSMLT
!  Reference: Lin et al.      1983, JCAM      22, p.1072 (32)
!  ----------------------------------------------------------

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qsmlt       =   0.0

c #hy     IF                        (W2xyz4(il,kl).gt.eps9)       THEN
!                                    W2xyz4 : old Snow Fl.Concentration

            sign_S      =  sign(unun,W2xyz4(il,kl)  - eps9)
            SnoM_s      =   max(zero,sign_S)
!           SnoM_s      =   1.0 if   W2xyz4(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (W2xyz1(il,kl).gt.0.e0)       THEN
!                                    W2xyz1 : old Celsius Temperature

            sign_T      =  sign(unun,W2xyz1(il,kl)  - 0.e0)
            SnoM_T      =   max(zero,sign_T)
!           SnoM_T      =   1.0 if   W2xyz1(il,kl)  > 0.e0
!                       =   0.0 otherwise

            SnoMOK      =  SnoM_s                   * SnoM_T

c #EW      IF(SnoMOK.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(17:17) = 'r'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

            alms  =    0.78    /  (W2xyz8(il,kl) *W2xyz8(il,kl))
     .            +  238.      *             sqrt(W2xyz6(il,kl))
     .                         / exp(2.625d0 *log(W2xyz8(il,kl)))

c #cn       cnos  = min(2.e8
c #cn.                 ,2.e6*exp(-.12*min(0.,W2xyz1(il,kl))))
            xCoef = 1.904d-8 *cnos *alms *r_LcCp /rolv2D(il,kl)
!                   1.904e-8: 2 pi / Lc /[1.e3=rho Factor]

            ACoef = 0.025d00 *xCoef
     .            +(psacw(il,kl) + psacr(il,kl)) *r_LcCp /78.8d0
!                   78.8    : Lc /[Cpw=4.187e3 J/kg/K]

            Bcoef = 62.34d+3 *rolv2D(il,kl) *(qv2D(il,kl)-W2xyz5(il,kl))
!                   62.34   : Ls*[psiv=2.200e-5 m2/s]
!                   46.88   : Lv*[psiv=1.875e-5 m2/s]
     .                       *xCoef
            Bcoef = min(-eps9,Bcoef)

            Tc    =    (tair2D(il,kl)-TfSnow-ACoef/Bcoef)*exp(-ACoef*xt)
            qsmlt =    (tair2D(il,kl)-TfSnow-Tc         )/     r_LcCp
            qsmlt = max( qsmlt,0.         )              *SnoMOK
            qsmlt = min( qsmlt,qs2D(il,kl))

cXF

c #XF       alms  = 0.78d0  /(W2xyz8(il,kl)*W2xyz8(il,kl))
c #XF.               +  238.d0 *       sqrt(W2xyz6(il,kl))
c #XF.                     /exp(2.625d0*log(W2xyz8(il,kl)))
c #XF       akps  = 0.025d0  *W2xyz1(il,kl)
c #XF.            + 46.875d3 *rolv2D(il,kl) *(qv2D(il,kl)-W2xyz5(il,kl))
C +...              46.875  : Lv*[psiv=1.875e-5m2/s]

c #XF       psmlt = 1.904d-8*cnos*akps*alms/rolv2D(il,kl)
C +...              1.904e-8: 2 pi / Lc /[1.e3=rho Factor]
c #XF.            -(psacw(il,kl) + psacr(il,kl)) *W2xyz1(il,kl) /78.8d0
C +...                               Lc /[Cpw=4.187e3 J/kg/K]  = 78.8
c #XF       qsmlt =     psmlt * xt        *          SnoMOK
c #XF       qsmlt = max(qsmlt,zero)
c #XF       qsmlt = min(qsmlt,qs2D(il,kl))
c this options increases the conversion of Snowfall to rainfall


              qs2D(il,kl) =   qs2D(il,kl) -          qsmlt
              qr2D(il,kl) =   qr2D(il,kl) +          qsmlt
            tair2D(il,kl) = tair2D(il,kl) - r_LcCp  *qsmlt

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'Qsmlt',qsmlt,itexpe,il,kl
c #WH       if (il.eq.ilmm) wsmlt(kl) = qsmlt

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Snow Particles Me'
c #wH         debugH(36:70)   = 'lting                              '
c #wH         proc_1          = 'Qsmlt g/kg'
c #wH         procv1          =  qsmlt
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(15,kl)   = -qsmlt

        END DO
        END DO


!  Graupels    Melting
!  Reference: Lin et al.      1983, JCAM      22, p.1076 (47)
!  ----------------------------------------------------------

! #qg   ! TO BE ADDED !


!  Rain Freezing
!  Reference: Lin et al.      1983, JCAM      22, p.1075 (45)
!  ----------------------------------------------------------

!  **CAUTION**: Graupel Formation TO BE ADDED !

        DO kl=mzhyd,klev
        DO il=1,klon

c #wH       qsfr        =   0.0

c #hy     IF                        (W2xyz3(il,kl).gt.eps9)       THEN
!                                    W2xyz3 : old Rain    Concentration

            sign_R      =  sign(unun,W2xyz3(il,kl)  - eps9)
            Freezr      =   max(zero,sign_R)
!           Freezr      =   1.0 if   W2xyz3(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (W2xyz1(il,kl).lt.0.e0)       THEN
!                                    W2xyz1 : old Celsius Temperature

            sign_T      = -sign(unun,W2xyz1(il,kl)  - 0.e0)
            FreezT      =   max(zero,sign_T)
!           FreezT      =   1.0 if   W2xyz1(il,kl)  < 0.e0
!                       =   0.0 otherwise

            FrerOK      =  Freezr                   * FreezT

c #EW      IF(FrerOK.gt.epsi)                                     THEN ! ctr
c #EW       mauxEW        =  mphy2D(il )
c #EW       mauxEW(19:19) = 's'
c #EW       mphy2D(il )   =  mauxEW
c #EW      END IF                                                      ! ctr

            psfr = 1.974d4 *cnor
     .       /(rolv2D(il,kl)*exp(7.d0 *log(W2xyz7(il,kl))))
     .                     *(exp(-0.66d0  *W2xyz1(il,kl))-1.d0)
            qsfr =     psfr * xt          *        FrerOK
            qsfr = min(qsfr,qr2D(il,kl))

              qr2D(il,kl) =   qr2D(il,kl) -          qsfr
              qs2D(il,kl) =   qs2D(il,kl) +          qsfr
!             CAUTION : graupel production is included into snow production
!                       proposed modification in line below.
! #qg         qg2D(il,kl) =   qg2D(il,kl) +          qsfr
            tair2D(il,kl) = tair2D(il,kl) + r_LcCp  *qsfr

!  Full Debug
!  ~~~~~~~~~~
c #WQ       write(6,*) 'Qsfre',qsfr,itexpe,il,kl
c #WH       if (il.eq.ilmm) wsfre(kl) = qsfr

c #hy     END IF
c #hy     END IF

!  Debug
!  ~~~~~
c #wH         debugH( 1:35)   = 'Lin et al.(1983): Rain Freezing    '
c #wH         debugH(36:70)   = '                                   '
c #wH         proc_1          = 'Qsfr g/kg'
c #wH         procv1          =  qsfr
c #wH         proc_2          = '          '
c #wH         procv2          =  0.
c #wH         proc_3          = '          '
c #wH         procv3          =  0.
c #wH         proc_4          = '          '
c #wH         procv4          =  0.
c #wh         include 'MAR_HY.Debug'
c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )
c #wH.        debugV(16,kl)   =  qsfr

        END DO
        END DO

!  Debug (Summary)
!  ~~~~~~~~~~~~~~~
c #wH   DO kl=mzhyd,klev
c #wH   DO il=1,klon

c #wH     IF(i_fvv(il).EQ.i0fvv.AND.j_fvv(il).EQ.j0fvv     )  THEN
c #kl.             kl .EQ.k0fvv                            )  THEN
c #wH          IF (kl .EQ.mzhyd)                              THEN
c #wH          write(6,6022)
 6022          format(/,'HYDmic STATISTICS'
     .                /,'=================')
c #wH          write(6,6026)
 6026          format(  '    T_Air Qv   Qw g/kg  Qi g/kg  CLOUDS % '
     .                 ,              ' Qs g/kg  Qr g/kg'
     .                 ,' Qi+ E.K.'
     .                 ,' Qi+ Mey.'
     .                 ,' Qi- Sub.'
     .                 ,' Qi- Mlt.'
     .                 ,' Qw+ Cds.'
     .                 ,' Qraut r+'
     .                 ,' Qsaut s+'
     .                 ,' Qracw r+')
c #wH          END IF
c #wH          write(6,6023)   kl
c #wH.              ,      tair2D(il,kl)-TfSnow
c #wH.              ,1.e3*   qv2D(il,kl)
c #wH.              ,1.e3*   qw2D(il,kl)
c #wH.              ,1.e3*   qi2D(il,kl)
c #wH.              ,1.e2* cfra2D(il,kl)
c #wH.              ,1.e3*   qs2D(il,kl)
c #wH.              ,1.e3*   qr2D(il,kl)
c #wH.             ,(1.e3* debugV(kv,kl),kv=1,08)
 6023          format(i3,f6.1,f5.2,2f9.6,f9.1,2f9.3,8f9.6)
c #wH          IF (kl .EQ.klev )                              THEN
c #wH          write(6,6026)
c #wH          write(6,*)  ' '
c #wH          write(6,6024)
 6024          format(  8x,'Z [km]'
     .                 ,' RH.w.[%]'
     .                 ,' RH.i.[%]'     ,9x
     .                 ,' Vss cm/s'
     .                 ,' Vrr cm/s'
     .                 ,' Qsacw s+'
     .                 ,' Qsaci s+'
     .                 ,' Qiacr r+'
     .                 ,' Qracs ds'
     .                 ,' Qrevp w-'
     .                 ,' Qssub s-'
     .                 ,' Qsmlt s-'
     .                 ,' Qsfr  s+')
c #wH          DO nl=mzhyd,klev
c #wH          write(6,6025)   nl       ,zsigma(   nl)*1.e-3
c #wH.              ,1.e2*   qv2D(il,nl)/qvsw2D(il,nl)
c #wH.              ,1.e2*   qv2D(il,nl)/qvsi2D(il,nl)
c #wH.              ,1.e2*     vs(il,nl)
c #wH.              ,1.e2*     vr(il,nl)
c #wH.             ,(1.e3* debugV(kv,nl),kv=9,16)
 6025          format(i3,f11.3,    2f9.1,9x,  2f9.1,8f9.6)
c #wH          END DO
c #wH          write(6,6024)
c #wH          write(6,*)  ' '
c #wH          END IF

c #wH     END IF

c #wH   END DO
c #wH   END DO


!  Vertical Integrated Energy and Water Content
!  ============================================

c #EW   DO       il=1,klon
c #EW     enr11D(il) = 0.0d00
c #EW     wat11D(il) = 0.0d00

c #EW     DO     kl=1,klev
c #EW     enr11D(il) = enr11D(il )
c #EW.               +(tair2D(il,kl)
c #EW.                 -(qw2D(il,kl)+qr2D(il,kl)) *r_LvCp
c #EW.                 -(qi2D(il,kl)+qs2D(il,kl)) *r_LsCp)*dsigm1(kl)
c #EW     wat11D(il) = wat11D(il )
c #EW.               +  (qv2D(il,kl)
c #EW.               +   qw2D(il,kl)+qr2D(il,kl)
c #EW.               +   qi2D(il,kl)+qs2D(il,kl)         )*dsigm1(kl)
c #EW     END DO

c #ew     enr11D(il) = enr11D(il ) * pst2Dn(il) * grvinv
c #EW     wat11D(il) = wat11D(il ) * pst2Dn(il) * grvinv
C +...    wat11D [m]   contains implicit factor 1.d3 [kPa-->Pa] /ro_Wat

c #EW   END DO


!  Precipitation
!  =============

!  Hydrometeors Fall Velocity
!  --------------------------

!  Pristine Ice Crystals Diameter and Fall Velocity
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO kl=mzhyd,klev
        DO il=1,klon

c #hy     IF                          (qi2D(il,kl).gt.eps9)       THEN

            sign_Q      =  sign(unun,  qi2D(il,kl)  - eps9)
            Sedi_c      =   max(zero,sign_Q)
!           Sedi_c      =   1.0 if     qi2D(il,kl)  > eps9
!                       =   0.0 otherwise

c #hy     IF                        (ccni2D(il,kl).gt.1.e0)       THEN

            signCC      =  sign(unun,ccni2D(il,kl)  - 1.e0)
            Sedicc      =   max(zero,signCC)
!           Sedicc      =   1.0 if   ccni2D(il,kl)  > 1.e0
!                       =   0.0 otherwise

            SediOK      =  Sedi_c  * Sedicc

            qid   = 0.16d0 *exp(third *log(thous*rolv2D(il,kl)
     .                *max(eps9,qi2D(il,kl))/max(ccni2D(il,kl),unun)))
!           qid   : Pristine Ice Crystals Diameter,
!                   Levkov et al. 1992, Contr. Atm. Phys. 65, (5) p.37
!                   where 6/(pi*ro_I)**1/3 ~ 0.16

            vi (il,kl)  =  SediOK * 7.d2*qid
     .         *exp(0.35d0*log(rolv2D(il,klev)  / rolv2D(il,kl)))
!           vi    : Terminal Fall Velocity for Pristine Ice Crystals
!                   Levkov et al. 1992, Contr. Atm. Phys. 65, (4) p.37
c #hy     ELSE
c #hy       vi (il,kl)  =  0.0d00

c #hy     END IF
c #hy     END IF

        END DO
        END DO

!  Set Up of the Numerical Scheme
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #VW     vwmx = 0.d0
          vrmx = 0.d0
          vsmx = 0.d0
          vimx = 0.d0
        DO il=1,klon
c #EW     watf1D(il) = 0.d0
!         watf1D     : Water Flux (Atmosphere --> Surface)

        END DO

!  Snow and Rain Fall Velocity (Correction)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO kl=mzhyd,klev
        DO il=    1,klon
          vi(il,kl) = vi(il,kl) *qi2D(il,kl)/max(qi2D(il,kl),eps9)
          vs(il,kl) = vs(il,kl) *qs2D(il,kl)/max(qs2D(il,kl),eps9)
c #VW     vw(il,kl) = vw(il,kl) *qw2D(il,kl)/max(qw2D(il,kl),eps9)
          vr(il,kl) = vr(il,kl) *qr2D(il,kl)/max(qr2D(il,kl),eps9)

          vimx = max(vi(il,kl),vimx)
          vsmx = max(vs(il,kl),vsmx)
c #VW     vwmx = max(vw(il,kl),vwmx)
          vrmx = max(vr(il,kl),vrmx)

c #WH     IF (vsmx.gt.vmmx)                                       THEN ! ctr
c #WH       vmmx  = vsmx
c #WH       ilmmi = il
c #WH     END IF                                                       ! ctr
c #WH     IF (vrmx.gt.vmmi)                                       THEN ! ctr
c #WH       vmmi  = vrmx
c #WH       ilmmi = il
c #WH     END IF                                                       ! ctr

        END DO
        END DO

            dzmn  =          10000.
        DO  il=1,klon
            dzmn  =min(dzmn,(gplv2D(il,mz1)-gplv2D(il,mz))*grvinv)
        END DO


!  Rain Drops  Precipitation (Implicit Scheme)
!  -------------------------------------------

        DO il=     1,klon
          W2xyz8(il,mzhyd-1) = 0.
        ENDDO

!  Precipitation Mass & Flux
!  ~~~~~~~~~~~~~~~~~~~~~~~~~
        DO kl= mzhyd,klev
        DO il=     1,klon
          W2xyz1(il,kl) = pst2Dn(il)    *dsigm1(kl)   *grvinv ! Air  Mass
          W2xyz6(il,kl) = xt* vr(il,kl) *rolv2D(il,kl)        ! Flux Fact.
c #vL   ENDDO

c #vL   DO il=     1,klon
          W2xyz5(il,kl) =   qr2D(il,kl) *W2xyz1(il,kl)        ! Rain Mass
     .                  +    0.5        *W2xyz8(il,kl-1)      ! From abov.
          W2xyz7(il,kl) =                                     ! Var. Fact.
     .             min(2.,W2xyz6(il,kl) /W2xyz1(il,kl))       ! Flux Limi.
c #vL   ENDDO

c #vL   DO il=     1,klon
          W2xyz8(il,kl) = W2xyz5(il,kl) *W2xyz7(il,kl)        ! Mass Loss
     .                              /(1.+W2xyz7(il,kl)*0.5)   !
c #vL   ENDDO

c #vL   DO il=     1,klon
          W2xyz5(il,kl) = W2xyz5(il,kl) -W2xyz8(il,kl)
     .                  +    0.5        *W2xyz8(il,kl-1)      ! From abov.

!  Cooling from above precipitating flux
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          tair2D(il,kl) = 
     .   (tair2D(il,kl)  *W2xyz1(il,kl)
     .   +tair2D(il,kl-1)*W2xyz8(il,kl-1))
     .  /(                W2xyz1(il,kl)
     .   +                W2xyz8(il,kl-1))
c #vL   ENDDO

c #vL   DO il=     1,klon
            qr2D(il,kl) = W2xyz5(il,kl) /W2xyz1(il,kl)
        ENDDO
        ENDDO

!  Precipitation reaching the Surface
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO il=     1,klon
          dwat          = W2xyz8(il,klev)
!         dwat contains an implicit factor 1.e3[kPa->Pa]/ro_Wat[kg/m2->m w.e.]

          rain2D(il )   = rain2D(il ) + dwat
!         rain2D        : snow precipitation height since start of run     [m]

c #EW     watf1D(il )   = watf1D(il ) - dwat

          prec2D(il )   = prec2D(il ) + dwat
!         prec2D        : rain precipitation height                        [m]
!                         is reset to zero after included in water reservoir
        END DO
          dwat          = 0.0


!  Droplets    Precipitation
!  -------------------------

c #VW   itmx = int(1.0d0 + xt * vwmx / dzmn)
!       normally,  0.5 is sufficient to take into account truncation effect
c #VW   itmx = max(1,itmx)
c #VW   xtmn = xt  / itmx

!  Precipitation reaching the Surface
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #VW   DO  it=    1,itmx
c #VW    DO il=    1,klon
c #VW     dwat        = vw(il,klev) *qw2D(il,klev) *rolv2D(il,klev)*xtmn
!         dwat contains an implicit factor 1.d3[kPa->Pa]/ro_Wat[kg/m2->m w.e.]

c #VW     rain2D(il ) = rain2D(il ) + dwat
!         rain2D      : rain precipitation height since start of run       [m]

c #Vw     watf1D(il ) = watf1D(il ) - dwat

c #VW     prec2D(il ) = prec2D(il ) + dwat
!         prec2D      : rain precipitation height                          [m]
!                       is reset to zero after included in water reservoir
!                       (cfr. routine SRFfrm_XXX)
c #VW    END DO

!  Precipitation elsewhere
!  ~~~~~~~~~~~~~~~~~~~~~~~
c #VW    DO kl= klev,mzhyd+1,-1
c #VW    DO il=    1,klon
c #VW     W2xyz1(il,kl) = qw2D(il,kl)  *pst2Dn(il) *dsigm1(kl)
c #VW.  + gravit *xtmn  *(qw2D(il,kl-1)*vw(il,kl-1)*rolv2D(il,kl-1)
c #VW.                   -qw2D(il,kl)  *vw(il,kl)  *rolv2D(il,kl)  )
c #VW    END DO
c #VW    END DO

c #VW    DO il=    1,klon
c #VW     W2xyz1(il,mzhyd)= qw2D(il,mzhyd)*pst2Dn(il)  *dsigm1(   mzhyd)
c #VW.  - gravit *xtmn    * qw2D(il,mzhyd)*vw(il,mzhyd)*rolv2D(il,mzhyd)
c #VW    END DO

c #VW    DO kl=      mzhyd,klev
c #VW    DO il=    1,klon
c #VW       qw2D(il,kl) = W2xyz1(il,kl) / (pst2Dn(il)  *dsigm1(kl))
c #VW    END DO
c #VW    END DO

c #VW   END DO


!  Snow Flakes Precipitation (Implicit Scheme)
!  -------------------------------------------

        DO il=     1,klon
          W2xyz8(il,mzhyd-1) = 0.
        ENDDO

!  Precipitation Mass & Flux
!  ~~~~~~~~~~~~~~~~~~~~~~~~~
        DO kl= mzhyd,klev
        DO il=     1,klon
          W2xyz1(il,kl) = pst2Dn(il)    *dsigm1(kl)   *grvinv ! Air  Mass
          W2xyz6(il,kl) = xt* vs(il,kl) *rolv2D(il,kl)        ! Flux Fact.
c #vL   ENDDO

c #vL   DO il=     1,klon
          W2xyz5(il,kl) =   qs2D(il,kl) *W2xyz1(il,kl)        ! Snow Mass
     .                  +    0.5        *W2xyz8(il,kl-1)      ! From abov.
          W2xyz7(il,kl) =                                     ! Var. Fact.
     .             min(2.,W2xyz6(il,kl) /W2xyz1(il,kl))       ! Flux Limi.
c #vL   ENDDO

c #vL   DO il=     1,klon
          W2xyz8(il,kl) = W2xyz5(il,kl) *W2xyz7(il,kl)        ! Mass Loss
     .                              /(1.+W2xyz7(il,kl)*0.5)   !
c #vL   ENDDO

c #vL   DO il=     1,klon
          W2xyz5(il,kl) = W2xyz5(il,kl) -W2xyz8(il,kl)
     .                  +    0.5        *W2xyz8(il,kl-1)      ! From abov.

!  Cooling from above precipitating flux
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          tair2D(il,kl) = 
     .   (tair2D(il,kl)  *W2xyz1(il,kl)
     .   +tair2D(il,kl-1)*W2xyz8(il,kl-1))
     .  /(                W2xyz1(il,kl)
     .   +                W2xyz8(il,kl-1))
c #vL   ENDDO

c #vL   DO il=     1,klon
            qs2D(il,kl) = W2xyz5(il,kl) /W2xyz1(il,kl)
        ENDDO
        ENDDO

!  Precipitation reaching the Surface
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO il=     1,klon
          dsno          = W2xyz8(il,klev)
!         dsno contains an implicit factor 1.e3[kPa->Pa]/ro_Wat[kg/m2->m w.e.]

          snow2D(il )   = snow2D(il ) + dsno
!         snow2D        : snow precipitation height since start of run     [m]

c #EW     watf1D(il )   = watf1D(il ) - dsno

          snoh2D(il )   = snoh2D(il ) + dsno
!         snoh2D        : snow precipitation height                        [m]
!                         is reset to zero after included in snow cover
!                        (cfr. routine SRFfrm_sno)
        END DO
          dsno          = 0.


!  Pristine Ice Crystals Precipitation
!  -----------------------------------

        itmx = int(1.0d0 + xt * vimx / dzmn)
!       normally,  0.5 is sufficient to take into account truncation effect
        itmx = max(1,itmx)
        xtmn = xt  / itmx

!  Precipitation reaching the Surface
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO  it=    1,itmx
         DO il=    1,klon
          dsno        = vi(il,klev) *qi2D(il,klev) *rolv2D(il,klev)*xtmn
!         dsno contains an implicit factor 1.d3[kPa->Pa]/ro_Wat[kg/m2->m w.e.]

          crys2D(il) = crys2D(il ) + dsno
          snow2D(il) = snow2D(il ) + dsno
!         snow2D     : snow precipitation height since start of run        [m]

c #EW     watf1D(il) = watf1D(il ) - dsno

          snoh2D(il) = snoh2D(il ) + dsno
!         snoh2D     : snow precipitation height                           [m]
!                    is reset to zero after included in snow cover
!                    (cfr. routine SRFfrm_sno)
         END DO

!  Precipitation elsewhere
!  ~~~~~~~~~~~~~~~~~~~~~~~
         DO kl= klev,mzhyd+1,-1
         DO il=    1,klon
          W2xyz1(il,kl) =   qi2D(il,kl)  *pst2Dn(il) *dsigm1(kl)
     .  + gravit *xtmn    *(qi2D(il,kl-1)*vi(il,kl-1)*rolv2D(il,kl-1)
     .                     -qi2D(il,kl)  *vi(il,kl)  *rolv2D(il,kl)  )
          W2xyz5(il,kl) = ccni2D(il,kl)  *pst2Dn(il) *dsigm1(kl)
     .  + gravit *xtmn  *(ccni2D(il,kl-1)*vi(il,kl-1)*rolv2D(il,kl-1)
     .                   -ccni2D(il,kl)  *vi(il,kl)  *rolv2D(il,kl)  )
         END DO
         END DO

         DO il=    1,klon
         W2xyz1(il,mzhyd)=  qi2D(il,mzhyd)*pst2Dn(il)  *dsigm1(mzhyd)
     .  -gravit *xtmn    *  qi2D(il,mzhyd)*vi(il,mzhyd)*rolv2D(il,mzhyd)
         W2xyz5(il,mzhyd)=ccni2D(il,mzhyd)*pst2Dn(il)  *dsigm1(mzhyd)
     .  -gravit *xtmn    *ccni2D(il,mzhyd)*vi(il,mzhyd)*rolv2D(il,mzhyd)
         END DO

         DO kl =      mzhyd,klev
         DO il=     1,klon
            qi2D(il,kl) = W2xyz1(il,kl) / (pst2Dn(il)  *dsigm1(kl))
          ccni2D(il,kl) = W2xyz5(il,kl) / (pst2Dn(il)  *dsigm1(kl))
         END DO
         END DO

        END DO


!  Fractional  Cloudiness ! Guess may be computed (Ek&Mahrt91 fracSC=.T.)
!  ====================== ! Final value  computed  below

! #sc   IF (fracld.AND..NOT.fracSC)                                 THEN
        IF (fracld)                                                 THEN
         IF(fraCEP) THEN ! ECMWF Large Scale Cloudiness
                         ! ----------------------------
          DO kl=mzhyd,klev
          DO il=1,klon
              cfra2D(il,kl) =             (qi2D(il,kl) +   qw2D(il,kl)
     .                                    +qs2D(il,kl) *  0.33
     .                 * (1.-min(1.,exp((tair2D(il,kl) -258.15)*0.1))))
     .                 / (0.02     *     qvsw2D(il,kl)                )
              cfra2D(il,kl) =min(1.000 , cfra2D(il,kl))
              cfra2D(il,kl) =max(0.001 , cfra2D(il,kl))
     .                     *max(0.,sign(1.,qi2D(il,kl) +   qw2D(il,kl)
     .                                    +qs2D(il,kl) -3.E-9         ))
          END DO
          END DO
         ELSE            ! XU and Randall  1996, JAS 21, p.3099 (4)
                         ! ----------------------------
          DO kl=mzhyd,klev
          DO il=1,klon
              qvs_wi=                                    qvsw2D(il,kl)
c #wi         qvs_wi=max(eps9,((qi2D(il,kl)+qs2D(il,kl))*qvsi2D(il,kl)
c #wi.                         +qw2D(il,kl)             *qvsw2D(il,kl))
c #wi.                /max(eps9,qi2D(il,kl)+qs2D(il,kl) +  qw2D(il,kl)))
              relhum=  min(relCri,      max(qv2D(il,kl) ,qv_MIN)
     .                                                 / qvs_wi)
              argexp=  (  (relCri  -relhum)            * qvs_wi)
     .                         **   0.49
              argexp        =   min(100.* (qi2D(il,kl) +   qw2D(il,kl)
     .                                    +qs2D(il,kl) *  0.33
     .                 * (1.-min(1.,exp((tair2D(il,kl) -258.15)*0.1))))
     .                                /max(eps9        , argexp       )
     .                             ,argmax                             )
              
              cfra2D(il,kl) =      (     relhum       ** 0.25         )
     .                         *   (1.  -   exp(-argexp)              )
          END DO
          END DO
         END IF

        ELSE
! #sc   ELSE IF (      .NOT.fracld)                                 THEN
          DO kl=mzhyd,klev
          DO il=1,klon
              qcloud        =              qi2D(il,kl) +   qw2D(il,kl)
c #hy       IF                            (qcloud     .gt.eps9)     THEN

              signQW        =  sign(unun,  qcloud       - eps9)
              cfra2D(il,kl) =   max(zero,signQW)
!             cfra2D(il,kl) =   1.0 if     qcloud       > eps9
!                           =   0.0 otherwise

c #hy       END IF
          END DO
          END DO

        END IF


!  Vertically Integrated Energy and Water Content
!  ==============================================

c #EW   DO il=1,klon
c #EW     enr21D(il) = 0.0d00
c #EW     wat21D(il) = 0.0d00
C +...    Vertical Integrated Energy and Water Content

c #EW   DO kl=1,klev
c #EW     enr21D(il) = enr21D(il )
c #EW.               +(tair2D(il,kl)
c #EW.                 -(qw2D(il,kl)+qr2D(il,kl))*r_LvCp
c #EW.                 -(qi2D(il,kl)+qs2D(il,kl))*r_LsCp   ) *dsigm1(kl)
c #EW     wat21D(il) = wat21D(il )
c #EW.               +  (qv2D(il,kl)
c #EW.               +   qw2D(il,kl)+qr2D(il,kl)
c #EW.               +   qi2D(il,kl)+qs2D(il,kl)           ) *dsigm1(kl)
c #EW   END DO

c #ew     enr21D(il) = enr21D(il ) * pst2Dn(il) * grvinv
c #EW     wat21D(il) = wat21D(il ) * pst2Dn(il) * grvinv
C +...    wat21D [m]   contains implicit factor 1.d3 [kPa-->Pa] /ro_Wat

c #EW   END DO


!  OUTPUT
!  ======

c #WH IF (mod(minuGE,6).eq.0.and.jsecGE.eq.0.and.ilmm.gt.0)       THEN
c #WH   write(6,1030) jhlr2D(ilmm),minuGE,jsecGE,itexpe,imm,jmm
 1030   format(//,i4,'LT',i2,'m',i2,'s (iter.',i6,')  /  Pt.(',2i4,')',
     .          /,'  ==========================================')
c #WH   write(6,1031)(kl,0.1019d0*gplv2D(ilmm,kl),qv2D(ilmm,kl),
c #WH.   1.d3*qiold(kl),1.d3*qi2D(ilmm,kl),
c #WH.   1.d3*wihm1(kl),1.d3*wihm2(kl),1.d3*wicnd(kl),
c #WH.   1.d3*widep(kl),1.d3*wisub(kl),1.d3*wimlt(kl),kl=mzhyd,klev)
 1031   format(/,
     .     '            |  Water Vapor |  Cloud Ice, Time n & n+1',
     .     '   Cloud Ice Nucleation Processes    |',
     .     '   Bergeron   Sublimation   Melting  ',
     .   /,'  k    z[m] |  qv   [g/kg] |  qi_n [g/kg] qi_n+[g/kg]',
     .     ' QiHm1[g/kg] QiHm2[g/kg] QiCnd[g/kg] |',
     .     '  QiDep[g/kg] QiSub[g/kg] QiMlt[q/kg]',
     .   /,'------------+--------------+-------------------------',
     .     '-------------------------------------+',
     .     '-------------------------------------',
     .   /,(i3,f8.1,' | ',f12.6,' | ',2f12.6,3d12.4,' | ',3d12.4))

c #WH   write(6,1032)(kl,0.1019d0*gplv2D(ilmm,kl),
c #WH.   1.d3*W2xyz4(ilmm,kl),1.d3*qs2D(ilmm,kl),
c #WH.   1.d3*wsaut(kl),1.d3*wsaci(kl),1.d3*wsacw(kl),
c #WH.   1.d3*wiacr(kl),1.d3*wsacr(kl),1.d3*wssub(kl),vs(ilmm,kl),
c #WH.              kl=mzhyd,klev)
 1032   format(/,
     .     '            |  Snow Flakes, Time n&n+1 Autoconver. |',
     .     '  Accretion Processes ===> Snow Flakes            |',
     .     '  Sublimation | Term.F.Vel',
     .   /,'  k    z[m] |  qs_n [g/kg] qs_n+[g/kg] Qsaut[g/kg] |',
     .     '  Qsaci[g/kg] Qsacw[g/kg] Qiacr[g/kg] Qsacr[g/kg] |',
     .     '  QsSub[g/kg] | vs   [m/s]',
     .   /,'------------+--------------------------------------+',
     .     '--------------------------------------------------+',
     .     '--------------+-----------',
     .   /,(i3,f8.1,' | ',2f12.6,e12.4,' | ',4d12.4,' | ',e12.4,
     .              ' | ',f10.6))

c #WH   write(6,1033)(kl,0.1019d0*gplv2D(ilmm,kl),tair2D(ilmm,kl),
c #WH.   1.d3*qwold(kl),1.d3*  qw2D(ilmm,kl),
c #WH.   1.d3*wwevp(kl),1.d2*cfra2D(ilmm,kl),kl=mzhyd,klev)
 1033   format(/,
     .   /,'            | Temperat.|  Cloud Water, Time n&n+1',
     .     ' Condens/Evp | Cloud ',
     .   /,'  k    z[m] | T    [K] |  qw_n [g/kg] qw_n+[g/kg]',
     .     ' QwEvp[g/kg] | Fract.',
     .   /,'------------+----------+-------------------------',
     .     '-------------+-------',
     .   /,(i3,f8.1,' | ',f8.3,' | ',2f12.6,e12.4,' | ',f5.1))

c #WH   write(6,1034)(kl,0.1019d0*gplv2D(ilmm,kl),
c #WH.   1.d3*W2xyz3(ilmm,kl),1.d3*qr2D(ilmm,kl),
c #WH.   1.d3*wraut(kl),1.d3*wracw(kl),1.d3*wraci(kl),
c #WH.   1.d3*wracs(kl),1.d3*wrevp(kl),1.d3*wsfre(kl),vr(ilmm,kl),
c #WH.              kl=mzhyd,klev)
 1034   format(/,
     .  /,'            | Rain Drops, Time n&n+1   Autoconver. |',
     .    '  Accretion Processes ===> Rain Drops |',
     .    '  Evaporation  Freezing   | Term.F.Vel',
     .  /,'  k    z[m] |  qr_n [g/kg] qr_n+[g/kg] Qraut[g/kg] |',
     .    '  Qracw[g/kg] Qraci[g/kg] Qracs[g/kg] |',
     .    '  QrEvp[g/kg] QsFre[g/kg] | vr   [m/s]',
     .  /,'------------+--------------------------------------+',
     .    '--------------------------------------+',
     .    '--------------------------+-----------',
     .  /,(i3,f8.1,' | ',2f12.6,e12.4,' | ',3d12.4,' | ',2d12.4,
     .             ' | ',f10.6))

c #WH   DO kl=mzhyd,klev
c #WH     wihm1(kl) = 0.d0
c #WH     wihm2(kl) = 0.d0
c #WH     wicnd(kl) = 0.d0
c #WH     widep(kl) = 0.d0
c #WH     wisub(kl) = 0.d0
c #WH     wimlt(kl) = 0.d0
c #WH     wwevp(kl) = 0.d0
c #WH     wraut(kl) = 0.d0
c #WH     wsaut(kl) = 0.d0
c #WH     wracw(kl) = 0.d0
c #WH     wsacw(kl) = 0.d0
c #WH     wsaci(kl) = 0.d0
c #WH     wraci(kl) = 0.d0
c #WH     wiacr(kl) = 0.d0
c #WH     wsacr(kl) = 0.d0
c #WH     wracs(kl) = 0.d0
c #WH     wrevp(kl) = 0.d0
c #WH     wssub(kl) = 0.d0
c #WH     wsmlt(kl) = 0.d0
c #WH     wsfre(kl) = 0.d0
c #WH   END DO
c #WH END IF


!  Vertical Integrated Energy and Water Content: OUTPUT
!  ====================================================

c #EW IF (ilmez.gt.0)                                             THEN
c #EW   waterb = wat21D(ilmez)-wat11D(ilmez)-watf1D(ilmez)
c #EW   write(6,606) itexpe,
c #EW.                     enr01D(ilmez),1.d3*wat01D(ilmez),
c #EW.                     mphy2D(ilmez),
c #EW.                     enr11D(ilmez),1.d3*wat11D(ilmez),
c #EW.                     enr21D(ilmez),1.d3*wat21D(ilmez),
c #EW.                                   1.d3*watf1D(ilmez),
c #EW.                                   1.d3*waterb
 606    format(i9,'  Before mPhy:  E0 =',f12.6,'  W0 = ',f9.6,3x,a20,3x,
     .       /,9x,'  Before Prec:  E1 =',f12.6,'  W1 = ',f9.6,
     .       /,9x,'  After  Prec:  E2 =',f12.6,'  W2 = ',f9.6,
     .                                         '  W Flux =',f9.6,
     .                                         '  Div(W) =',e9.3)
c #EW END IF

      IF (jmmMAR.eq.0.and.jssMAR.eq.0)                            THEN
            IO_loc =  IO_gen + 2
        DO  io=io1   ,io5

          IF         (io.gt.0)                                    THEN
            il=ioutIO(io)

            IF((  itexpe.gt.0.and.jmmMAR.eq.0.and.jssMAR.eq.0.and.
     .          ((IO_loc.ge.4.and.    jhurGE   .eq.0) .or.
     .           (IO_loc.ge.5.and.mod(jhurGE,3).eq.0) .or.
     .           (IO_loc.ge.6)                            )       ).or.
     .            IO_loc.ge.7                                   ) THEN

!             ***********
              call TIMcor
!             ***********

              write(4,1037) jdplus,mmplus,jhlr2D(il),minuGE,
     .                      igrdIO(io),jgrdIO(io)
 1037         format(/,' Ice-Crystal mPhy ',
     .                   i2,'/',i2,1x,i2,'h',i2,'LT',
     .                 ' -- Grid Point (',i5,',',i5,')',
     .  /,' ==========================================================',
     .         /,'     |  z  [m] | T  [K] | qi[g/kg] |',
     .                ' Ni [m-3] | Ni0[m-3] | vi [m/s] | qs[g/kg] |'
     .         /,'-----+---------+--------+----------+',
     .                '----------+----------+----------+----------+')
              write(4,1038)(kl,gplv2D(il,kl)*grvinv,tair2D(il,kl),
     .                          qi2D(il,kl)*1.d3,
     .                        ccni2D(il,kl),W2xyz2(il,kl),vi(il,kl),
     .                          qs2D(il,kl)*1.d3,kl=mzhyd,klev)
 1038         format((i4,' |' ,  f8.1,' |',f7.2,' |',f9.6,' |',
     .            2(d9.3,' |'),2(f9.6,' |')))
            END IF

          END IF

        END DO

            IO_loc = IO_gen

      END IF

c #WH ilmm = ilmmi


!  Latent Heat Release
!  ===================

      DO kl=mzhyd,klev
      DO il=1,klon
        pkt0          =  pkta2D(il,kl)
        pkta2D(il,kl) =  tair2D(il,kl)/pk2D(il,kl)
        hlat2D(il,kl) =  tair2D(il,kl)*(1.d0-pkt0/pkta2D(il,kl))
     .                                  /xt
      END DO
      END DO


!  Limits on Microphysical Variables
!  =================================

        DO kl=1,mzhyd
        DO il=1,klon
            qv2D(il,kl)=max(qv2D(il,kl),qv_MIN)
            qv2D(il,kl)=min(qv2D(il,kl),qvsi2D(il,kl))
            qw2D(il,kl)=    zero
            qi2D(il,kl)=    zero
          ccni2D(il,kl)=    zero
            qr2D(il,kl)=    zero
            qs2D(il,kl)=    zero
        END DO
        END DO

        DO kl=mzhyd,klev
        DO il=1,klon
            qw2D(il,kl)=max(zero,  qw2D(il,kl))
            qi2D(il,kl)=max(zero,  qi2D(il,kl))
          ccni2D(il,kl)=max(zero,ccni2D(il,kl))
            qr2D(il,kl)=max(zero,  qr2D(il,kl))
            qs2D(il,kl)=max(zero,  qs2D(il,kl))
        END DO
        END DO

        DO kl=1,klev
        DO il=1,klon
            W2xyz1(il,kl) = 0.d0
            W2xyz2(il,kl) = 0.d0
            W2xyz3(il,kl) = 0.d0
            W2xyz4(il,kl) = 0.d0
            W2xyz5(il,kl) = 0.d0
            W2xyz6(il,kl) = 0.d0
            W2xyz7(il,kl) = 0.d0
            W2xyz8(il,kl) = 0.d0
        END DO
        END DO

        return
        end



      subroutine H2O_WB(NoSubr,NoPass,dtProc,INI_WB,makeWB)
 
C +---------------------------------------------------------------------------+
C |                                                       Mon  1-11-2010  MAR |
C |                                                                           |
C |   subroutine H2O_WB calculates Components of Atmospheric Water Budget     |
C |                                                                           |
C |                     needs that Option #WB be preprocessed                 |
C |                                                                           |
C |   Components are:  0: Mass Change        (opstDY ---> pstDYn) [mm w.e./d] |
C |                    1: Advection          (Leap-Frog Backward) [mm w.e./d] |
C |                    2: Diffusion          (Horizontal)         [mm w.e./d] |
C |                    3: Convection                              [mm w.e./d] |
C |                    4: Diffusion          (Vertical)           [mm w.e./d] |
C |                    5: Cloud Microphysics                      [mm w.e./d] |
C |                    6: Horizontal Filter                       [mm w.e./d] |
C |                    7: Budget             (0+1+2+3+4+5+6 Cont) [mm w.e./d] |
C |                                                                           |
C |   INPUT: qiHY(i,j,k): Ice Crystals Concentration                 [kg/kg]  |
C |          qwHY(i,j,k): Cloud  Drops Concentration                 [kg/kg]  |
C |          qsHY(i,j,k): Snow  Flakes Concentration                 [kg/kg]  |
C |          qrHY(i,j,k): Rain   Drops Concentration                 [kg/kg]  |
C |          qvDY(i,j,k): Water  Vapor Concentration                 [kg/kg]  |
C |                                                                           |
C |   STATUS of ROUTINE: Latent Heat Release from micPhys. not yet included   |
C |                                                                           |
C +---------------------------------------------------------------------------+
 
 
      IMPLICIT NONE
 
 
C +--General Variables
C +  =================
 
      include 'MARCTR.inc'
      include 'MARphy.inc'
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
      include 'MAR_LB.inc'
      include 'MAR_DY.inc'
      include 'MAR_FI.inc'
      include 'MARqqm.inc'
      include 'MAR_TU.inc'
      include 'MAR_HY.inc'
c #CA include 'MAR_CA.inc'
      include 'MAR_SL.inc'
 
C +...BEGIN of MAR_WB.inc
      real            dq__WB(mx,my,0:9),timeWB(0:9)
      real            qLB_WB(      0:9),qSB_WB(0:9)
      real            qt__WB(      0:9)
      real            wq__WB(mx,my)    ,uq__WB(mx,my),us__WB(mx,my)
      real            rr_0WB(mx,my)    ,rrc0WB(mx,my)
      real            ss_0WB(mx,my)    ,ssc0WB(mx,my)
      real            drr_WB(mx,my)    ,drrcWB(mx,my)
      real            dss_WB(mx,my)    ,dsscWB(mx,my)
      real            upq_WB(mx,my)    ,vpq_WB(mx,my),cpq_WB(mx,my)
      real            ups_WB(mx,my)    ,vps_WB(mx,my),cps_WB(mx,my)
      real            qinpWB           ,qoutWB
      real            qOv_WB           ,qLv_WB
      real            qLrsWB           ,qOrsWB
      real            qL_0WB           ,qO_0WB
      real            q00_WB           ,qn__WB
      real            dqt_WB           ,timtWB
      common/WaterB_r/dq__WB           ,timeWB
     .               ,qLB_WB           ,qSB_WB
     .               ,qt__WB
     .               ,wq__WB           ,uq__WB       ,us__WB
     .               ,rr_0WB           ,rrc0WB
     .               ,ss_0WB           ,ssc0WB
     .               ,drr_WB           ,drrcWB
     .               ,dss_WB           ,dsscWB
     .               ,upq_WB           ,vpq_WB       ,cpq_WB
     .               ,ups_WB           ,vps_WB       ,cps_WB
     .               ,qinpWB           ,qoutWB
     .               ,qOv_WB           ,qLv_WB
     .               ,qLrsWB           ,qOrsWB
     .               ,qL_0WB           ,qO_0WB
     .               ,q00_WB           ,qn__WB
     .               ,dqt_WB           ,timtWB
C +...END   of MAR_WB.inc
 
      integer         nttH2O
      real            qttH2O(0:8)
      common/H2Obilii/nttH2O
 
      integer         NoSubr
      real            NoPass,dtProc
 
      logical         INI_WB,makeWB
 
      integer         npt,log_pt,use_pt(mx,my)
      common/H2Obil_i/npt,log_pt,use_pt
 
 
C +--Local   Variables
C +  =================
 
      integer   npx ,npy ,nxy
      parameter(npx = max(1,mx-lb-lb-2))
      parameter(npy = max(1,my-lb-lb-2))
      parameter(nxy = npx    *npy      )
 
      integer         n                !
      real            ti_REF           !
      real            p_star(mx,my)    ! Local       Mass
      real            qq_int(mx,my)    ! Local Water Mass X g [m w.e. m/s2]
      real            qt(    -2: 2)    !
      real            qFag  ,qFad      !
      real            qFagi ,qFadi     !
      real            qFdg  ,qFdd      !
      real            qinp  ,qout ,qLS !
      real            qinpX ,qoutX     !
      real            qvapL ,qvapO,qvap!
      real            qL    ,qO   ,qrs !
      real            qLt   ,qOt       !
      real            qMARij,dqt       !
      real            dpq   ,dps       !
 
      logical         LFBord
 
      character*20    Process(0:9)
 
 
C +--DATA
C +  ====
 
       data  LFBord            /.FALSE./
 
       data (Process(n),n=0,9) /'Mass Change         ',   ! 0
     .                          'Advection           ',   ! 1
     .                          'Diffusion (Horiz.)  ',   ! 2
     .                          'Convection          ',   ! 3
     .                          'Diffusion (Verti.)  ',   ! 4
     .                          'Cloud Microphysics  ',   ! 5
     .                          'Horizontal Filter   ',   ! 6
     .                          'Effective  Change   ',   ! 7
     .                          'Budget    (S_0to6)  ',   ! 8
     .                          'Budget    (Host)    '/   ! 9
 
 
C +--First INITIALIZATION
C +  ====================
 
C +--Lateral Boundary Length
C +  -----------------------
 
      IF(log_pt.EQ.0)                                               THEN
         log_pt =  1
            npt = (npx+npx)*min(1,max(0,my-1))
     .          + (npy+npy)*min(1,max(0,mx-1))
         DO j=1,my
         DO i=1,mx
 
 
C +--Domain Definition
C +  -----------------
 
         use_pt(i,j) =         max(0,min(1,i-lgx+1))
     .                       * max(0,min(1,ldx-i+1))
     .                       * max(0,min(1,j-lgy+1))
     .                       * max(0,min(1,ldy-j+1))
         ENDDO
         ENDDO


C +--FULL MODEL DOMAIN WATER BUDGET
C +  ------------------------------

c #ww       qinpWB   = 0.
c #ww       qoutWB   = 0.

c #ww       qLv_WB   = 0.
c #ww       qOv_WB   = 0.

c #ww       dqt_WB   = 0.
c #ww       timtWB   = 0.

C +--FULL MODEL DOMAIN WATER CONTENT                         [m w.e.]
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                         ~~~~~~~~
c #ww       q00_WB   = 0.
c #ww     DO j=1,my
c #ww     DO i=1,mx
c #ww       qMARij   = 0.
c #ww     DO k=1,mz
c #ww       qMARij   = qMARij
c #ww.               + dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
c #ww.                                        +qrHY(i,j,k)+qsHY(i,j,k))
c #ww     ENDDO
c #ww       q00_WB   = q00_WB +  pstDYn(i,j)  *grvinv  * qMARij
c #ww     ENDDO
c #ww     ENDDO

C +--PRECIPITATION                                           [m w.e.]
C +  ~~~~~~~~~~~~~                                           ~~~~~~~~
c #ww       qL       = 0.
c #ww       qO       = 0.
c #ww     DO j=1,my
c #ww     DO i=1,mx
c #ww       qrs      = rainHY(i,j) + snowHY(i,j)
c #ww       qL       = qL + qrs * (1-maskSL(i,j)) 
c #ww       qO       = qO + qrs *    maskSL(i,j) 
c #ww     ENDDO
c #ww     ENDDO
c #ww       qL_0WB   = qL /(mx*my)
c #ww       qO_0WB   = qO /(mx*my)
 
      END IF
 
 
C +--(Re)--INITIALIZATION (when OUTPUT in OUT_nc)
C +  ====================
 
      IF (INI_WB)                                                   THEN
 
        DO n=0,9
            DO j=1,my
            DO i=1,mx
               dq__WB(i,j,n) = 0.
            ENDDO
            ENDDO
c #WW          qLB_WB(    n) = 0.
c #WW          timeWB(    n) = 0.
        ENDDO


C +--Contribution from the Boundaries
C +  --------------------------------

            DO j=1,my
            DO i=1,mx
               wq__WB(i,j)   = 0.
               uq__WB(i,j)   = 0.
               us__WB(i,j)   = 0.
               rr_0WB(i,j)   = rainHY(i,j)
               ss_0WB(i,j)   = snowHY(i,j)
c #CA          rrc0WB(i,j)   = rainCA(i,j)
c #CA          ssc0WB(i,j)   = snowCA(i,j)
 
 
C +--Water Mass Increment (vertical Integral)                      [m w.e.]
C +  ----------------------------------------                      --------
 
               qq_int(i,j)   = 0.
             DO k=1,mz
               qq_int(i,j)   = qq_int(i,j)
     .             + dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
     .                                      +qrHY(i,j,k)+qsHY(i,j,k))
             ENDDO
               qq_int(i,j)   = qq_int(i,j)  *pstDYn(i,j)
               dq__WB(i,j,7) = dq__WB(i,j,7)-qq_int(i,j)*grvinv
 

C +--VertiCally integrated Water Fluxes
C +  ----------------------------------

               upq_WB(i,j)   = 0.
               vpq_WB(i,j)   = 0.
               cpq_WB(i,j)   = 0.
               ups_WB(i,j)   = 0.
               vps_WB(i,j)   = 0.
               cps_WB(i,j)   = 0.
            ENDDO
            ENDDO
 
      END IF
 
 
C +--Contribution of a Budget Component
C +  ==================================
 
C +--Local
C +  -----
 
      IF   (NoSubr.GE.0)                                            THEN
 
C +--Air   Mass
C +  ~~~~~~~~~~
        IF (NoSubr.EQ.0 .AND. NoPass.LT.0.)                         THEN
          DO j=1,my
          DO i=1,mx
            p_star(i,j)        = opstDY(i,j)
          ENDDO
          ENDDO
        ELSE
          DO j=1,my
          DO i=1,mx
            p_star(i,j)        = pstDYn(i,j)
          ENDDO
          ENDDO
        END IF
 
C +--Water Mass Increment (vertical Integral)                      [m w.e.]
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                      ~~~~~~~~
          DO j=1,my
          DO i=1,mx
            qq_int(i,j)        = 0.
          DO k=1,mz
            qq_int(i,j)        = qq_int(i,j)
     .               + dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
     .                                        +qrHY(i,j,k)+qsHY(i,j,k))
          ENDDO
            qq_int(i,j)        = qq_int(i,j)              *p_star(i,j)
            dq__WB(i,j,NoSubr) = dq__WB(i,j,NoSubr)+NoPass*qq_int(i,j)
     .                                                    *grvinv
          ENDDO
          ENDDO
 
        IF (NoPass.GT.0.)                                           THEN
            timeWB(    NoSubr) = timeWB(    NoSubr)+dtProc
        END IF
 
 
C +--Verticaly integrated Water Fluxes
C +  ---------------------------------
        IF (NoSubr.EQ.1 .AND. NoPass.LT.0.)                         THEN
          DO k=1,mz
          DO j=1,my
          DO i=1,mx
             dpq         = 500.*(opstDY(i,j)+pstDYn(i,j)) *dtProc
     .               * dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
     .                                        +qrHY(i,j,k)+qsHY(i,j,k))
     .               * grvinv
             dps         = 500.*(opstDY(i,j)+pstDYn(i,j)) *dtProc
     .               * dsigm1(k) *                         qsHY(i,j,k)
     .               * grvinv
             upq_WB(i,j) =       upq_WB(i,j)+uairDY(i,j,k)*dpq
             vpq_WB(i,j) =       vpq_WB(i,j)+vairDY(i,j,k)*dpq
             cpq_WB(i,j) =       cpq_WB(i,j)+              dpq
             ups_WB(i,j) =       ups_WB(i,j)+uairDY(i,j,k)*dps
             vps_WB(i,j) =       vps_WB(i,j)+vairDY(i,j,k)*dps
             cps_WB(i,j) =       cps_WB(i,j)+              dps
          ENDDO
          ENDDO
          ENDDO


C +--Domain      Inflow: Surface Boundary
C +  ------------------------------------
 
C +--Domain      Inflow: Surface Boundary: Vertical    Advection   [m w.e.]
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          DO j=1,my
          DO i=1,mx
            wq__WB(i,j)    = wq__WB(i,j)
     .            + dtProc * psigDY(i,j,mz) *
     .                      (qvapSL(i,j)-qvDY(i,j,mz)
     .                                  -qwHY(i,j,mz)
     .                                  -qrHY(i,j,mz)
     .                                  -qiHY(i,j,mz)
     .                      +qsrfHY(i,j)-qsHY(i,j,mz)) * grvinv
C +...         contains implicit factor 1.e3[kPa->Pa]/rowat[kg/m2-->m w.e.]
C +            < 0 ==> Atmospheric Loss ==> Surface Gain
          ENDDO
          ENDDO
        END IF
 
C +--Domain      Inflow: Surface Boundary: Sublimation/Evaporation [m w.e.]
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Blowing     Snow        [m w.e.]
C +                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF (NoSubr.EQ.4 .AND. NoPass.LT.0.)                         THEN
          DO j=1,my
          DO i=1,mx
            uq__WB(i,j)    = uq__WB(i,j)
     .             - dtProc * SLuqs(i,j)*rolvDY(i,j,mz)
c #WW       us__WB(i,j)    = us__WB(i,j)
c #WW.             - dtProc *uss_HY(i,j)*rolvDY(i,j,mz)
          ENDDO
          ENDDO
        END IF
 
C +--Advection                                               [m w.e. m2/s3]
C +  ~~~~~~~~~                                               ~~~~~~~~~~~~~~
c #WW   IF (NoSubr.EQ.1 .AND. NoPass.LT.0.)                         THEN
 
C +--Leap-Frog Backward Formulation
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #WW    IF(LFBord)                                                 THEN
c #WW     IF (mx .GT. 1)                                            THEN
c #WW       DO j=lgy,ldy
c #WW          qFag      = 0.
c #WW          qFad      = 0.
c #WW          qFagi     = 0.
c #WW          qFadi     = 0.
c #WW        DO k=1,mz
 
C +--Water Concentration, x< Boundary

c #WW          qt(-2)    =(qvDY(lgx2,j,k)
c #WW.                    +qwHY(lgx2,j,k)+qiHY(lgx2,j,k)
c #WW.                    +qrHY(lgx2,j,k)+qsHY(lgx2,j,k))*p_star(lgx2,j)
c #WW          qt(-1)    =(qvDY(lgx1,j,k)
c #WW.                    +qwHY(lgx1,j,k)+qiHY(lgx1,j,k)
c #WW.                    +qrHY(lgx1,j,k)+qsHY(lgx1,j,k))*p_star(lgx1,j)
c #WW          qt( 0)    =(qvDY(lgx ,j,k)
c #WW.                    +qwHY(lgx ,j,k)+qiHY(lgx ,j,k)
c #WW.                    +qrHY(lgx ,j,k)+qsHY(lgx ,j,k))*p_star(lgx ,j)
 
C +--Water Fluxes,        x< Boundary

c #WW          qFag      =   qFag      +uairDY(lgx ,j,k) *dsigm1(k)
c #WW.                   *f2_3*((qt(-1)-qt( 0)) +0.125*(qt( 0)-qt(-2)))
c #WW          qFagi     =   qFagi     +uairDY(lgxx,j,k) *dsigm1(k)
c #WW.                   *f2_3*(                 0.125*(qt( 0)-qt(-1)))
 
C +--Water Concentration, x> Boundary

c #WW          qt( 0)    =(qvDY(ldx ,j,k)
c #WW.                    +qwHY(ldx ,j,k)+qiHY(ldx ,j,k)
c #WW.                    +qrHY(ldx ,j,k)+qsHY(ldx ,j,k))*p_star(ldx ,j)
c #WW          qt( 1)    =(qvDY(ldx1,j,k)
c #WW.                    +qwHY(ldx1,j,k)+qiHY(ldx1,j,k)
c #WW.                    +qrHY(ldx1,j,k)+qsHY(ldx1,j,k))*p_star(ldx1,j)
c #WW          qt( 2)    =(qvDY(ldx2,j,k)
c #WW.                    +qwHY(ldx2,j,k)+qiHY(ldx2,j,k)
c #WW.                    +qrHY(ldx2,j,k)+qsHY(ldx2,j,k))*p_star(ldx2,j)
 
C +--Water Fluxes,        x> Boundary

c #WW          qFad      =   qFad      -uairDY(ldx ,j,k) *dsigm1(k)
c #WW.                   *f2_3*((qt( 1)-qt( 0)) +0.125*(qt( 0)-qt( 2)))
c #WW          qFadi     =   qFadi     -uairDY(ldxx,j,k) *dsigm1(k)
c #WW.                   *f2_3*(                 0.125*(qt( 0)-qt( 1)))
 
c #WW        ENDDO
 
c #WW          qLB_WB(1) = qLB_WB(1) +(qFag+qFad+qFagi+qFadi) ! [m w.e. m2/s3]
c #WW       ENDDO
 
 
C +--Water Concentration, y< Boundary

c #WW      IF (my .GT. 1)                                           THEN
c #WW       DO i=lgx,ldx
c #WW          qFag      = 0.
c #WW          qFad      = 0.
c #WW          qFagi     = 0.
c #WW          qFadi     = 0.
c #WW        DO k=1,mz
c #WW          qt(-2)    =(qvDY(i,lgy2,k)
c #WW.                    +qwHY(i,lgy2,k)+qiHY(i,lgy2,k)
c #WW.                    +qrHY(i,lgy2,k)+qsHY(i,lgy2,k))*p_star(i,lgy2)
c #WW          qt(-1)    =(qvDY(i,lgy1,k)
c #WW.                    +qwHY(i,lgy1,k)+qiHY(i,lgy1,k)
c #WW.                    +qrHY(i,lgy1,k)+qsHY(i,lgy1,k))*p_star(i,lgy1)
c #WW          qt( 0)    =(qvDY(i,lgy ,k)
c #WW.                    +qwHY(i,lgy ,k)+qiHY(i,lgy ,k)
c #WW.                    +qrHY(i,lgy ,k)+qsHY(i,lgy ,k))*p_star(i,lgy )
 
C +--Water Fluxes,        y< Boundary

c #WW          qFag      =   qFag      +vairDY(i,lgy ,k) *dsigm1(k)
c #WW.                   *f2_3*((qt(-1)-qt( 0)) +0.125*(qt( 0)-qt(-2)))
c #WW          qFagi     =   qFagi     +vairDY(i,lgyy,k) *dsigm1(k)
c #WW.                   *f2_3*(                 0.125*(qt( 0)-qt(-1)))
 
C +--Water Concentration, y> Boundary

c #WW          qt( 0)    =(qvDY(i,ldy ,k)
c #WW.                    +qwHY(i,ldy ,k)+qiHY(i,ldy ,k)
c #WW.                    +qrHY(i,ldy ,k)+qsHY(i,ldy ,k))*p_star(i,ldy )
c #WW          qt( 1)    =(qvDY(i,ldy1,k)
c #WW.                    +qwHY(i,ldy1,k)+qiHY(i,ldy1,k)
c #WW.                    +qrHY(i,ldy1,k)+qsHY(i,ldy1,k))*p_star(i,ldy1)
c #WW          qt( 2)    =(qvDY(i,ldy2,k)
c #WW.                    +qwHY(i,ldy2,k)+qiHY(i,ldy2,k)
c #WW.                    +qrHY(i,ldy2,k)+qsHY(i,ldy2,k))*p_star(i,ldy2)
 
C +--Water Fluxes,        y> Boundary

c #WW          qFad      =   qFad      -vairDY(i,ldy ,k) *dsigm1(k)
c #WW.                   *f2_3*((qt( 1)-qt( 0)) +0.125*(qt( 0)-qt( 2)))
c #WW          qFadi     =   qFadi     -vairDY(i,ldyy,k) *dsigm1(k)
c #WW.                   *f2_3*(                 0.125*(qt( 0)-qt( 1)))
 
c #WW        ENDDO
c #WW          qLB_WB(1) = qLB_WB(1) +(qFag+qFad+qFagi+qFadi) ! [m w.e. m2/s3]
c #WW       ENDDO
c #WW      END IF
c #WW     END IF
 
C +--General Formulation
C +  ^^^^^^^^^^^^^^^^^^^
c #WW    ELSE
c #WW      DO   k=1,mz
 
c #WW        DO j=lgy,ldy
c #WW         qt(-1)    =   qvDY(lgx,j,k)
c #WW.                     +qwHY(lgx,j,k) +qiHY(lgx,j ,k)
c #WW.                     +qrHY(lgx,j,k) +qsHY(lgx,j ,k)
c #WW         qt( 1)    =   qvDY(ldx,j,k)
c #WW.                     +qwHY(ldx,j,k) +qiHY(ldx,j ,k)
c #WW.                     +qrHY(ldx,j,k) +qsHY(ldx,j ,k)
c #WW         qLB_WB(1) = qLB_WB(1)    + dsigm1(k)
c #WW.        *(p_star(lgx,j) * qt(-1) * uairDY(lgx,j,k)
c #WW.         -p_star(ldx,j) * qt( 1) * uairDY(ldx,j,k))
c #WW        ENDDO
 
c #WW        DO i=lgx,ldx
c #WW         qt(-1)    =   qvDY(i,lgy,k)
c #WW.                     +qwHY(i,lgy,k) +qiHY(i,lgy ,k)
c #WW.                     +qrHY(i,lgy,k) +qsHY(i,lgy ,k)
c #WW         qt( 1)    =   qvDY(i,ldy,k)
c #WW.                     +qwHY(i,ldy,k) +qiHY(i,ldy ,k)
c #WW.                     +qrHY(i,ldy,k) +qsHY(i,ldy ,k)
c #WW         qLB_WB(1) = qLB_WB(1)    + dsigm1(k)
c #WW.        *(p_star(i,lgy) * qt(-1) * vairDY(i,lgy,k)
c #WW.         -p_star(i,ldy) * qt( 1) * vairDY(i,ldy,k))
c #WW        ENDDO
 
c #WW      END DO
c #WW    END IF
c #WW   END IF
 
 
C +--Horizontal Diffusion                                 [m w.e. m2/s3]
C +  ~~~~~~~~~~~~~~~~~~~~                                 ~~~~~~~~~~~~~~
c #WW   IF (NoSubr.EQ.2 .AND. NoPass.LT.0.)                         THEN
c #WW     IF (mx .GT. 1)                                            THEN
c #WW       DO j=lgy,ldy
c #WW          qFdg      = 0.
c #WW          qFdd      = 0.
c #WW        DO k=1,mz
 
C +--Water Concentration, x< Boundary

c #WW          qt(-1)    =(qvDY(lgx1,j,k)
c #WW.                    +qwHY(lgx1,j,k)+qiHY(lgx1,j,k)
c #WW.                    +qrHY(lgx1,j,k)+qsHY(lgx1,j,k))*p_star(lgx1,j)
c #WW          qt( 0)    =(qvDY(lgx ,j,k)
c #WW.                    +qwHY(lgx ,j,k)+qiHY(lgx ,j,k)
c #WW.                    +qrHY(lgx ,j,k)+qsHY(lgx ,j,k))*p_star(lgx ,j)
 
C +--Water Fluxes,        x< Boundary

c #WW          qFdg      =   qFdg
c #WW.                   + (TUkhx(lgx1,j,k) *(qt(-1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
C +--Water Concentration, x> Boundary

c #WW          qt( 0)    =(qvDY(ldx ,j,k)
c #WW.                    +qwHY(ldx ,j,k)+qiHY(ldx ,j,k)
c #WW.                    +qrHY(ldx ,j,k)+qsHY(ldx ,j,k))*p_star(ldx ,j)
c #WW          qt( 1)    =(qvDY(ldx1,j,k)
c #WW.                    +qwHY(ldx1,j,k)+qiHY(ldx1,j,k)
c #WW.                    +qrHY(ldx1,j,k)+qsHY(ldx1,j,k))*p_star(ldx1,j)
 
C +--Water Fluxes,        x> Boundary

c #WW          qFdd      =   qFdd
c #WW.                   + (TUkhx(ldx ,j,k) *(qt( 1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
c #WW        ENDDO
c #WW          qLB_WB(2) = qLB_WB(2) + qFdg + qFdd      ! [m w.e. m2/s3]
c #WW       ENDDO
 
 
C +--Water Concentration, y< Boundary

c #WW      IF (my .GT. 1)                                           THEN
c #WW       DO i=lgx,ldx
c #WW          qFdg      = 0.
c #WW          qFdd      = 0.
c #WW        DO k=1,mz
c #WW          qt(-1)    =(qvDY(i,lgy1,k)
c #WW.                    +qwHY(i,lgy1,k)+qiHY(i,lgy1,k)
c #WW.                    +qrHY(i,lgy1,k)+qsHY(i,lgy1,k))*p_star(i,lgy1)
c #WW          qt( 0)    =(qvDY(i,lgy ,k)
c #WW.                    +qwHY(i,lgy ,k)+qiHY(i,lgy ,k)
c #WW.                    +qrHY(i,lgy ,k)+qsHY(i,lgy ,k))*p_star(i,lgy )
 
C +--Water Fluxes,        y< Boundary

c #WW          qFdg      =   qFdg
c #WW.                   +( TUkhy(i,lgy1,k) *(qt(-1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
C +--Water Concentration, y> Boundary

c #WW          qt( 0)    =(qvDY(i,ldy ,k)
c #WW.                    +qwHY(i,ldy ,k)+qiHY(i,ldy ,k)
c #WW.                    +qrHY(i,ldy ,k)+qsHY(i,ldy ,k))*p_star(i,ldy )
c #WW          qt( 1)    =(qvDY(i,ldy1,k)
c #WW.                    +qwHY(i,ldy1,k)+qiHY(i,ldy1,k)
c #WW.                    +qrHY(i,ldy1,k)+qsHY(i,ldy1,k))*p_star(i,ldy1)
 
C +--Water Fluxes,        y> Boundary

c #WW          qFdd      =   qFdd
c #WW.                   +( TUkhy(i,ldy ,k) *(qt( 1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
c #WW        ENDDO
c #WW          qLB_WB(2) = qLB_WB(2) + qFdg + qFdd      ! [m w.e. m2/s3]
c #WW       ENDDO
c #WW      END IF
c #WW     END IF
c #WW   END IF
 
 
C +--Digital Filter                                       [m w.e. m2/s3]
C +  ~~~~~~~~~~~~~~                                       ~~~~~~~~~~~~~~
c #WW   IF (NoSubr.EQ.6 .AND. NoPass.LT.0. .AND. FIBord)            THEN
c #WW     IF (mx .GT. 1)                                            THEN
c #WW       DO j=lgy,ldy
c #WW          qFdg      = 0.
c #WW          qFdd      = 0.
c #WW        DO k=1,mz
 
C +--Water Concentration, x< Boundary

c #WW          qt(-1)    =(qvDY(lgx1,j,k)
c #WW.                    +qwHY(lgx1,j,k)+qiHY(lgx1,j,k)
c #WW.                    +qrHY(lgx1,j,k)+qsHY(lgx1,j,k))*p_star(lgx1,j)
c #WW          qt( 0)    =(qvDY(lgx ,j,k)
c #WW.                    +qwHY(lgx ,j,k)+qiHY(lgx ,j,k)
c #WW.                    +qrHY(lgx ,j,k)+qsHY(lgx ,j,k))*p_star(lgx ,j)
 
C +--Water Fluxes,        x< Boundary

c #WW          qFdg      =   qFdg
c #WW.                   + (FIkhmn*FacFIk   *(qt(-1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
C +--Water Concentration, x> Boundary

c #WW          qt( 0)    =(qvDY(ldx ,j,k)
c #WW.                    +qwHY(ldx ,j,k)+qiHY(ldx ,j,k)
c #WW.                    +qrHY(ldx ,j,k)+qsHY(ldx ,j,k))*p_star(ldx ,j)
c #WW          qt( 1)    =(qvDY(ldx1,j,k)
c #WW.                    +qwHY(ldx1,j,k)+qiHY(ldx1,j,k)
c #WW.                    +qrHY(ldx1,j,k)+qsHY(ldx1,j,k))*p_star(ldx1,j)
 
C +--Water Fluxes,        x> Boundary

c #WW          qFdd      =   qFdd
c #WW.                   + (FIkhmn*FacFIk   *(qt( 1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
c #WW        ENDDO
c #WW          qLB_WB(6) = qLB_WB(6) + qFdg + qFdd      ! [m w.e. m2/s3]
c #WW       ENDDO
 
 
C +--Water Concentration, y< Boundary

c #WW      IF (my .GT. 1)                                           THEN
c #WW       DO i=lgx,ldx
c #WW          qFdg      = 0.
c #WW          qFdd      = 0.
c #WW        DO k=1,mz
c #WW          qt(-1)    =(qvDY(i,lgy1,k)
c #WW.                    +qwHY(i,lgy1,k)+qiHY(i,lgy1,k)
c #WW.                    +qrHY(i,lgy1,k)+qsHY(i,lgy1,k))*p_star(i,lgy1)
c #WW          qt( 0)    =(qvDY(i,lgy ,k)
c #WW.                    +qwHY(i,lgy ,k)+qiHY(i,lgy ,k)
c #WW.                    +qrHY(i,lgy ,k)+qsHY(i,lgy ,k))*p_star(i,lgy )
 
C +--Water Fluxes,        y< Boundary

c #WW          qFdg      =   qFdg
c #WW.                   +( FIkhmn*FacFIk   *(qt(-1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
C +--Water Concentration, y> Boundary

c #WW          qt( 0)    =(qvDY(i,ldy ,k)
c #WW.                    +qwHY(i,ldy ,k)+qiHY(i,ldy ,k)
c #WW.                    +qrHY(i,ldy ,k)+qsHY(i,ldy ,k))*p_star(i,ldy )
c #WW          qt( 1)    =(qvDY(i,ldy1,k)
c #WW.                    +qwHY(i,ldy1,k)+qiHY(i,ldy1,k)
c #WW.                    +qrHY(i,ldy1,k)+qsHY(i,ldy1,k))*p_star(i,ldy1)
 
C +--Water Fluxes,        y> Boundary

c #WW          qFdd      =   qFdd
c #WW.                   +( FIkhmn*FacFIk   *(qt( 1)-qt( 0)) / dx)
c #WW.                   * dsigm1(k)
 
c #WW        ENDDO
c #WW          qLB_WB(6) = qLB_WB(6) + qFdg + qFdd       ! [m w.e. m2/s3]
c #WW       ENDDO
c #WW      END IF
c #WW     END IF
c #WW   ELSE IF (NoSubr.EQ.6     .AND.     .NOT. FIBord)            THEN
c #WW       DO j=lgy,ldy
c #WW       DO i=lgx,ldx
c #WW          qLB_WB(6) = qLB_WB(6) + NoPass*qq_int(i,j)! [m w.e. m/s2]
c #WW       ENDDO
c #WW       ENDDO
c #WW   END IF
 
 
C +--FULL MODEL DOMAIN WATER BUDGET
C +  ------------------------------
 
C +--MODEL DOMAIN WATER CONTENT                            [m w.e. m2/s3]
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~                            ~~~~~~~~~~~~~~
c #ww   IF (NoSubr.EQ.9)                                            THEN
c #ww       qn__WB   = 0.
c #ww     DO j=1,my
c #ww     DO i=1,mx
c #ww       qMARij   = 0.
c #ww     DO k=1,mz
c #ww       qMARij   = qMARij
c #ww.               + dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
c #ww.                                        +qrHY(i,j,k)+qsHY(i,j,k))
c #ww     ENDDO
c #ww       qn__WB   = qn__WB +  p_star(i,j)  *grvinv  * qMARij
c #ww     ENDDO
c #ww     ENDDO
c #ww       dqt      =(qn__WB -  q00_WB) *864.e5/(dtProc*mx*my)
c #ww       dqt_WB   = dqt_WB +  dqt
c #ww       q00_WB   = qn__WB

C +--PRECIPITATION                                         [m w.e. m2/s3]
C +  ~~~~~~~~~~~~~                                         ~~~~~~~~~~~~~~
c #ww       qL  = 0.
c #ww       qO  = 0.
c #ww     DO j=1,my
c #ww     DO i=1,mx
c #ww       qrs = rainHY(i,j) + snowHY(i,j)
c #ww       qL  = qL + qrs * (1-maskSL(i,j)) 
c #ww       qO  = qO + qrs *    maskSL(i,j) 
c #ww     ENDDO
c #ww     ENDDO
c #ww       qL     =          qL                  /(mx*my)
c #ww       qLrsWB = qLrsWB +(qL - qL_0WB) *864.e5/dtProc   
c #ww       qLt    =         (qL - qL_0WB) *864.e5/dtProc
c #ww       qL_0WB =          qL

c #ww       qO     =          qO                  /(mx*my)
c #ww       qOrsWB = qOrsWB +(qO - qO_0WB) *864.e5/dtProc  
c #ww       qOt    =         (qO - qO_0WB) *864.e5/dtProc
c #ww       qO_0WB =          qO
 
C +--EVAPORATION                                           [m w.e. m2/s3]
C +  ~~~~~~~~~~~                                           ~~~~~~~~~~~~~~
c #ww       qvapL  =   0.
c #ww       qvapO  =   0.
c #ww     DO j=1,my
c #ww     DO i=1,mx
c #ww       qvap   =          - SLuqs(i,j)*rolvDY(i,j,mz)
c #ww       qvapL  =   qvapL  +  qvap * (1-maskSL(i,j))
c #ww       qvapO  =   qvapO  +  qvap *    maskSL(i,j)
c #ww     ENDDO
c #ww     ENDDO
c #ww       qvapL  =   qvapL             *864.e5/       (mx*my)
c #ww       qLv_WB =  qLv_WB  +  qvapL 
c #ww       qvapO  =   qvapO             *864.e5/       (mx*my)
c #ww       qOv_WB =  qOv_WB  +  qvapO 

C +--LARGE SCALE INFLOW/OUTFLOW                            [m w.e. m2/s3]
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~                            ~~~~~~~~~~~~~~
c #ww       qinpX              = 0.
c #ww       qoutX              = 0.

c #ww        i=1
c #ww     DO j=1,my
c #ww       qinp               = 0.
c #ww       qout               = 0.
c #ww     DO k=1,mz
c #ww       qLS                = uairDY(i,j,k)
c #ww.               * dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
c #ww.                                        +qrHY(i,j,k)+qsHY(i,j,k))
c #ww       qinp               = qinp + max(0.,qLS)
c #ww       qout               = qout + min(0.,qLS)
c #ww     ENDDO
c #ww       qinpX              = qinpX  + qinp * grvinv   *p_star(i,j)
c #ww       qoutX              = qoutX  + qout * grvinv   *p_star(i,j)
c #ww     ENDDO

c #ww        j=1
c #ww     DO i=1,mx
c #ww       qinp               = 0.
c #ww       qout               = 0.
c #ww     DO k=1,mz
c #ww       qLS                = vairDY(i,j,k)
c #ww.               * dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
c #ww.                                        +qrHY(i,j,k)+qsHY(i,j,k))
c #ww       qinp               = qinp + max(0.,qLS)
c #ww       qout               = qout + min(0.,qLS)
c #ww     ENDDO
c #ww       qinpX              = qinpX  + qinp * grvinv   *p_star(i,j)
c #ww       qoutX              = qoutX  + qout * grvinv   *p_star(i,j)
c #ww     ENDDO

c #ww        i=mx
c #ww     DO j=1,my
c #ww       qinp               = 0.
c #ww       qout               = 0.
c #ww     DO k=1,mz
c #ww       qLS                = uairDY(i,j,k)
c #ww.               * dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
c #ww.                                        +qrHY(i,j,k)+qsHY(i,j,k))
c #ww       qout               = qout - max(0.,qLS)
c #ww       qinp               = qinp - min(0.,qLS)
c #ww     ENDDO
c #ww       qinpX              = qinpX  + qinp * grvinv   *p_star(i,j)
c #ww       qoutX              = qoutX  + qout * grvinv   *p_star(i,j)
c #ww     ENDDO

c #ww        j=my
c #ww     DO i=1,mx
c #ww       qinp               = 0.
c #ww       qout               = 0.
c #ww     DO k=1,mz
c #ww       qLS                = vairDY(i,j,k)
c #ww.               * dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
c #ww.                                        +qrHY(i,j,k)+qsHY(i,j,k))
c #ww       qout               = qout - max(0.,qLS)
c #ww       qinp               = qinp - min(0.,qLS)
c #ww     ENDDO
c #ww       qinpX              = qinpX  + qinp * grvinv   *p_star(i,j)
c #ww       qoutX              = qoutX  + qout * grvinv   *p_star(i,j)
c #ww     ENDDO

c #ww       qinpX              =          qinpX *864.e5/(mx*my*dx)
c #ww       qinpWB             = qinpWB + qinpX
c #ww       qoutX              =          qoutX *864.e5/(mx*my*dx)
c #ww       qoutWB             = qoutWB + qoutX
c #ww       timtWB             = timtWB                + 1.
c #ww   END IF

 
C +--Continental Inflow
C +  ------------------
 
 
      END IF
 
 
C +--Budget Evaluation
C +  =================
 
 
C +--FULL MODEL DOMAIN WATER BUDGET
C +  ------------------------------
 
c #ww IF (NoSubr.EQ.9)                                              THEN
c #ww     IF (                       minuGE.EQ.0.AND.jsecGE.EQ.0)
c #ww.      write(6,6007) jdarGE,mmarGE,iyrrGE,jhurGE,minuGE,jsecGE
c #w+.                   ,qinpX ,qoutX ,qinpX +qoutX
c #w+.                   ,qOt   ,qLt   ,qOt   +qLt
c #w+.                   ,qvapO ,qvapL ,qvapO +qvapL ,dqt
c #ww.                   ,qinpWB        /timtWB
c #ww.                   ,qoutWB        /timtWB
c #ww.                  ,(qinpWB+qoutWB)/timtWB
c #ww.                   ,qOrsWB        /timtWB
c #ww.                   ,qLrsWB        /timtWB
c #ww.                  ,(qOrsWB+qLrsWB)/timtWB
c #ww.                   ,qOv_WB        /timtWB
c #ww.                   ,qLv_WB        /timtWB
c #ww.                  ,(qOv_WB+qLv_WB)/timtWB
c #ww.                   ,dqt_WB        /timtWB
c #ww.    ,(qinpWB+qoutWB-qOrsWB-qLrsWB+qOv_WB+qLv_WB-dqt_WB)/timtWB
 6007       format(i3,'-',i2,'-',i4,i3,'h',i2,':',i2,10f9.3
c #w+.          ,/,20x                              ,10f9.3
     .                                                 f9.3)
c #ww     IF (mod(jhurGE,6).EQ.0.AND.minuGE.EQ.0.AND.jsecGE.EQ.0)
c #ww.      write(6,6006)
 6006       format(' DD-MM-YYYY' ,9x
     .               ,6x,  'INP' ,6x,  'OUT  INP+OUT'
     .               ,4x,'ppp_O' ,4x,'ppp_L',6x,'ppp'
     .               ,4x,'vap_O' ,4x,'vap_L',6x,'vap'
     .               ,3x,'dq_DOM',3x,'BUDGET')
c #ww END IF
 
 
C +--Water Mass Increment (vertical Integral)                   [m w.e.]
C +  ----------------------------------------                   --------
 
      IF (makeWB)                                                   THEN
 
            DO j=1,my
            DO i=1,mx
               qq_int(i,j)   = 0.
             DO k=1,mz
               qq_int(i,j)   = qq_int(i,j)
     .             + dsigm1(k) *(qvDY(i,j,k)+qwHY(i,j,k)+qiHY(i,j,k)
     .                                      +qrHY(i,j,k)+qsHY(i,j,k))
             ENDDO
               qq_int(i,j)   = qq_int(i,j)  *pstDYn(i,j)
               dq__WB(i,j,7) = dq__WB(i,j,7)+qq_int(i,j)*grvinv
            ENDDO
            ENDDO
 
               ti_REF        =                 timeWB(0)
               timeWB(7)     =                 timeWB(0)
 
 
C +--Contribution of the Surface Water Fluxes
C +  ----------------------------------------
 
c #WW       DO n=0,8
c #WW          qSB_WB(n)     =  0.
c #WW       ENDDO
          IF  (timeWB(  1) .GT. 0. .AND. timeWB(  4) .GT. 0.)       THEN
            DO j=1,my
            DO i=1,mx
               wq__WB(i,j)   =(wq__WB(i,j)   / timeWB(  1)) *864.e5
               uq__WB(i,j)   =(uq__WB(i,j)   / timeWB(  4)) *864.e5
               us__WB(i,j)   =(us__WB(i,j)   / timeWB(  4)) *864.e5
c #WW          qSB_WB(1)     = qSB_WB(1)     + wq__WB(i,j)  *use_pt(i,j)
c #WW          qSB_WB(4)     = qSB_WB(4)     +(uq__WB(i,j)
c #WW.                                        +us__WB(i,j)) *use_pt(i,j)
            ENDDO
            ENDDO
          END IF
c #WW          qSB_WB(1)     = qSB_WB(1)     / nxy
c #WW          qSB_WB(4)     = qSB_WB(4)     / nxy
 
 
C +--Atmospheric Budgets
C +  -------------------
 
        DO n=0,7
c #WW     IF  (timeWB(    n) .NE.              ti_REF)              THEN
c #WW          write(6,5999) jdarGE,labmGE(mmarGE),iyrrGE
c #WW.                      ,jhurGE,minuGE        ,jsecGE
c #WW.                      ,n     ,timeWB(n)/3600,ti_REF/3600
 5999          format(' CAUTION in Water Budget Evaluation: '
     .             ,/,' ON',i3,'-',a3,'-',i4,' at',i3,':',i2,':',i2,'UT'
     .               ,' Time Integral on Process',i2,' =',f8.2,'h .NE. '
     .               ,                                    f8.2,'h'     )
c #WW     END IF
 
C +--Local       Budget
C +  ~~~~~~~~~~~~~~~~~~
          IF  (timeWB(    n) .GT. 0.)                               THEN
c #WW          qt__WB(    n) =    0.
            DO j=1,my
            DO i=1,mx
               dq__WB(i,j,n) =(dq__WB(i,j,n) / timeWB(    n))
     .                       * 864.e5
               ! Conversion   [m w.e./s] --> [mm w.e./day]
 
C +--Domain      Budget
C +  ~~~~~~~~~~~~~~~~~~
               qt__WB(    n) = qt__WB(    n) + dq__WB(i,j,n)*use_pt(i,j)
            ENDDO
            ENDDO
c #WW          qt__WB(    n) = qt__WB(    n) /    nxy
c #WW          qLB_WB(    n) =(qLB_WB(    n) / timeWB(    n))
c #WW.                       * 864.e5
               timeWB(    n) =    0.
          END IF
        ENDDO
 
C +--Contribution of Lateral Boundaries: Conversion --> [m w.e.]
 
c #WW          qLB_WB(    1) = qLB_WB(    1) * dtx * grvinv / nxy
c #WW          qLB_WB(    2) = qLB_WB(    2) * dtx * grvinv / nxy
c #WW          qLB_WB(    6) = qLB_WB(    6) * dtx * grvinv / nxy
 
 
C +--Contribution of Precipitation
C +  ------------------------------
 
          IF  (ti_REF        .GT. 0.)                               THEN
            DO j=1,my
            DO i=1,mx
               drr_WB(i,j)   =(rainHY(i,j)   - rr_0WB(i,j))
     .                       * 864.e5        / ti_REF
               dss_WB(i,j)   =(snowHY(i,j)   - ss_0WB(i,j))
     .                       * 864.e5        / ti_REF
c #CA          drrcWB(i,j)   =(rainCA(i,j)   - rrc0WB(i,j))
c #CA.                       * 864.e5        / ti_REF
c #CA          dsscWB(i,j)   =(snowCA(i,j)   - ssc0WB(i,j))
c #CA.                       * 864.e5        / ti_REF
               qSB_WB(5)     = qSB_WB(5)     -(drr_WB(i,j)
     .                                        +dss_WB(i,j)
c #PC.                                        +drrcWB(i,j)
c #PC.                                        +dsscWB(i,j)
     .                                        +us__WB(i,j))*use_pt(i,j)
            ENDDO
            ENDDO
c #WW          qSB_WB(5)     = qSB_WB(5)     / nxy
               ti_REF        =    0.
          END IF
 
 
C +--OUTPUT
C +  ------
 
c #WW       write(6,6000)jdarGE,labmGE(mmarGE),iyrrGE,jhurGE,minuGE
 6000       format(/,'WATER BUDGET on',i3,'-',a3,'-',i4,
     .                           ' at',i3,'h',i2)
c #WW       write(6,6001)
 6001       format('------------------------+-------------+',
     .                                      '-------------+',
     .                                      '-------------+',
     .                                      '-------------+')
c #WW       write(6,6002)
 6002       format('No Process              | Domain      |',
     .                                      ' LB          |',
     .                                      ' SB          |',
     .                                      ' Budget      |')
c #WW       write(6,6001)
c #WW                     n=7
c #WW       write(6,6003) n,Process(7),qt__WB(7),qLB_WB(7),qSB_WB(7)
c #WW.                                ,qt__WB(7)-qLB_WB(7)-qSB_WB(7)
c #WW       qt__WB(8) =                0.
c #WW       qLB_WB(8) =                0.
c #WW       qSB_WB(8) =                0.
c #WW     DO n=0,6
c #WW       write(6,6003) n,Process(n),qt__WB(n),qLB_WB(n),qSB_WB(n)
c #WW.                                ,qt__WB(n)-qLB_WB(n)-qSB_WB(n)
 6003       format(i2,1x,a20,' |',4(f12.6,' |'))
c #WW       qt__WB(8) =                qt__WB(8)+qt__WB(n)
c #WW       qLB_WB(8) =                qLB_WB(8)+qLB_WB(n)
c #WW       qSB_WB(8) =                qSB_WB(8)+qSB_WB(n)
c #WW     ENDDO
c #WW                     n=8
c #WW       write(6,6003) n,Process(8),qt__WB(8),qLB_WB(8),qSB_WB(8)
c #WW.                                ,qt__WB(8)-qLB_WB(8)-qSB_WB(8)
c #WW       write(6,6001)
c #WW       write(6,6004)
 6004       format(1x)

          IF (iterun.EQ.0)                                          THEN
              nttH2O = 0
              open(unit=34,status='NEW',file='H2O_WB.OUT')
          END IF
              nttH2O    = nttH2O      +       1
          DO         n=0,8
              qttH2O(n) =              qt__WB(n)-qLB_WB(n)-qSB_WB(n)
          ENDDO
            write(34,341) jdarGE,mmarGE,iyrrGE,jhurGE,minuGE,jsecGE
     .                   ,nttH2O     ,(qttH2O(n),n=0,8)
 341        format(2i3,i5,3i3,i6,9f10.6)
 
 
C +--Continental Budget
C +  ------------------
 
 
      END IF
 
      return
      end


      subroutine DUST

C +------------------------------------------------------------------------+
C | MAR          DUST SubModel                             30-09-2002  MAR |
C |   SubRoutine DUST computes Dust Particles Sedimentation                |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_TC.inc'

      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

      integer  itmx  ,it          !
      real     wwDust             ! Dust Sedimentation Velocity
      real     vsmx  ,dzmn ,dtmn  !


C +--DATA
C +  ====

      data     wwDust/0.1/


C +--CAUTION
C +  =======

      IF (ntrac.NE.1)                                             THEN
        write(6,*) ' NO or MORE THAN ONE Dust Species ',
     .             ' !!#¹@|#@&##!!     EMERGENCY EXIT '
        STOP
      END IF


C +--DUST Sedimentation
C +  ==================

        vsmx = wwDust
        dzmn = zsigma(mz)

        itmx = int(1.0d0 + dt * vsmx /(dzmn*0.25))
C +...  accounts for strong vertical gradient of falling blown snow particles
C +
        itmx = max(1,itmx)
        dtmn = dt  / itmx

      DO    it=    1,itmx

         DO k =      mz,2,-1
         DO j =    1,my
         DO i =    1,mx
          WKxyz1(i,j,k) = qxTC(i,j,k  ,1)*pstDYn(i,j)*dsigm1(    k  )
     .  + gravit *dtmn  *(qxTC(i,j,k-1,1)*wwDust     *rolvDY(i,j,k-1)
     .                   -qxTC(i,j,k  ,1)*wwDust     *rolvDY(i,j,k  ))
         END DO
         END DO
         END DO

         DO j =    1,my
         DO i =    1,mx
          WKxyz1(i,j,1) = qxTC(i,j,1  ,1)*pstDYn(i,j)*dsigm1(    1)
     .  - gravit *dtmn  * qxTC(i,j,1  ,1)*wwDust     *rolvDY(i,j,1)
         END DO
         END DO

         DO k =    1,mz
         DO j =    1,my
         DO i =    1,mx
            qxTC(i,j,k,1) = WKxyz1(i,j,k) / (pstDYn(i,j)*dsigm1(k))
         END DO
         END DO
         END DO

      END DO


C +--WORK Variable RESET
C +  ===================

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.
      END DO
      END DO
      END DO

      return
      end


      subroutine TRCadv_ver
C +
C +------------------------------------------------------------------------+
C | MAR TRACERS                                            18-09-2001  MAR |
C |   SubRoutine TRCadv_ver includes the Vertical   Advection Contribution |
C |                              for the Tracers (Chemical Species, Dust..)|
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   METHOD:  Unstaggered Grid: 1st Accurate in Space Upstream Scheme     |
C |   ^^^^^^^^   Staggered Grid: 2nd Accurate in Space                     |
C |                                                                        |
C |   INPUT  : qxTC  : Tracer x        (Positive Definite)        (kg/kg)  |
C |   ^^^^^^^^ qsTC  : Tracer x        (Surface Value)            (kg/kg)  |
C |                                                                        |
C |   OUTPUT : idem                                                        |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C | # OPTIONS: +CA: Convective adjustement inhibits Vertical Advection     |
C | # ^^^^^^^^ + => still to be included (when included in conv_adjust)    |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_TC.inc'
C +
C +CA include 'MAR_CA.inc'
C +
      include 'MAR_WK.inc'
C +
c #WA integer                  nadvrd
c #WA common  /DYNadv_ver_loc/ nadvrd
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  ntimax,itimax,n
      real     cflmax,cflsig,faccfl
      real     qv_0  ,qw_0  ,qr_0  
      real     old__u,old__v,old__t
C +
      logical  centrL
c #ZU logical  adv3rd
c #ZU real     gat(mx,my,mz),ga0(mx,my)
C +
C +
C +--DATA
C +  ====
C +
c #ZU data adv3rd/ .true./
C +
      data centrL/ .true./
c #UP      centrL=.false.
C +
C +
C +--Slip condition for Mountain Wave Experiments
C +  ============================================
C +
c #OM   DO       j=jp11,my1
c #OM   DO       i=ip11,mx1
c #OM     psigDY(i,j,mz)=0.d0
c #OM   END DO
c #OM   END DO
C +
C +
C +--First and Second Order Schemes
C +  ==============================
C +
c #ZU IF (.not.adv3rd)                                            THEN 
C +
C +
C +--Courant Number
C +  --------------
C +
           cflmax     = 0.d0
C +
C +--Centered second Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       IF (centrL.and.staggr)                                     THEN
C +
c #WA     write(6,6001)iterun
 6001     format(i6,' 6001       centrL .and.       staggr /CFL Number')
C +
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*psigDY(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.d0)
            cflsig     = abs(WKxyz7(i,j,k)+WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)=                 0.00d0
          END DO
          END DO
C +
          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=dt*psigDY(i,j,km1(k))
     .                     /(pstDYn(i,j)*dsigm1(k)*2.d0)
            cflsig     = abs(WKxyz8(i,j,k)+WKxyz8(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
       ELSE
C +
C +--Upstream first  Order Scheme on a       staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF           (staggr)                                     THEN
C +
c #WA     write(6,6002)iterun
 6002     format(i6,' 6002 .not. centrL .and.       staggr /Wind Speed')
C +
          DO       k=kp1(1),mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)=(psigDY(i,j,k-1)*dsig_1(k-1)
     .                    +psigDY(i,j,k)  *dsig_1(k))
     .                   /(dsig_1    (k-1)+dsig_1(k))
          END DO
          END DO
          END DO
C +
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,1)= psigDY(i,j,1)  *dsig_1(1)
     .                   /(dsig_1    (0)  +dsig_1(1))
          END DO
          END DO
C +
C +--Upstream first  Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE
C +
c #WA     write(6,6003)iterun
 6003     format(i6,' 6003 (.not.)centrL.and. .not. staggr /Wind Speed')
C +
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz8(i,j,k)= psigDY(i,j,k)
          END DO
          END DO
          END DO
C +
        END IF
C +
C +--Centered second Order Scheme on a  non  staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IF(centrL)                                                THEN
C +
c #WA     write(6,6004)iterun
 6004     format(i6,' 6004        centrL.and. .not. staggr /CFL Number')
C +
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)=dt*WKxyz8(i,j,k)     
     .                     /(pstDYn(i,j)*dsigm1(k)*2.d0)
            cflsig     = abs(WKxyz7(i,j,k))
            cflmax     = max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
C +--Upstream first  Order Scheme on a (non) staggered Grid
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ELSE
C +
c #WA     write(6,6005)iterun
 6005     format(i6,' 6005  .not. centrL.and.(.not.)staggr /CFL Number')
C +
          DO          k=    1 ,mmz1
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.d0)                             THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO
          END DO
C +
                      k=  mz
          DO          j=jp11,my1
          DO          i=ip11,mx1
            IF(WKxyz8(i,j,k).gt.0.d0)                             THEN
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k-1))
            ELSE
               WKxyz7(i,j,k)=-dt*WKxyz8(i,j,k)/(pstDYn(i,j)*dsig_1(k  ))
            END IF
               cflsig       =abs(WKxyz7(i,j,k))
               cflmax       =max(cflsig,cflmax)
          END DO
          END DO
C +
          DO          j=1,my
          DO          i=1,mx
               WKxyz7(i,j,1)= 0.d0
          END DO
          END DO
C +
C +--Work Array Reset
C +  ~~~~~~~~~~~~~~~~
          DO          k=1,mz
          DO          j=1,my
          DO          i=1,mx
               WKxyz8(i,j,k)= 0.d0
          END DO
          END DO
          END DO
C +
        END IF
C +
       END IF
C +
C +
C +--Set Up    of the Local Split Time Differencing
C +  ----------------------------------------------
C +
            cflmax    = 2.d0 *cflmax
C +...      restricted CFL Criterion
C +
            ntimax    =       cflmax
       IF  (centrL)                                               THEN
            ntimax    = max(2,ntimax)
c #WA     write(6,6006)ntimax
 6006     format(i6,' 6006        centrL.and.(.not.)staggr /Nb Iterat.')
       ELSE
            ntimax    = max(1,ntimax)
c #WA     write(6,6007)ntimax
 6007     format(i6,' 6007  .not. centrL.and.(.not.)staggr /Nb Iterat.')
       END IF
C +
C +--Update of CFL Number
C +  ~~~~~~~~~~~~~~~~~~~~
       IF  (ntimax.gt.1)                                          THEN
            faccfl       = 1.0d+0        / ntimax    
          DO       k=1,mz
          DO       j=jp11,my1
          DO       i=ip11,mx1
            WKxyz7(i,j,k)= WKxyz7(i,j,k) * faccfl 
            WKxyz8(i,j,k)= WKxyz8(i,j,k) * faccfl 
          END DO
          END DO
          END DO
       END IF
C +
C +--OUTPUT for Verification
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #WA  nadvrd      = nadvrd                 + 1
c #WA  write(6,6000) nadvrd,cflmax,ntimax
 6000  format(i6,' CFLmax ',3x,' ',3x,'  =',f7.4,
     .        6x,' ntimax ',8x,  '   =',i4)
C +
C +
C +--Loop on Tracers; BEGIN
C +  ======================
C +
       DO n=1,ntrac
C +
C +--2nd Order Centered Energy conserving:  Local Split Time Differencing
C +  --------- (Haltiner & Williams 1980 7.2.2, (7-47b) p.220) ----------
C +            -----------------------------------------------
C +
       IF   (centrL)                                              THEN
C +
        IF  (staggr)                                              THEN
C +
c #WA     write(6,6008)
 6008     format(6x,' 6008        centrL.and.       staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN
C +
            DO       j=jp11,my1
C +
C +--Vertical Differences
C +  
                     k=    1
              DO     i=ip11,mx1
                  qv_0       =                    qxTC(i,j,k  ,n)
                WKxzc(i,k)   =(  qxTC(i,j,k,n)-   qv_0)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxzc(i,k)   =(  qxTC(i,j,k,n)-   qxTC(i,j,k-1,n)) 
              END DO
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   =                - WKxyz4(i,j,k-1)
                WKxy2(i,j)   =                - WKxyz5(i,j,k-1)
                WKxy3(i,j)   =(  qxTC(i,j,k,n)- WKxyz6(i,j,k-1)) 
              END DO
C +
C +--Advection Contribution
C +  
              DO       k=    1 ,mmz1
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  * WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  * WKxzc(i,k)
                WKxyz3(i,j,k)=   qxTC(i,j,k,n)- WKxzd(i,k)
                WKxyz6(i,j,k)=   qxTC(i,j,k,n)-(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO
C +
                       k=       mmz
              DO       i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  * WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  * WKxzc(i,k)
                WKxyz3(i,j,k)=   qxTC(i,j,k,n)- WKxzd(i,k)
                WKxyz6(i,j,k)=   qxTC(i,j,k,n)-(WKxzd(i,k)+WKxzd(i,k))
              END DO
C +
            END DO
C +
C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN
C +
C +--Vertical Differences
C +
            DO       j=jp11,my1
C +
                     k=    1
              DO     i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k)  -  qw_0)
                WKxzb(i,k)   =(WKxyz5(i,j,k)  -  qr_0)
                WKxzc(i,k)   =(WKxyz6(i,j,k)  -  qv_0)
              END DO
C +
              DO      k=kp1(1),mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k)  -WKxyz4(i,j,k-1)) 
                WKxzb(i,k)   =(WKxyz5(i,j,k)  -WKxyz5(i,j,k-1)) 
                WKxzc(i,k)   =(WKxyz6(i,j,k)  -WKxyz6(i,j,k-1)) 
              END DO
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   =                -WKxyz4(i,j,k-1)
                WKxy2(i,j)   =                -WKxyz5(i,j,k-1)
                WKxy3(i,j)   =(  qsTC(i,j,n)  -WKxyz6(i,j,k-1)) 
              END DO
C +
C +--Advection Contribution
C +  
              DO      k=    1 ,mmz1
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxza(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzb(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxzc(i,k+1)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy1(i,j)
     .                        +WKxyz8(i,j,k)  *WKxza(i,k)
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy2(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzb(i,k)
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzd(i,k)+WKxzd(i,k))
C +
                WKxzd( i,k)  = WKxyz7(i,j,k)  *WKxy3(i,j)
     .                        +WKxyz8(i,j,k)  *WKxzc(i,k)
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzd(i,k)+WKxzd(i,k))
              END DO
C +
            END DO
C +
C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE
C +
            DO       j=jp11,my1
C +
C +--Vertical Differences
C +  
                      k=    1
              DO      i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k)  -  qw_0)
                WKxzb(i,k)   =(WKxyz5(i,j,k)  -  qr_0)
                WKxzc(i,k)   =(WKxyz6(i,j,k)  -  qv_0)
              END DO
C +
              DO      k=kp1(1),mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k)  -WKxyz4(i,j,k-1)) 
                WKxzb(i,k)   =(WKxyz5(i,j,k)  -WKxyz5(i,j,k-1)) 
                WKxzc(i,k)   =(WKxyz6(i,j,k)  -WKxyz6(i,j,k-1)) 
              END DO
              END DO
C +
                      k=       mzz
              DO      i=ip11,mx1
                WKxy1(i,j)   =                -WKxyz4(i,j,k-1)
                WKxy2(i,j)   =                -WKxyz5(i,j,k-1)
                WKxy3(i,j)   =(  qsTC(i,j,n)  -WKxyz6(i,j,k-1)) 
              END DO
C +
C +--Wat.Vapr.Advect.avoids double Counting in case of convective Adjustment
C +
              DO             k=    1 ,mmz1
              DO           i=ip11,mx1
C +CA           IF (adj_CA(i,j).eq.0)                             THEN
                      qxTC(i,j,k,n)= max(zero,WKxyz3(i,j,k)
     .                                      -(WKxyz7(i,j,k)*WKxzc(i,k+1)
     .                                       +WKxyz8(i,j,k)*WKxzc(i,k)))
C +CA           END IF
              END DO
              END DO
C +
                             k=       mmz
              DO           i=ip11,mx1
C +CA           IF (adj_CA(i,j).eq.0)                             THEN
                      qxTC(i,j,k,n)= max(zero,WKxyz3(i,j,k)
     .                                      -(WKxyz7(i,j,k)*WKxy3(i,j)
     .                                       +WKxyz8(i,j,k)*WKxzc(i,k)))
C +CA           END IF
              END DO
C +
            END DO
C +
          END IF
C +
C +
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
C +
C +--2nd Order Centered Leap-Frog Backward: Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
        ELSE
C +
c #WA     write(6,6009)
 6009     format(6x,' 6009        centrL.and. .not. staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--First        internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          IF(itimax.eq. 1)                                        THEN
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +  
                     k=    1
              DO     i=ip11,mx1
                  qv_0       =                     qxTC(i,j,k  ,n)
                WKxzc(i,k)   =(  qxTC(i,j,k+1,n)-  qxTC(i,j,k  ,n)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxzc(i,k)   =(  qxTC(i,j,k+1,n)-  qxTC(i,j,k-1,n)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxzc(i,k)   =(  qsTC(i,j,n)    -  qxTC(i,j,k-1,n)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO       k=    1 ,mmz
              DO       i=ip11,mx1
                WKxyz3(i,j,k)=   qxTC(i,j,k,n)- WKxzc(i,k)
                WKxyz6(i,j,k)=   qxTC(i,j,k,n)-(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
            END DO
C +
C +--Intermediary internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE IF (itimax.lt.ntimax)                              THEN
C +
C +--Advection Increment
C +
            DO       j=jp11,my1
C +
                     k=    1
              DO     i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qw_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-  qr_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(  qsTC(i,j,n)  -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Advection Contribution
C +  
              DO      k=    1 ,mmz
              DO      i=ip11,mx1
                old__u       = WKxyz1(i,j,k)
                WKxyz1(i,j,k)= WKxyz4(i,j,k)
                WKxyz4(i,j,k)= old__u        -(WKxza(i,k)+WKxza(i,k))
                old__v       = WKxyz2(i,j,k)
                WKxyz2(i,j,k)= WKxyz5(i,j,k)
                WKxyz5(i,j,k)= old__v        -(WKxzb(i,k)+WKxzb(i,k))
                old__t       = WKxyz3(i,j,k)
                WKxyz3(i,j,k)= WKxyz6(i,j,k)
                WKxyz6(i,j,k)= old__t        -(WKxzc(i,k)+WKxzc(i,k))
              END DO
              END DO
C +
            END DO
C +
C +--Last         internal Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ELSE
C +
            DO       j=jp11,my1
C +
C +--Advection Increment
C +
                      k=    1
              DO      i=ip11,mx1
                  qw_0       =                 WKxyz4(i,j,k)
                  qr_0       =                 WKxyz5(i,j,k)
                  qv_0       =                 WKxyz6(i,j,k)
C +
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-  qw_0)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-  qr_0)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-  qv_0)
     .                        *WKxyz7(i,j,k)
              END DO
C +
              DO      k=kp1(1),mmz1
              DO      i=ip11,mx1
                WKxza(i,k)   =(WKxyz4(i,j,k+1)-WKxyz4(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =(WKxyz5(i,j,k+1)-WKxyz5(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(WKxyz6(i,j,k+1)-WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
              END DO
C +
                      k=       mmz
              DO      i=ip11,mx1
                WKxza(i,k)   =                -WKxyz4(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzb(i,k)   =                -WKxyz5(i,j,k-1)
     .                        *WKxyz7(i,j,k)
                WKxzc(i,k)   =(  qsTC(i,j,n)  -WKxyz6(i,j,k-1)) 
     .                        *WKxyz7(i,j,k)
              END DO
C +
C +--Wat.Vapr.Advect.avoids double Counting in case of convective Adjustment
C +
              DO             k=    1 ,mmz
                DO           i=ip11,mx1
C +CA             IF (adj_CA(i,j).eq.0)                           THEN
                        qxTC(i,j,k,n) = max(zero,
     .                                      WKxyz3(i,j,k) -WKxzc(i,k))
C +CA             END IF
                END DO
              END DO
C +
            END DO
C +
          END IF
C +
C +
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
         END DO
C +
        END IF
C +
C +
C +--First  Order Upstream Scheme:          Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
       ELSE
C +
c #WA     write(6,6010)
 6010     format(6x,' 6010  .not. centrL.and.(.not.)staggr /A Contrib.')
C +
         DO  itimax=    1,ntimax
C +
C +--Auxiliary Variables
C +  ~~~~~~~~~~~~~~~~~~~
c #WA     write(6,6011)itimax,
c #WA.                 WKxyz1(imez,jmez,mz1)  ,WKxyz1(imez,jmez,mz)
c #WA.                ,  qxTC(imez,jmez,mz1,1),  qxTC(imez,jmez,mz,1)
 6011     format(6x,' 6011  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)
C +
             DO       k=1,mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz3(i,j,k)=   qxTC(i,j,k,n)
             END DO
             END DO
             END DO
C +
C +--Vertical Differences
C +  ~~~~~~~~~~~~~~~~~~~~
                      k=1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = 0.0d+0
               WKxyz5(i,j,k) = 0.0d+0
               WKxyz6(i,j,k) = 0.0d+0
             END DO
             END DO
C +
             DO       k=kp1(1),mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz4(i,j,k) = WKxyz1(i,j,k)-WKxyz1(i,j,k-1)
               WKxyz5(i,j,k) = WKxyz2(i,j,k)-WKxyz2(i,j,k-1)
               WKxyz6(i,j,k) = WKxyz3(i,j,k)-WKxyz3(i,j,k-1)
             END DO
             END DO
             END DO
C +
                      k=  mzz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxy1 (i,j)   =              -WKxyz1(i,j,k-1)
               WKxy2 (i,j)   =              -WKxyz2(i,j,k-1)
               WKxy3 (i,j)   =   qsTC(i,j,n)-WKxyz3(i,j,k-1)
             END DO
             END DO
C +
C +--Advection Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~
             DO       k=    1 ,mmz1
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz3(i,j,k)=  qxTC(i,j,k,n)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k+1)
             END DO
             END DO
             END DO
C +
                      k=mz
             DO       j=jp11,my1
             DO       i=ip11,mx1
               WKxyz3(i,j,k)=  qxTC(i,j,k,n)
     .             +min(zero,WKxyz7(i,j,k))*WKxyz6(i,j,k)
     .             +max(zero,WKxyz7(i,j,k))*WKxy3( i,j)
             END DO
             END DO
C +
C +--Wat.Vapr.Update avoids double Counting in case of convective Adjustment
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             DO             k=1,mz
             DO             j=jp11,my1
               DO           i=ip11,mx1
C +CA            IF (adj_CA(i,j).eq.0)                            THEN
                       qxTC(i,j,k,n) = max(zero,WKxyz3(i,j,k))
C +CA            END IF
               END DO
             END DO
             END DO
C +
C +
C +--End of the                             Local Split Time Differencing
C +  --------------------------------------------------------------------
C +
c #WA     write(6,6012)itimax,
c #WA.                 WKxyz1(imez,jmez,mz1)  ,WKxyz1(imez,jmez,mz)
c #WA.                ,  qxTC(imez,jmez,mz1,1),  qxTC(imez,jmez,mz,1)
 6012     format(6x,' 6012  .not. centrL.and.(.not.)staggr /A Contrib.',
     .                        4f9.6)
         END DO
C +
       END IF
C +
C +
C +--Work Arrays Reset
C +  -----------------
C +
       DO       j=1,my
       DO       i=1,mx
         WKxy1( i,j)   = 0.d0
         WKxy2( i,j)   = 0.d0
         WKxy3( i,j)   = 0.d0
       END DO
       END DO
C +
       DO       k=1,mz
       DO       i=1,mx
         WKxza( i,  k) = 0.d0
         WKxzb( i,  k) = 0.d0
         WKxzc( i,  k) = 0.d0
         WKxzd( i,  k) = 0.d0
       END DO
       END DO
C +
       DO       k=1,mz
       DO       j=1,my
       DO       i=1,mx
         WKxyz1(i,j,k) = 0.d0
         WKxyz2(i,j,k) = 0.d0
         WKxyz3(i,j,k) = 0.d0
         WKxyz4(i,j,k) = 0.d0
         WKxyz5(i,j,k) = 0.d0
         WKxyz6(i,j,k) = 0.d0
       END DO
       END DO
       END DO
C +
C +
C +--Loop on Tracers;   END
C +  ======================
C +
       END DO
C +
C +
C +--Work Arrays Reset
C +  =================
C +
       DO       k=1,mz
       DO       j=1,my
       DO       i=1,mx
         WKxyz7(i,j,k) = 0.d0
         WKxyz8(i,j,k) = 0.d0
       END DO
       END DO
       END DO
C +
C +
C +--Third Order Vertical Scheme
C +  ===========================
C +
c #ZU ELSE 
C +
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  ga0(i,j)      =   qsTC(i,j,n)  
c #ZO  ga0(i,j)      =   qxTC(i,j,mz,n)
c #ZU  END DO
c #ZU  END DO
C +
c #ZU  DO  k=1,mz
c #ZU  DO  j=jp11,my1
c #ZU  DO  i=ip11,mx1
c #ZU  gat(i,j,k)    =   qxTC(i,j,k ,n)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
C +    ****************
c #ZU  call DYNadv_cubv(gat,ga0)
C +    ****************
C +
c #ZU  DO     k=1,mz
c #ZU  DO     j=jp11,my1
c #ZU  DO     i=ip11,mx1
c #ZU    qxTC(i,j,k,n) = max(gat(i,j,k),zero)
c #ZU  END DO
c #ZU  END DO
c #ZU  END DO
C +
c #ZU end if 
C +
      return
      end
      subroutine POSfil
C +
C +------------------------------------------------------------------------+
C | MAR HYDROL.  FILTER                                    15-09-2001  MAR |
C |   SubRoutine POSfil     is used to Filter Microphysical Variables      |
C |                                           Tracers    Fields            |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT  : qwHY, qiHY, qrHY, qsHY, ccniHY: variables to be filtered    |
C |   ^^^^^^^^ qxTC                                                        |
C |                                                                        |
C |   OUTPUT : qwHY, qiHY, qrHY, qsHY, ccniHY                              |
C |   ^^^^^^^^ qxTC                                                        |
C |                                                                        |
C |   LATERAL BOUNDARIES:                                                  |
C |   ^^^^^^^^^^^^^^^^^^^                                                  |
C |      The value    of the variable is fixed at the Boundary             |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_FI.inc'
C +
c #HY include 'MAR_HY.inc'
c #TC include 'MAR_TC.inc'
C +
      include 'MAR_WK.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      integer itrac 
c #HY real    S1_pqw,S1_pqi,S1_pci,S1_pqr,S1_pqs
c #HY real    S2_pqw,S2_pqi,S2_pci,S2_pqr,S2_pqs
c #TC real    S1_pqx,S2_pqx
C +
      logical TRCfil,HYDfil
      data    TRCfil/.true./
      data    HYDfil/.false./
C +
C +
C +--Filtering of Microphysical Variables
C +  ====================================
C +
c #HY if     (HYDfil) then
C +
c #HY do 4101 k=1,mz
C +
C +
C +--Cloud         Variables
C +  -----------------------
C +
c #HY S1_pqw = 0.0d0
c #HY S1_pqi = 0.0d0
c #HY S1_pci = 0.0d0
C +
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY S1_pqw = S1_pqw +  pstDYn(    i ,    j ) *   qwHY(    i ,    j ,k)
c #HY WKxy1(i,j) = 
c #HY.                                             qwHY(im1(i),jp1(j),k)
c #HY.           + 2.d0*                           qwHY(    i ,jp1(j),k)
c #HY.           +                                 qwHY(ip1(i),jp1(j),k)
c #HY.           + 2.d0*                           qwHY(im1(i),    j ,k) 
c #HY.           + 4.d0*                           qwHY(    i ,    j ,k)     
c #HY.           + 2.d0*                           qwHY(ip1(i),    j ,k)     
c #HY.           +                                 qwHY(im1(i),jm1(j),k) 
c #HY.           + 2.d0*                           qwHY(    i ,jm1(j),k)
c #HY.           +                                 qwHY(ip1(i),jm1(j),k)
C +
c #HY S1_pqi = S1_pqi +  pstDYn(    i ,    j ) *   qiHY(    i ,    j ,k)
c #HY WKxy2(i,j) = 
c #HY.                                             qiHY(im1(i),jp1(j),k)
c #HY.           + 2.d0*                           qiHY(    i ,jp1(j),k)
c #HY.           +                                 qiHY(ip1(i),jp1(j),k)
c #HY.           + 2.d0*                           qiHY(im1(i),    j ,k) 
c #HY.           + 4.d0*                           qiHY(    i ,    j ,k)     
c #HY.           + 2.d0*                           qiHY(ip1(i),    j ,k)     
c #HY.           +                                 qiHY(im1(i),jm1(j),k) 
c #HY.           + 2.d0*                           qiHY(    i ,jm1(j),k)
c #HY.           +                                 qiHY(ip1(i),jm1(j),k)
C +
c #HY S1_pci = S1_pci +  pstDYn(    i ,    j ) * ccniHY(    i ,    j ,k)
c #HY WKxy3(i,j) = 
c #HY.                                           ccniHY(im1(i),jp1(j),k)
c #HY.           + 2.d0*                         ccniHY(    i ,jp1(j),k)
c #HY.           +                               ccniHY(ip1(i),jp1(j),k)
c #HY.           + 2.d0*                         ccniHY(im1(i),    j ,k) 
c #HY.           + 4.d0*                         ccniHY(    i ,    j ,k)     
c #HY.           + 2.d0*                         ccniHY(ip1(i),    j ,k)     
c #HY.           +                               ccniHY(im1(i),jm1(j),k) 
c #HY.           + 2.d0*                         ccniHY(    i ,jm1(j),k)
c #HY.           +                               ccniHY(ip1(i),jm1(j),k)
c #HY end do
c #HY end do
C +
c #HY S2_pqw = 0.0d0
c #HY S2_pqi = 0.0d0
c #HY S2_pci = 0.0d0
C +
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY S2_pqw = S2_pqw +  pstDYn(    i ,    j ) *  WKxy1(    i ,    j)
c #HY S2_pqi = S2_pqi +  pstDYn(    i ,    j ) *  WKxy2(    i ,    j)
c #HY S2_pci = S2_pci +  pstDYn(    i ,    j ) *  WKxy3(    i ,    j)
c #HY end do
c #HY end do
C +
c #HY if (S2_pqw.gt.0.d0) then
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY   qwHY(i,j,k) = WKxy1(i,j) * S1_pqw / S2_pqw
c #HY end do
c #HY end do
c #HY end if
C +
c #HY if (S2_pqi.gt.0.d0) then
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY   qiHY(i,j,k) = WKxy2(i,j) * S1_pqi / S2_pqi
c #HY end do
c #HY end do
c #HY end if
C +
c #HY if (S2_pci.gt.0.d0) then
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY ccniHY(i,j,k) = WKxy3(i,j) * S1_pci / S2_pci
c #HY end do
c #HY end do
c #HY end if
C +
C +
C +--Precipitation Variables
C +  -----------------------
C +
c #HY S1_pqr = 0.0d0
c #HY S1_pqs = 0.0d0
C +
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY S1_pqr = S1_pqr +  pstDYn(    i ,    j ) *   qrHY(    i ,    j ,k)
c #HY WKxy1(i,j) = 
c #HY.                                             qrHY(im1(i),jp1(j),k)
c #HY.           + 2.d0*                           qrHY(    i ,jp1(j),k)
c #HY.           +                                 qrHY(ip1(i),jp1(j),k)
c #HY.           + 2.d0*                           qrHY(im1(i),    j ,k) 
c #HY.           + 4.d0*                           qrHY(    i ,    j ,k)     
c #HY.           + 2.d0*                           qrHY(ip1(i),    j ,k)     
c #HY.           +                                 qrHY(im1(i),jm1(j),k) 
c #HY.           + 2.d0*                           qrHY(    i ,jm1(j),k)
c #HY.           +                                 qrHY(ip1(i),jm1(j),k)
C +
c #HY S1_pqs = S1_pqs +  pstDYn(    i ,    j ) *   qsHY(    i ,    j ,k)
c #HY WKxy2(i,j) = 
c #HY.                                             qsHY(im1(i),jp1(j),k)
c #HY.           + 2.d0*                           qsHY(    i ,jp1(j),k)
c #HY.           +                                 qsHY(ip1(i),jp1(j),k)
c #HY.           + 2.d0*                           qsHY(im1(i),    j ,k) 
c #HY.           + 4.d0*                           qsHY(    i ,    j ,k)     
c #HY.           + 2.d0*                           qsHY(ip1(i),    j ,k)     
c #HY.           +                                 qsHY(im1(i),jm1(j),k) 
c #HY.           + 2.d0*                           qsHY(    i ,jm1(j),k)
c #HY.           +                                 qsHY(ip1(i),jm1(j),k)
c #HY end do
c #HY end do
C +
c #HY S2_pqr = 0.0d0
c #HY S2_pqs = 0.0d0
C +
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY S2_pqr = S2_pqr +  pstDYn(    i ,    j ) *  WKxy1(    i ,    j)
c #HY S2_pqs = S2_pqs +  pstDYn(    i ,    j ) *  WKxy2(    i ,    j)
c #HY end do
c #HY end do
C +
c #HY if (S2_pqr.gt.0.d0) then
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY   qrHY(i,j,k) = WKxy1(i,j) * S1_pqr / S2_pqr
c #HY end do
c #HY end do
c #HY end if
C +
c #HY if (S2_pqs.gt.0.d0) then
c #HY do      j=1,my
c #HY do      i=1,mx
c #HY   qsHY(i,j,k) = WKxy2(i,j) * S1_pqs / S2_pqs
c #HY end do
c #HY end do
c #HY end if
C +
 4101 continue
C +
c #HY end if
C +
C +
C +--Filtering of Tracer        Variables
C +  ====================================
C +
c #TC if     (TRCfil) then
C +
c #TC do 4102 itrac=1,ntrac
c #TC do 4102 k=1,mz
C +
c #TC S1_pqx = 0.0d0
C +
c #TC do      j=1,my
c #TC do      i=1,mx
c #TC S1_pqx = S1_pqx   +   pstDYn(i,j)   *  qxTC(    i ,    j ,k,itrac)
c #TC WKxy1(i,j) = 
c #TC.                                       qxTC(im1(i),jp1(j),k,itrac)
c #TC.     + 2.d0*                           qxTC(    i ,jp1(j),k,itrac)
c #TC.     +                                 qxTC(ip1(i),jp1(j),k,itrac)
c #TC.     + 2.d0*                           qxTC(im1(i),    j ,k,itrac) 
c #TC.     + 4.d0*                           qxTC(    i ,    j ,k,itrac)     
c #TC.     + 2.d0*                           qxTC(ip1(i),    j ,k,itrac)     
c #TC.     +                                 qxTC(im1(i),jm1(j),k,itrac) 
c #TC.     + 2.d0*                           qxTC(    i ,jm1(j),k,itrac)
c #TC.     +                                 qxTC(ip1(i),jm1(j),k,itrac)
c #TC end do
c #TC end do
C +
c #TC S2_pqx = 0.0d0
C +
c #TC do      j=1,my
c #TC do      i=1,mx
c #TC S2_pqx = S2_pqx   +   pstDYn(i,j)   *  WKxy1(i ,j)
c #TC end do
c #TC end do
C +
c #TC if (S2_pqx.gt.0.d0) then
c #TC do      j=1,my
c #TC do      i=1,mx
c #TC   qxTC(i,j,k,itrac) = WKxy1(i,j) * S1_pqx / S2_pqx
c #TC end do
c #TC end do
c #TC end if
C +
 4102 continue
C +
c #TC end if
C +
C +
C +--Work Arrays Reset
C +  =================
C +
       do 25  j=1,my
       do 25  i=1,mx
       WKxy1 (i,j)   = 0.d0
       WKxy2 (i,j)   = 0.d0
       WKxy3 (i,j)   = 0.d0
 25    continue 
C +
      return
      end
      subroutine LBC000_run(var,kdim0g)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS LBC                                       17-11-2002  MAR |
C |   SubRoutine LBC000_run treats 0-Gradient Lateral Boundary Condition   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  INPUT / OUTPUT:        var may be:                                    |
C |  ^^^^^^^^^^^^^^                                                        |
C |       1) The Horizontal     x-Wind Component uairDY(mx,my,mz)    [m/s] |
C |  .or. 2) The Horizontal     y-Wind Component vairDY(mx,my,mz)    [m/s] |
C |  .or. 3) The Specific       Humidity           qvDY(mx,my,mzz) [kg/kg] |
C |  .or. 4) The Potential      Temperature      pktaDY(mx,my,mzz)         |
C |  .or. 5) The Model Pressure Thickness        pstDYn(mx,my)       [kPa] |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      integer  kdim0g
      real     var(mx,my,mz)
C +
C +
C +--Boundary Condition
C +  ==================
C +
C +--`Left' Boundary (x small)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
        DO k=1,kdim0g
        DO j=1,my
          var( 1,j,k) = var(ip11,j,k) 
        END DO
        END DO
C +
C +--`Right' Boundary (x large)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~
        DO k=1,kdim0g
        DO j=1,my
          var(mx,j,k) = var(mx1,j,k) 
        END DO
        END DO
C +
C +--`Bottom' Boundary (y small)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IF (mmy.ge.1)                                               THEN
        DO k=1,kdim0g
        DO i=1,mx
          var(i, 1,k) = var(i,jp11,k) 
        END DO
        END DO
C +
C +--`Top' Boundary (y large)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
        DO k=1,kdim0g
        DO i=1,mx
          var(i,my,k) = var(i,my1,k) 
        END DO
        END DO
C +
C +--Corners
C +  ~~~~~~~
          var( 1, 1,k) = 0.5*(var(ip11, 1,k)+var( 1,jp11,k))
          var(mx, 1,k) = 0.5*(var( mx1, 1,k)+var(mx,jp11,k))
          var( 1,my,k) = 0.5*(var(ip11,my,k)+var( 1, my1,k))
          var(mx,my,k) = 0.5*(var( mx1,my,k)+var(mx, my1,k))
C +
      END IF
C +
      return
      end
      subroutine LBCrad_atm(ff,fu,fv,iv,kdimRB)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS LBC                                       17-11-2002  MAR |
C |   SubRoutine LBCrad_atm computes the Lateral Boundary Conditions       |
C |              following the Carpenter (1982) scheme                     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Carpenter, QJRMS 108, pp.717--719, 1982                     |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   INPUT / OUTPUT : ff (containing uairDY, vairDY, qvDY, pktaDY, pstDYn |
C |   ^^^^^^^^     for iv =                1,      2,    3,      4,      5)|
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_LB.inc'
C +
      real     ff(mx,my,mz),fu(mx,my,mz),fv(mx,my,mz)
      integer  iv,kdimRB
C +
C +
C +--Local  Variables
C +  ================
C +
      real     wavcfl,denolb,fac1lb,fac2lb
      real     wavesp,alphlb
C +
C +
C +--DATA
C +  ====
C +
      data     wavesp/20.e0/
C +...         wavesp: assumed Gravity Wave Speed
C +
      data     alphlb/0.5e0/
C +
C +
C +--Initialization
C +  ==============
C +
      wavcfl =                       wavesp *dtx
      denolb =  1.d0 +       alphlb *wavcfl
      fac1lb = (1.d0 - (1.d0-alphlb)*wavcfl)/denolb
      fac2lb =                       wavcfl /denolb
C +...Semi-Implicit Scheme for Advection at Lateral Boundaries
C +
C +
C +--x Boundaries
C +  ============
C +
C +--Wind Speed Normal to the lateral boundary is u
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IF     (mmx.gt.1)                                           THEN
C +
        IF   (iv .eq.1)                                           THEN
C +
          IF (tim2LB.gt.tim1LB)                                   THEN
C +
            DO  k=1,kdimRB
            DO  j=1,my
C +
C +--`Left' Boundary (x <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~
              ff ( 1,j,k) =      ff( 1,j,k) 
     .        + dt *        (v2xgLB( 1,j,k,iv)-v1xgLB(  1,j,k,iv))
     .                     /(tim2LB           -tim1LB            ) 
C +
C +--`Right' Boundary (x >>)
C +  ~~~~~~~~~~~~~~~~~~~~~~~
              ff (mx,j,k) =      ff(mx,j,k) 
     .        + dt *        (v2xdLB(mx,j,k,iv)-v1xdLB(mx ,j,k,iv))
     .                     /(tim2LB           -tim1LB            ) 
            END DO
            END DO
C +
          END IF
C +
            DO k=1,kdimRB
            DO j=1,my
C +
C +--`Left' Boundary (x <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~
              ff ( 1,j,k) = 
     .          fac1lb* ff    ( 1,j,k)    + fac2lb* ff    (  2,j,k)
     .         +wavcfl*(vaxgLB( 1,j,k,iv) -         vaxgLB(  2,j,k,iv))
C +
C +--`Right' Boundary (x >>)
C +  ~~~~~~~~~~~~~~~~~~~~~~~
              ff (mx,j,k) = 
     .          fac1lb* ff    (mx,j,k)    + fac2lb* ff    (mx1,j,k)
     .         +wavcfl*(vaxdLB(mx,j,k,iv) -         vaxdLB(mx1,j,k,iv))
            END DO
            END DO
C +
        ELSE
C +
C +--`Left' Boundary (x <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~
            DO k=1,kdimRB
            DO j=1,my
              IF (fu(  1,j,k).gt.0.d0)                            THEN !
                  ff(  1,j,k)  =  vaxgLB(  1,j,k,iv)
              END IF                                                   !
            END DO
            END DO
C +
C +--`Right' Boundary (x >>)
C +  ~~~~~~~~~~~~~~~~~~~~~~~
            DO k=1,kdimRB
            DO j=1,my
              IF (fu(mx ,j,k).lt.0.d0)                            THEN !
                  ff(mx ,j,k)  =  vaxdLB(mx ,j,k,iv)
              END IF                                                   !
            END DO
            END DO
C +
        END IF
C +
      END IF
C +
C +
C +--y Boundaries
C +  ------------
C +
C +--Wind Speed Normal to the lateral boundary is v
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      IF     (mmy.gt.1)                                           THEN
C +
        IF   (iv .eq.2)                                           THEN
C +
          IF (tim2LB.gt.tim1LB)                                   THEN
C +
            DO k=1,kdimRB
            DO i=1,mx
C +
C +--`Bottom' Boundary (y <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
              ff (i, 1,k) =      ff(i, 1,k) 
     .        + dt *        (v2yiLB(i, 1,k,iv)-v1yiLB(i,  1,k,iv))
     .                     /(tim2LB           -tim1LB            )
C +
C +--`Top' Boundary (y >>)
C +  ~~~~~~~~~~~~~~~~~~~~~
              ff (i,my,k) =      ff(i,my,k) 
     .        + dt *        (v2ysLB(i,my,k,iv)-v1ysLB(i,my ,k,iv))
     .                     /(tim2LB           -tim1LB            )
            END DO
            END DO
C +
          END IF
C +
            DO k=1,kdimRB
            DO i=1,mx
C +
C +--`Bottom' Boundary (y <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
              ff (i, 1,k) = 
     .          fac1lb* ff    (i, 1,k)    +fac2lb*ff    (i,jp11,k)
     .         +wavcfl*(vayiLB(i, 1,k,iv) -       vayiLB(i,jp11,k,iv))
C +
C +--`Top' Boundary (y >>)
C +  ~~~~~~~~~~~~~~~~~~~~~
              ff (i,my,k) = 
     .          fac1lb* ff    (i,my,k)    +fac2lb*ff    (i,my1   ,k)
     .         +wavcfl*(vaysLB(i,my,k,iv) -       vaysLB(i,my1   ,k,iv))
            END DO
            END DO
C +
        ELSE
C +
C +--`Bottom' Boundary (y <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
            DO k=1,kdimRB
            DO i=1,mx
              IF (fv(i,  1,k).gt.0.d0)                            THEN !
                  ff(i,  1,k)  =  vayiLB(i,  1,k,iv)
              END IF                                                   !
            END DO
            END DO 
C +
C +--`Top' Boundary (y >>)
C +  ~~~~~~~~~~~~~~~~~~~~~
            DO k=1,kdimRB
            DO i=1,mx
              IF (fv(i, my,k).lt.0.d0)                            THEN !
                  ff(i, my,k)  =  vaysLB(i, my,k,iv)
              END IF 
            END DO
            END DO
C +
        END IF
C +
      END IF
C +
      return
      end
      subroutine LBCnud_ini
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS LBC                                       18-09-2001  MAR |
C |   SubRoutine LBCnud_ini initialize the Nudging Coefficient             | 
C |                 for the lateral boundary conditions of Davies, 1983    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Davies, MWR   111, p.1002-1012, 1983                        |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   OUTPUT : rxLB,ryLB: nudging coefficients of the relaxation zones     |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_LB.inc'
C +
      include 'MAR_IO.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      real     d25
c #da real     cspeed
C +
C +
C +--Nudging Coefficient Multiplied by the Time Step
C +  ===============================================
C +
c #da   cspeed   = 300.d0*max(n6-1,1)*max(n6-1,1)
c #da.                  /(max(n6-2,1)*max(n6-2,1))
c #da   rxbase   = cspeed/(2.d0*dx)
C +***  rxbase: Optimal Maximum Relaxation Coefficient
C +             (see Davies 1983, MWR 111 p. 1007, 2e col. K*  = K(dx)/c,
C +                               with K*~0.5, c= c_max= sqrt(gH)=300m/s)
c #da   rxfact   = 0.5*dt*max(n6-1,1)*max(n6-1,1)
c #da.                  /(max(n6-2,1)*max(n6-2,1))
C +***  rxfact: Such that nu* < 1, but Diffusion_Relaxation replaces Diffusion
C +             (see Davies 1983, MWR 111 p. 1004, 1e col. nu* = K(dx)/c,
C +                                       p. 1007, 1e col. 21b)
C +
        if (IO_loc.ge.2) write(21,999) rxbase,rxfact
 999    format(/,'   --- Initialisation / LBCnud_ini ---',
     .         /,'       K(relax)max =',f14.6,' (Davies 1983 MWR)',
     .         /,'       K_H(fac)    =',f14.6)
C +
        d25      =(n6-1)*(n6-1)
        rxLB(1)  = 0.d0
        rxLB(mx) = 0.d0
       if (mmx.gt.1) then
        do 1 i=ip11,mx1
        rxLB(i)  =(max(0,n6-i)     *max(0,n6-i)
     .            +max(0,n6-1+i-mx)*max(0,n6-1+i-mx))
     .            *rxbase /d25
 1      continue
       end if
C +
        ryLB(1)  = 0.d0
        ryLB(my) = 0.d0
       if (mmy.gt.1) then
        do 2 j=jp11,my1
        ryLB(j)  =(max(0,n6-j)     *max(0,n6-j)
     .            +max(0,n6-1+j-my)*max(0,n6-1+j-my))
     .            *rxbase /d25
 2      continue
       end if
C +
      return
      end
      subroutine LBCnud_par
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS LBC                                       26-09-2001  MAR |
C |   SubRoutine LBCnud_par initialize the implicit numerical scheme       | 
C |               for LBC on Wind Component parallel to the Boundary       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Davies, QJRMS 102, pp.405--418, 1976                        |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   INPUT  : vaXX : large scale values of relevant dependant variables   |
C |   ^^^^^^^^   ^X=(x->x axis border, y->y axis border)                   |
C |               ^X=(g->x small, d->x large, b->y small, h->y large)      |
C |                                                                        |
C |   OUTPUT : wiXX : coefficient used in semi-implicit numerical scheme   |
C |   ^^^^^^^^ tiXX : independant term of semi-implicit numerical scheme   |
C |              ^X=(x->x axis border--variable v,                         |
C |                  y->y axis border--variable u)                         |
C |               ^X=(g->x small, d->x large, b->y small, h->y large)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_LB.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  il,ic,ii,nn,n2,n3,n4,lmin,lmax,jl,jc,iv_nup,n1
      real     wkxd(mx-n6:mx1,mx-n6:mx1)
C + 
C +
C +--Matrix Inversion for x large (Reference Boundary)
C +  =================================================
C +
      IF   (iterun.eq.0)                                          THEN
C +
        IF (mmx.gt.1)                                             THEN
C +
          DO il=mx-n6,mx1
          DO ic=mx-n6,mx1
            wkxd(il,ic) = 0.d0
          END DO
          END DO
C +
          DO ii=mx-n6,mmx2
            wkxd(ii,ii+1)  =                  rxLB(ii+1) -rxLB(ii)
          END DO
          DO ii=mx-n6,mmx1
            wkxd(ii,ii  )  = 1 + 2*rxLB(ii) + rxLB(ii+1) -rxLB(ii-1)
          END DO
c #OB       wkxd(mx1,mx1)  = 1              + rxLB(mx  ) -rxLB(mmx2)
          DO ii=mx-n6+1,mmx1
            wkxd(ii,ii-1)  =       rxLB(ii)
          END DO
          DO nn=1,n6-3
             n2=nn+1
             n3=nn+2
             n4=n6-1-nn
          DO ii=mx-n4,mmx1
            wkxd(ii,ii-n2) =       rxLB(ii-nn)-rxLB(ii-n3)
          END DO
          END DO
C +
            wkxd(mx1,mx-n6)=       rxLB(mmx5)
C +
          lmin=mx-n6
          lmax=mx1
C +
C +       ***********
          call matinv(wkxd,wixdLB,lmin,lmax)
C +       ***********
C +
C +--Inverted Matrices at Other Boundaries
C +  =====================================
C +
          DO il=2,n7
          DO ic=2,n7
            wixgLB(il,ic) = wixdLB(mx+1-il,mx+1-ic)
          END DO
          END DO
C +...    x small     
C +
        END IF
C +
        IF (mmy.gt.1)                                             THEN
C +
          DO jl=2,n7
          DO jc=2,n7
            wiyiLB(jl,jc) = wixgLB(jl,jc)
          END DO
          END DO
C +...    y small     
C +
          DO jl=2,n7
          DO jc=2,n7
          wiysLB(my+1-jl,my+1-jc) = wiyiLB(jl,jc)
          END DO
          END DO
C +...    y large  
C +
        END IF
      END IF
C +
C +
C +--Independant Terms (Constant Coefficients) 
C +  =========================================
C +
C +--x Boundaries
C +  ------------
C +
      IF (mmx.gt.1)                                               THEN
C +
             iv_nup= 2
        DO   k = 1,mz
          DO j = 1,my
C +
C +--x large
C +  ~~~~~~~
            DO i=mx-n6,mmx1
             tixdLB(i,j,k) = rxLB(n50xLB) *vaxdLB(mx-n6 ,j,k,iv_nup) 
            END DO
            DO i=mx-n6,mmx2
             tixdLB(i,j,k) = tixdLB(i,j,k) +(rxLB(i+1)
     .        -rxLB(i)  )   *vaxdLB(i+1   ,j,k,iv_nup)
            END DO
            DO i=mx-n6+1,mmx2
             tixdLB(i,j,k) = tixdLB(i,j,k) +(2*rxLB(i)+rxLB(i+1)
     .        -rxLB(i-1))   *vaxdLB(i     ,j,k,iv_nup)
            END DO
            DO i=mx-n6+2,mmx1
             tixdLB(i,j,k) = tixdLB(i,j,k)
     .       + rxLB(n40xLB) *vaxdLB(n50xLB,j,k,iv_nup)
            END DO
C +
            DO nn=n6-4,n6-3
               n1=nn+1
               n2=nn+2
            DO i =mx-nn,mmx1
             tixdLB(i,j,k) = tixdLB(i,j,k)
     .       +(rxLB(mx-nn)-rxLB(mx-n2)      )*vaxdLB(mx-n1 ,j,k,iv_nup)
            END DO
            END DO
C +
c #OB       IF (openLB)                                           THEN
c #OB        tixdLB(mx1,j,k) = tixdLB(mx1,j,k)
c #OB.       +(rxLB(mmx1)-rxLB(mmx3))*vaxdLB(mmx2  ,j,k,iv_nup)
c #OB.      +3*rxLB(mmx1)            *vaxdLB(mmx1  ,j,k,iv_nup)
c #OB       ELSE
             tixdLB(mx1,j,k) = tixdLB(mx1,j,k)
     .       +(rxLB(mmx1)-rxLB(mmx3))*vaxdLB(mmx2  ,j,k,iv_nup)
     .      +2*rxLB(mmx1)            *vaxdLB(mmx1  ,j,k,iv_nup)
c #OB       END IF
C +
C +--x small
C +  ~~~~~~~
            DO i=n7mxLB,2  ,-1
              tixgLB(i,j,k) = rxLB(n6mxLB) *vaxgLB(n7mxLB,j,k,iv_nup) 
            END DO
            DO i=n7mxLB,3  ,-1
              tixgLB(i,j,k) = tixgLB(i,j,k) +(  rxLB(i-1)
     .         -rxLB(i)  )   *vaxgLB(i-1   ,j,k,iv_nup)
            END DO
            DO i=n6   ,3  ,-1
              tixgLB(i,j,k) = tixgLB(i,j,k) +(2*rxLB(i)+rxLB(i-1)
     .         -rxLB(i+1))   *vaxgLB(i     ,j,k,iv_nup)
            END DO
            DO i=n6-1 ,2  ,-1
              tixgLB(i,j,k) = tixgLB(i,j,k)
     .         +rxLB(n5mxLB) *vaxgLB(n6mxLB,j,k,iv_nup)
            END DO
C +
            DO nn=n6-3,n6-2
               n1=nn+1
               n2=nn+2
            DO  i=nn  ,2   ,-1
              tixgLB(i,j,k) = tixgLB(i,j,k)
     .        +(rxLB(nn  )-rxLB(n2))  *vaxgLB(n1  ,j,k,iv_nup)
            END DO
            END DO
C +
c #OB       IF (openLB)                                           THEN
c #OB         tixgLB(2,j,k) = tixgLB(2,j,k)
c #OB.        +(rxLB(m0x2)-rxLB(m0x4))*vaxgLB(m0x3,j,k,iv_nup)
c #OB.       +3*rxLB(m0x2)            *vaxgLB(m0x2,j,k,iv_nup)
c #OB       ELSE
              tixgLB(2,j,k) = tixgLB(2,j,k)
     .        +(rxLB(m0x2)-rxLB(m0x4))*vaxgLB(m0x3,j,k,iv_nup)
     .       +2*rxLB(m0x2)            *vaxgLB(m0x2,j,k,iv_nup)
c #OB       END IF
          END DO
C +
        END DO
C +
      END IF
C +
C +
C +--y Boundaries
C +  ------------
C +
      IF (mmy.gt.1)                                               THEN
C +
             iv_nup = 1
        DO   k=1,mz
          DO i=1,mx
C +
C +--y large
C +  ~~~~~~~
            DO j=my-n6,mmy1
              tiysLB(i,j,k) =   ryLB(n50yLB)
     .                       *vaysLB(i,my-n6myLB,k,iv_nup) 
            END DO
            DO j=my-n6,mmy2
              tiysLB(i,j,k) = tiysLB(i,j  ,k) +(ryLB(j+1)
     .         -ryLB(j)  )   *vaysLB(i,j+1,      k,iv_nup)
            END DO
            DO j=my-n6+1,mmy2
              tiysLB(i,j,k) = tiysLB(i,j,k) +(2*ryLB(j)+ryLB(j+1)
     .         -ryLB(j-1))   *vaysLB(i,j        ,k,iv_nup)
            END DO
            DO j=my-n6+2,mmy1
              tiysLB(i,j,k) = tiysLB(i,j,k)
     .         +ryLB(n40yLB) *vaysLB(i,my-n6+1  ,k,iv_nup)
            END DO
C +
            DO nn=n6-4,n6-3
               n1=nn+1
               n2=nn+2
            DO j =my-3,mmy1
              tiysLB(i,j,k) = tiysLB(i,j,k)
     .        +(ryLB(my-nn)-ryLB(my-n2))*vaysLB(i,my-n1  ,k,iv_nup)
            END DO
            END DO
C +
c #OB       IF (openLB)                                           THEN
c #OB         tiysLB(i,my1,k) = tiysLB(i,my1,k)
c #OB.        +(ryLB(mmy1)-ryLB(mmy3))*vaysLB(i,mmy2   ,k,iv_nup)
c #OB.       +3*ryLB(mmy1)            *vaysLB(i,mmy1   ,k,iv_nup)
c #OB       ELSE
              tiysLB(i,my1,k) = tiysLB(i,my1,k)
     .        +(ryLB(mmy1)-ryLB(mmy3))*vaysLB(i,mmy2   ,k,iv_nup)
     .       +2*ryLB(mmy1)            *vaysLB(i,mmy1   ,k,iv_nup)
c #OB       END IF
C +
C +--y small
C +  ~~~~~~~
            DO j=n7   ,2  ,-1
              tiyiLB(i,j,k) = ryLB(n6myLB)   *vayiLB(i,n7myLB,k,iv_nup) 
            END DO
            DO j=n7   ,3  ,-1
              tiyiLB(i,j,k) = tiyiLB(i,j,k) +(           ryLB(j-1)
     .         -ryLB(j)  )   *vayiLB(i,j-1   ,k,iv_nup)
            END DO
            DO j=n6  ,3  ,-1
              tiyiLB(i,j,k) = tiyiLB(i,j,k) +(2*ryLB(j) +ryLB(j-1)
     .         -ryLB(j+1))   *vayiLB(i,j     ,k,iv_nup)
            END DO
            DO j=n6-1,2  ,-1
              tiyiLB(i,j,k) = tiyiLB(i,j,k)
     .        + ryLB(n5myLB) *vayiLB(i,n6myLB,k,iv_nup)
            END DO
C +
            DO nn=n6-3,n6-2
             n1=nn+1
             n2=nn+2
            DO j=nn  ,2  ,-1
              tiyiLB(i,j,k) = tiyiLB(i,j,k)
     .        +(ryLB(nn  )-ryLB(n2))*vayiLB(i,n2  ,k,iv_nup)
            END DO
            END DO
C +
             j=2  
c #OB       IF (openLB)                                           THEN
c #OB         tiyiLB(i,2,k) = tiyiLB(i,2,k)
c #OB.        +(ryLB(m0y2)-ryLB(m0y4))*vayiLB(i,m0y3,k,iv_nup)
c #OB.       +3*ryLB(m0y2)            *vayiLB(i,m0y2,k,iv_nup)
c #OB       ELSE
              tiyiLB(i,2,k) = tiyiLB(i,2,k)
     .        +(ryLB(m0y2)-ryLB(m0y4))*vayiLB(i,m0y3,k,iv_nup)
     .       +2*ryLB(m0y2)            *vayiLB(i,m0y2,k,iv_nup)
c #OB       END IF
          END DO
        END DO
C +
      END IF
C +
      return
      end
      subroutine matinv(wk1,wk2,l_min,l_max)
C +
C +------------------------------------------------------------------------+
C | MAR DYNAMICS LBC                                       27-09-2001  MAR |
C |   SubRoutine matinv performs a Matrix Inversion using a Companion      |
C |                                                                        | 
C +------------------------------------------------------------------------+
C |                                                                        | 
C |   INPUT  : wk1 : Matrix to be inverted                                 | 
C |   ^^^^^^^^       Dimension : (lmin:lmax) -> jdim=lmax-lmin+1           |
C |                  This Matrix is Loss after the Matrix Inversion        |
C |                                                                        | 
C |   OUTPUT : wk2 : Inverted Matrix                                       |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      integer      l_min,l_max
      real     wk1(l_min:l_max,l_min:l_max),wk2(l_min:l_max,l_min:l_max)
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  l ,k ,ll,llp1,llx1,llm1
      real     xx,yy
C +
C +
C +--wk2 = Compagnion Matrix = Unity Matrix
C +  --------------------------------------
C +
      DO   l=l_min,l_max
        DO k=l_min,l_max
          wk2(l,k)=0.d0
        END DO
          wk2(l,l)=1.d0
      END DO
C +
C +...Combinaisons lineaires de lignes de la matrice wk1 de facon a y faire
C +   apparaitre des 0 dans le triangle inferieur et des 1 sur la diagonale.
C +   Memes operations effectuees systematiquement sur la matrice compagnon.
C +
      ll=l_min
 50   llp1=ll+1
      xx=wk1(ll,ll)
C +
C +...Si l'element diagonal est nul,la ligne le contenant est interchangee
C +   avec une des suivantes...jusqu'a ce qu'on obtienne un element non nul.
C +   Dans le cas contraire la matrice est singuliere.
C +
      IF (xx.eq.0.0d0)                                            THEN
        llx1=ll+1
 90     IF (wk1(llx1,llx1).eq.0.0d0)                              THEN
                llx1=llx1+1
          IF   (llx1.gt.l_max) write(21,*)'Matrice non inversible'
          GO TO 90
        END IF
        DO k=l_min,l_max
          yy=wk1(ll,k)
          wk1(ll,k)=wk1(llx1,k)
          wk1(llp1,k)=yy
          yy=wk2(ll,k)
          wk2(ll,k)=wk2(llx1,k)
          wk2(llp1,k)=yy
        END DO
          xx=wk1(ll,ll)
      END IF
C +
C +...Division pour obtenir 1 sur la diagonale
C +
      DO k=l_min,l_max
          wk1(ll,k)=wk1(ll,k)/xx
          wk2(ll,k)=wk2(ll,k)/xx
      END DO
C +
C +...Soustraction pour obtenir 0 dans le triangle inferieur
C +
      DO l=llp1,l_max
          xx=wk1(l,ll)
        DO k=l_min,l_max
          wk1(l,k)=wk1(l,k)-xx*wk1(ll,k)
          wk2(l,k)=wk2(l,k)-xx*wk2(ll,k)
        END DO
      END DO
C +
C +...Passage a la ligne suivante
C +
      IF (ll.lt.l_max)                                            THEN
          ll=ll+1
        GO TO 50
      END IF
C +
C +...Combinaisons lineaires effectuees sur la matrice wk1 
C +   pour y faire apparaitre des 0 dans le triangle superieur. 
C +   Memes operations effectuees sur la matrice compagnon
C +
      ll=l_max
 60   llm1=ll-1
      DO l=llm1,l_min,-1
          xx=wk1(l,ll)
        DO k=l_min,l_max
          wk1(l,k)=wk1(l,k)-xx*wk1(ll,k)
          wk2(l,k)=wk2(l,k)-xx*wk2(ll,k)
        END DO
      END DO
      IF (ll.gt.l_min)                                            THEN
          ll=ll-1
        GO TO 60
      END IF
C +
      return
      end

      subroutine LBCnud_atm(f__LBC,iv_nua,kd_nua)

C +------------------------------------------------------------------------+
C | MAR DYNAMICS LBC                                   Fri  4-12-2009  MAR |
C |   SubRoutine LBCnud_atm computes the Lateral Boundary Conditions       | 
C |              following the Davies (1976) scheme                        |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT / OUTPUT : f__LBC, i.e. uairDY, vairDY, qvDY, pktaDY, pstDYn   |
C |   ^^^^^^^^     for iv_nua =          1,      2,    3,      4,      5   |
C |                    f_LBC0 reevalued on a 5-points width boundary zone  |
C |                                                                        |
C |   INPUT:   iv_nua: Index of the Variable to relax to Outer Conditions  |
C |   ^^^^^^   kd_nua: Maximum Value of the k (vertical) Index             |
C |                                                                        |
C |   INPUT (via common block)                                             |
C |   ^^^^^    reaLBC: Input INI: Previous Dyn.Simulation (MAR .or. GCM)   |
C |            rxfact: Lateral Sponge Coefficient         (A89)            |
C |            rxLB,ryLB: Nudging Coefficient                              |
C |            Independant Term  used in the Implicit Scheme               |
C |                                                                        |
C |   REFER. : Davies, QJRMS 102, pp.405--418, 1976  (relation 11 p.409)   |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   INPUT  : Nudging Coefficient rxLB and ryLB                           |
C |   ^^^^^^^^ Inverted Matrices used in the Implicit Scheme               |
C |                        wixgLB (zone x <<), wixdLB (zone x >>)          |
C |                        wiyiLB (zone y <<), wiysLB (zone y >>)          |
C |            Independant Term  used in the Implicit Scheme               |
C |            Variable v: tixgLB (zone x <<), tixdLB (zone x >>)          |
C |            Variable u: tiyiLB (zone y <<), tiysLB (zone y >>)          |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_LB.inc'
      include 'MAR_WK.inc'

      real     f__LBC(mx,my,mz)
      integer  kd_nua,iv_nua


C +--Local  Variables
C +  ================

c #OG logical relaxg

      integer il,ic,jl,jc
      real    sx(mx,mz)
      real    sy(my,mz)
      real    txg(2:n7,mz),txd(mx-n6:mx1,mz)
      real    tyi(2:n7,mz),tys(my-n6:my1,mz)

      real    fmagng(6),fmagnd(6),fmagnb(6),fmagnh(6)

      data fmagng/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
      data fmagnd/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
      data fmagnb/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
      data fmagnh/1.0e0,1.0e0,1.0e0,1.0e0,1.0e0,1.0e0/
C +...     fmagnX:magnification factor (=>nudging selectively modified)

c #OG data relaxg/.false./
C +...     relaxg=.false.==> NO nudging  at the left boundary. 


!    x Boundaries
!    ============

      IF   (mmx   .gt.1)                                          THEN
c #DA   IF (iv_nua.eq.2)                                          THEN
C +
c #DA     DO j=jp11,my1

C +--`Left' Boundary (x <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~
c #DA       DO   il = ip11,n7
c #DA           DO  k = 1,kd_nua
c #DA             txg(il,k)  = 0.d0
c #DA           END DO
c #DA         DO ic = ip11,n7
c #DA           DO  k = 1,kd_nua
c #DA             txg(il,k)  = txg(il,  k) 
c #DA.                   + (tixgLB(ic,j,k) 
c #DA.                     +f__LBC(ic,j,k))*wixgLB(il,ic)
c #DA           END DO
c #DA         END DO
c #DA       END DO
c #DA       DO i  = ip11,n7
c #DA           DO  k = 1,kd_nua
c #DA             f__LBC (i,j,k) = txg(i,   k)
c #DA           END DO
c #DA       END DO

C +--`Right' Boundary (x >>)
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #DA       DO  il = mx-n6,mx1
c #DA           DO  k = 1,kd_nua
c #DA             txd(il,k)  = 0.d0
c #DA           END DO
c #DA         DO ic = mx-n6,mx1
c #DA           DO  k = 1,kd_nua
c #DA             txd(il,k)  = txd(il,  k) + 
c #DA.                     (tixdLB(ic,j,k) 
c #DA.                     +f__LBC(ic,j,k))*wixdLB(il,ic)
c #DA           END DO
c #DA         END DO
c #DA       END DO
c #DA         DO i  = mx-n6mxLB,mx1
c #DA           DO  k = 1,kd_nua
c #DA             f__LBC (i,j,k) = txd(i,   k)
c #DA           END DO
c #DA         END DO
c #DA     END DO

c #DA   ELSE
          DO  j=jp11,my1
c #OG       IF (relaxg)                                           THEN
              DO i=ip11,n6-1
                DO  k = 1,kd_nua
                  f__LBC(i,j,k) =              (f__LBC(i,j,k)
     .                  +fmagng(iv_nua)*rxLB(i)*vaxgLB(i,j,k,iv_nua))
     .            /(1.d0+fmagng(iv_nua)*rxLB(i))
                END DO
              END DO
c #OG       END IF
              DO i=mx-n6+2,mx1
                DO  k = 1,kd_nua
                  f__LBC(i,j,k) =              (f__LBC(i,j,k)
     .                  +fmagnd(iv_nua)*rxLB(i)*vaxdLB(i,j,k,iv_nua))
     .            /(1.d0+fmagnd(iv_nua)*rxLB(i))
                END DO
              END DO
          END DO
c #DA   END IF


!    Zero Gradient at y LBC if fmagng,d = 0 / otherwise prescribed LBC
!    -----------------------------------------------------------------

          DO   k=1,kd_nua
            DO j=1,my
              f__LBC( 1,j,k) = 
     .           (1.-fmagng(iv_nua))*f__LBC(ip11,j,k)
     .         +     fmagng(iv_nua) *vaxgLB(   1,j,k,iv_nua)
              f__LBC(mx,j,k) = 
     .           (1.-fmagnd(iv_nua))*f__LBC( mx1,j,k)
     .         +     fmagnd(iv_nua) *vaxdLB( mx ,j,k,iv_nua)
            END DO
          END DO


!    Nudging
!    -------

        DO     i=ip11,n6-1
          DO   k=   1,kd_nua
            DO j=jp11,my1
                WKxyz1(i  ,j,k)   =    f__LBC(  i,j,k) + rxfact*rxLB(i)
     .        *(f__LBC(i+1,j,k)       +f__LBC(i-1,j,k)     
     .         -f__LBC(i  ,j,k)       -f__LBC(i  ,j,k)
     .         -vaxgLB(i+1,j,k,iv_nua)-vaxgLB(i-1,j,k,iv_nua)
     .         +vaxgLB(i  ,j,k,iv_nua)+vaxgLB(i  ,j,k,iv_nua))
            END DO
          END DO
        END DO
        DO     i=ip11,n6-1
          DO   k=   1,kd_nua
            DO j=jp11,my1
                    f__LBC(i  ,j,k) =  WKxyz1(i  ,j,k)
            END DO
          END DO
        END DO

        DO     i=mx-n6+2,mx1
          DO   k=   1   ,kd_nua
            DO j=jp11   ,my1
                WKxyz1(i  ,j,k)   =    f__LBC(  i,j,k) + rxfact*rxLB(i)
     .        *(f__LBC(i+1,j,k)       +f__LBC(i-1,j,k)     
     .         -f__LBC(i  ,j,k)       -f__LBC(i  ,j,k)
     .         -vaxdLB(i+1,j,k,iv_nua)-vaxdLB(i-1,j,k,iv_nua)
     .         +vaxdLB(i  ,j,k,iv_nua)+vaxdLB(i  ,j,k,iv_nua))
            END DO
          END DO
        END DO
        DO     i=mx-n6+2,mx1
          DO   k=  1    ,kd_nua
            DO j=jp11   ,my1
                    f__LBC(i  ,j,k) = WKxyz1(i  ,j,k)
            END DO
          END DO
        END DO


!    Zero Gradient at y LBC if fmagng,d = 0 / otherwise prescribed LBC
!    -----------------------------------------------------------------

          DO   k=1,kd_nua
            DO j=jp11,my1
              f__LBC( 1,j,k) = 
     .           (1.-fmagng(iv_nua))*f__LBC(ip11,j,k)
     .         +     fmagng(iv_nua) *vaxgLB(   1,j,k,iv_nua)
              f__LBC(mx,j,k) = 
     .           (1.-fmagnd(iv_nua))*f__LBC( mx1,j,k)
     .         +     fmagnd(iv_nua) *vaxdLB( mx ,j,k,iv_nua)
            END DO
          END DO

      END IF


!    y Boundaries
!    ============

      IF  (mmy.gt.1)                                              THEN

c #DA   IF (iv_nua.eq.1)                                          THEN

c #DA     DO i=1,mx

C +--`Bottom' Boundary (y <<)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
c #DA       DO     jl = jp11,n7
c #DA           DO  k =    1,kd_nua
c #DA             tyi(jl,k)  = 0.d0
c #DA           END DO
c #DA         DO   jc = jp11,n7
c #DA           DO  k =    1,kd_nua
c #DA             tyi(jl,k)  = tyi(  jl,k)
c #DA.                    +(tiyiLB(i,jc,k) 
c #DA.                     +f__LBC(i,jc,k))*wiyiLB(jl,jc)
c #DA           END DO
c #DA         END DO
c #DA       END DO
c #DA       DO j  = jp11,n7
c #DA           DO  k = 1,kd_nua
c #DA             f__LBC (i,j,k) = tyi(   j,k)
c #DA           END DO
c #DA       END DO

C +--`Top' Boundary (y >>)
C +  ~~~~~~~~~~~~~~~~~~~~~
c #DA       DO  jl = my-n6,my-1
c #DA           DO  k = 1,kd_nua
c #DA             tys(jl,k)  = 0.d0
c #DA           END DO
c #DA         DO jc = my-n6,my-1
c #DA           DO  k = 1,kd_nua
c #DA             tys(jl,k)  = tys(  jl,k)
c #DA.                    +(tiysLB(i,jc,k) 
c #DA.                     +f__LBC(i,jc,k))*wiysLB(jl,jc)
c #DA           END DO
c #DA         END DO
c #DA       END DO
c #DA       DO j  = my-n6,my-1
c #DA           DO  k = 1,kd_nua
c #DA             f__LBC (i,j,k) = tys(   j,k)
c #DA           END DO
c #DA       END DO
c #DA     END DO

c #DA   ELSE
          DO     j=jp11,n6-1
            DO   k=  1 ,kd_nua
              DO i=  1 ,mx
                f__LBC(i,j,k) =              (f__LBC(i,j,k)
     .                +fmagnb(iv_nua)*ryLB(j)*vayiLB(i,j,k,iv_nua))
     .          /(1.d0+fmagnb(iv_nua)*ryLB(j))
              END DO
            END DO
          END DO
          DO     j=my-n6+2,my1
            DO   k=  1    ,kd_nua
              DO i=  1    ,mx
                f__LBC(i,j,k) =              (f__LBC(i,j,k)
     .                +fmagnh(iv_nua)*ryLB(j)*vaysLB(i,j,k,iv_nua))
     .          /(1.d0+fmagnh(iv_nua)*ryLB(j))
              END DO
            END DO
          END DO
c #DA   END IF


!    Zero Gradient at y LBC if fmagnb,h = 0 / otherwise prescribed LBC
!    -----------------------------------------------------------------

          DO   k=1,kd_nua
            DO i=1,mx        
              f__LBC(i, 1,k) = 
     .           (1.-fmagnb(iv_nua))*f__LBC(i,jp11,k)
     .         +     fmagnb(iv_nua) *vayiLB(i,   1,k,iv_nua)
              f__LBC(i,my,k) = 
     .           (1.-fmagnh(iv_nua))*f__LBC(i, my1,k)
     .         +     fmagnh(iv_nua) *vaysLB(i, my ,k,iv_nua)
            END DO
          END DO


!    Nudging
!    -------

          DO     j=2   ,n6-1
            DO   k=1   ,kd_nua
              DO i=ip11,mx1
                WKxyz2(i,j  ,k)   =    f__LBC(i,j  ,k) + rxfact*ryLB(j)
     .        *(f__LBC(i,j+1,k)       +f__LBC(i,j-1,k)     
     .         -f__LBC(i,j  ,k)       -f__LBC(i,j  ,k)
     .         -vayiLB(i,j+1,k,iv_nua)-vayiLB(i,j-1,k,iv_nua)
     .         +vayiLB(i,j  ,k,iv_nua)+vayiLB(i,j  ,k,iv_nua))
              END DO
            END DO
          END DO
          DO     j=2   ,n6-1
            DO   k=1   ,kd_nua
              DO i=ip11,mx1
                f__LBC(i,j  ,k) =  WKxyz2(i,j  ,k)
              END DO
            END DO
          END DO

          DO     j=my-n6+2,my1
            DO   k=1      ,kd_nua
              DO i=ip11   ,mx1
                WKxyz2(i,j  ,k)   =    f__LBC(i,j  ,k) + rxfact*ryLB(j) 
     .        *(f__LBC(i,j+1,k)       +f__LBC(i,j-1,k)     
     .         -f__LBC(i,j  ,k)       -f__LBC(i,j  ,k)
     .         -vaysLB(i,j+1,k,iv_nua)-vaysLB(i,j-1,k,iv_nua)
     .         +vaysLB(i,j  ,k,iv_nua)+vaysLB(i,j  ,k,iv_nua))
              END DO
            END DO
          END DO
          DO     j=my-n6+2,my1
            DO   k=1      ,kd_nua
              DO i=ip11   ,mx1
                    f__LBC(i,j  ,k) =  WKxyz2(i,j  ,k)
              END DO
            END DO
          END DO


!    Zero Gradient at y LBC if fmagnb,h = 0 / otherwise prescribed LBC
!    -----------------------------------------------------------------

          DO   k=1,kd_nua
          DO   i=ip11,mx1    
              f__LBC(i, 1,k) = 
     .           (1.-fmagnb(iv_nua))*f__LBC(i,jp11,k)
     .         +     fmagnb(iv_nua) *vayiLB(i,   1,k,iv_nua)
              f__LBC(i,my,k) = 
     .           (1.-fmagnh(iv_nua))*f__LBC(i, my1,k)
     .         +     fmagnh(iv_nua) *vaysLB(i, my ,k,iv_nua)
            END DO
          END DO


c #OB       DO k=1     ,kd_nua
c #OB               f__LBC( 1, 1,k) = (f__LBC(   1,jp11,k)
c #OB.                                +f__LBC(ip11,   1,k)) *0.5d0
c #OB               f__LBC(mx, 1,k) = (f__LBC(  mx,jp11,k)
c #OB.                                +f__LBC( mx1,   1,k)) *0.5d0
c #OB               f__LBC( 1,my,k) = (f__LBC(   1, my1,k)
c #OB.                                +f__LBC(ip11, my ,k)) *0.5d0
c #OB               f__LBC(mx,my,k) = (f__LBC( mx , my1,k)
c #OB.                                +f__LBC( mx1, my ,k)) *0.5d0
c #OB       END DO

      END IF


!    Work Arrays Reset
!    =================

      DO k=1,mz
      DO j=1,my
      DO i=1,mx
        WKxyz1(i,j,k) = 0.0
        WKxyz2(i,j,k) = 0.0
      END DO
      END DO
      END DO

      return
      end


      subroutine LBCnud_srf
C +
C +------------------------------------------------------------------------+
C | MAR, Routine LBCnud_srf                                 4-06-2002  MAR |
C |              LBCnud_srf includes the Surface Boundary Conditions       | 
C |              corresponding to Surface Variables                        |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT : sst_LB: Surface Temperature LBC                              |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   OUTPUT: tsrfSL: Surface Temperature                                  |
C |   ^^^^^^^                                                              |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_LB.inc'
C +
      include 'MAR_SL.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      logical     MAR_SI
C +
C +
C +--Initialization
C +  ==============
C +
                  MAR_SI=.false.
c #SI IF(VSISVAT) MAR_SI=.true.
C +
C +
C +--LBC: New Surface Temperatures
C +  =============================
C +
      IF (.NOT.polmod .and. .not. MAR_SI)                         THEN
        DO j=1,my
        DO i=1,mx
          IF   (isolSL(i,j).le.2      )                           THEN
                tsrfSL(i,j,1) = sst_LB(i,j)
 
C +---1. Open Water
C +   ~~~~~~~~~~~~~
            IF (sst_LB(i,j).gt. Tfr_LB)                           THEN
                isolSL(i,j)   = 1
                 d1_SL(i,j)   = 2.09d+8
                albeSL(i,j)   = 0.10
                eps0SL(i,j)   = 0.97
                 SL_z0(i,j,1) =          zs_SL
                 SL_r0(i,j,1) = 0.1     *zs_SL
                 ch0SL(i,j)   = 0.00132
                rsurSL(i,j)   = 0.0
 
C +---2. Sea Ice
C +   ~~~~~~~~~~
            ELSE
                isolSL(i,j)   = 2
                 d1_SL(i,j)   = 1.05d+5
                albeSL(i,j)   = 0.70d00
                eps0SL(i,j)   = 0.97d00
                 SL_z0(i,j,1) =          zn_SL
                 SL_r0(i,j,1) = 0.1     *zn_SL
                 ch0SL(i,j)   = 0.0021
C +...          (Kondo and Yamazaki, 1990, JAM 29, p.376)
                rsurSL(i,j)   = 0.0
            END IF
          END IF
        END DO
        END DO
      END IF
C +
      return
      end


      subroutine qsat2D(tair2D,pst2D,tsrf2D,qvsi2D,qvsw2D)

C +------------------------------------------------------------------------+
C | MAR PHYSICS                                         Mc 30-05-2007  MAR |
C |   SubRoutine qsat2D computes the Saturation Specific Humidity  (kg/kg) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT :   TairSL: Surface Air Temperature                        (K) |
C |   ^^^^^^^   Tair2D:         Air Temperature                        (K) |
C |              pst2D: Model Pressure Thickness                     (kPa) |
C |                                                                        |
C |   OUTPUT :  qvsw2D: Saturation Specific Humidity  over Water   (kg/kg) |
C |   ^^^^^^^   qvsi2D: Saturation Specific Humidity  over Ice     (kg/kg) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_2D.inc'

C +--Local Variables
C +  ===============

      integer il,klq

      real    WatIce,ExpWat,ExpWa2,ExpIce


C +--DATA
C +  ====

      data WatIce/273.16e0/
      data ExpWat/5.138e0/
      data ExpWa2/6827.e0/
      data ExpIce/6150.e0/


C +--Temperature (K) and Pressure (hPa)
C +  ==================================

      DO   klq=1,klev
        DO il =1,klon
          W2xyz5(il,klq)   = tair2D(il,klq)
          W2xyz6(il,klq)   = (pst2D(il) * sigma(klq) + ptopDY) * 10.0d0
        END DO
      END DO

        DO il=1,klon
          W2xyz5(il,klev+1) = tsrf2D(il)
          W2xyz6(il,klev+1) = (pst2D(il)             + ptopDY) * 10.0d0
        END DO


C +--Saturation Vapor Pressure over Ice
C +  ==================================

      DO   klq=1,klev+1
        DO il =1,klon
          W2xyz7(il,klq) = 
     .    6.1070d0 * exp (ExpIce*(unun/WatIce-unun/W2xyz5(il,klq)))
C +...    Dudhia (1989) JAS, (B1) and (B2) p.3103 

          W2xyz8(il,klq) = .622d0*W2xyz7(il,klq)
     .  /(W2xyz6(il,klq) - .378d0*W2xyz7(il,klq))


C +--Saturation Vapor Pressure over Water
C +  ====================================

          W2xyz7(il,klq) = 
     .    6.1078d0 * exp (ExpWat*  log(WatIce     /W2xyz5(il,klq)))
     .             * exp (ExpWa2*(unun/WatIce-unun/W2xyz5(il,klq)))
C +...    Dudhia (1989) JAS, (B1) and (B2) p.3103 
C +       See also Pielke (1984), p.234 and Stull (1988), p.276 

          qvsw2D(il,klq) = max(eps9  ,      .622d0*W2xyz7(il,klq)
     .  /(W2xyz6(il,klq) -                  .378d0*W2xyz7(il,klq)))
C +...    Saturation Vapor Specific Concentration over Water
C +       (even for temperatures less than freezing point)


C +--Water Phase Discriminator
C +  =========================

          W2xyz7(il,klq) = max(zero,sign(unun,W2xyz5(il,klq)-WatIce))
C +...    W2xyz7(il,klq) =     1    if        Tair     >    273.16
C +                            0    if        Tair     <    273.16

C +--Saturation Vapor Specific Concentration over Ice
C +  ================================================
C +
          qvsi2D(il,klq) = 
     .       max(eps9    , qvsw2D(il,klq) *      W2xyz7(il,klq) 
     .                   + W2xyz8(il,klq) *(unun-W2xyz7(il,klq)))


C +--Work Area Reset
C +  ===============

          W2xyz5(il,klq) = 0.0
          W2xyz6(il,klq) = 0.0
          W2xyz7(il,klq) = 0.0
          W2xyz8(il,klq) = 0.0
        END DO
      END DO

      return
      end


      subroutine qsat3D

C +------------------------------------------------------------------------+
C | MAR PHYSICS                                         Mc 30-05-2007  MAR |
C |   SubRoutine qsat3D computes the Saturation Specific Humidity  (kg/kg) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT :   TairSL: Surface Air Temperature                        (K) |
C |   ^^^^^^^   TairDY:         Air Temperature                        (K) |
C |              pstDY: Model Pressure Thickness                     (kPa) |
C |                                                                        |
C |   OUTPUT :  qvswDY: Saturation Specific Humidity  over Water   (kg/kg) |
C |   ^^^^^^^   qvsiDY: Saturation Specific Humidity  over Ice     (kg/kg) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'

      include 'MAR_DY.inc'
      include 'MAR_SL.inc'
      include 'MAR_WK.inc'


C +--Local  Variables
C +  ================

      real     WatIce,ExpWat,ExpWa2,ExpIce


C +--DATA
C +  ====

      data     WatIce/273.16e0/
      data     ExpWat/5.138e0/
      data     ExpWa2/6827.e0/
      data     ExpIce/6150.e0/


C +--Temperature (K) and Pressure (hPa)
C +  ==================================

      DO   k=1,mz
        DO j=1,my
        DO i=1,mx
          WKxyz5(i,j,k)   = tairDY(i,j,k)
          WKxyz6(i,j,k)   = (pstDY(i,j)  * sigma(k) + ptopDY) * 10.0d0
        END DO
        END DO
      END DO

        DO j=1,my
        DO i=1,mx
          WKxyz5(i,j,mzz) = TairSL(i,j)
          WKxyz6(i,j,mzz) = (pstDY(i,j)             + ptopDY) * 10.0d0
        END DO
        END DO


C +--Saturation Vapor Pressure over Ice
C +  ==================================

      DO   k=1,mzz
        DO j=1,my
        DO i=1,mx
          WKxyz7(i,j,k) = 
     .    6.1070d0 * exp (ExpIce*(unun/WatIce-unun/WKxyz5(i,j,k)))
C +...    Dudhia (1989) JAS, (B1) and (B2) p.3103 

          WKxyz8(i,j,k) = .622d0*WKxyz7(i,j,k)
     .  /(WKxyz6(i,j,k) - .378d0*WKxyz7(i,j,k))


C +--Saturation Vapor Pressure over Water
C +  ====================================

          WKxyz7(i,j,k) = 
     .    6.1078d0 * exp (ExpWat*  log(WatIce     /WKxyz5(i,j,k)))
     .             * exp (ExpWa2*(unun/WatIce-unun/WKxyz5(i,j,k)))
C +...    Dudhia (1989) JAS, (B1) and (B2) p.3103 
C +       See also Pielke (1984), p.234 and Stull (1988), p.276 

          qvswDY(i,j,k) = max(eps9  ,       .622d0*WKxyz7(i,j,k)
     .  /(WKxyz6(i,j,k) -                   .378d0*WKxyz7(i,j,k)))
C +...    Saturation Vapor Specific Concentration over Water
C +       (even for temperatures less than freezing point)


C +--Water Phase Discriminator
C +  =========================

          WKxyz7(i,j,k) = max(zero,sign(unun,WKxyz5(i,j,k)-WatIce))
C +...    WKxyz7(i,j,k) =     1    if        Tair     >    273.16
C +                           0    if        Tair     <    273.16


C +--Saturation Vapor Specific Concentration over Ice
C +  ================================================

          qvsiDY(i,j,k) =
     .       max(eps9   , qvswDY(i,j,k) *      WKxyz7(i,j,k) 
     .                  + WKxyz8(i,j,k) *(unun-WKxyz7(i,j,k)))


C +--Work Area Reset
C +  ===============

          WKxyz5(i,j,k) = 0.0
          WKxyz6(i,j,k) = 0.0
          WKxyz7(i,j,k) = 0.0
          WKxyz8(i,j,k) = 0.0
        END DO
        END DO
      END DO

      return
      end 

      
      function qsat0D(ttq,ss,pstar,pt,lsf)

C +------------------------------------------------------------------------+
C | MAR PHYSICS                                         Mc 30-05-2007  MAR |
C |   Function qsat0D computes the Saturation Specific Humidity    (kg/kg) |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT :   ttq            : Air Temperature                       (K) |
C |   ^^^^^^^   pstar * ss + pt: Pressure of sigma level ss          (kPa) |
C |                                                                        |
C |   OUTPUT :  esat: Saturation Vapor Pressure                      (hPa) |
C |   ^^^^^^^   qsat0D: Saturation Specific Humidity               (kg/kg) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      real     qsat0D,ttq   ,ss    ,pstar ,pt    
      integer  lsf


C +--Local  Variables
C +  ================

      real     pr    ,esat
      real     r273p1


C +--DATA
C +  ====

      data     r273p1/273.16e0/

      pr   = 10.d0 *(pstar *ss + pt)
C +...pr   : pressure (hPa)

      IF (ttq.ge.273.16d0.or.lsf.eq.0)                              THEN

        esat =  6.1078d0 * exp (5.138d0*log(r273p1/ttq))
     .                   * exp (6827.d0*(unun/r273p1-unun/ttq))
C +...  esat : saturated vapor pressure with respect to water
C +***  Dudhia (1989) JAS, (B1) and (B2) p.3103 
C +     See also Pielke (1984), p.234 and Stull (1988), p.276 

      ELSE
        esat =  6.107d0  * exp (6150.d0*(unun/r273p1-unun/ttq))
C +...  esat : saturated vapor pressure with respect to ice
C +***  Dudhia (1989) JAS, 1989, (B1) and (B2) p.3103 

      END IF

C +     ******
        qsat0D = max(eps9  , .622d0*esat/(pr-.378d0*esat))
C +     ******

      return
      end      


      function qse_0D(tt,sigma,ps,ptop)

!--------------------------------------------------------------------------+
!                                                          Tue 30-Jun-2009 |
!     fonction qse_0D computes ECMWF saturation specific humidities        |
!                                                                          |
!--------------------------------------------------------------------------+

      IMPLICIT NONE

      real     ps    ,sigma ,ptop  ,foeew ,zcor
      real     tt    ,pp    ,qswT
      real     rkbol ,rnavo ,r     ,rmd   ,rmv
      real     rd    ,rv    ,restt ,r2es  ,r3les
      real     r3ies ,r4les ,r4ies ,retv  ,rtt
      real     qse_0D


      data rkbol  /1.380658e-23 /
      data rnavo  /6.0221367e+23/
      data rmd    /28.9644      /
      data rmv    /18.0153      /
      data restt  /611.21       /
      data r3les  /17.502       /
      data r3ies  /22.587       /
      data r4les  /32.19        /
      data r4ies  /-0.7         /
      data rtt    /273.16       /

           r      = rnavo*rkbol
           rd     = 1000.*r/rmd
           rv     = 1000.*r/rmv
           r2es   = restt*rd/rv
           retv   = rv/rd-1

           pp     = ps*sigma+ptop


           foeew  = r2es*exp((r3les*(tt-rtt))/(tt-r4les))
        
           qswT   = foeew/(1000.*pp)
           zcor   = 1./(1.-retv*qswT)
           qswT   = qswT*zcor

           qse_0D = qswT


! FROM ECMWF
! ----------
! #
! #   computes qsat for water , USAGE qsat T P
! #
! set -e
! if [ $1 ] ; then 
!    dummy=0 
! else 
!    echo "computes qsat for water; USAGE: qsat T P " >&2 ; exit 2 
! fi
! if [ $2 ] ; then 
!    dummy=0 
! else 
!    echo "computes qsat for water; USAGE: qsat T P " >&2 ; exit 2 
! fi
! echo $1 $2 | awk 'BEGIN { \
!                 rkbol=1.380658e-23; rnavo=6.0221367e+23; r=rnavo*rkbol; \
!                 rmd=28.9644; rmv=18.0153; rd=1000.*r/rmd; rv=1000.*r/rmv; \
!                 restt=611.21; r2es=restt*rd/rv; r3les=17.502; r3ies=22.587; \
!                 r4les=32.19; r4ies=-0.7; 
!                 retv=rv/rd-1; rtt=273.16}
!                 {t=$1; p=$2; \
!                 foeew=r2es*exp((r3les*(t-rtt))/(t-r4les)) ; \
!                 qs=foeew/p ; zcor=1/(1-retv*qs);qs=qs*zcor ; print qs}'
! #
! # computes satration water vapor pressure over water as in the IFS
! # usage: qsat T P    ! T in K and P in Pa e.g. qsat 293 1e5
! #

      RETURN

      END

      
      subroutine PHYrad_LMD

C +------------------------------------------------------------------------+
C | MAR PHYSICS                                            04-03-2004  MAR |
C |   SubRoutine PHYrad_LMD    interfaces MAR        with        the       |
C |              ECMW Solar/Infrared      Radiative  Transfer Scheme       |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables (MAR)
C +  ======================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'   
      include 'MARgrd.inc'
      include 'MAR_GE.inc'   

      include 'MAR_DY.inc'  

c #HY include 'MAR_HY.inc'  
c #AR include 'MAR_TC.inc'  
      include 'MAR_RA.inc'  

      include 'MAR_SL.inc'    
c #SN include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'    
C +
      include 'MAR_WK.inc'  
      include 'MAR_IO.inc'  


C +--Global Variables (LMDZ)
C +  =======================
C +
C +--INPUT
C +  -----
C +
      REAL      co2ppm,SolarC
      REAL      rjour0
      REAL       rlat0(klon)
      REAL      tsol_0(klon)
      REAL      cosZeA(klon)
      REAL      fracSo(klon)
      REAL      albedS(klon)
      REAL      pplay0(klon,klev)
      REAL      paprs0(klon,klev+1)
      REAL      tair_0(klon,klev)
      REAL      qair_0(klon,klev)
      REAL          wo(klon,klev)
      REAL      cldfr0(klon,klev)
      REAL      cldta0(klon,klev)
      REAL      cldem0(klon,klev)
      REAL      aerta0(klon,klev)
C +
C +
C +--OUTPUT
C +  ------
C +
      REAL      heatn( klon,klev)
      REAL      heatn0(klon,klev)
      REAL      cooln( klon,klev)
      REAL      cooln0(klon,klev)
      REAL      rirsol(klon) 
      REAL      albpln(klon)
      REAL      to_sw( klon)
      REAL      to_lw( klon)
      REAL      so_sw( klon)
      REAL      so_lw( klon)
      REAL      to_sw0(klon)
      REAL      to_lw0(klon)
      REAL      so_sw0(klon)
      REAL      so_lw0(klon)
C +
C +
C +--Local  Variables
C +  ================
C +
      character*3 vectra
      integer   klraOK
      integer   iklon    ,klr      ,n        ,io
C +
      real      bsegal   ,albmax   ,albx     ,dalb     ,albu  
      real      czemax   ,czrx
      REAL      DistST
C +...          DistST:   Normalized Earth's Sun Distance
C +
      real      t_altostr
      real      rho_dz   ,cw_LWP   ,ci_LWP   ,cs_LWP   ,cwiLWP
      real                fraliq             ,frabls
      real                rad_chaud,rad_froid,rad_BlowS,radius
      real      coef_chau,coef_froi                    ,coef
      real                cw_TAP                       ,radaer
      real      siceOK   ,ciceOK   ,zangOK   ,sign_T   ,ColdOK
      real      sign_S   ,snowOK   
      real      heatng   ,zlevel   ,pr_atm   ,qcloud   ,fcloud
C +
C +
C +--DATA
C +  ====
C +
      data bsegal/2.00e0/      !
      data albmax/0.99e0/      !
      data czemax/0.173648178/ ! czeMAX: 80.deg (Segal et al., 1991 JAS)
C +
      data t_altostr/10.0e0/   ! Alto-Stratus  Optical Thickness  !
      data rad_chaud/20.0e0/   ! Cloud Droplet Optical Radius     ! Laurent Li
      data rad_froid/40.0e0/   ! Ice   Crystal Optical Radius     ! Personal
      data coef_chau/0.13e0/   ! Cloud Droplet Emissivity Factor  ! Communicat.
      data coef_froi/0.05e0/   ! Ice   Crystal Emissivity Factor  ! 20 Nov 1993
      data rad_BlowS/10.0e1/   ! Blown Snow    Optical Radius     ! GUESS
      data radaer  /500.0e0/   ! Aerosol       Optical Radius     ! GUESS    
C +
C +
C +--Set UP Verification
C +  ===================
C +
      IF     (iterun        .eq.0)                                THEN
C +
                  klraOK = mx2*my2
c #ll             klraOK =       1
            IF   (klon.ne. klraOK)                                THEN
              IF (klon.gt.1)                                      THEN
                  vectra = 'NON'
              ELSE
                  vectra = '   '
              END IF
                write(6,6000) klon,klraOK,vectra
 6000           format(/,'++++++++ klon (MARdim.inc) =',i6,' .NE.',i6,
     .                       ' ++++++++++++++',
     .                 /,'++++++++ NOT adapted to a ',a3,' vectorized ',
     .                   'code ++++++++++++++',
     .                 /,'++++++++ BAD SET UP of #ll or klon parameter',
     .                      '  ++++++++++++++',
     .                 /,'     ==> !?%@&* Emergency EXIT in PHYrad_LMD')
                STOP
            END IF
C +
C +
C +--Radiative Computations Set Up
C +  =============================
C +
C +     ***************
        call MAR_to_LMD
C +     ***************
C +
      END IF
C +
C +
C +--Insolation (top of the atmosphere)
C +  ==================================
C +
C +   ***************
      call PHYrad_top(DistST)
C +   ***************
C +
C +
C +--Zenith Angle Correction of Snow Albedo
C +  ======================================
C +
      IF  ( mod(itexpe,jtRadi).eq.0)                              THEN
        IF(.NOT.VSISVAT)                                          THEN
C +
          DO j=jp11,my1
          DO i=ip11,mx1
C +
            siceOK = 1 - min(iabs(isolSL(i,j)-2),iun)
            ciceOK = 1 - min(iabs(isolSL(i,j)-3),iun)
C +
            zangOK =     max(siceOK,ciceOK)
C +
            sign_T =    sign(unun  ,TfSnow-TairSL(i,j))
            ColdOK =     max(zero  ,sign_T)
            zangOK =     max(zangOK,ColdOK)
C +
            sign_S =         zero
c #sn       sign_S =    sign(unun  ,dzSNow(i,j,1)-eps9)
            snowOK =     max(zero  ,sign_S)
            zangOK =     max(zangOK,snowOK)
C +
c #CP       zangOK =         0.0e+0
C +
C +
C +--Snow and/or ice covered surface 
C +  -------------------------------
C +
            albx        =            alb0SL(i,j)
            czrx        = max(czemax,czenGE(i,j))
            dalb        = 0.32e0*((bsegal+unun)/(unun+2.e0*bsegal*czrx)
     .                           - unun ) / bsegal
            dalb        = max(dalb,zero)
            albx        =     dalb+alb0SL(i,j)
            albx        = min(albx,albmax)
C +***      Influence of Sun Zenith Angle 
C +         (Segal et al., 1991 JAS 48, p.1025)
C +
C +
C +--Underlying Surface Albedo
C +  -------------------------
C +
            albu        = alb0SL(i,j)
C +
C +
C +--Actual Albedo
C +  -------------
C +
            albeSL(i,j) = zangOK *albx +(1-zangOK) *albu
C +
          END DO
          END DO
C +
        END IF
C +
C +
C +--Effective Radiating Surface Temperature
C +  =======================================
C +
        DO j=jp11,my1
        DO i=ip11,mx1
C +
               WKxy1(i,j) = 0.0e+0
            DO n=1     ,mw
               WKxy1(i,j) =  WKxy1(i,j) 
     .      + eps0SL(i,j) * SLsrfl(i,j,n) *tsrfSL(i,j,n)*tsrfSL(i,j,n)
     .                                    *tsrfSL(i,j,n)*tsrfSL(i,j,n)
            END DO
               tviRA(i,j) = sqrt( sqrt( WKxy1(i,j) 
     .              +(1.-eps0SL(i,j)) *RAd_ir(i,j)/stefan) )
C +
        END DO
        END DO


C +--Solar and IR Transfer through the Atmosphere
C +  ============================================

c #SA   IF (.not.sALONE)                                          THEN


C +--INPUT
C +  -----

C +--Global constants
C +  ~~~~~~~~~~~~~~~~
             co2ppm        =  367.
C +...       co2ppm:       :  CO2 Concentration

            SolarC         = 1370.
C +...      SolarC         : solar constant

             rjour0        = njyrGE(mmarGE) + jdarGE

C +--Geographical Dependance
C +  ~~~~~~~~~~~~~~~~~~~~~~~
                     iklon  =         0
          DO j = jp11,my1
          DO i = ip11,mx1
                     iklon  = iklon + 1
c #ll                iklon  =         1

               rlat0(iklon) = GElatr(i,j) / degrad
              cosZeA(iklon) = czenGE(i,j)
C +...        cosZeA        : cosine of the zenithal distance

              fracSo(iklon) = 1.0d+0
C +...        fracSo        : normalized insolation time

C +--Surface
C +  ~~~~~~~
              tsol_0(iklon) =  tviRA(i,j)
C +...        tsol_0        : surface temperature

              albedS(iklon) = albeSL(i,j)
C +...        albedS        : surface albedo

C +--Pressure
C +  ~~~~~~~~
               paprs0(iklon, 1) =(pstDY(i,j)             + ptopDY) *1.e3
               pplay0(iklon, 1) =(pstDY(i,j)*sigma(mz)   + ptopDY) *1.e3
            DO klr= 2,klev
               k = mzz-klr
               paprs0(iklon,klr)= (pstDY(i,j)*sigmid(k+1)+ ptopDY) *1.e3
C +...         paprs0           : pressure at layer interface       [Pa]
C +
               pplay0(iklon,klr)= (pstDY(i,j)*sigma( k)  + ptopDY) *1.e3
C +...         pplay0           : pressure in layer                 [Pa]
            END DO
               paprs0(iklon,klev+1) =
     .                           (pstDY(i,j)*sigmid(  1) + ptopDY) *1.e3

C +--Thermodynamics
C +  ~~~~~~~~~~~~~~
            DO klr= 1,klev
               k = mzz-klr
               tair_0(iklon,klr) = tairDY(i,j,k)
               qair_0(iklon,klr) =   qvDY(i,j,k)
            END DO

C +--Clouds
C +  ~~~~~~
              cld_SL(i,j)      = 0.
              RAcdtO(i,j)      = 0.
              RAertO(i,j)      = 0.
            DO klr= 1,klev
               k = mzz-klr
c #HY         cldfr0(iklon,klr)= cfraHY(i,j,k)
              rho_dz           = rolvDY(i,j,k)                   *1.0e+3
     .                         *(gpmiDY(i,j,k) -gpmiDY(i,j,k+1)) *grvinv
c #HY         cw_LWP           =   qwHY(i,j,k)                   *rho_dz
c #HY         ci_LWP           =   qiHY(i,j,k)                   *rho_dz
c +--Crude parameterization of the radiative impact of the Diamond Dust 
c?#HY.                   +max(zero,qvDY(i,j,k) -qvsiDY(i,j,k) *0.8000)
c?#HY.                   *max(zero,1.00 -   exp(tairDY(i,j,k) -248.15))
c?#HY.                                                           *rho_dz
c #HY         cs_LWP           =   qsHY(i,j,k)                   *rho_dz
c #HY         cwiLWP           =(cw_LWP        +ci_LWP       +cs_LWP )
c #HY.                     / max(cminHY        ,cfraHY(i,j,k)        )  
C +...        cwiLWP           : Liquid Water Path (kg/m2, i.e. mm water)

              fraliq           = cw_LWP    /max(cwiLWP,eps9)
              frabls           = cs_LWP    /max(cwiLWP,eps9)

              radius           = rad_chaud *        fraliq 
     .                         + rad_froid * (1.0d0-fraliq-frabls)
     .                         + rad_BlowS *        frabls
              cldta0(iklon,klr)= 1.5e+3        *cwiLWP           /radius
C +...        cldta0           : Cloud Optical Depth 
C +                              1.5e+3 = 1000 * 3/2

              cld_SL(i,j)      = max(cld_SL(i,j),                 ! Cloudiness
     .                               cldta0(iklon,klr)/t_altostr) !
              RAcdtO(i,j)      =     RAcdtO(i,j)
     .                         +     cldta0(iklon,klr)

              coef             =(coef_chau *        fraliq 
     .                         + coef_froi * (1.0e0-fraliq))     *1.0e+3

              cldem0(iklon,klr) = 1.0e00 - exp(-coef*cwiLWP)
C +...        Ref. : Laurent Li, 1993, Personnal Communication 
C +                 (e-mail 20Nov93)
C +
C +***        cldem0           = 1.0e00 - exp(-130.*cwiLWP)
C +           Ref. : Laurent Li, 1990, LMD Thesis, p.67, relation (43)
C +                 (IR / 8-12 microm)

              cldem0(iklon,klr) = max(zero,cldem0(iklon,klr))
              cldem0(iklon,klr) = min(unun,cldem0(iklon,klr))

C +--Terrigeneous Aerosols
C +  ~~~~~~~~~~~~~~~~~~~~~
              aerta0(iklon,klr)= 1.0e-15
c #AR         cw_TAP            =  qxTC(i,j,k,1)                 *rho_dz
c #AR         aerta0(iklon,klr)= 0.5e+3        *cw_TAP           /radaer
C +                              0.5e+3 = 3000 * 3/2, 
C +                                  with 3000 kg/m3: Dust Particle Density
              RAertO(i,j)      =     RAertO(i,j)
     .                         +     aerta0(iklon,klr)
            END DO

              cld_SL(i,j)      = min(cld_SL(i,j),unun)            ! Cloudiness
C +
C +
C +--LMDZ (Laurent Li) Routine, in case of NO Vectorization (scalar computer)
C +  ------------------------------------------------------------------------
C +
C +--Ozone Concentration
C +  ~~~~~~~~~~~~~~~~~~~
C +         ************
c #ll       call ozoncli(rjour0, rlat0 , paprs0, wo)
C +         ************
C +
C +         ************
c #ll       call radlwsw(DistST, cosZeA, fracSo, co2ppm, SolarC,
c #ll.                   paprs0, pplay0, tsol_0, albedS,
c #ll.                   tair_0, qair_0,     wo,
c #ll.                   cldfr0, cldem0, cldta0, aerta0,
c #ll.                   heatn , heatn0, cooln  ,cooln0, rirsol,albpln,
c #ll.                   to_sw , to_lw , so_sw , so_lw ,
c #ll.                   to_sw0, to_lw0, so_sw0, so_lw0)
C +         ************
C +
C +
C +--OUTPUT, in case of NO Vectorization
C +  -----------------------------------
C +
c #ll          RAdOLR(i,j)  =  to_lw(iklon)
C +...         RAdOLR       :  Outgoing Longwave Radiation
C +
c #ll          sol_SL(i,j)  =  so_sw(iklon)
C +...         sol_SL       :  Absorbed Solar Flux (by the Surface)
C +
c #ll          RAd_ir(i,j)  =  so_lw(iklon)
C +...                         so_lw: NET  IR Flux (at the Surface, + DownW)
c #ll.                      +  WKxy1(i,j) * stefan
C +...         RAd_ir       :  Downward    IR Flux (at the Surface)
C +
c #ll       DO klr= 1,klev
c #ll          k = mzz-klr
c #ll          heatng       = (heatn(iklon,klr)-cooln(iklon,klr))/86400.
C +...                         heatn: solar heating                    (K/day)
C +                                            cooln: infrared cooling (K/day)
c #ll          pktRAd(i,j,k)=  heatng   * dt  / pkDY(i,j,k)
C +
c #ll       END DO 
C +
          END DO
          END DO
C +
C +
C +--LMDZ (Laurent Li) Routine, in case of    Vectorization
C +  ------------------------------------------------------
C +
c #ll     IF (klon.gt.1)                                          THEN
C +
C +--Ozone Concentration
C +  ~~~~~~~~~~~~~~~~~~~
C +         ************
            call ozoncli(rjour0, rlat0 , paprs0, wo)
C +         ************
C +
C +         ************
            call radlwsw(DistST, cosZeA, fracSo, co2ppm, SolarC,
     .                   paprs0, pplay0, tsol_0, albedS,
     .                   tair_0, qair_0,     wo,
     .                   cldfr0, cldem0, cldta0, aerta0,
     .                   heatn , heatn0, cooln , cooln0, rirsol, albpln,
     .                   to_sw , to_lw , so_sw , so_lw ,
     .                   to_sw0, to_lw0, so_sw0, so_lw0)
C +         ************
C +
C +
C +--OUTPUT, in case of    Vectorization
C +  -----------------------------------
C +
                     iklon   =          0
            DO j = jp11,my1
            DO i = ip11,mx1
                     iklon   =  iklon + 1
C +
               RAdOLR(i,j)   =  to_lw(iklon)
C +...         RAdOLR        :  Outgoing Longwave Radiation
C +
               sol_SL(i,j)   =  so_sw(iklon)
C +...         sol_SL        :  Absorbed Solar Flux (by the Surface)
C +
               RAd_ir(i,j)   =  so_lw(iklon)
C +...                          so_lw: NET  IR Flux (at the Surface, + DownW)
     .                       +  WKxy1(i,j) * stefan
C +...         RAd_ir        :  Downward    IR Flux (at the Surface)
C +
              DO klr= 1,klev
               k = mzz-klr
               heatng        = (heatn(iklon,klr)-cooln(iklon,klr))/86400.
C +...                          heatn: solar heating                    (K/day)
C +                                             cooln: infrared cooling (K/day)
               pktRAd(i,j,k) =  heatng  * dt / pkDY(i,j,k)
C +
              END DO 
            END DO
            END DO
C +
c #ll     END IF
C +
c #SA   END IF
C +
C +
C +--OUTPUT, write
C +  -------------
C +
        IF (  jmmMAR.eq.0.and.    jssMAR   .eq.0       .and.
     .      ((IO_loc.ge.2.and.mod(jhurGE,3).eq.0).or.
     .       (IO_loc.ge.3                            ))     )     THEN
C +
          DO  io=1,min(klon,5)
              i  = igrdIO(io)
              j  = jgrdIO(io)
C +
C +         ***********
            call TIMcor
C +         ***********
C +
              iklon =  i      -ip11+1
     .              + (mx1-ip11+1)*(j -jp11)
c #ll         iklon =  1
C +
c #WL     write(6,6001)
 6001     format(//,' INPUT du fichier `donnees` de radiat.F',
     .            /,' ======================================')
c #WL       write(6,6002)paprs0(iklon,1),tsol_0(iklon)
c #WL     DO k=1,klev
c #WL       write(6,6002)pplay0(iklon,k),tair_0(iklon,k),qair_0(iklon,k)
c #WL.                  ,cldfr0(iklon,k),cldem0(iklon,k),cldta0(iklon,k)
c #WL.                  ,aerta0(iklon,k)
 6002       format(f8.1,f9.3,e13.6,4f5.1)
c #WL     END DO
C +
            write(4,401)jdplus,mmplus,jhlrGE(i ,j ),minuGE,
     .                                itizGE(i ,j ), i ,j ,iklon
c #WL       write(6,401)jdplus,mmplus,jhlrGE(i ,j ),minuGE,
c #WL.                                itizGE(i ,j ), i ,j ,iklon
  401       format(//,' +-- Radiative  Heat Fluxes --+',
     .       i4,'/',i2,i4,':',i2,' h.LT (',i3,')',
     .               '   (i,j) = (',i3,',',i3,')  (',i5,')',
     .        //,' | Altitud | Pressur.| Temper.|  Ozone  | W.Vapor|',
     .      ' Clouds | Clouds |  Opt.D | Aer.OD.| So Warm.|',
     .       ' Emiss.| IR Cool.|',
     .         /,' |   [km]  |   [hPa] |   [K]  | [cmSTP] | [g/kg] |',
     .      ' [g/kg] |   [%]  |   [-]  |   [-]  | [K/day] |',
     .       '  [-]  | [K/day] |',
     .         /,' +---------+---------+--------+---------+--------+',
     .      '--------+--------+--------+--------+---------+',
     .       '-------+---------+')
C +
            DO k =1,mz
               klr=  mzz-k
               zlevel = 1.e-3* grvinv   *gplvDY(i ,j ,k)
               pr_atm = 1.e-2           *pplay0(iklon,klr)
c #HY          qcloud = 1.e+3*(qwHY(i,j,k)+qiHY(i ,j ,k))
c #HY          fcloud = 1.e+2           *cfraHY(i ,j ,k)
C +
               write(4,402) zlevel, pr_atm,
     .            tair_0(iklon,klr),     wo(iklon,klr),
     .       1.e3*qair_0(iklon,klr), qcloud, fcloud,
     .            cldta0(iklon,klr), aerta0(iklon,klr),heatn(iklon,klr),
     .            cldem0(iklon,klr),  cooln(iklon,klr)
c #WL          write(6,402) zlevel, pr_atm,
c #WL.            tair_0(iklon,klr),     wo(iklon,klr),
c #WL.       1.e3*qair_0(iklon,klr), qcloud, fcloud,
c #WL.            cldta0(iklon,klr), aerta0(iklon,klr),heatn(iklon,klr),
c #WL.            cldem0(iklon,klr),  cooln(iklon,klr)
  402          format( ' | ',  f7.3,' |' ,f8.2,' |',f7.2,' |',e8.2,' |',
     .          2(f7.3,' |'),3(f7.2,' |'),f8.4,' |',f6.3,' |',f8.4,' |')
            END DO
C +
               pr_atm = 1.e-2           * paprs0(iklon, 1)
C +
            write(4,403) pr_atm,tsol_0(iklon),rirsol(iklon),
     .                          TairSL(i,j)  ,eps0SL(i,j)  ,RAd_ir(i,j)
  403       format(
     .           ' +---------+---------+--------+---------+--------+',
     .      '--------+--------+--------+--------+---------+',
     .       '-------+---------+',
     .                   /,' |     SOL |',f8.2,' |',f7.2,' |', 8x ,' |',
     .         2( 7x ,' |'),3( 7x ,' |'),  8x ,' |', 6x ,' |',f8.1,' |',
     .                   /,' |         |', 8x ,' |',f7.2,' |', 8x ,' |',
     .         2( 7x ,' |'),3( 7x ,' |'),  8x ,' |',f6.3,' |',f8.1,' |')
          END DO
        END IF
      END IF
C +
C +
C +--Lateral Boundary Conditions for Radiative Variables
C +  ===================================================
C +
       DO k=1,mz
         DO j=1,my
           pktRAd( 1,j,k) = pktRAd(ip11,j,k)
           pktRAd(mx,j,k) = pktRAd( mx1,j,k)
         END DO
         DO i=1,mx
           pktRAd(i, 1,k) = pktRAd(i,jp11,k)
           pktRAd(i,my,k) = pktRAd(i, my1,k)
         END DO
       END DO
C +
C +
C +--Work Array Reset
C +  ================
C +
       DO j=1,my
       DO i=1,mx
         WKxy1(i,j) = 0.0
       END DO
       END DO
C +
      return
      end
      subroutine PHYrad_MAR

C +------------------------------------------------------------------------+
C | MAR PHYSICS                                            23-02-2004  MAR |
C |   SubRoutine PHYrad_MAR    interfaces MAR        with        the       |
C |              LLN  Solar/Infrared      Radiative  Transfer Scheme       |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'   
      include 'MARgrd.inc'
      include 'MAR_GE.inc'   

      include 'MAR_DY.inc'  

c #HY include 'MAR_HY.inc'  
      include 'MAR_RA.inc'  

      include 'MAR_SL.inc'    
c #sn include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'    

      include 'MAR_WK.inc'  
      include 'MAR_IO.inc'  


C +--Local  Variables
C +  ================

      integer  ii    ,logalb,n
      REAL     DistST 
      real     bsegal,albmax,czemax,albx  ,czrx  ,dalb  ,tg1_4 ,tg2_4


C +--DATA
C +  ====

      data     bsegal/2.00e0/       !
      data     albmax/0.99e0/       !
      data     czemax/0.173648178/  ! czeMAX: 80.deg (Segal et al. 1991 JAS)


C +--Radiative Computations
C +  ======================
C +
C +--Insolation (Atmosphere Top)
C +  ---------------------------
C +
C +    ***************
c #MR  call PHYrad_top(DistST)
C +    ***************
C +  
       do 99 j=jp11,my1
       do 99 i=ip11,mx1
C +
                                                     IO_loc = IO_gen
        if (IO_gen.ge.1.and.jmmMAR.eq.0.and.jssMAR.eq.0) then
         do 60 ii=1,5
          if (igrdIO(ii).eq.i.and.(jgrdIO(ii).eq.j)) IO_loc = IO_gen+2
  60     continue
        end if
C +
       IF (mod(itexpe,jtRadi).eq.0)                               THEN
         IF(.NOT.VSISVAT)                                         THEN
C +   
C +
C +--Zenith Angle Correction of Snow Albedo
C +  --------------------------------------
C +
                                                            logalb = 0
           if (isolSL(i,j).ge.2 .and.isolSL(i,j).le.3)      logalb = 1
           if (isolSL(i,j).ge.4 .and.TairSL(i,j).le.TfSnow) logalb = 1
c #sn      if (dzSNow(i,j,1)                    .gt.0.0d+0) logalb = 1
c #SA                                                       logalb = 0
c #CP                                                       logalb = 0              
c #XF                                                       logalb = 1
           if (logalb     .ge.1                           ) then
             albx        =            alb0SL(i,j)
             czrx        = max(czemax,czenGE(i,j))
             dalb        = 0.32d0*((bsegal+unun)/(unun+2.d0*bsegal*czrx)
     .                            - unun ) / bsegal
             dalb        = max(dalb,zero)
             albx        =     dalb+alb0SL(i,j)
             albx        = min(albx,albmax)
C +***       Influence of Sun Zenith Angle 
C +          (Segal et al., 1991 JAS 48, p.1025)
C +
             albeSL(i,j) = albx
           else
             albeSL(i,j) = alb0SL(i,j)
           end if
         END IF
C +
C +
C +--Effective Radiating Surface Temperature
C +  ---------------------------------------
C +
         IF (nSLsrf(i,j).eq.1)                                    THEN
           tviRA(i,j) = tsrfSL(i,j,1)
         ELSE
               WKxy1(i,j) = 0.0e+0
            DO n=1     ,mw
               WKxy1(i,j) =  WKxy1(i,j) 
     .      + eps0SL(i,j) * SLsrfl(i,j,n) *tsrfSL(i,j,n)*tsrfSL(i,j,n)
     .                                    *tsrfSL(i,j,n)*tsrfSL(i,j,n)
            END DO
               tviRA(i,j) =      sqrt( sqrt(WKxy1(i,j)) )
               WKxy1(i,j) = 0.0e+0
         END IF
C +  
C +
C +--Solar and IR Transfer through the Atmosphere
C +  --------------------------------------------
C +
c #SA    IF (.not.sALONE)                                         THEN
C +
C +        ***************
c #MR      call PHYrad_int
C +        ***************
C +
c #SA    END IF
C +
       end if
C +
 99    continue
C +
C +
C +--Lateral Boundary Conditions for Radiative Variables
C +  ===================================================
C +
       do 103 k=1,mz
       do 101 j=1,my
       pktRAd( 1,j,k) = pktRAd(ip11,j,k)
       pktRAd(mx,j,k) = pktRAd(mx1,j,k)
 101   continue
       do 102 i=1,mx
       pktRAd(i, 1,k) = pktRAd(i,jp11,k)
       pktRAd(i,my,k) = pktRAd(i,my1,k)
 102   continue
 103   continue
C +
      return
      end
      subroutine PHYrad_int
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (INTERFACE)                                25-09-2001  MAR |
C |   SubRoutine PHYrad_int is the Interface between MAR and               |
C |                                              the radiative scheme      |
C |                         generates the Atmospheric Vertical Profiles    |
C |                                   used in Radiative computations       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT :  pstDY(mx,my)    : Pressure Depth p*(t)                (kPa) |
C |   ^^^^^   pktaDY(mx,my,mzz): Reduced  Potential Temperature            |
C |             qvDY(mx,my,mz) : specific humidity                   (m/s) |
C |             qwHY(mx,my,mz) : cloud droplets     concentration  (kg/kg) |
C |             qiHY(mx,my,mz) : cloud ice crystals concentration  (kg/kg) |
C |                                                                        |
C |   OUTPUT: pktRAd(mx,my,my) : Radiative Heating Rate                    |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   Discretization Choice :                                              |
C |   ^^^^^^^^^^^^^^^^^^^^^^^                                              |
C |     Radiative levels = MAR half levels           (vehalf=.true.)       |
C |     Radiative levels = MAR      levels  (STANDARD/vehalf=.false.)      |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MARSND.inc'
C +
      include 'MAR_DY.inc'
C +
c #HY include 'MAR_HY.inc'
      include 'MAR_RA.inc'
      include 'MAR_SO.inc'
      include 'MAR_IR.inc'
C +
      include 'MAR_SL.inc'
C +
      include 'MAR_IO.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      logical  vehalf
C +
      real     zradia(mzir)
      real     rhoair(mzir)
      real     rhovap(mzir)
      real     rhoco2(mzir)
      real     qtgram(mzir)
C +
      integer  kpbl  ,mzzp1 ,kk    ,iww   ,iww2
      real     pmbvap,zpbl  
      real     aoz1  ,aoz2  ,boz   ,coz1  ,coz2  ,zoz1  ,zoz2  
      real     qqww  ,qqii  ,qlwpw ,qlwpi ,dzniv ,fraliq,radius,coef
      real     rtop  ,dtsol 
c #HY real     dznivp,dznivm
C +
      real     eps1  ,pmbtop,ppmco2,facco2,rad_chaud,rad_froid
      real                                 coef_chau,coef_froi
C +
C +
C +--DATA
C +  ====
C +
      data vehalf/.false./
C +...     vehalf/.true./ ==> Variables are from Half Levels
C +
      data eps1  /1.0e-1/
C +
      data pmbtop/1.0e+0/
C +...Upper Layer Pressure for radiative computations   (hPa)
C +
      data ppmco2/3.3e+2/
      data facco2/1.0e+0/
C +
      data rad_chaud/20.0e0/
      data rad_froid/40.0e0/
      data coef_chau/0.13e0/
      data coef_froi/0.05e0/
C +...Cloud Particles Radiative Characteristics 
C +   (Laurent Li, Personal Communication, 20 Nov 1993)
C +
C +
C +--Temperature / Water Vapor / CO2 Vertical Profiles within the Model Domain 
C +  =========================================================================
C +
          zradia(1) =   gplvDY(i,j,mzz) * grvinv
C +
          tairRA(1) =   tviRA(i,j)
C +       tairRA    :   defined as an Effective Radiating Surface Temperature
C +
          pmb_RA(1) = ( pstDY(i,j)            +ptopDY)         *1.0d1
          qvapRA(1) =  qvapSL(i,j)
          pmbvap    =  qvapRA(1) *pmb_RA(1) 
     .                /0.62d0 /(1.d0+0.608d0*qvapRA(1))     
          rhovap(1) =  pmbvap   /(RVapor*tairRA(1))            *1.0d2
          rhoair(1) =  pmb_RA(1)/(RDryAi*tairRA(1))            *1.0d2
          rhoco2(1) =  pmb_RA(1)*5.29d-07*ppmco2/tairRA(1)
C +
C +   -----------
      IF (vehalf)                                                 THEN
C +   -----------
C +
        DO k  = kp1(1),mz
          zradia(k) =  gpmiDY(i,j,mzz-k+1) * grvinv
          tairRA(k) = (tairDY(i,j,mzz-k+1)+tairDY(i,j,mzz-k))  *0.5d0
          rhoair(k) = (rolvDY(i,j,mzz-k+1)+rolvDY(i,j,mzz-k))  *5.0d2
          pmb_RA(k) = ( pstDY(i,j)*sigmid(mzz-k+1)+ptopDY)     *1.0d1
          qvapRA(k) = (  qvDY(i,j,mzz-k+1)+  qvDY(i,j,mzz-k))  *0.5d0
          pmbvap    =  qvapRA(k) *pmb_RA(k) 
     .                /0.62d0 /(1.d0+0.608d0*qvapRA(k))       
          rhovap(k) =  pmbvap   /(RVapor*tairRA(k))            *1.0d2
          rhoco2(k) =  pmb_RA(k)*5.29d-07*ppmco2/tairRA(k)
        END DO
C +
          zradia(mzz) =  gplvDY(i,j,1) * grvinv
          tairRA(mzz) =  tairDY(i,j,1)                                      
          rhoair(mzz) =  rolvDY(i,j,1)                     *1.0d3
          pmb_RA(mzz) = ( pstDY(i,j)*sigma(1)+ptopDY)      *1.0d1
          qvapRA(mzz) =      qvDY(i,j,1)                                       
          pmbvap      =  qvapRA(mzz) *pmb_RA(mzz) 
     .                  /0.62d0 /(1.d0+0.608d0*qvapRA(mzz))
          rhovap(mzz) =  pmbvap             /(RVapor*tairRA(mzz)) *1.0d2
          rhoco2(mzz) =  pmb_RA(mzz)*5.29d-07*ppmco2/tairRA(mzz)
C +
C +   ----
      ELSE
C +   ----
C +
        DO k = kp1(1),mzz
          zradia(k) =  gplvDY(i,j,mzz-k+1) * grvinv
          tairRA(k) =  tairDY(i,j,mzz-k+1)
          rhoair(k) =  rolvDY(i,j,mzz-k+1)                     *1.0d3
          pmb_RA(k) = ( pstDY(i,j)*sigma(mzz-k+1)+ptopDY)      *1.0d1
          qvapRA(k) =      qvDY(i,j,mzz-k+1)
          pmbvap    =  qvapRA(k) *pmb_RA(k) 
     .                /0.62d0 /(1.d0+0.608d0*qvapRA(k))        
          rhovap(k) =  pmbvap/(RVapor*tairRA(k))               *1.0d2
          rhoco2(k) =  pmb_RA(k)*5.29d-07*ppmco2/tairRA(k)
        END DO
C +
C +   ------
      END IF
C +   ------
C +
C +
C +--Temperature / Water Vapor / CO2 Vertical Profiles above  the Model Domain 
C +  =========================================================================
C +
      zpbl = gplvDY(i,j,1) * grvinv
C +do until
      kpbl = 1
 111  continue
      if (zpbl.lt.zSND(kpbl,1)) go to 110 
      kpbl = kpbl + 1
      go to 111 
 110  continue
C +
             mzzp1  =       mzir1
      IF    (mzir1.gt.mmz+1)                                        THEN
             mzzp1  = mzz+1 
        DO       k  = mzzp1,mzir1
          zradia(k) = zSND(kpbl,1)
          pmb_RA(k) = pSND(kpbl,1)                                 *1.d1
          tairRA(k) = tSND(kpbl,1)
C +
          qvapRA(k) = qSND(kpbl,1)
          rhovap(k) = qvapRA(k)       *pmb_RA(k)/(RVapor*tairRA(k))*1.d2
C +
          rhoair(k) = pmb_RA(k)                 /(RDryAi*tairRA(k))*1.d2
          rhoco2(k) = 5.294d-07*ppmco2*pmb_RA(k)/        tairRA(k)  
          kpbl      = kpbl + 1
        END DO
      END IF
C +
C +
C +--Swab Isothermal Layer
C +  =====================
C +
       pmb_RA(mzir)=pSND(kpbl,1)                                   *1.d1
       pmb_RA(mzir)= min(pmbtop,pmb_RA(mzir))
       tairRA(mzir)=tSND(kpbl-1,1)
       zradia(mzir)=zradia(mzir-1)-(RDryAi*tairRA(mzir)*grvinv)
     .                           *log(pmb_RA(mzir)/ pmb_RA(mzir-1))
       qvapRA(mzir)=qSND(kpbl-1,1)
       rhovap(mzir)=qvapRA(mzir)*1.d2*pmb_RA(mzir)/(RDryAi*tairRA(mzir))
       rhoair(mzir)=             1.d2*pmb_RA(mzir)/(RDryAi*tairRA(mzir))
       rhoco2(mzir)=5.294d-07*ppmco2 *pmb_RA(mzir)/    tairRA(mzir)
C +
C +
C +--Ozone Vertical Profile 
C +  ======================
C +
         aoz1       =  0.331d0
         aoz2       =  0.012d0
         boz        = 23.d0
         coz1       =  4.55d0
         coz2       =  5.23d0
         zoz1       = (aoz1+(aoz1*exp(-boz/coz1)))
       DO k=1,mzir-1
         zoz2       = (1.d-3*zradia(k+1)-boz)/coz1
         wo3_RA(k+1)=  zoz1/(1.d0+exp(zoz2))
         wo3_RA(k+1)=  wo3_RA(k+1)+aoz2*exp(-1.d-3*zradia(k+1)/coz2)
       END DO
         wo3_RA(1)  = aoz1+aoz2
C +...   wo3_RA(1)  : Total Ozone Concentration (cm STP)
C +                   Max / Min Uccle : 0.38 (April) / 0.28 (October)
C +***   wo3_RA       profile parameterized as in Wang et al. (Sciences,1976)
C +
       DO k=1,mzir-1
         dwo3RA(k)  = wo3_RA(k)-wo3_RA(k+1)
           FSOn(k)  = 0.
       END DO
           FSOn(mzir) = 0.
C +
C +
C +--Clouds
C +  ======
C +
       do 115 k=1,mzir
        cld_RA(k) = 0.d0
        qlwpRA(k) = 0.d0
        toptRA(k) = 0.d0
        ocldSO(k) = 0.d0
         epsIR(k) = 0.d0
        ecldIR(k) = 0.d0
 115   continue
C +
       qqww     =   0.d0
       qqii     =   0.d0
       qlwpw    =   0.d0
       qlwpi    =   0.d0
C +
      do 116 k=kp1(1),mz
           kk=1+mzz-k
C +
C +   ----------------
c #HY if (vehalf) then
C +   ----------------
C +
c #HY  qqww     = ( qwHY(i,j,kk  ) + qwHY(i,j,kk-1) ) * 0.5d0
c #HY  qqii     = ( qiHY(i,j,kk  ) + qiHY(i,j,kk-1) ) * 0.5d0
c #HY else
c #HY  qqww     =   qwHY(i,j,kk  ) 
c #HY  qqii     =   qiHY(i,j,kk  ) 
c #HY end if
C +
       qtgram(k)=   qqww           + qqii
C +
C +
C +--Clouds Optical Depth and Single Scattering Albedo
C +  -------------------------------------------------
C +
      if (qtgram(k).gt.epsi) then 
C +
c #HY  cld_RA(k)=           cfraHY(i,j,kk  )
       dzniv    = 0.1019d0*(gpmiDY(i,j,kk  )-gpmiDY(i,j,kk+1))*rhoair(k)
c #HY  dznivp   = 0.1019d0*(gplvDY(i,j,kk  )-gplvDY(i,j,kk+1))*rhoair(k)
c #HY  dznivm   = 0.1019d0*(gplvDY(i,j,kk-1)-gplvDY(i,j,kk  ))*rhoair(k)
C +
c #HY if (vehalf) then
c #HY  qlwpw    =(dznivm  * qwHY (i,j,kk-1)
c #HY.          + dznivp  * qwHY (i,j,kk)  ) * 0.5d+0
c #HY  qlwpi    =(dznivm  * qiHY (i,j,kk-1)
c #HY.          + dznivp  * qiHY (i,j,kk)  ) * 0.5d+0
c #HY else
c #HY  qlwpw    = dzniv   * qwHY (i,j,kk)  
c #HY  qlwpi    = dzniv   * qiHY (i,j,kk)  
c #HY end if
C +
C +--Fractional Cloudiness
C +  ~~~~~~~~~~~~~~~~~~~~~
c #HY  IF ( cld_RA(k) .gt. cminHY) THEN
c #HY       qlwpRA(k)=(qlwpw+qlwpi)/ cld_RA(k)
c #HY  ELSE
            qlwpRA(k)=(qlwpw+qlwpi)
C +...      qlwpRA(k): Liquid Water Path (kg/m2, i.e. mm water)
C +
c #HY  ENDIF
C +
C +--Optical Depth
C +  ~~~~~~~~~~~~~
C +... toptw    = 750.d0*qlwpw
C +               1.5 * W(Liquid Water Path) /(rhow[=1000kg/m3] * 20microm)
C +    Reference: Fouquart et al., 1990, Rev. Geoph., rel.(3) p.148
C +               Boucher  et al., 1993, Person.Com., rel.(5) p.  5
C +
C +... topti    = 0.6d+2*qlwpi
C +               1.5 * W(Liquid Water Path) /(rhow[=1000kg/m3] * 40microm)
C +
C +... toptRA (k) = toptw + topti
C +
       if (qlwpRA(k).gt.0.d0) then
           fraliq    = qlwpw / qlwpRA(k)
           radius    = rad_chaud * fraliq + rad_froid * (1.0d0-fraliq)  
           coef      = coef_chau * fraliq + coef_froi * (1.0d0-fraliq)
           toptRA(k) = 3.d0 / 2.d0 * 1000.d0 * qlwpRA(k) / radius
       else
           coef      = 0.d0
           toptRA(k) = 0.d0
       end if
C +
C +--Simple Scattering Cloud Albedo
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       ocldSO(k) = 0.9989d0 - 0.004d0*exp(-0.15d0*toptRA(k))
C +...             Fouquart-Bonnel parametrisation
C +
C +HY  ocldSO(k) = 1.d-3*(0.9d0+2.75d0*(czenGE(i,j)+1.d0)
C +  .                               *exp(-9.d-2*toptRA(k)))
C +*** ocldSO    : Simple Scattering cloud albedo
C +    Reference:  Fouquart et al., 1990, Rev. Geoph., rel.(7) p.149
C +                Warning : designed for summer temperate regions
C +
C +***  epsIR(k) = 1.d00 - exp(-130.d0*qlwpRA(k))
C +     Ref. : Laurent Li, 1990, LMD Thesis, p.67, relation (43)
C +           (IR / 8-12 microm)
C +
        epsIR(k) = 1.d00 - exp(-coef  *qlwpRA(k) *1000.d0)
C +     Ref. : Laurent Li, 1993, Personnal Communication (e-mail 20Nov93)
C +
        epsIR(k) = max(zero,epsIR(k))
        epsIR(k) = min(unun,epsIR(k))
C +
       ecldIR(k) = cld_RA(k) * epsIR(k)
C +
      end if
 116  continue
C +
C +
C +**** SOLAIRE (Tricot) *****
C +     ================
C +
C +--Radiation Input
C +  ---------------
C +
C +                      ******************
c #MR  if (.not.SOdata)  call iniso(facco2) 
C +                      ******************
C +
                SOdata =.true.
C +
       if(czenGE(i,j).gt.cz0_GE)  then
C +
C +     ***************
c #MR   call PHYrad_sol
C +     ***************
C +
        sol_SL(i,j) =  rsunGE *cverGE(i,j)     *FSOn(1)
        rtop        =  rsunGE *czenGE(i,j)
C +
        if (vehalf) then
         do 121 k   = kp1(1),mz
         htngSO(k)  =  rtop        *(  FSOn(k)-  FSOn(k-1))
     .                /rhoair(k)/cp/(zradia(k)-zradia(k-1))
 121     continue
        else
         htngSO(2)  =  rtop        *(  FSOn(3)/2+  FSOn(2)/2-  FSOn(1))
     .                /rhoair(2)/cp/(zradia(3)/2+zradia(2)/2-zradia(1))
         do 122 k   = min(3,mz),mz
         htngSO(k)  =  rtop        *(  FSOn(k+1)-  FSOn(k-1))
     .                /rhoair(k)/cp/(zradia(k+1)-zradia(k-1))
 122     continue
        end if
C +
       else
        sol_SL(i,j) = 0.d0
        do 123 k    = kp1(1),mz
        htngSO(k)   = 0.d0
 123    continue
       end if
C +
C +
C +**** I.R. (Morcrette) *****
C +     ================
C +
       iww  = 2
       iww2 = 2
       dtsol= 0.0d0
C +
C +
C +--Input
C +  -----
C +
c #MR  if (.not.IRdata)  call data2i
c #MR           IRdata =.true.
C +
C +
C +--Infrared Calculations
C +  ---------------------
C +
C +    **************
c #MR  call PHYrad_IR (dtsol,stefan,eps0SL(i,j),ppmco2,mzir,iww,iww2)
C +    **************
C +
       if (iww.eq.1) write (21,210)
 210    format (//,10x,'   PHYrad_IR  passee   ')
C +
       RAd_ir(i,j) = FIRd(1)
       RAdOLR(i,j) = FIRm(mzir)
C +
C +
C +--Radiative Heating Rate
C +  ======================
C +
C +--Solar
C +  -----
C +
      htngSO(1) =  sol_SL(i,j) *24.d0 *3600.d0 /4.18d6 
C +.. htngSO(1) :  Heating of 1.m water column (K / day)
C +
C +
C +--I.R.
C +  ----
C +
       do 431 k = 1,mzz
       FIRn(k)     =  FIRm(k)  -FIRd(k)
 431   continue
C +
C +   ----------------
      if (vehalf) then
C +   ----------------
C +
       do 432 k = kp1(1),mz
        htngIR(k) = -(  FIRn(k  )-  FIRn(k-1))
     . /rhoair(k)/cp/(zradia(k  )-zradia(k-1))
 432   continue
      else
       do 433 k = kp1(1),mz
       if (k.eq.2) then
        htngIR(2) = -(  FIRn(3)/2 +  FIRn(2)/2-  FIRn(  1))
     . /rhoair(2)/cp/(zradia(3)/2 +zradia(2)/2-zradia(  1))
       else
        htngIR(k) = -(  FIRn(k+1)-  FIRn(k-1))
     . /rhoair(k)/cp/(zradia(k+1)-zradia(k-1))
       end if
 433   continue
C +
C +   ------
      end if
C +   ------
C +
C +
C +--Total Radiative Heating Rate
C +  ============================
C +
      do 434 k = kp1(1),mzz
      htngRA(k)     =      htngSO(k) +htngIR (k)
      htngSO(k)     =      htngSO(k)  *24.d0 *3600.d0
      htngIR(k)     =      htngIR(k)  *24.d0 *3600.d0
 434  continue
      do 435 k = kp1(1),mz
      kk            =  mzz + 1 - k
      pktRAd(i,j,kk)=  dt *htngRA(k) /exp(cap*log(eps1*pmb_RA(k)))
 435  continue
      pktRAd(i,j,1) =  pktRAd(i,j,kp1(1))
C +
C +
C +--Output
C +  ======
C +
      if ((  jmmMAR.eq.0.and.    jssMAR   .eq.0         .and.
     .     ((IO_loc.ge.3.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.4.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.5)                            )       ).or.
     .       IO_loc.ge.7                                          ) then
C +
C +   nres = 1  ===>  Radiative Fluxes are Listed
C +        = 0  ===>  No Ouput          
C +        = 2  ===>  Radiative Fluxes are Listed, as well as 
C +                   Optical Depths, and CO2 and H2O Absorptivities
C +
C +   ***********
c #MR call TIMcor
C +   ***********
C +
      write(4,501)jdplus,mmplus,jhlrGE(i,j),minuGE,itizGE(i,j),
     .            i,j
  501 format(//,' --- Radiative Heat Fluxes ---',i4,'/',i2,
     & i4,':',i2,' h.LT (',i3,')   (i,j) = (',i3,',',i3,')',2(/,1x),
     &      '|    z(m) | IR K/d.|  p(hPa) |  T(K)  |rhov(kg/m3)|', 
     & '  IR+  |-(IR-) |IR W/m2|So K/d.|So W/m2|qt g/kg|',
     & ' Opt.D |W  kg/m2|Eff.Clou| ',
     & /,1x,'|_________|________|_________|________|___________|',
     & '_______|_______|_______|_______|_______|_______|',
     & '_______|________|________| ')
      write(4,502)zradia(1),
     .                      pmb_RA(1),tairRA(1),rhovap(1),
     .              FIRm(1),  FIRd(1),  FIRn(1),
     .            htngSO(1),FSOn(1)
  502 format(1x,'| ',f7.1,' |',8x,   '| ',f7.2,' | ',f6.2,' | ',
     . e9.3,' | ',2(f5.1,' | '),f5.1,' |',f5.1,'  | ',f5.3,' | ',
     .  4x ,'  | ', 5x, ' | ', 6x ,' | ', 6x ,' | ')
C +
      do 504 k=kp1(1),mz
      write(4,503)zradia(k),
     .            htngIR(k),pmb_RA(k),tairRA(k),rhovap(k),
     .              FIRm(k),  FIRd(k),  FIRn(k),
     .            htngSO(k),  FSOn(k),
     .       1.d3*qtgram(k),toptRA(k),qlwpRA(k),ecldIR(k)
  503 format(1x,'| ',f7.1,' |',f7.2,' | ',f7.2,' | ',f6.2,' | ',
     . e9.3,' | ',3(f5.1,' | '),          f5.2,' | ',f5.3,' | ',
     . f5.3,' | ',f5.2,' |', f7.4,' | ',f6.4,' | ')
  504 continue
C +
             k=  mzz
      write(4,505)zradia(k),
     .            htngIR(k-1),pmb_RA(k),tairRA(k),rhovap(k),
     .              FIRm(k),    FIRd(k),  FIRn(k),
     .           htngSO(k),FSOn(k)
  505 format(1x,'| ',f7.1,' |',f7.2,' | ',f7.2,' | ',f6.2,' | ',
     . e9.3,' | ',3(f5.1,' | '),          f5.2,' | ',f5.3,' | ',
     .  4x ,'  | ', 5x, ' | ', 6x ,' | ', 6x ,' | ')
      do 507 k=mzz+1,mzir
      write(4,506)zradia(k),
     .                      pmb_RA(k),tairRA(k),rhovap(k),
     .              FIRm(k),  FIRd(k),
     .            htngSO(k),  FSOn(k)
  506 format(1x,'| ',f7.1,' |',8x,   '| ',f7.2,' | ',f6.2,' | ',
     . e9.3,' | ',2(f5.1,' | '),6x,'| ',  f5.2,' | ',f5.3,' | ',
     .  4x ,'  | ', 5x, ' | ', 6x ,' | ', 6x ,' | ')
  507 continue
      end if
C +
      return
      end
      subroutine PHYrad_sol
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (solarn)                                   15-09-2001  MAR |
C |   SubRoutine PHYrad_sol computes                                       |
C |      Normalized Absorbed Solar Radiation at Surface and by Atmosphere  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER.:   Ch. Tricot, personal communication, January  1994          |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   INPUT :   rsunGE      : Insolation normal to Atmosphere Top (W/m2)   |
C |   ^^^^^^^   rsunGE        not used in the routine (except in write)    |
C |             czenGE(i,j) : Cosinus of the Zenithal Distance             |
C |                                                                        |
C |   OUTPUT:   FSOn(i,j,k) : Net Solar Radiative Heat Flux (normalized)   |
C |   ^^^^^^^                                                              |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_RA.inc'
      include 'MAR_SO.inc'
C +
      include 'MAR_SL.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      real            uinf(3),aap(3,6),bbp(3,6)
      common /eti200/ uinf   ,aap     ,bbp
C +
      real     ud(3,mzir),aki(2)
      real     rj(6,mzir)
      real     rk(6,mzir)
      real     tr(2,mzir)
      real     rl(8),ruef(8)
      real     udd(mzir),um(mzir),tcou(mzir)
C +
      real     taurae(mzir),grae (mzir),orae(mzir)
      real     rj1 (2,mzir),rk1(2,mzir),rmue(mzir)
      real     refz(2,mzir)
      real     rayldw(mzir)
      real     ray1  (mzir),ray2 (mzir)
      real     tra1  (mzir),tra2 (mzir)
C +
      real     pnrm  (mzir)
      real     clouvl(mzir)
      real     clds  (mzir),topts(mzir)
C +
      integer  iatst ,idiffu,iwri  ,np1   ,niv   ,liv   ,lp
      integer  im    ,kk    ,ip    ,n     ,jiv   ,kkp1  ,ktest
      integer  iab   ,kiv   ,jp    
      real     taer  ,oaer  ,gaer  ,ysol  ,y     ,x1    ,x2
      real     h2otot,co2tot,to    ,gravi ,ala   ,fach2o,fctw
      real     h2ot  ,co2t  ,fco2  ,xeridw,r     ,rrayae,faer  ,rdov
      real     fac1  ,trc1  ,fac2  ,trc2  ,diff  
      real     rneb  ,re1   ,re2   ,te1   ,te2
      real     xmue  ,rmu   ,asae  ,omae  ,taae  
      real     rae1  ,tae1  ,rae2  ,tae2
      real     wc1   ,to1   ,cn1   ,cn2   ,asf   ,ros   ,re11  ,rki
      real     aa    ,sabs  ,gabs  ,weff  ,r1    ,fupdwn,r2    ,r3
C +
      real     wvvp  ,taeri ,oaeri ,gaeri ,cgdata,e02   ,e10
      integer  ih1   ,ico2  ,io3   
C +
C +   logical variable for aerosol included or not
C +
      logical aero
C +
C +
C +--DATA
C +  ====
C +
      data aero /.false./
      data wvvp /2.5e0/
C +...     wvvp : Smith Water Vapor Vertical Profile Exponent
C +              (estimated from Ohring and Adler, 1978, JAS)
C +              (see also       Gallee et al.,    1991, JGR)
C +               is used if iatst = 1
      data taeri /0.0033e0/
C +...     taeri :optical depth aerosol:
C +               suggestions (Tricot, pers.comm.):
C +                         |   PBL    | Troposphere | Stratosphere |
C +               ----------+----------+-------------+--------------+
C +               Ocean     |  0.05    |    0.25     |    0.07      |
C +               Continent |  0.20    |    0.25     |    0.07      |
C +               Ice Sheet |  0.00    |    0.00     |    0.00      |
C +
      data oaeri /0.9e0/
C +...     oaeri :single scattering aerosol albedo:
C +               suggestions (Tricot, pers.comm.):
C +                         |   PBL    | Troposphere | Stratosphere |
C +               ----------+----------+-------------+--------------+
C +               Ocean     | 0.982545 |   0.872212  |  0.997975    |
C +               Continent | 0.872212 |   0.872212  |  0.997975    |
C +
C +
      data gaeri /0.647596e0/
C +
      data cgdata /0.85e0/
C +
      data ih1  /1/
C +...     ih1  =1 => Absorption by H2O is taken into account
      data ico2 /1/
C +...     ico2 =1 => Absorption by CO2 is taken into account
      data io3  /1/
C +...     io3  =1 => Absorption by O3  is taken into account
C +
      data e02  /1.e-02/
C +
      data e10  /1.e-10/
C +...     e10 is a fixed threshold depending on the computer precision
C +            to prevent negative logarithm or logarithm of zero
C +
C +--INITIALISATION
C +  ==============
C +
C +--Parameters Initialisation
C +  -------------------------
C +
      iatst = 0
C +...iatst = 1 : Smith Profile used (Climatology)
C +           0 : Interactive Humidity
      idiffu= 1
C +
      iwri  = 0
C +
      np1=mzir
C +
      if (.not.aero) then
       taer=0.
       oaer=oaeri
       gaer=gaeri
      else
       taer=taeri
       oaer=oaeri
       gaer=gaeri
      end if
C +
      ysol=sqrt(1224.d0*czenGE(i,j)*czenGE(i,j)+1.d0)/35.d0
C +...ysol:Magnification Factor
C +
      if (iwri.eq.1) 
     .write(6,600) rsunGE*czenGE(i,j),czenGE(i,j),
     .             mzir1,np1,ysol,    albeSL(i,j)
 600  format (//,5x,'****  SOLARI ROUTINE   ****',
     .         /,5x,'****  RSun =',f8.1,'   ****',
     .           3x,'****  CosZ =',f8.3,'   ****',
     .         /,5x,'****  mzir1=',i8,  '   ****',
     .           3x,'****  mzir =',i8,  '   ****',
     .         /,5x,'****  ysol =',f8.5,'   ****',
     .           3x,'****  albS =',f8.3,'   ****',/)
C +
C +
C +--Normalized Pressure
C +  -------------------
C +
      do 1  k=1,mzir
       pnrm (k) = pmb_RA (k)   /   pmb_RA (1)
 1    continue
C +
C +
C +--Corrected Cloudiness
C +  --------------------
C +
      do 10 k=1,mzir
      if (toptRA(k).gt.e02) then
C +...Small Optical Thickness generates (under,over)flow in flux2
C +
       topts(k) = toptRA(k)
       clds (k) = cld_RA(k)
      else
       topts(k) = 0.d0
       clds (k) = 0.d0
      end if
 10   continue
C +
C +
C +--Ozone Content in each Layer
C +  ---------------------------
C +
      udd(np1) = 0.0d0
      do 4001 niv=1,mzir1
      liv      = np1-niv
      lp       = liv+1
      udd(liv) = udd(lp) + dwo3RA(liv)/ysol
 4001 continue
      y        = 0.6024d0
      um (1)   = udd(1)
      do 4002 niv=2,np1
      im       = niv-1
      um (niv) = um (im) + dwo3RA(im) /y
 4002 continue
C +
C +
C +  Amount of absorber in each layer
C +  For H2O                : ud(1,niv)
C +  For O2,CO2             : ud(2,niv)
C +  ----------------------------------
C +
      ud(3,np1)=0.00d0
      ud(1,np1)=0.00d0
      ud(2,np1)=0.00d0
C +
C +
C +--O3
C +  --
C +
      do 20 niv=1,mzir1
      kk=np1-niv
      ud(3,kk)=udd(kk)
   20 continue
C +
C +
C +--H2O, CO2
C +  --------
C +
      h2otot=0.d0
      co2tot=0.d0
C +
      to=273.d0
      gravi=9.81d0
      ala=wvvp+1.9d0
      fach2o=10.d0*1013.d0*qvapRA(1)/(gravi*ala)
C +
      do 40 niv=1,mzir1
      ip=niv+1
      tcou(niv)=0.5d0*(tairRA(niv)+tairRA(ip))
      fctw=(to/tcou(niv))**0.45d0
      fco2=(to/tcou(niv))**1.375d0
C +
      if (iatst.ne.1)
     . ud(1,niv)=.5d0*543.62d0*(qvapRA(niv)+qvapRA(ip))
     .                    *(pnrm(niv)**1.9d0-pnrm(ip)**1.9d0)*fctw
      if (iatst.eq.1)
     . ud(1,niv)=fach2o*fctw*(pnrm(niv)**ala-pnrm(ip)**ala)
C +
      h2otot=h2otot+ud(1,niv)
      ud(2,niv)=150.678d0*fco2*(pnrm(niv)**1.75d0-pnrm(ip)**1.75d0)
      co2tot=co2tot+ud(2,niv)
 40   continue
C +
C +
C +--Output
C +  ------
C +
      if (iwri.eq.1) then
       write(6,51)
 51    format(/,11x,'uh2o',10x,'uco2',11x,'udo3',11x,'um03',10x,
     .              'h2otot',10x,'co2tot')
       do 5 niv=1,np1
       write(6,52) niv,ud(1,niv),ud(2,niv),ud(3,niv),um(niv),
     .             h2otot,co2tot
 52    format(i4,8(2x,e13.7))
 5     continue
      end if
C +
C +
C +--Grey Absorption Coefficients for approximative Absorption by
C +  (1) H2O ,(2) CO2,O2  ---------------------------------------
C +  -------------------
C +...The grey coefficients are computed such that
C +   the incident solar flux at the surface is correct
C +   if the scattering is ignored and assuming a clear sky
C +
      h2ot = h2otot / ysol
      co2t = co2tot / ysol
      n    = 1
C +
C +   *********
c #MR call tttt(n,h2ot,x1)
C +   *********
C +
      aki(1)=-log(x1)/h2ot
      n    = 2
C +
C +   *********
c #MR call tttt(n,co2t,x2)
C +   *********
C +
      aki(2)=-log(x2)/co2t
C +
      if (iwri.eq.1) then
       write(6,53) czenGE(i,j),h2otot,h2ot,x1,aki(1)
 53    format( /,' czenGE(i,j),h2otot,h2ot,x1,aki(1) = ',f15.6,4e15.6)
       write(6,56)     co2tot,co2t,x2,aki(2)
 56    format(   '     co2tot,co2t,x2,aki(2) = ', 15x, 4e15.6)
      end if
C +
C +
C +--OPTICAL PARAMETERS FOR RAYLEIGH AND AEROSOLS
C +  ============================================
C +
C +--Total Optical Depth due to Rayleigh Scattering
C +  ----------------------------------------------
C +
      xeridw=0.0294d0+0.313d0*ysol
     .              -0.6316d0*ysol*ysol
     .              +0.608d0 *ysol*ysol*ysol
     .              -0.2194d0*ysol*ysol*ysol*ysol
C +
      do 224 niv=1,mzir1
      jiv=niv+1
      r         =(pmb_RA(niv)-pmb_RA(jiv))                   / 1013.d0
      rayldw(niv)=xeridw*r
      rrayae     =rayldw(niv)/(rayldw(niv)+taer)
      faer       =gaer       *gaer
      taurae(niv)=rayldw(niv)+taer*(1.d0-oaer*faer)
      grae  (niv)=gaer  *(1.d0-rrayae)                 /(1.d0+gaer)
      orae  (niv)=rrayae+(1.d0-rrayae)*oaer*(1.d0-faer)/(1.d0-oaer*faer)
 224  continue
C +
C +
C +--Total Cloudiness above the Level k
C +  ----------------------------------
C +
       rdov       = 0.d0
       clouvl(mzir)=0.d0
       do 2 k=1,mzir1
       kk         = mzir-k
       kkp1       = kk+1
       fac1       = 1.-orae(kk)*grae(kk)*grae(kk)
       trc1       = exp(-fac1*taurae(kk)/ysol)
       fac2       = 1.-ocldSO(kk)*cgdata*cgdata
       trc2       = exp(-fac2*topts(kk)/ysol)
       rdov       = clds(kk)*(1.-trc1*trc2)+(1.-clds(kk))*(1.-trc1)
       clouvl(kk) = 1.-(1.-clouvl(kkp1))*(1.-rdov)
C +... clouvl     => total cloudiness above level kk  --- random overlap
C +
 2    continue
C +
       cld_SL(i,j)= clouvl(1)
C +
      if (iwri.eq.1) then
       write(6,54)
 54    format (/,' **** Cloud Overlap  Optical Depth          q H2O')
       do 50 niv=1,mzir1
       write(6,52) niv,clouvl(niv),topts(niv),qvapRA(niv)
 50    continue
       write(6,55)
 55    format (/,1x)
      end if
C +
C +
C +--PHOTON PATH (computed assuming Diffusion only / No Absorption)
C +  ==============================================================
C +
C +--Ground Level
C +  ------------
C +
      refz(1,1)=albeSL(i,j)
      refz(2,1)=albeSL(i,j)
C +...Photon Path Length is computed
C +
      diff     =1.66
      if (iwri.eq.1) then
       write(6,400)
 400   format( 9x,'refz1',9x,'refz2',11x,'tr1',12x,'tr2',11x,'refup',
     .        10x,'trup',10x,'refae',10x,'trae',/)
      end if
C +
C +
C +--For each Level
C +  --------------
C +
      do 420 niv=2,np1
      jiv = niv-1
      rneb= clds(jiv)
      re1 = 0.0
      te1 = 0.0
      re2 = 0.0
      te2 = 0.0
C +
      ktest = 1
C +
C +
C +--Equivalent Zenith Angle
C +  -----------------------
C +
      xmue=(1.-clouvl(niv))/ysol+clouvl(niv)*diff
      rmue(niv)=1./xmue
C +
C +
C +--Reflectivity of layer jiv due to Rayleigh + Aerosol scattering
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
      rmu = rmue(niv)
      asae= grae(jiv)
      omae= orae(jiv)
      taae= taurae(jiv)
C +
C +    ***********
c #MR  call fluxae (asae,omae,taae,rae1,tae1,rmu,rae2,tae2)
C +    ***********
C +
      ray1(jiv)= rae1
      tra1(jiv)= tae1
      ray2(jiv)= rae2
      tra2(jiv)= tae2
C +
C +
C +--Clouds are included
C +  -------------------
C +
      if (rneb.ne.0.d0) then
C +
       ktest = 0
C +
       wc1=max(ocldSO(jiv),e02)
       to1=topts(jiv)/wc1+taurae(jiv)/orae(jiv)
       cn1=topts(jiv)+taurae(jiv)
       cn2=topts(jiv)/cn1
       asf=cn2*cgdata+(1.-cn2)*grae(jiv)
       wc1=cn1/to1
       ros=refz(1,jiv)
       rmu=rmue(niv)
C +
C +    **********
c #MR  call flux2 (ros,asf,wc1,to1,re1,te1,rmu,re2,te2)
C +    **********
C +
      end if
C +
C +--Computation of refz(2,jiv): reflexion of layer jiv
C +                              for ref. of underlying layer =0
C +...              refz(1,jiv): for ref. of underlying layer #0
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
      refz(2,niv)=(1.-rneb) * (ray1(jiv) + 
     .             ktest*refz(2,jiv)*tra1(jiv)*tra2(jiv) /
     .             (1.-ray2(jiv)*refz(2,jiv))) + 
     .                                    rneb * re1
      tr(2,jiv)  =((1.-rneb) * tra1(jiv) / 
     .             (1.-ktest*ray2(jiv)*refz(2,jiv))) + 
     .                                    rneb * te1
c #TR refz(2,niv)=(1.-rneb) * ray1(jiv) + rneb * re1
c #TR tr(2,jiv)  =(1.-rneb) * tra1(jiv) + rneb * te1
C +
      refz(1,niv)=(1.-rneb) * (ray1(jiv)+refz(1,jiv)*
     *             tra1(jiv)*tra2(jiv)/(1.-ray2(jiv)*refz(1,jiv)))
     *         +  rneb * re2
      tr(1,jiv)  =((1.-rneb)*tra1(jiv)/(1.-ray2(jiv)*refz(1,jiv)))
     .         +  rneb * te2
C +
      if (iwri.eq.1) then
       write(6,401) jiv,refz(1,niv),refz(2,niv),tr(1,jiv),
     .              tr(2,jiv),ray1(jiv),tra1(jiv),ray2(jiv),tra2(jiv)
 401   format (i4,8(1x,e13.7))
      end if
C +
 420  continue
C +
C +
C +--Output
C +  ------
C +
      do 440 jiv=1,2
      if (iwri.eq.1) write(6,450) jiv
 450  format (//,' jiv =',i6,/)
      if (iwri.eq.1) write(6,451)
 451  format (5x,'     pression      rj1(down)      rk1(up)')
C +...rj : downward
C +...rk : upward
      rj1(jiv,np1)=1.d0
      rk1(jiv,np1)=refz(jiv,np1)
      do 441 niv=1,mzir1
      kk=np1-niv
      lp=kk+1
      rj1(jiv,kk)=rj1(jiv,lp)*tr(jiv,kk)
      re11=rj1(jiv,kk)
      rk1(jiv,kk)=re11*refz(jiv,kk)
      if (iwri.eq.1)
     . write(6,401)kk,pnrm(kk),rj1(jiv,kk),rk1(jiv,kk)
 441  continue
 440  continue
C +
      if (iwri.eq.1) write(6,77)
 77   format (/,4x,'        rj(1)        rj(2)',
     .             '        rk(1)        rk(2)')
      do 79 niv=1,np1
      rj(1,niv)=rj1(1,niv)
      rj(2,niv)=rj1(2,niv)
      rk(1,niv)=rk1(1,niv)
      rk(2,niv)=rk1(2,niv)
      if (iwri.eq.1)
     . write(6,78) niv,rj(1,niv),rj(2,niv),rk(1,niv),rk(2,niv)
 78    format (i4,4e13.6)
 79   continue
C +
      if (iwri.eq.1) then
       write(6,82)(niv,qvapRA(niv),pnrm(niv),tairRA(niv),niv=1,mzir1)
 82    format (//,15x,'qvapRA',10x,'pnrm',9x,'TempK',
     .          /,(i5,1x,e12.4,2x,e12.4,2x,e12.4))
      end if
C +
C +
C +--ABSORPTION
C +  ==========
C +
C +--For downward radiation : ud
C +  For upward   radiation : um
C +  Interactions between O3 absorption and scattering are neglected
C +  Amount of absorber in each layer
C +  For H2O                : ud(1,niv)
C +  For O2,CO2             : ud(2,niv)
C +  ----------------------------------
C +
      diff=1.66
      n=2
C +
C +--Flux Computation with Simulated Absorption
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      do 90 iab=1,2
      if (iwri.eq.1) write(6,1008) iab
 1008 format (/,1x,'iab =',i6,/)
      rki=aki(iab)
C +
      if ((iab.eq.1).and.(ih1 .ne.1)) rki=0.0d0
      if ((iab.eq.2).and.(ico2.ne.1)) rki=0.0d0
C +
      refz(1,1)=albeSL(i,j)
      refz(2,1)=albeSL(i,j)
      do 100 niv=2,np1
      jiv=niv-1
      rneb=clds(jiv)
      aa=ud(iab,jiv)
      sabs= exp(-rki*aa*diff)
      gabs= exp(-rki*aa/rmue(niv))
C +
      ktest = 1
C +
      re1=0.d0
      te1=0.d0
      re2=0.d0
      te2=0.d0
C +
C +
C +--Clouds are included
C +  -------------------
C +
      if (rneb.ne.0.d0) then
C +
       ktest = 0
C +
       wc1 = max(ocldSO(jiv),e02)
       to1 = topts(jiv)/wc1 + taurae(jiv)/orae(jiv)+rki*aa
       cn1 = topts(jiv)     + taurae(jiv)
       cn2 = topts(jiv)/cn1
       asf = cn2*cgdata    + (1.d0-cn2) *grae(jiv)
       wc1 = cn1/to1
       ros = refz(1,jiv)
       rmu = rmue(niv)
C +
C +    **********
c #MR  call flux2 (ros,asf,wc1,to1,re1,te1,rmu,re2,te2)
C +    **********
C +
      end if
C +
C +--Computation of refz(2,jiv): reflexion of layer jiv
C +                              for ref. of underlaying layer =0
C +...              refz(1,jiv): r#0
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
      refz(2,niv)=(1.d0-rneb) * gabs * sabs * (ray1(jiv) + 
     .             ktest*refz(2,jiv)*tra1(jiv)*tra2(jiv) /
     .             (1.d0-ray2(jiv)*refz(2,jiv))) + 
     .                                    rneb * re1
      tr(2,jiv)  =((1.d0-rneb) * gabs * tra1(jiv) / 
     .             (1.-ktest*ray2(jiv)*refz(2,jiv))) + 
     .                                    rneb * te1
c #TR refz(2,niv)=(1.d0-rneb)* ray1(jiv) * sabs * gabs + rneb * re1
c #TR tr(2,jiv)  =(1.d0-rneb)* tra1(jiv) * gabs + rneb * te1
C +
      refz(1,niv)=(1.d0-rneb) * gabs * sabs * (ray1(jiv) + 
     .                   refz(1,jiv)*tra1(jiv)*tra2(jiv) /
     .             (1.d0-ray2(jiv)*refz(1,jiv))) + 
     .                                    rneb * re2
      tr(1,jiv)  =((1.d0-rneb) * gabs * tra1(jiv) / 
     .             (1.-      ray2(jiv)*refz(1,jiv))) + 
     .                                    rneb * te2
C +
  100 continue
C +
C +
C +--Output
C +  ------
C +
      if (iwri.eq.1) then
       write(6,61) n,iab
 61    format (3x,'n =',i6,3x,'iab =',i6,/)
       write(6,62)
 62    format (9x,'refz1',10x,'refz2',12x,'tr1',13x,'tr2',/)
       do 6 niv=2,np1
       jiv=niv-1
       write(6,52) niv,refz(1,niv),refz(2,niv),tr(1,jiv),tr(2,jiv)
 6     continue
       write(6,55)
      end if
C +
      do 60 kiv=1,2
C +
      n=n+1
      if (iwri.eq.1) then
       write(6,63) kiv,n
 63    format (/,' kiv =',i6,6x,'n =',i6/)
       write(6,64)
 64    format (5x,'    pression       rj(down)       rk(up)')
      end if
C +
      rj(n,np1)=1.d0
      rk(n,np1)=refz(kiv,np1)
      do 65 niv=1,mzir1
      kk=np1-niv
      lp=kk+1
      rj(n,kk)=rj(n,lp)*tr(kiv,kk)
      re11=rj(n,kk)
      rk(n,kk)=re11*refz(kiv,kk)
 65   continue
C +
      if (iwri.eq.1) then
       do 66 niv=1,mzir1
       kk=np1-niv
       write(6,52) kk,pnrm(kk), rj(n,kk),rk(n,kk)
 66    continue
      end if
C +
 60   continue
C +
 90   continue
C + *******************************************************************
C +--Now the fluxes up(rk) and down(rj) are calculated
C +  without gaz absorption : n=1,2
C +  with    H2O absorption : n=3,4
C +  with    CO2 absorption : n=5,6
C +  n=1,3,5 : underlying reflectivity = 0
C +    2,4,6 :                         # 0
C + *******************************************************************
C +
      do 130 niv=1,np1
      do 131 jiv=1,5,2
      jp=jiv+1
      rj(jiv,niv)=rj(jiv,niv)-rj(jp,niv)
      rk(jiv,niv)=rk(jiv,niv)-rk(jp,niv)
      rj(jiv,niv)=max(rj(jiv,niv),e10)
      rk(jiv,niv)=max(rk(jiv,niv),e10)
  131 continue
  130 continue
      do 140 niv=1,np1
      do 141 jiv=2,6,2
      rj(jiv,niv)=max(rj(jiv,niv),e10)
      rk(jiv,niv)=max(rk(jiv,niv),e10)
  141 continue
  140 continue
C +
      if (iwri.eq.1) then
       write(6,1013)
 1013  format (/,1x,'*** 1: sans reflexion de la couche sous jacente')
       write(6,1014)
 1014  format (  1x,'*** 2: avec reflexion de la couche sous jacente',/)
       write(6,166)
 166   format (31x,'u.eff down',25x,'*',30x,'u.eff up')
       write(6,164)
 164   format (1x,65('-'),'*',64('-'))
       write(6,165)
 165   format(66x,'*')
       write(6,162)
 162   format (9x,'h2o:1',11x,'h2o:2',11x,'co2:1',11x,'co2:2',
     .  4x,'*',8x,'h2o:1',11x,'h2o:2',11x,'co2:1',11x,'co2:2')
       write(6,165)
      end if
C +
C + *******************************************************************
C +--Calculation of the equivalent amount of absorber
C +  (inverse Laplace transform)
C +     ueff= -ln(f(kiv)/f(0))/kiv
C +  computation of the corresponding transmission Functions of H2O
C +              and CO2+O2
C +  computation for upward and downward fluxes
C + *******************************************************************
C +
      do 150 niv=1,np1
      kiv=1
      do 160 jiv=1,2
      rki=aki(jiv)
      do 161 n=1,2
C +- Effective amount
      weff=log(max(unun,rj(n,niv)/rj(n+2*jiv,niv)))/rki
C +- Calculation of the transmission
C +
C +   *********
c #MR call tttt(jiv,weff,r1)
C +   *********
C +
C + ----------
      if ((jiv.eq.1).and.(ih1 .ne.1)) r1=1.0d0
      if ((jiv.eq.2).and.(ico2.ne.1)) r1=1.0d0
C + ----------
      rl(kiv)=r1
      ruef(kiv)=weff
      weff=log(max(unun,rk(n,niv)/rk(n+2*jiv,niv)))/rki
C +
C +   *********
c #MR call tttt(jiv,weff,r1)
C +   *********
C +
C + ----------
      if ((jiv.eq.1).and.(ih1 .ne.1)) r1=1.0d0
      if ((jiv.eq.2).and.(ico2.ne.1)) r1=1.0d0
C + ----------
      rl(kiv+4)=r1
      ruef(kiv+4)=weff
      kiv=kiv+1
 161  continue
 160  continue
C +
      if (iwri.eq.1) write(6,163)niv,(ruef(jiv),jiv=1,8)
 163  format(1h ,i4,e12.4,3e16.4,1x,'*',4e16.4)
C +
C +
C +--Upward and Downward Fluxes with H2O and CO2 Absorption
C +  ------------------------------------------------------
C +
      FSOd(niv)=rj(1,niv)*rl(1)*rl(3)+rj(2,niv)*rl(2)*rl(4)
      FSOm(niv)=rk(1,niv)*rl(5)*rl(7)+rk(2,niv)*rl(6)*rl(8)
C +
 150  continue
C +
      if (iwri.eq.1) then
       write(6,2014)
 2014  format (//,9x,  'fSod(h2o,co2)',5x,'fSom(h2o,co2)')
       do 2015 niv=1,np1
       write(6,2013)niv,FSOd(niv),         FSOm(niv)
 2013  format (i4,5x,e13.7,5x,e13.7)
 2015  continue
      end if
C +
C +--Absorption O3
C +  -------------
      iab=3
      do 170 niv=1,np1
      weff=ud(3,niv)
C +
C +   *********
c #MR call tttt(iab,weff,r1)
C +   *********
C +
C + ----------
      if (io3.ne.1) r1=1.0d0
C + ----------
      FSOd(niv)=r1*FSOd(niv)
      weff=um(niv)
C +
C +   *********
c #MR call tttt(iab,weff,r1)
C +   *********
C +
C + ----------
      if (io3.ne.1) r1=1.0d0
C + ----------
      FSOm(niv)=r1*FSOm(niv)
  170 continue
C +
C +
C +--NET FLUXES
C +  ==========
C +
      do 180 niv=1,np1
      FSOn(niv)=FSOd(niv)-FSOm(niv)
  180 continue
C +
C +
C +--Output => MAR
C +  -------------
C +
      fupdwn=100.d0*(FSOm(np1)/FSOd(np1))
      if (iwri.eq.1) then
       write(6,185) fupdwn
 185   format(' albedo: ',e13.7)
       write(6,192)
 192   format(/,3x,'niv',5x,'pnrm(niv+1)',6x,'pnrm(niv)',11x,'f up',
     *          9x,'f down',10x,'f net',10x,'dFSOn')
       write(6,195) np1,FSOm(np1),FSOd(np1),FSOn(np1)
      end if
C +
      dFSOn(np1)=0.d0
      do 190 niv=1,mzir1
      kk=np1-niv
      lp=kk+1
      r2=pnrm(lp)
      r3=pnrm(kk)
      dFSOn(kk)=FSOn(lp)-FSOn(kk)
C +
      if (iwri.eq.1) then
       write(6,195) kk,r2,r3,FSOm(kk),FSOd(kk),
     .                      FSOn(kk),dFSOn(kk)
 195   format(1h ,i6,6(2x,e13.7))
      end if
C +
 190  continue
C +
      return
      end
      subroutine fluxae(asae,omae,taae,rae1,tae1,rmu,rae2,tae2)             
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (solarn)                                   15-09-2001  MAR |
C |   SubRoutine fluxae computes Reflectivity and Transmissivity for a     |
C |    isolated layer with and without reflectivity of underlying layers   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |   Delta-Eddington approximation                                        |
C |                                                                        |
C |   asae: asymmetry factor                                               |
C |   taae: optical thickness                                              |
C |   omae: reflectivity of underlying layer                               |
C |   gp,wcp,top : equivalent optical parameters                           |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      real    asae  ,omae  ,taae  ,rae1  ,tae1  ,rmu   ,rae2   ,tae2
C +
C +
C +--Local  Variables
C +  ================
C +
      real    ff    ,gp    ,top   ,wcp   ,dt    ,x1    ,wm    ,rm2   
      real    rk    ,x2    ,rp    ,alpha ,beta  ,exmuo ,exkp  ,exkm  
      real    xp2p  ,xm2p  ,ap2b  ,am2b  
      real    a11   ,a12   ,a13   ,a22   ,a21   ,a23   ,d
      real    c1    ,c2    ,ri0   ,ri1   ,ri0d  ,ri1d  ,rmue
C +
C +
C +
C +
C +
      omae=min(omae,0.99999)
      ff=asae*asae
      gp=asae/(1.+asae)
      top=(1.-omae*ff)*taae
      wcp=(1.-ff)*omae/(1.-omae*ff)
      dt=2./3.
      x1=1.-wcp*gp
      wm=1.-wcp
C +...direct incident radiation              
C +   without reflection of underlying layer
      rm2=rmu*rmu
      rk=sqrt(3.*wm*x1)
      x2=4.*(1.-rk*rk*rm2)
      rp=sqrt(3.*wm/x1)
      alpha=3.*wcp*rm2*(1.+gp*wm)/x2
      beta=3.*wcp*rmu*(1.+3.*gp*rm2*wm)/x2
      exmuo=exp(-top/rmu)
      exkp=exp(rk*top)
      exkm=1./exkp
      xp2p=1.+dt*rp
      xm2p=1.-dt*rp
      ap2b=alpha+dt*beta
      am2b=alpha-dt*beta
      a11=xp2p
      a12=xm2p
      a13=ap2b
      a22=xp2p*exkp
      a21=xm2p*exkm
      a23=am2b*exmuo
      d=a11*a22-a21*a12
      c1=(a22*a13-a12*a23)/d
      c2=(a11*a23-a21*a13)/d
      ri0=c1+c2-alpha
      ri1=rp*(c1-c2)-beta
      rae1=(ri0-dt*ri1)/rmu
      ri0d=c1*exkm+c2*exkp-alpha*exmuo
      ri1d=rp*(c1*exkm-c2*exkp)-beta*exmuo
      tae1=exmuo+(ri0d+dt*ri1d)/rmu
C +...diffuse incident radiation              
C +   without reflection of underlying layer
      rmue=0.6024
      rm2=rmue*rmue
      rk=sqrt(3.*wm*x1)
      x2=4.*(1.-rk*rk*rm2)
      rp=sqrt(3.*wm/x1)
      alpha=3.*wcp*rm2*(1.+gp*wm)/x2
      beta=3.*wcp*rmue*(1.+3.*gp*rm2*wm)/x2
      exmuo=exp(-top/rmue)
      exkp=exp(rk*top)
      exkm=1./exkp
      xp2p=1.+dt*rp
      xm2p=1.-dt*rp
      ap2b=alpha+dt*beta
      am2b=alpha-dt*beta
      a11=xp2p
      a12=xm2p
      a13=ap2b
      a22=xp2p*exkp
      a21=xm2p*exkm
      a23=am2b*exmuo
      d=a11*a22-a21*a12
      c1=(a22*a13-a12*a23)/d
      c2=(a11*a23-a21*a13)/d
      ri0=c1+c2-alpha
      ri1=rp*(c1-c2)-beta
      rae2=(ri0-dt*ri1)/rmue
      ri0d=c1*exkm+c2*exkp-alpha*exmuo
      ri1d=rp*(c1*exkm-c2*exkp)-beta*exmuo
      tae2=exmuo+(ri0d+dt*ri1d)/rmue
C +
      return
      end
      subroutine flux2(ros,asf,wc1,to1,re1,te1,rmu,re2,te2)
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (solarn)                                   15-09-2001  MAR |
C |   SubRoutine flux2  computes Reflectivity and Transmissivity for a     |
C |    isolated layer with and without reflectivity of underlying layers   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |   Delta-Eddington approximation                                        |
C |                                                                        |
C |   asf : asymmetry factor                                               |
C |   to  : optical thickness                                              |
C |   ros : reflectivity of underlying layer                               |
C |   gp,wcp,top : equivalent optical parameters                           |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      real     ros   ,asf   ,wc1   ,to1   
      real     re1   ,te1   ,rmu   ,re2   ,te2
C +
C +
C +--Local  Variables
C +  ================
C +
      real     ff    ,gp    ,top   ,wcp   ,dt    ,x1    ,wm    ,rm2
      real     rk    ,x2    ,rp    ,alpha ,beta  ,exmuo ,exkp  ,exkm
      real     xp2p  ,xm2p  ,ap2b  ,am2b
      real     a11   ,a12   ,a13   ,a21   ,a22   ,a23   ,d
      real     c1    ,c2    ,ri0   ,ri1   ,ri0d  ,ri1d
C +
C +
C +
C +
C +
      ff=asf*asf
      gp=asf/(1.+asf)
      top=(1.-wc1*ff)*to1
      wcp=(1.-ff)*wc1/(1.-wc1*ff)
      dt=2./3.
      x1=1.-wcp*gp
      wm=1.-wcp
      rm2=rmu*rmu
      rk=sqrt(3.*wm*x1)
      x2=4.*(1.-rk*rk*rm2)
      rp=sqrt(3.*wm/x1)
      alpha=3.*wcp*rm2*(1.+gp*wm)/x2
      beta=3.*wcp*rmu*(1.+3.*gp*rm2*wm)/x2
      exmuo=exp(-top/rmu)
      exkp=exp(rk*top)
      exkm=1./exkp
      xp2p=1.+dt*rp
      xm2p=1.-dt*rp
      ap2b=alpha+dt*beta
      am2b=alpha-dt*beta
C +...without reflection of underlying layer
      a11=xp2p
      a12=xm2p
      a13=ap2b
      a22=xp2p*exkp
      a21=xm2p*exkm
      a23=am2b*exmuo
      d=a11*a22-a21*a12
      c1=(a22*a13-a12*a23)/d
      c2=(a11*a23-a21*a13)/d
      ri0=c1+c2-alpha
      ri1=rp*(c1-c2)-beta
      re1=(ri0-dt*ri1)/rmu
      ri0d=c1*exkm+c2*exkp-alpha*exmuo
      ri1d=rp*(c1*exkm-c2*exkp)-beta*exmuo
      te1=exmuo+(ri0d+dt*ri1d)/rmu
C +...with reflection of underlying layer
      a21=a21-ros*xp2p*exkm
      a22=a22-ros*xm2p*exkp
      a23=a23-ros*exmuo*(ap2b-rmu)
      d=a11*a22-a21*a12
      c1=(a22*a13-a12*a23)/d
      c2=(a11*a23-a21*a13)/d
      ri0=c1+c2-alpha
      ri1=rp*(c1-c2)-beta
      re2=(ri0-dt*ri1)/rmu
      ri0d=c1*exkm+c2*exkp-alpha*exmuo
      ri1d=rp*(c1*exkm-c2*exkp)-beta*exmuo
      te2=exmuo+(ri0d+dt*ri1d)/rmu
C +
      return
      end
      subroutine tttt(j,w,r1)
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (solarn)                                   15-09-2001  MAR |
C |   SubRoutine tttt: computation of gaz transmission by pade approximants|
C |   Corrected to prevent (under,over)flow                                |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      integer  j
      real     w     ,r1
C +
      real            uinf(3),aap(3,6),bbp(3,6)
      common /eti200/ uinf   ,aap     ,bbp
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  i     ,k
      real     r2    ,r1dr2
C +
C +
C +
C +
C +
        r1=aap(j,6)
        r2=bbp(j,6)
      DO i=1,5
         k=6-i
        r1=r1*w+aap(j,k)
      END DO
      DO i=1,5
         k=6-i
        r2=r2*w+bbp(j,k)
      END DO
C +
        r1dr2 = log(r1) - log(r2)
        r1dr2 = max(r1dr2,argmin)
        r1dr2 = min(r1dr2,argmax)
        r1dr2 = exp(r1dr2)
        r1=(r1dr2)*(1-uinf(j))+uinf(j)
C +...  r1=(r1/r2)*(1-uinf(j))+uinf(j)
C +
      return
      end
      subroutine iniso (facco2)
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (solarn)                                   15-09-2001  MAR |
C |   SubRoutine iniso  includes Solar    Radiation Data                   |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
C +
      real     facco2
C +
      real            uinf(3),aap(3,6),bbp(3,6)
      common /eti200/ uinf   ,aap     ,bbp
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  i     ,j
C +
C +
C +--INPUT
C +  =====
C +
      IF (facco2.ne.2.d0)                                         THEN
C +
        open (unit=7,status='old',file='MARs01.dat')
        rewind     7
C +
        read (7,1000) uinf(1),uinf(2),uinf(3)
        read (7,1001) ((aap(i,j),j=1,6),i=1,3)
        read (7,1001) ((bbp(i,j),j=1,6),i=1,3)
 1000   format (3(f6.3))
 1001   format (e15.9)
C +
        close(unit=7)
C +
      ELSE
C +
        open (unit=8,status='old',file='MARs02.dat')
        rewind     8
C +
        read (8,1000) uinf(1),uinf(2),uinf(3)
        read (8,1001) ((aap(i,j),j=1,6),i=1,3)
        read (8,1001) ((bbp(i,j),j=1,6),i=1,3)
C +
        close(unit=8)
C +
      END IF
C +
      write(21,2000)
 2000 format (///,'    end of the solar radiative data lecture',//)
C +
      return
      end
      subroutine PHYrad_IR (dt0,stefan,em0,ppmco2,nl,iww,iww2)
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (infra)                                    24-09-2001  MAR |
C |   SubRoutine PHYrad_IR computes IR Fluxes (Morcrette, Thesis, 1984)    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   OUTPUT:   FIRm(k) : Upward   IR   Radiative Heat Flux                |
C |   ^^^^^^^   FIRd(k) : Downward IR   Radiative Heat Flux                |
C |             FIRn(k) : Net      IR   Radiative Heat Flux                |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARdim.inc'
C +
      include 'MAR_RA.inc'
      include 'MAR_IR.inc'
C +
      real     dt0   ,stefan,em0   ,ppmco2
      integer  nl    ,iww          ,iww2
C +
      integer   mzir3
      parameter(mzir3=mzir*3+1)
C +
      real           xp(2,6,4),tstand
      integer                         nint
      common   /ir4/ xp       ,tstand,nint
      real           rt1(2),wg1(2)
      integer                      ng1
      common   /ir5/ rt1   ,wg1   ,ng1
      real           at(10),bt(6),o1h,o2h
      common   /ir6/ at    ,bt   ,o1h,o2h
      real           ga(16,6),gb(16,6)
      integer                          npad(16)
      common /padel/ ga      ,gb      ,npad
C +
C +
C +--Local  Variables
C +  ================
C +
      real    o12h
      integer nc    ,ng1p1 ,nglp1 ,ngl   
C +
C +
C +--Output Variables
C +  ----------------
C +
      real      z(mzir)
      real     dz(mzir) 
      real     b(4,mzir),bint(mzir)
      real     f(2,mzir),tave(mzir)
      real     indcl(mzir)
      real     cntrb(mzir,mzir),fup(mzir,mzir),fdn(mzir,mzir)
      real     u(8,mzir3),v(10,mzir3),w(4,mzir3),xt(mzir3)
C +
      real     bsol(4),btop(4)
C +
      real        uu(8)
      real        uh    ,uc    ,uo    ,uw    ,uho   ,uf    ,uw63  ,uw15
      equivalence(uu(1),uh),(uu(2),uc),(uu(3),uo),(uu(4),uw),(uu(5),uho)
     .          ,(uu(6),uf),(uu(7),uw63),(uu(8),uw15)
      real        tt(8)
      real        th    ,tc    ,to    ,tw    ,t15   ,tf    ,tw63  ,tw15
      equivalence(tt(1),th),(tt(2),tc),(tt(3),to),(tt(4),tw),(tt(5),t15)
     .          ,(tt(6),tf),(tt(7),tw63),(tt(8),tw15)
C +
      real     bsolin,co2   ,psol  ,q     ,zp    ,zm    ,zm2   ,xxu   
      real     u6    ,fppw  ,tavic ,factt ,fact63,fact15,tx    ,tx2
      real     xz    ,xr    ,coef  ,xo    ,xxo   ,upm   ,xxc   ,xq
      real     psih  ,epsih ,ps15  ,eps15 ,psic  ,epsic
      real     pshw  ,epshw ,phio  ,ephio ,ti    ,res
      real     xmont ,xdesc ,xadjd ,xadjm ,xdg   ,wtr   ,dzxdg 
      real     th1   ,tc1   ,to1   ,tw1   ,t151  ,tf1   ,tw631 ,tw151
      real     th2   ,tc2   ,to2   ,tw2   ,t152  ,tf2   ,tw632 ,tw152
      real     ww    ,xmg   ,dzxmg ,cnsol ,cntop ,fd    ,fd1   ,bgnd  
      real     fm    ,outgir,firsol,fupsol,stsol4,absatm
  
      integer  niv   ,i     ,j     ,mmi   ,ncloud,ipp1  ,jpn   
      integer  k     ,kp1   ,l     ,ic    ,icp1  ,int   ,jx
      integer  ll    ,ig    ,jpig  ,ind1  ,ind2  ,in    ,id
      integer  id1   ,ig1   ,id2   ,k2    ,jpp1  ,imm1  ,im2
      integer  iu1   ,iu2   ,im
C +
      nc=nl-1
      ng1p1=ng1+1
      nglp1=nc*ng1p1+1
      ngl=nglp1-1
      o12h=o1h*o2h
      if (iww2.eq.1) write (21,210) (ecldIR(niv),niv=1,nc)
 210  format (/,10x,'ecldIR(niv)',/,(5x,e12.5))
C +
      do 100 i=1,nglp1
      do 100 j=1,nint
      w(j,i) = 0.0d0
 100  continue
C +
C +--Ozone modifie 
C +  ~~~~~~~~~~~~~
      do 101 i=1,nl
      bint(i) =0.00d0
      do 101 j=1,nl
      fup(j,i)=0.0d0
      fdn(j,i)=0.0d0
      FIRn (i)=0.0d0
101   continue
      bsolin=0.0d0
C +
C +--ppm en ppm   mco2= 44 divise par mair= 28.97
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      co2    = 1.519d-06*ppmco2
      mmi    = 0
      ncloud = 0
      do 102 i=1,nc
      tave(i)= 0.5d0*(tairRA(i)+tairRA(i+1))
      if (ecldIR(i).eq.0.d0)go to 102
       ncloud=ncloud+1
       indcl(ncloud)=i
102   continue
      if (ncloud.ne.0)      mmi=indcl(ncloud)
      psol   = pmb_RA(1)
C +
      do 103 i=1,nl
      z(i)   =-log(pmb_RA(i)/psol)
      q      = qvapRA(i)
      w(1,i) = q
 103  continue
c #WR if (iww2.eq.1) write (21,211) (w(1,i),wo3_RA(i),tairRA(i),i=1,nl)
c #WR if (iww2.eq.1) write (21,212) (tave(i),i=1,nc)
 211  format (/,10x,'  w  ',10x,'  o3 ',10x,'  t  ',
     .        /,(4x,e12.4,5x,e12.4,5x,e12.4))
 212  format (/,10x,'tave',/,(5x,e14.6))
C +
      do 105 i=1,nl
      ipp1  = i+1
      j     =(i-1)*ng1p1+1
      u(1,j)= wo3_RA(i)
      u(7,j)= pmb_RA(i)/psol
      if(i.eq.nl) go to 105
       zp   =(z(i)+z(ipp1))/2.0d0
       zm   =(z(ipp1)-z(i))/2.0d0
       dz(i)= zm
       zm2  = 2.0d0*zm
       do 104 ig1=1,ng1
       j =j+1
       xz=rt1(ig1)*zm+zp
       u(7,j)=exp(-xz)
       xt(j) =(tairRA(ipp1)-tairRA(i))/zm2
       xr    =(xz-z(i))/zm2
       u(1,j)=wo3_RA(i)+xr*(wo3_RA(ipp1)-wo3_RA(i))
 104   continue
 105  continue
      coef=1033.2275d0
C +...coef:101325/9.80665/10
C +
      do 106 i=1,ngl
      ipp1=i+1
      xo  =(u(1,i)-u(1,ipp1))
      xxo =xo/466.968d0
C +...        466.668d0 = 22400/48
C +  
      upm   =(u(7,i)+u(7,ipp1))/2.0d0
      u(3,i)=(u(7,i)-u(7,ipp1))*coef
      u(5,i)=upm
      u(1,i)=xxo
      u(2,i)=xxo*upm
      xxc   =co2*u(3,i)
      u(4,i)=xxc*upm
 106  continue
C +
      do 108 i=1,nc
      ipp1=i+1
      xq=(w(1,i)+w(1,ipp1))/2.0d0
      j=(i-1)*ng1p1+1
      jpn=j+ng1
      do 107 k=j,jpn
      kp1=k+1
      xxu=xq*u(3,k)
      u6=xxu*u(5,k)
      fppw= 1.6078d0 *xq/(1.0d0+0.608d0*xq)
C +...      1.6078d0 = 28.9647 / 18.0153
C +
      u(6,k)=u6
      u(7,k)=u6*fppw
c #WR if (iww2.eq.1) write(21,213)u(2,k),u(4,k),u(6,k),u(7,k)
 213  format (10e12.6)
 107  continue
 108  continue
      do 109 i=1,10
      v(i,nglp1)=0.0d0
 109  continue
C +
C +--Introduction de l'Effet de Temperature sur les Quantites d'Absorbant
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      do 113 i=1,nc
      j      =(i-1)*ng1p1+1
      jpn    = j+ng1
      l      = nl-i
      tavic  = tave(l)
      do 112 k=j,jpn
      ic     = nglp1-k
      icp1   = ic+1
      factt  = exp(6.08d0*(296.0d0/tavic   -1.0d0))
      fact63 = 1.d0
      fact15 = factt
      v(7,ic)= v(7,icp1)+u(7,ic)*factt*1.66d0
      v(2,ic)= v(2,icp1)+u(7,ic)*fact63*1.66d0
      v(3,ic)= v(3,icp1)+u(7,ic)*fact15*1.66d0
      tx     = tavic-250.0d0
      tx2    = tx*tx
      psih   = at(1)*tx+at(2)*tx2
      epsih  = exp(psih)
      ps15   = at(3)*tx+at(4)*tx2
      eps15  = exp(ps15)
      psic   = at(5)*tx+at(6)*tx2
      epsic  = exp(psic)
      pshw   = at(7)*tx+at(8)*tx2
      epshw  = exp(pshw)
      phio   = at(9)*tx+at(10)*tx2
      ephio  = exp(phio)
      v(1,ic)=v(1,icp1)+u(1,ic)*ephio*1.66d0
      v(4,ic)=v(4,icp1)+u(4,ic)*epsic*1.66d0
      v(6,ic)=v(6,icp1)+u(6,ic)*epsih*1.66d0
      v(9,ic)=v(9,icp1)+u(6,ic)*eps15*1.66d0
      v(10,ic)=v(10,icp1)+u(6,ic)*epshw*1.66d0
c #WR if (iww2.ne.1) goto 111
c #WR write(21,214)ic,v(1,ic),v(4,ic),v(6,ic),v(7,ic),v(9,ic),v(10,ic)
 214  format(i3,10e12.6)
 111  continue
 112  continue
 113  continue
C +
C +
C +--Calcul des Fonctions de Planck b(t) et db/dt (Polynome Degre 5)
C +  ---------------------------------------------------------------
C +
      do 129 int=1,nint
      do 122 i=1,nl
      ti=(tairRA(i)-tstand)/tstand
      res=xp(1,6,int)
      do 121 ll=1,5
      l=6-ll
      res=res*ti+xp(1,l,int)
 121  continue
      b(int,i)=res
      bint(i)=bint(i)+res
 122  continue
      bsol(int)=b(int,1)
      if (dt0.eq.0.0d0) go to 124
      ti=(tairRA(1)+dt0-tstand)/tstand
      res=xp(1,6,int)
      do 123 ll=1,5
      l=6-ll
      res=res*ti+xp(1,l,int)
 123  continue
      bsol(int)=res
 124  btop(int)=b(int,nl)
      bsolin=bsolin+bsol(int)
      do 126 i=1,nc
      j=(i-1)*ng1p1+1
      ti=(tave(i)-tstand)/tstand
      res=xp(2,6,int)
      do 125 ll=1,5
      l=6-ll
      res=res*ti+xp(2,l,int)
 125  continue
      do 126 ig=1,ng1
      jpig=j+ig
      w(int,jpig)=res
 126  continue
c #WR if (iww2.eq.1) write(21,213)(b(int,l),l=1,nl)
c #WR if (iww2.eq.1) write(21,213)(w(int,l),l=1,nglp1)
 129  continue
c #WR if (iww2.eq.1) write(21,213)(bsol(int),int=1,nint)
c #WR if (iww2.eq.1) write(21,213)(btop(int),int=1,nint)
      ind1=0
      ind2=1
C +
C +
C +--Integration verticale
C +  ---------------------
C +  se fait par trapeze sauf 
C +    pour les couches adjacentes au niveau de calcul 
C +    ou on utilise une quadrature de gauss a ng1 points
C +
      do 151 i=1,nl
      in    =(i-1)*ng1p1+1
      ipp1  = i+1
      xmont = 0.0d0
      xdesc = 0.0d0
      xadjd = 0.0d0
      xadjm = 0.0d0
C +
C +--Flux Descendants
C +  ~~~~~~~~~~~~~~~~
      if(i.eq.nl) go to 141
      do 135 j=i,nc
      jx=(j-1)*ng1p1+1
      xdg=0.d0
      if (j.ne.i) go to 131
C +
      do 130 ig=1,ng1
      id=jx+ig
      uh=v(6,in)-v(6,id)
      uho=v(9,in)-v(9,id)
      uf=v(10,in)-v(10,id)
      uc=v(4,in)-v(4,id)
      uo=v(1,in)-v(1,id)
      uw=v(7,in)-v(7,id)
      uw63=v(2,in)-v(2,id)
      uw15=v(3,in)-v(3,id)
C +
C +   ***********
c #MR call hornel( uu, tt, ind1)
C +   ***********
C +
C +--140 / 490
C +  ~~~~~~~~~
      wtr=w(1,id)*th*tw63+w(2,id)*t15*tc*tw15+tw*tf*(w(3,id)+w(4,id)*to)
      xdg=xdg+wtr*xt(id)*wg1(ig)
 130  continue
      dzxdg=dz(j)*xdg
      xadjd=dzxdg
      go to 134
 131  continue
      if (j.ne.ipp1) go to 132
      id1=jx
      uh=v(6,in)-v(6,id1)
      uho=v(9,in)-v(9,id1)
      uf=v(10,in)-v(10,id1)
      uc=v(4,in)-v(4,id1)
      uo=v(1,in)-v(1,id1)
      uw=v(7,in)-v(7,id1)
      uw63=v(2,in)-v(2,id1)
      uw15=v(3,in)-v(3,id1)
C +
C +   ***********
c #MR call hornel( uu, tt, ind1)
C +   ***********
C +
      th1=th
      tc1=tc
      to1=to
      tw1=tw
      t151=t15
      tf1=tf
      tw631=tw63
      tw151=tw15
 132  continue
      id2=jx+ng1p1
      uh=v(6,in)-v(6,id2)
      uho=v(9,in)-v(9,id2)
      uf=v(10,in)-v(10,id2)
      uc=v(4,in)-v(4,id2)
      uo=v(1,in)-v(1,id2)
      uw=v(7,in)-v(7,id2)
      uw63=v(2,in)-v(2,id2)
      uw15=v(3,in)-v(3,id2)
C +
C +   ***********
c #MR call hornel( uu, tt, ind1)
C +   ***********
C +
      th2=th
      tc2=tc
      to2=to
      tw2=tw
      t152=t15
      tf2=tf
      tw632=tw63
      tw152=tw15
      th=(th1+th2)*0.5d0
      tc=(tc1+tc2)*0.5d0
      to=(to1+to2)*0.5d0
      tw=(tw1+tw2)*0.5d0
      t15=(t151+t152)*0.5d0
      tf=(tf1+tf2)*0.5d0
      tw63=(tw631+tw632)*0.5d0
      tw15=(tw151+tw152)*0.5d0
      k2=id2-1
c #WR if (iww2.ne.1) goto 133
c #WR write(21,215)i,th,tc,to,tw,t15,tf,tw63,tw15,(w(l,k2),l=1,3),
c #WR.               xt(k2),dz(j)
 133  continue
 215  format(1x,i2,8f7.4,5e12.6)
      ww=w(1,k2)*th*tw63+w(2,k2)*tc*t15*tw15+tw*tf*(w(3,k2)+w(4,k2)*to)
      xdg=ww*xt(k2)*2.0d0
      dzxdg=dz(j)*xdg
      xdesc=xdesc+dzxdg
      th1=th2
      tc1=tc2
      to1=to2
      tw1=tw2
      t151=t152
      tf1=tf2
      tw631=tw632
      tw151=tw152
 134  continue
      jpp1=j+1
      cntrb(i,jpp1)=dzxdg
 135  continue
C +
C +--Flux Montants
C +  ~~~~~~~~~~~~~
 141  continue
      if (i.eq.1) go to 147
      imm1=i-1
      im2=i-2
      do 146 l=1,imm1
      j=i-l
      jx=(j-1)*ng1p1+1
      xmg=0.d0
      if(j.ne.imm1) go to 143
      do 142 ig=1,ng1
      im=jx+ig
      uh=v(6,im)-v(6,in)
      uho=v(9,im)-v(9,in)
      uf=v(10,im)-v(10,in)
      uc=v(4,im)-v(4,in)
      uo=v(1,im)-v(1,in)
      uw=v(7,im)-v(7,in)
      uw63=v(2,im)-v(2,in)
      uw15=v(3,im)-v(3,in)
C +
C +   ***********
c #MR call hornel( uu, tt, ind1)
C +   ***********
C +
      wtr=w(1,im)*th*tw63+w(2,im)*t15*tc*tw15+tw*tf*(w(3,im)+w(4,im)*to)
      xmg=xmg+wtr*xt(im)*wg1(ig)
 142  continue
      dzxmg=dz(j)*xmg
      xadjm=dzxmg
      go to 145 
 143  continue
      if(j.ne.im2) go to 144
      iu1=jx+ng1p1
      uh=v(6,iu1)-v(6,in)
      uho=v(9,iu1)-v(9,in)
      uf=v(10,iu1)-v(10,in)
      uc=v(4,iu1)-v(4,in)
      uo=v(1,iu1)-v(1,in)
      uw=v(7,iu1)-v(7,in)
      uw63=v(2,iu1)-v(2,in)
      uw15=v(3,iu1)-v(3,in)
C +
C +   ***********
c #MR call hornel( uu, tt, ind1)
C +   ***********
C +
      th1=th
      tc1=tc
      to1=to
      tw1=tw
      t151=t15
      tf1=tf
      tw631=tw63
      tw151=tw15
 144  continue
      iu2=jx
      uh=v(6,iu2)-v(6,in)
      uho=v(9,iu2)-v(9,in)
      uf=v(10,iu2)-v(10,in)
      uc=v(4,iu2)-v(4,in)
      uo=v(1,iu2)-v(1,in)
      uw=v(7,iu2)-v(7,in)
      uw63=v(2,iu2)-v(2,in)
      uw15=v(3,iu2)-v(3,in)
C +
C +   ***********
c #MR call hornel( uu, tt, ind1)
C +   ***********
C +
      th2=th
      tc2=tc
      to2=to
      tw2=tw
      t152=t15
      tf2=tf
      tw632=tw63
      tw152=tw15
      th=(th1+th2)*0.5d0
      tc=(tc1+tc2)*0.5d0
      to=(to1+to2)*0.5d0
      tw=(tw1+tw2)*0.5d0
      t15=(t151+t152)*0.5d0
      tf=(tf1+tf2)*0.5d0
      tw63=(tw631+tw632)*0.5d0
      tw15=(tw151+tw152)*0.5d0
      k2=jx+1
      ww=w(1,k2)*th*tw63+w(2,k2)*tc*t15*tw15+tw*tf*(w(3,k2)+w(4,k2)*to)
      xmg=ww*xt(k2)*2.0d0
      dzxmg=dz(j)*xmg
      xmont=xmont+dzxmg
      th1=th2
      tc1=tc2
      to1=to2
      tw1=tw2
      t151=t152
      tf1=tf2
      tw631=tw632
      tw151=tw152
 145  continue
      cntrb(i,j)=dzxmg
 146  continue
 147  continue
C +
C +--Contribution du Sommet de l'Atmosphere 
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      cnsol=0.0d0
      cntop=btop(1)+btop(2)+btop(3)+btop(4)
      if(i.eq.nl) go to 148
      uh=v(6,in)
      uho=v(9,in)
      uf=v(10,in)
      uc=v(4,in)
      uo=v(1,in)
      uw=v(7,in)
      uw63=v(2,in)
      uw15=v(3,in)
C +
C +   ***********
c #MR call hornel( uu, tt, ind2)
C +   ***********
C +
      cntop=btop(1)*th*tw63
     .     +btop(2)*tc*t15*tw15+tw*tf*(btop(3)+btop(4)*to)
 148  continue
      fd=cntop-bint(i)-xdesc-xadjd
      if(i.eq.1) fd1=-fd
C +
C +--Contribution de la Surface
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~
      bgnd=bsolin*em0+(1.0d0-em0)*fd1-bint(1)
      if(bgnd.eq.0.d0) go to 149
      uh=v(6,1)-v(6,in)
      uho=v(9,1)-v(9,in)
      uf=v(10,1)-v(10,in)
      uc=v(4,1)-v(4,in)
      uo=v(1,1)-v(1,in)
      uw=v(7,1)-v(7,in)
      uw63=v(2,1)-v(2,in)
      uw15=v(3,1)-v(3,in)
C +
C +   ***********
c #MR call hornel( uu, tt, ind2)
C +   ***********
C +
      cnsol=bsol(1)*th*tw63
     .     +bsol(2)*tc*t15*tw15+tw*tf*(bsol(3)+bsol(4)*to)
      cnsol=cnsol*bgnd/bsolin
 149  continue
      fm=cnsol+bint(i)-xmont-xadjm
      fup(1,i)=fm
      fdn(1,i)=fd
c #WR if (iww2.ne.1) goto 150
c #WR write(21,214)i,cntop,xadjd,xdesc,fd,bint(i),fm,cnsol,xadjm,xmont
 150  continue
 151  continue
C +
      if (ncloud.ne.0) go to 161
       do 159 i=1,nl
       f(1,i)=fup(1,i)
       f(2,i)=fdn(1,i)
       FIRm(i)=f(1,i)
       FIRd(i)=-f(2,i)
       FIRn(i)=f(1,i)+f(2,i)
 159   continue
      go to 160
 161  continue
C +
C +   ***********
c #MR call cloudy (bsolin,cntrb,f,fup,fdn,bint,em0,indcl,mmi,nl,ncloud)
C +   ***********
C +
      do 158 i=1,nl
      FIRm(i) =  f(1,i)
      FIRd(i) = -f(2,i)
      FIRn(i) =  f(1,i) +f(2,i)
 158  continue
 160  continue
C +
      do 171 i=1,nc
      ipp1=i+1
 171  continue
C +
      outgir =  f(1,nl)
      firsol = -f(2,1)
      fupsol =  f(1,1)
      stsol4 =  stefan *tairRA(1) *tairRA(1) *tairRA(1) *tairRA(1)
      absatm =  f(1,1) -outgir    -firsol
c #WR if (iww2.eq.1) write (21,213) (FIRm(i),i=1,nl)
c #WR if (iww2.eq.1) write (21,213) (FIRd(i),i=1,nl)
c #WR if (iww2.eq.1) write (21,213) (FIRn(i),i=1,nl)
C +
      return
      end
      subroutine data2i 
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (infra)                                    24-09-2001  MAR |
C |   SubRoutine data2i includes Infrared Radiation Data                   |
C |              for infra Routine (PHYrad_IR), Morcrette, Thesis, 1984    |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      logical  lpri
C +
      real           xp(2,6,4),tstand
      integer                         nint
      common   /ir4/ xp       ,tstand,nint
      real           rt1(2),wg1(2)
      integer                      ng1
      common   /ir5/ rt1   ,wg1   ,ng1
      real           at(10),bt(6),o1h,o2h
      common   /ir6/ at    ,bt   ,o1h,o2h
      real           ga(16,6),gb(16,6)
      integer                          npad(16)
      common /padel/ ga      ,gb      ,npad
C +
C +
C +--Local  Variables
C +  ================
C +
      integer        i       ,j       ,k
C +
C +
C +--INPUT
C +  =====
C +
      lpri=.false.
C +
      open(unit=9,file='MARinf.dat',status='old')
      rewind    9
      read (9,100) ng1,nint,tstand,o1h,o2h
      read (9,110) (rt1(i),i=1,2)
      read (9,120) (wg1(i),i=1,2)
      read (9,130) (npad(i),i=1,16)
      if (lpri) write (21,100) ng1,nint,tstand,o1h,o2h
      if (lpri) write (21,110) (rt1(i),i=1,2)
      if (lpri) write (21,120) (wg1(i),i=1,2)
      if (lpri) write (21,130) (npad(i),i=1,16)
 100  format (1x,i1,1x,i1,1x,f5.1,1x,f6.1,1x,f6.4)
 110  format (2(1x,f12.9))
 120  format (2(1x,f3.1))
 130  format (16(1x,i1))
      read (9,140) (at(i),i=1,6)
      read (9,140) (at(i),i=7,10)
      if (lpri) write (21,140) (at(i),i=1,6)
      if (lpri) write (21,140) (at(i),i=7,10)
 140  format (6(e10.3))
      DO k=1,4
      DO i=1,2
        read (9,150) (xp(i,j,k),j=1,3)
        read (9,150) (xp(i,j,k),j=4,6)
        if (lpri) write (21,151) (xp(i,j,k),j=1,3)
        if (lpri) write (21,151) (xp(i,j,k),j=4,6)
      END DO
      END DO
 150  format (3(e14.7))
 151  format (3(1x,e14.7))
      DO i=1,6
        read (9,160) (ga(i,j),j=1,3)
        read (9,160) (ga(i,j),j=4,6)
        if (lpri) write (21,160) (ga(i,j),j=1,3)
        if (lpri) write (21,160) (ga(i,j),j=4,6)
      END DO
      DO i=7,8
        read (9,170) (ga(i,j),j=1,4)
        if (lpri) write (21,170) (ga(i,j),j=1,4)
      END DO
      DO i=9,12
        read (9,160) (ga(i,j),j=1,3)
        read (9,160) (ga(i,j),j=4,6)
        if (lpri) write (21,160) (ga(i,j),j=1,3)
        if (lpri) write (21,160) (ga(i,j),j=4,6)
      END DO
      DO i=13,16
        read (9,170) (ga(i,j),j=1,4)
        if (lpri) write (21,170) (ga(i,j),j=1,4)
      END DO
      DO i=1,6
        read (9,160) (gb(i,j),j=1,3)
        read (9,160) (gb(i,j),j=4,6)
        if (lpri) write (21,160) (gb(i,j),j=1,3)
        if (lpri) write (21,160) (gb(i,j),j=4,6)
      END DO
      DO i=7,8
        read (9,170) (gb(i,j),j=1,4)
        if (lpri) write (21,170) (gb(i,j),j=1,4)
      END DO
      DO i=9,12
        read (9,160) (gb(i,j),j=1,3)
        read (9,160) (gb(i,j),j=4,6)
        if (lpri) write (21,160) (gb(i,j),j=1,3)
        if (lpri) write (21,160) (gb(i,j),j=4,6)
      END DO
      DO i=13,16
        read (9,170) (gb(i,j),j=1,4)
        if (lpri) write (21,170) (gb(i,j),j=1,4)
      END DO
 160  format (3(e13.7))
 170  format (4(e13.7))
      close(unit=9)
      write (21,210)
 210  format (///,'    end of the ir radiative data lecture ',//)
      return
      end
      subroutine hornel( uu, tt, ind)
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (infra)                                    24-09-2001  MAR |
C |   SubRoutine hornel computes Transmissions from Pade Coefficients      |
C |              for infra Routine (PHYrad_IR), Morcrette, Thesis, 1984    |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      real           uu(8)   ,tt(8)
      integer        ind
C +
      real           ga(16,6),gb(16,6)
      integer                          npad(16)
      common /padel/ ga      ,gb      ,npad
C +
C +
C +--Local  Variables
C +  ================
C +
      integer        ia    ,l     ,np    ,npp1  ,i     ,j
      real           xn    ,xd    ,z     ,r
C +
C +
C +
C +
C +
      DO ia=1,8
        tt(ia)=1.0d0
      END DO
C +
      do 20 ia=1,8
      l      = 2*ia-ind
      np     = npad(l)
      npp1   = np+1
      xn     = 0.0d0
      xd     = 1.0d0
      z      = uu(ia)
      do 2 j=1,np
      i      = npp1-j
      xn     = xn*z+ga(l,i)
      xd     = xd*z+gb(l,i)
 2    continue
      r      = xn/xd
      tt(ia) = r
 20   continue
c #WR write(21,210) (uu(l),tt(l),l=1,8)
 210  format(1x,8(1x,e10.4,f9.5))
      return
      end
      subroutine cloudy(bsol,cntrb,f,fup,fdn,bint,em0,
     .                  indcl,mmi,nl,ncloud)
C +
C +------------------------------------------------------------------------+
C | MAR PHYSICS (infra)                                    15-09-2001  MAR |
C |   SubRoutine cloudy computes Transmissions from Pade Coefficients      |
C |              for infra Routine (PHYrad_IR), Morcrette, Thesis, 1984    |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARdim.inc'
C +
      include 'MAR_IR.inc'
C +
      integer  mmi   ,nl    ,ncloud
      real     bsol  ,em0   
      real     indcl   (mzir),cntrb(mzir,mzir)
      real     fup(mzir,mzir),fdn  (mzir,mzir)
      real     bint    (mzir),f      ( 2,mzir)
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  i     ,j     ,k     ,icloud,icp1  
      integer  im    ,ip    ,mmi1  ,i1    ,i2    ,ij    ,j1    ,j2
      real     fcldup,fclddn,fm    ,fd    ,cloud ,ci    ,ccld
C +
C +
C +
C +
C +
      DO i=1,nl
      DO j=2,nl
        fup(j,i)=fup(1,i)
        fdn(j,i)=fdn(1,i)
      END DO
      END DO
C +
      do 190 k=1,ncloud
      icloud=indcl(k)
      icp1=icloud+1
      fcldup=bint(icp1)
      fclddn=bint(icloud)
      fm=0.0d0
      fd=0.0d0
      do 180 i=1,nl
      im=i-1
      ip=i+1
      if(i.le.icloud) go to 150
      fm=fcldup
      if(i.eq.icp1) go to 141
      do 140 j=icp1,im
      fm=fm+cntrb(i,j)
140   continue
141   fdn(icp1,i)=fdn(1,i)
      fup(icp1,i)=bint(i)+fcldup-fm
      go to 180
150   fd=fclddn
      if(i.eq.icloud) go to 170
      do 160 j=ip,icloud
      fd=fd+cntrb(i,j)
160   continue
170   fdn(icp1,i)=-bint(i)+fclddn-fd
      fup(icp1,i)=fup(1,i)
180   continue
      do 181 i=1,nl
      f(1,i)=fup(icp1,i)
      f(2,i)=fdn(icp1,i)
181   continue
      if(ncloud.gt.1) go to 190
      if (ecldIR(icloud).ne.1.0d0) go to 190
      return
190   continue
      mmi1=mmi+1
      fm=0.0d0
      fd=0.0d0
      do 291 i=1,nl
      ip=i+1
      cloud=1.0d0
      if(i.gt.mmi) go to 280
      ci=ecldIR(i)
      fd=fdn(ip,i)*ci
      do 260 j=i,mmi
      j1=j+1
      j2=j+2
      cloud=cloud*(1.00d0-ecldIR(j))
      if (j.eq.mmi) go to 270
      ccld=cloud*ecldIR(j1)
      fd=fd+fdn(j2,i)*ccld
260   continue
270   fd=fd+fdn(1,i)*cloud
      f(2,i)=fd
      go to 290
280   f(2,i)=fdn(1,i)
290   continue
291   continue
      f(1,1)=em0*bsol-(1.0d0-em0)*f(2,1)
      do 250 i=2,nl
      im=i-1
      cloud=1.0d0
      if(i.gt.mmi1) go to 220
      fm=fup(i,i)*ecldIR(im)
      i2=im
      i1=i
      go to 221
220   fm=fup(mmi1,i)*ecldIR(mmi)
      i2=mmi
      i1=mmi1
221   do 222 j=1,i2
      ij=i1-j
      cloud=cloud*(1.00d0-ecldIR(ij))
      if(ij.eq.1) go to 223
      ccld=cloud*ecldIR(ij-1)
      fm=fm+fup(ij,i)*ccld
222   continue
223   fm=fm+fup(1,i)*cloud
      f(1,i)=fm
250   continue
      return
      end


      subroutine PHYrad_top(Dis_ST)

C +------------------------------------------------------------------------+
C | MAR PHYSICS (INSOL)                                    15-11-2007  MAR |
C |   SubRoutine PHYrad_top computes                                       |
C |      Time Insolation at the Top of the Atmosphere                      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER.:   Ch.  Tricot, personal communication                        |
C |   ^^^^^^^   M.F. Loutre, personal communication and thesis (1993)      |
C |                                                                        |
C |   INPUT :   mmarGE, jdarGE: Month and Day of the Year                  |
C |   ^^^^^^^   jhurGE, minuGE, jsecGE: Hour, Minute, and Second           |
C |             GElat0, GElon0: Latitude, Longitude                        |
C |             GElatr(mx,my) : Latitude                         (radians) |
C |             GElonh(mx,my) : Longitude                          (hours) |
C |             itizGE(mx,my) : Time Zone                                  |
C |                                                                        |
C |   OUTPUT:   rsunGE        : Insolation normal to Atmosphere Top (W/m2) |
C |   ^^^^^^^   czenGE(mx,my) : Cosinus of the Zenithal Distance           |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MARSND.inc'

      include 'MAR_WK.inc'

      include 'MAR_IO.inc'

      REAL     Dis_ST


C +--LOCAL VARIABLES
C +  ===============

      real     pirr  ,xl    ,so
      real     xllp  ,xee   ,xse   
      real     xlam  ,dlamm ,anm   ,ranm  ,ranv  ,anv   ,tls
      real     Tyear ,step  ,rlam  ,sd    ,cd    ,deltar,delta

      real     ddt   ,arg   ,et    ,argc  ,ahc
      real     c1    ,c2    ,c3    ,s1    ,s2    ,s3
      real     timdl ,timh  ,ahor  ,ahorr ,RadLat,chor  ,zenitr
      integer  nj    ,lhc

      real     omesun
c #AZ real     slopx ,slopy ,omenor
c #AZ real     comes ,somes ,omeswr,anormr,omenwr
c #AZ integer  momask

c #MM real     dxdx  ,azim_0,azim_1,azimdd,azimut,r_azim
c #MM real     azimxx,azimxa,azimxs,azimyy,azimya,azimys
c #MM real     ddxx_2,ddyy_2,ddxy_2,ddzz  ,tmnt_2,cmnt  
c #MM integer  k_azim,nax   ,nal   ,na    ,na2   ,ka
c #MM integer  i_azim,j_azim,j_azmn,j_azmx,i_azmn,i_azmx,nocoun
c #MM integer  knazim,ni1   ,ni2   ,nj1   ,nj2
c #MM integer  i1    ,i2    ,j1    ,j2    ,ni 

      real     om    ,ecc   ,perh  ,xob 


C +--DATA
C +  ====

      data     om /0.0172142d0/


C +--Present Day Insolation
C +  ----------------------

      data ecc  /  0.01673/      ! Eccentricity 
      data perh /102.4    /      ! Longitude of the Perihelion (degrees)
      data xob  / 23.445  /      ! Obliquity                   (degrees)


C +--6 kBP       Insolation
C +  ----------------------

c #6k data ecc  /  0.018682/     ! Eccentricity
c #6k data perh /  0.87    /     ! Longitude of the Perihelion (degrees)
c #6k data xob  /  24.105  /     ! Obliquity                   (degrees)


C +--10 kBP      Insolation
C +  ----------------------

c #10 data ecc  /  0.019419/     ! Eccentricity
c #10 data perh /294.81    /     ! Longitude of the Perihelion (degrees)
c #10 data xob  / 24.226   /     ! Obliquity                   (degrees)


C +--Insolation at the Top of the Atmosphere (TIME       PARAMETERS)
C +  ===============================================================

C +--Solar declination : delta
C +  -------------------------

      nj    = jdarGE+njyrGE(mmarGE)
      Tyear = 365.25d0
      step  = 360.0d0/Tyear

      pirr  = degrad /  3600.0
      xl    = perh   +  180.0
      so    = sin(xob*degrad)
C +...so    : sinus of obliquity

      xllp  =xl*degrad
      xee   =ecc*ecc
      xse   =sqrt(1.0d0-xee)
      xlam  =(ecc/2.0+ecc*xee/8.0d0)*(1.0+xse)*sin(xllp)-xee/4.0*
     .       (0.5+xse)*sin(2.0*xllp)+ecc*xee/8.0*(1.0/3.0+xse)*
     .        sin(3.0*xllp)
      xlam  =2.0d0*xlam/degrad
      dlamm =xlam+(nj-80)*step
C +...xlam  : true long. sun for mean long. = 0
C +...dlamm : mean long. sun for ma-ja
      anm   =dlamm-xl                                                 
      ranm  =anm*degrad
      xee   =xee*ecc                                                      
      ranv  =ranm+(2.0*ecc-xee/4.0)*sin(ranm)+5.0/4.0*ecc*ecc*   
     .       sin(2.0*ranm)+13.0/12.0*xee*sin(3.0*ranm)             
      anv   =ranv/degrad
      tls   =anv+xl      
      rlam  =tls*degrad
C +...tls   : longitude vraie   (degrees)
C +...rlam  : longitude vraie   (radian)
C +...anv   : anomalie vraie    (degrees)
C +...ranv  : anomalie vraie    (radian)

      sd    = so * sin(rlam) 
      cd    = sqrt(1.0d0-sd*sd)
C +...sd and cd: cosinus and sinus of solar declination angle (delta)
C +...sinus delta = sin (obl)*sin(lambda) with lambda = real longitude
C +...(Phd. thesis of Marie-France Loutre, ASTR-UCL, Belgium, 1993)

      deltar= atan(sd/cd)
      delta = deltar/degrad
C +...delta: Solar Declination (degrees, angle sun at equator)


C +--Eccentricity Effect
C +  -------------------

      Dis_ST  =(1.0-ecc*ecc)/(1.0+ecc*cos(ranv))
      ddt     = 1.0 /  Dis_ST
C +...ddt  :    1   /  normalized earth's sun distance


C +--Insolation normal to the atmosphere (W/m2)
C +  ------------------------------------------

cXF
      rsunGE  = ddt *ddt *1360.8d0


C +--Time Equation (Should maybe be modified in case other than present 
C +  -------------  conditions are used, minor impact)

      arg = om*nj
      c1  = cos(arg)
      c2  = cos(2.d0*arg)
      c3  = cos(3.d0*arg)
      s1  = sin(arg)
      s2  = sin(2.d0*arg)
      s3  = sin(3.d0*arg)

      et=0.0072d0*c1 -0.0528d0*c2 -0.0012d0*c3
     .  -0.1229d0*s1 -0.1565d0*s2 -0.0041d0*s3
C +...et (hour)
C +     = difference between true solar and mean solar hour angles.
C +      (connected to the earth orbital rotation speed)


C +--Insolation at the Top of the Troposphere (Auxiliary Variables)
C +  ==============================================================


C +--Day Length, Time Sunrise and Sunset at Sounding Grid Point (iSND,jSND)
C +  ----------------------------------------------------------------------

      i = iSND
      j = jSND

         argc   = -tan(GElatr(i,j))*tan(deltar)
       if (abs(argc).gt. 1.d0) then
         ahc    =  0.d0
        if    (argc .gt. 1.d0) then
         lhc    = -1
         timdl  = 00.d0
C +...   Polar  Night
        else
         lhc    =  1
         timdl  = 24.d0
C +...   Midnight Sun
        end if
         tlsrGE = 00.d0
         tlssGE = 00.d0
       else
         ahc    =  acos(argc)
         lhc    =  0

        if(ahc.lt.0.d0)    ahc = -ahc
         ahc    =          ahc / hourad
         timdl  =          ahc * 2.d0
         tlsrGE = 12.d0  - ahc + itizGE(i,j) - et - GElonh(i,j)
         tlssGE = tlsrGE + timdl
       end if

         tl__GE = jhurGE + minuGE / 60.d0         - itizGE(i,j)


C +--Time Angle
C +  ----------

      DO j=1,my
      DO i=1,mx
         timh  = jhurGE + minuGE      / 60.d0
         ahor  = timh   + GElonh(i,j) - 12.d0 - et
C +...   ahor  : time angle (hours)

         ahorr = ahor   * hourad
C +...   ahorr : time angle (radians)

         chor  = cos(ahorr)


C +--Solar Zenithal Distance zenitr (radians) and
C +  Insolation (W/m2) at the Atmosphere Top  ===
C +  =======================================

         czenGE(i,j) =      slatGE(i,j) *sd
     .                    + clatGE(i,j) *cd *chor
         czenGE(i,j) =  max(czenGE(i,j),zero)
         cverGE(i,j) =      czenGE(i,j)


C +--Slope Impact
C +  ------------

c #AZ    zenitr      = acos(czenGE(i,j))
c #AZ    WKxy3 (i,j) =  sin(zenitr)
c #AZ    WKxy4 (i,j) =  sin(ahorr)
      END DO
      END DO

C +--Slope Azimuth
C +  ~~~~~~~~~~~~~
c #AZ IF (iterun.le.1)                                            THEN
c #AZ   DO j=1,my
c #AZ   DO i=1,mx
c #AZ     slopx        =(sh(ip1(i),j)-sh(im1(i),j))*dxinv2
c #AZ     slopy        =(sh(i,jp1(j))-sh(i,jm1(j)))*dyinv2
c #AZ     slopGE(i,j)  =sqrt(slopx*slopx+slopy*slopy)
c #AZ     slopGE(i,j)  =cos(atan(slopGE(i,j)))
C +...    slopGE ...... Cosine of Fall Line Angle

c #AZ     IF (abs(slopx).gt.zero)                                 THEN
c #AZ           omenor = atan(slopy/slopx)
c #AZ       IF   (slopx.lt.zero)
c #AZ.          omenor =  omenor + pi

c #AZ       IF (omenor.gt.         pi)
c #AZ.          omenor =  -2.0d0 * pi + omenor
c #AZ       IF (omenor.lt.        -pi)
c #AZ.          omenor =   2.0d0 * pi + omenor

c #AZ     ELSE
c #AZ       IF   (slopy.gt.zero) then
c #AZ           omenor =   0.5d0 * pi
c #AZ       ELSE
c #AZ           omenor =   1.5d0 * pi
c #AZ       END IF
c #AZ     END IF
C +...          omenor      :      Fall Line Azimuth   (Upslope Direction)
C +
c #AZ           omenGE(i,j) =      omenor - pi
C +...          omenGE(i,j) :      Fall Line Azimuth (Downslope Direction)
C +                                               (in MAR Reference Frame)
C +                                            (positive counterclockwise)
c #AZ   END DO
c #AZ   END DO

C +--Mountains Mask
C +  ~~~~~~~~~~~~~~
c #AZ       momask =   1
c #MM   IF (momask.ne. 1)
c #MM.stop'++++++++ Preprocessing Error: #AZ not removed ++++++++++++++'
C +
c #MM         dxdx   =  dx    * dx
C +
c #MM         daziGE =  2.0d0 * pi /   n_azim
c #MM   DO k_azim   = 1,n_azim
c #MM         azim_0 =  (k_azim-1) *   daziGE
c #MM         azim_1 =   k_azim    *   daziGE

c #MM     DO j=1,mmy
c #MM     DO i=1,mmx
c #MM         cmntGE(i,j,k_azim)   = 0.0d00
c #MM     END DO
c #MM     END DO

c #MM     IF (abs(cos(azim_0)).gt.abs(sin(azim_0)))               THEN
c #MM           nax    = mx1 / 2
c #MM     ELSE
c #MM           nax    = my1 / 2
c #MM     END IF
c #MM           nal    =          30
c #MM           nax    = min(nax,nal)

c #MM     DO  na=1,nax

c #MM           na2    = na  / 2
c #MM           na2    = max(na2,1)

c #MM           azimdd =                 daziGE /  na

c #MM       DO j=1,mmy
c #MM       DO i=1,mmx
c #MM           WKxy1(i,j) = 0.0d00
c #MM           WKxy2(i,j) = 0.0d00
c #MM       END DO
c #MM       END DO

c #MM       DO ka=1,na
c #MM           azimut = azim_0 + azimdd * (ka-0.5d0)

c #MM           azimxx =(na+demi)*cos(azimut)
c #MM           i_azim =              azimxx
c #MM           azimxa =          abs(azimxx)
c #MM           azimxs =    sign(unun,azimxx)

c #MM           azimyy =(na+demi)*sin(azimut)
c #MM           j_azim =              azimyy
c #MM           azimya =          abs(azimyy)
c #MM           azimys =    sign(unun,azimyy )

c #MM         IF   (i_azim.eq.0.and.j_azim.eq.0)                  THEN
c #MM           IF (azimxa.gt.azimya)                             THEN
c #MM               i_azim =  azimxs
c #MM           ELSE
c #MM               j_azim =  azimys
c #MM           END IF
c #MM         END IF

c #MM         DO j=2,my1
c #MM               j_azmn =  1-j
c #MM               j_azmx = my-j

c #MM         DO i=2,mx1
c #MM               i_azmn =  1-i
c #MM               i_azmx = mx-i

c #MM                                                     nocoun = 0
c #MM           IF (j_azim.gt.j_azmx.or.j_azim.lt.j_azmn) nocoun = 1
c #MM           IF (i_azim.gt.i_azmx.or.i_azim.lt.i_azmn) nocoun = 1

c #MM           IF (nocoun.eq.1)                             GO TO 150

c #MM               ddxx_2 =     i_azim*i_azim   *dxdx
c #MM               ddyy_2 =     j_azim*j_azim   *dxdx
c #MM               ddxy_2 =     ddxx_2+ddyy_2

c #MM               ddzz  = sh(i+i_azim,j+j_azim)-sh(i,j)
c #MM.                    - sqrt(earthr *earthr + ddxy_2) + earthr
C +...              Correction for Earth Curvature

c #MM               ddzz  =   max(ddzz,zero)

c #MM               tmnt_2 = ddzz * ddzz / ddxy_2
c #MM               cmnt   = sqrt(tmnt_2 /(unun  +tmnt_2))

c #MM               WKxy1(i,j)           =     WKxy1(i,j) + cmnt
c #MM               WKxy2(i,j)           =     WKxy2(i,j) + unun

 150            CONTINUE

c #MM         END DO
c #MM         END DO

c #MM       END DO

c #MM       DO j=2,my1
c #MM       DO i=2,mx1
c #MM         IF (WKxy2( i,j).gt.0.d0)                            THEN
c #MM             WKxy1( i,j)       =     WKxy1(i,j)/ WKxy2(i,j)
c #MM             cmntGE(i,j,k_azim)= max(WKxy1(i,j),cmntGE(i,j,k_azim))
c #MM         END IF
c #MM       END DO
c #MM       END DO

c #MM     END DO

c #MM   END DO

c #AZ END IF

C +--Sun   Azimuth
C +  ~~~~~~~~~~~~~
c #AZ DO j=1,my
c #AZ DO i=1,mx

c #AZ     WKxy3 (i,j) = max(epsi       ,WKxy3 (i,j))

c #AZ     comes       =(sd-slatGE(i,j) *czenGE(i,j))
c #AZ.                /(   clatGE(i,j) *WKxy3 (i,j))
C +...    comes: Cosine of Sun Azimuth

c #AZ     somes       =(cd*WKxy4(i,j)) /WKxy3 (i,j)
C +...    somes:   Sine of Sun Azimuth

c #AZ   IF (abs(comes).gt.zero)                                   THEN
c #AZ           omesun = atan(somes/comes)
c #AZ     IF   (comes.lt.zero)
c #AZ.          omesun =  omesun + pi

c #AZ     IF   (omesun.gt.         pi)
c #AZ.          omesun =  -2.0d0 * pi + omesun
c #AZ     IF   (omesun.lt.        -pi)
c #AZ.          omesun =   2.0d0 * pi + omesun

c #AZ   ELSE
c #AZ     IF   (somes.gt.zero)                                    THEN
c #AZ           omesun =   0.5d0 * pi
c #AZ     ELSE
c #AZ           omesun =   1.5d0 * pi
c #AZ     END IF
c #AZ   END IF

c #AZ   IF (i.eq.iSND.and.j.eq.jSND) omeswr = omesun / degrad
C +
c #AZ           omesun =  -2.0d0 * pi + omesun + GEddxx * degrad
C +...          omesun :  Sun Azimuth              (in MAR Reference Frame)
C +                                             (positive counterclockwise)

C +--Minimum Zenithal Distance
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
c #AZ   czmnGE(i,j) = 0.0d00
c #MM                            r_azim = omesun  / daziGE
c #MM                            k_azim = r_azim
c #MM   IF (k_azim.le.     0)                                     THEN
c #MM                            r_azim = r_azim  + n_azim
c #MM                            k_azim = k_azim  + n_azim
c #MM   END IF
c #MM                            knazim = k_azim  + 1
c #MM   IF (knazim.gt.n_azim)    knazim = knazim  - n_azim

c #MM   czmnGE(i,j) = cmntGE(i,j,k_azim)+(r_azim  - k_azim)
c #MM.              *(cmntGE(i,j,knazim)-cmntGE(i,j,k_azim))

C +--Cosine of Solar Normal Angle
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AZ   cverGE(i,j) = slopGE(i,j) * czenGE(i,j)
c #AZ.              +  WKxy3(i,j) * slopGE(i,j)*sqrt(unun  -slopGE(i,j))
c #AZ.                            *              cos(omesun-omenGE(i,j))
c #AZ   cverGE(i,j) =                            max(zero  ,cverGE(i,j))
c #AZ IF            (czenGE(i,j).le.czmnGE(i,j))
c #AZ.  cverGE(i,j) = 0.0d00
c #AZ END DO
c #AZ END DO


C +--Output
C +  ======

c #MM if (    iterun.eq.0                                         ) then

c #MM         ni1=imez/20+1
c #MM         ni2=imez/20+1
c #MM         nj1=jmez/20+1
c #MM         nj2=jmez/20+1

c #MM  do nj= nj2,nj1,-1
c #MM    j1=(nj-1)*20+1
c #MM    j2= nj   *20
c #MM  do ni= ni1,ni2
c #MM    i1=(ni-1)*20+1
c #MM    i2= ni   *20

c #MM  write(4,60)   (             i          ,i=i1,i2),
c #MM.            (j,(1.d-3*sh    (i,j       ),i=i1,i2),j=j2,j1,-1)
 60    format(///,'TOPOGRAPHY',
     .          /,'==========',      /,4x,20i4,/,(i4,20f4.1))

c #MM  do k_azim=1,n_azim
c #MM              azimut =         (k_azim-0.5d0) * daziGE / degrad
c #MM  write(4,61) azimut,
c #MM.               (             i          ,i=i1,i2),
c #MM.            (j,(      cmntGE(i,j,k_azim),i=i1,i2),j=j2,j1,-1)
 61    format(///,'AZIMUTH   ',f6.1,
     .          /,'================',/,4x,20i4,/,(i4,20f4.2))

c #MM  end do

c #MM  end do
c #MM  end do

c #MM end if

      if ((  jmmMAR.eq.0.and.    jssMAR   .eq.0         .and.
     .     ((IO_loc.ge.2.and.    jhurGE   .eq.0) .or.
     .      (IO_loc.ge.2.and.mod(jhurGE,3).eq.0) .or.
     .      (IO_loc.ge.3)                            )       ).or.
     .       IO_loc.ge.7                                          ) then

         ahor  = timh   + GElonh(iSND,jSND)  - 12.d0 - et
         zenitr=     acos(czenGE(iSND,jSND)) / degrad
c #AZ    anormr=     acos(cverGE(iSND,jSND)) / degrad
c #AZ    omenwr= GEddxx - omenGE(iSND,jSND)  / degrad
c #AZ    if (omenwr.lt.  0.) omenwr = omenwr + 360.d0
c #AZ    if (omenwr.gt.360.) omenwr = omenwr - 360.d0
c #AZ                        omeswr = 360.d0 - omeswr
c #AZ    if (omeswr.lt.  0.) omeswr = omeswr + 360.d0
c #AZ    if (omeswr.gt.360.) omeswr = omeswr - 360.d0

        write(4,1) GElat0,GElon0,jdarGE,mmarGE,jhurGE,minuGE,jsecGE
 1      format(/,' lat.=',f6.1,3x,'long.=',f7.1,4x,'date :',i3,'-',i2,
     .           ' / ',i2,' h.UT',i3,' min.',i3,' sec.')
        write(4,2) iSND,jSND,GElatr(iSND,jSND)/degrad,GElonh(iSND,jSND)
 2      format(' Sounding at (',i3,i3,') / (',f6.2,'dg,',f6.2,'ho)')
        write(4,3) rsunGE*cverGE(iSND,jSND),ahor,zenitr
c #AZ.            ,omeswr,omenwr           ,     anormr
     .            ,delta
 3      format(' Insolation [W/m2]  = ',f7.2,'   Hor.Angle = ',f7.2,
     .         '   Zenith.Angle = ',f7.2
c #AZ.      ,/,'                      ', 7x ,'   Sol.Azim. = ',f7.2
c #AZ.      ,/,'                      ', 7x ,'   Nrm.Azim. = ',f7.2
c #AZ.        ,'   Normal Angle = ',f7.2
     .      ,/,' Solar Declination  = ',f7.2)

       if (lhc.eq.-1)
     .  write(4,4) tlsrGE,timdl,tlssGE
 4      format(' Sun Rise Time [h]  = ',f7.2,'   Day Leng. = ',f7.2,
     .         '   Sun Set Time = ',f7.2,'  -- POLAR  NIGHT --')
       if (lhc.eq. 0)
     .  write(4,5) tlsrGE,timdl,tlssGE
 5      format(' Sun Rise Time [h]  = ',f7.2,'   Day Leng. = ',f7.2,
     .         '   Sun Set Time = ',f7.2,'  -- SOLAR  TIME  --')
       if (lhc.eq. 1)
     .  write(4,6) tlsrGE,timdl,tlssGE
 6      format(' Sun Rise Time [h]  = ',f7.2,'   Day Leng. = ',f7.2,
     .         '   Sun Set Time = ',f7.2,'  -- MIDNIGHT SUN --')
      end if


C +--Work Arrays Reset
C +  =================

c #AZ DO j=1,my
c #AZ DO i=1,mx
c #MM   WKxy1(i,j) = 0.d0
c #MM   WKxy2(i,j) = 0.d0
c #AZ   WKxy3(i,j) = 0.d0
c #AZ   WKxy4(i,j) = 0.d0
c #AZ END DO
c #AZ END DO

      return
      end


      subroutine SSpray

C +--------------------------------------------------------------------------+
C |                                                          Sat 29-Jul-2009 |
C |                                                                          |
C |   subroutine SSpray computes contribution of Sea Spray                   |
C |              ^^^^^^                       to Sensible & Latent Heat Flux |
C |                                                                          |
C |   Reference A_03 Andreas, 2003, Preprints.                               | 
C |                  12th Conference on Interactions of the Sea & Atmosphere |
C |                  Long Beach, CA, American Meteorological Society         |
C |                  http://ams.confex.com/ams/pdfpapers/77949.pdf           |
C |                                                                          |
C |             AD02 Andreas & Decosmo, 2002, BLM 103, 303-333               |
C |                  The signature of sea spray                              |
C |                                in the HEXOS turbulent heat flux data     |
C |                                                                          |
C |             AE01 Andreas & Emanuel, 2001, JAS  58, 3741-3751             |
C |                  Effects of Sea Spray on Tropical Cyclone Intensity      |
C |                                                                          |
C |             A_95 Andreas, 1995, JAS 52(7) , 852-862                      |
C |                  The Temperature of Evaporating Sea Spray Droplets       |
C |                                                                          |
C |             A_90 Andreas, 1990, Tellus 42B, 481-497                      |
C |                  Time Constants for the Evolution of Sea Spray Droplets  |
C |                                                                          |
C |                                                                          |
C +--------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARCTR.inc"
      include  "MARphy.inc"
      include  "MARdim.inc"
      include  "MARgrd.inc"
      include  "MAR_DY.inc"
      include  "MAR_SL.inc"
      include  "MAR_WK.inc"


C +--Internal  Constants and Variables
C +  =================================

      real alphaC,Uf_Spr,t50_eq,f50_eq
      real ustar2,alo10g,A13wav,tf_Spr
      real Ta_wet,r50_eq,r50__t,r50n_t,QS_Spr,qq_Spr,QL_Spr


C +--DATA
C +  ====

      data alphaC /0.0185/                                             ! A_03
                                                                       ! ( 3)
                                                                       !
      data Uf_Spr /0.1   /                                             ! A_90
C +...     Uf_Spr = .1 = 1/tau_f where tau_f = 10 sec                  ! fig9
                                                                       !
      data t50_eq /0.2000e+3/                                          ! A_90
                                                                       ! fig9
                                                                       !
      data f50_eq /0.3125e-4/                                          ! A_90
C +...             0.3125e-4 = 50.e-6 m * 0.5          / 0.8           ! p490
C +                                     * 0.5  when RH = 0.8


C +--Wave Height
C +  ===========

      DO j=1,my
      DO i=1,mx
      A13wav = 0.015        * ssvSL(i,j,mz)                            ! AD02
                                                                       ! ( 4)
c #A3 ustar2 = SLuusl(i,j,1)*SLuusl(i,j,1)                             !
c #A3 alo10g =       log(10.*gravit/alphaC)                            !
c #A3 A13wav =                                                         ! A_03
c #A3.  0.015*(ustar2/vonkar)*(2.*ustar2-SLuusl(i,j,1)*(2.*alo10g+8.)) ! (13)
c #A3.                                +(alo10g*alo10g + 2.*alo10g+4.)  !

      A13wav =       min(20.,A13wav)


C +--Sea Spray Residence Time
C +  ========================

      tf_Spr = A13wav/Uf_Spr                                           ! A_03
                                                                       ! (12)

C +--Sea Spray Sensible Heat Flux Correction
C +  =======================================

      Ta_wet = tairDY(i,j,mz)-(Lv_H2O/cp)*(qvswDY(i,j,mz)-qvDY(i,j,mz))! A_95
      Ta_wet =      max(tfrwat       ,Ta_wet)                          !
      QS_Spr = 4.187e6*(tsrfSL(i,j,1)-Ta_wet)                          ! AE01
                                                                       ! ( 7)
     .        *1.65e-6* SLuusl(i,j,1)*SLuusl(i,j,1)*SLuusl(i,j,1)      ! A_03
     .                                                                 ! (14a)


C +--Sea Spray Latent   Heat Flux Correction
C +  =======================================

      r50_eq = f50_eq * min(1.,  qvDY(i,j,mz)      /qvswDY(i,j,mz))    ! A_90
                                                                       ! p490
      r50__t = r50_eq +(50.e-6-r50_eq) *       exp(-tf_Spr/t50_eq)     ! 
      r50n_t = r50__t / 50.e-6
      qq_Spr = 1000.00                 *(1.-r50n_t *r50n_t*r50n_t)     ! A_03
     .        *2.65e-8* SLuusl(i,j,1)**2.61                            ! (11)
      QL_Spr =        - Lv_H2O         *   qq_Spr                      ! A_03
                                                                       ! (11)

C +--Update
C +  ======

C +--Increment
C +  ~~~~~~~~~
c #X  pktaDY(i,j,mz) = pktaDY(i,j,mz)+maskSL(i,j)*SLsrfl(i,j,1)        !
c #X .  *(QS_Spr+QL_Spr)*dt_Loc/(1.e3*pstDYn(i,j)*dsigm1(mz)*grvinv)   !
c #X .                              /(  pkDY(i,j,mz)        *cp    )   !

       WKxy1(i,j)    =                maskSL(i,j)*SLsrfl(i,j,1)        !
     .  *(QS_Spr+QL_Spr)*dt_Loc/(1.e3*pstDYn(i,j)*dsigm1(mz)*grvinv)   !
     .                              /(  pkDY(i,j,mz)        *cp    )   !

C +--Increment (after limiting the fluxes)
C +  ~~~~~~~~~
       WKxy2(i,j) =
     .   max(0.0,sign(1.,pktaDY(i,j,mz) -pktaDY(i,j,mzz)           ))  ! LOWER
     .  *max(0.0,sign(1.,pktaDY(i,j,mzz)-pktaDY(i,j,mz )-WKxy1(i,j)))  !
     .  *max(WKxy1(i,j) ,pktaDY(i,j,mzz)-pktaDY(i,j,mz )            )  !
     . + max(0.0,sign(1.,pktaDY(i,j,mz) -pktaDY(i,j,mzz)+WKxy1(i,j)))  ! UPPER
     .  *max(0.0,sign(1.,pktaDY(i,j,mzz)-pktaDY(i,j,mz )           ))  !
     .  *min(WKxy1(i,j) ,pktaDY(i,j,mzz)-pktaDY(i,j,mz )            )  !
     . + max(0.0,sign(1.,pktaDY(i,j,mz) -pktaDY(i,j,mzz)+WKxy1(i,j))   ! OTHER
     .          *sign(1.,pktaDY(i,j,mz) -pktaDY(i,j,mzz)           ))  !
     .  *    WKxy1(i,j)                                                !

       WKxy2(i,j)    =                           sign(1.,WKxy2(i,j))   !  max:
     .                             *min(10.*dt/3600.,abs(WKxy2(i,j)))  ! 10Â°C/h
      pktaDY(i,j,mz) =   pktaDY(i,j,mz)                 +WKxy2(i,j)

      qq_Spr         =   qq_Spr  *  WKxy2(i,j)/(sign(1.0,WKxy1(i,j))
     .                                    * max(eps9,abs(WKxy1(i,j))))

        qvDY(i,j,mz) =   qvDY(i,j,mz)+maskSL(i,j)*SLsrfl(i,j,1)        !
     .  * qq_Spr        *dt_Loc/(1.e3*pstDYn(i,j)*dsigm1(mz)*grvinv)   !

      ENDDO
      ENDDO

      DO j=1,my
      DO i=1,mx
       WKxy1(i,j) = 0.0
       WKxy2(i,j) = 0.0
      ENDDO
      ENDDO

      return
      end


      subroutine PHY_SISVAT(ihamr_SIS,nhamr_SIS)

C +------------------------------------------------------------------------+
C | MAR          SISVAT_Driver                        Thu 10-Nov-2011  MAR |
C |   SubRoutine PHY_SISVAT    interfaces MAR        with        the       |
C |              Soil/Ice Snow Vegetation Atmosphere Transfer Scheme       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT: ihamr_SIS: Time Digital Filter Status                         |
C |   ^^^^^  nhamr_SIS: Time Digital Filter Set Up                         |
C |                                                                        |
C |   INPUT    (via common block)                                          |
C |   ^^^^^     VegMod: SISVAT    is set up when .T.                       |
C |             SnoMod: Snow Pack is set up when .T.                       |
C |             reaLBC: Update Bound.Condit.when .T.                       |
C |             iterun: Run Iterations Counter                             |
C |                                                                        |
C |   INPUT    (via common block)                                          |
C |   ^^^^^     xxxxTV: SISVAT/MAR interfacing variables                   |
C |                                                                        |
C | # CAUTION: #sa: Stand Alone Preprocessing Label must be removed        |
C | # ^^^^^^^       when SISVAT is coupled with MAR                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT PHYSICS                                |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^                                |
C | #                        #HY                                           |
C | #                        #SN: Snow         Model                       |
C | #                        #BS: Blowing Snow Parameterization            |
C | #                        #SI  Sea-Ice      Parameterization            |
C | #                        #GP  LAI and GLF  Variations not specified    |
C | #                        #OP  SST       is interactive                 |
C |                                                                        |
C | #                        #DS: diffuse radiation differing from direct  |
C |                              (variable RADsod must still be included)  |
C |                                                                        |
C |   Preprocessing  Option: SISVAT PHYSICS: Col de Porte                  |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^                  |
C | #                        #CP: SBL,                       Col de Porte  |
C | #                        #cp  Solar Radiation,           Col de Porte  |
C | #                        #AG: Snow Ageing,               Col de Porte  |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # ANI.yyyymmdd.LAB.nc  | #NC: OUTPUT on NetCDF File (Stand Alone EXP.) |
C |                        |                                               |
C | # SISVAT_iii_jjj_n     | #E0: OUTPUT on ASCII  File (SISVAT Variables) |
C | #                      |(#E0  MUST BE PREPROCESSED BEFORE #e1 & #e2 !) |
C | # SISVAT_iii_jjj_n     ! #e1: OUTPUT/Verification: Energy Conservation |
C | # SISVAT_iii_jjj_n     ! #e2: OUTPUT/Verification: Energy Consrv.2e pt.|
C |                        |                           (no premature stop) |
C |                        |                                               |
C | # SISVAT_iii_jjj_n     | #m0: OUTPUT/Verification: H2O    Conservation |
C | # SISVAT_iii_jjj_n     | #m1: OUTPUT/Verification: * Mass Conservation |
C | # SISVAT_iii_jjj_n     | #m2: OUTPUT/Verification: SeaIce Conservation |
C |                        |                                               |
C | # SISVAT_zSn.vz        | #vz: OUTPUT/Verification: Snow Layers Agrega. |
C |                        |      unit 41, SubRoutine  SISVAT_zSn **ONLY** |
C | # SISVAT_qSo.vw        | #vw: OUTPUT/Verif+Detail: H2O    Conservation |
C |                        |      unit 42, SubRoutine  SISVAT_qSo **ONLY** |
C | # SISVAT_qSn.vm        | #vm: OUTPUT/Verification: Energy/Water Budget |
C |                        |      unit 43, SubRoutine  SISVAT_qSn **ONLY** |
C | # SISVAT_qSn.vu        | #vu: OUTPUT/Verification: Slush  Parameteriz. |
C |                        |      unit 44, SubRoutine  SISVAT_qSn **ONLY** |
C | # SISVAT_wEq.ve        | #ve: OUTPUT/Verification: Snow/Ice Water Eqv. |
C |                        |      unit 45, SubRoutine  SISVAT_wEq **ONLY** |
C | # SnOptP____.va        | #va: OUTPUT/Verification: Albedo Parameteriz. |
C |                        |      unit 46, SubRoutine  SnOptP     **ONLY** |
C | # SISVAT_GSn.vp        | #vp: OUTPUT/Verification: Snow   Properties   |
C |                        |      unit 47, SubRoutines SISVAT_zSn, _GSn    |
C | # PHY_SISVAT.v0        | #v0: OUTPUT/Verification: DUMP                |
C |                        |      unit 50, SubRoutine  PHY_SISVAT **ONLY** |
C |                        |                                               |
C | # stdout               | #s0: OUTPUT of Snow Buffer Layer              |
C |                        |      unit  6, SubRoutine  SISVAT     **ONLY** |
C | # stdout               | #wx: OUTPUT/Verification: specified i,j,k,n   |
C | # stdout               | #wz: OUTPUT of Roughness Length (Blown Snow)  |
C |                        |      unit  6, SubRoutines SISVAT, PHY_SISVAT  |
C |                        |                                               |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARCTR.inc"
      include  "MARphy.inc"

      include  "MARdim.inc"
      integer   mw0
      parameter(mw0=3)
      include  "MARgrd.inc"
      include  "MAR_GE.inc"

      include  "MAR_RA.inc"

      include  "MAR_LB.inc"
      include  "MAR_DY.inc"
c #HY include  "MAR_HY.inc"
c #BW include  "MAR_TE.inc"
      include  "MAR_TU.inc"

c #TC include  "MAR_TC.inc"

      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"

      include  "MAR_SL.inc"
c #AO include  "MAR_AO.inc"
      include  "MAR_TV.inc"
      include  "MAR_BS.inc"
c #SN include  "MARsSN.inc"
c #IB include  "MAR_IB.inc"

      include  "MARsIB.inc"
c #PO include  "MAR_PO.inc"

      include  "MAR_WK.inc"

      integer   ihamr_SIS ,nhamr_SIS          ! Hamming Filter Counters
      integer   newglfSIS                     !
      integer   newsicSI                      !

      real          rtime
      integer       ntime
      common/c_time/ntime


C +--INTERFACE Variables
C +  ===================

      include  "MARxSV.inc"
C +--Level of negligible blown Snow Particles Concentration
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE integer                 kB
c #AE common  /SISVAT_MAR__BS/kB

C +--10-m Level
C +  ~~~~~~~~~~
        integer                  kSBL
        common /PHY_SISVAT_SBLi/ kSBL
        real                     rSBL10,VV__10(mx,my)
        common /PHY_SISVAT_SBLr/ rSBL10

C +--V,  dT(a-s)    Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AW real             V__mem(klonv,ntaver)   ! ntaver defined in MAR_SL.inc
c #AW real             VVmmem(klonv)          !
c #AW common/SVeSBLmem/V__mem,VVmmem          !
c #AH real             T__mem(klonv,ntaver)   !
c #AH real             dTmmem(klonv)          !
c #AH common/STeSBLmem/T__mem,dTmmem          !

!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/SVeSBLmem/,/STeSBLmem/)

C +--u*, u*T*, u*s* Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM real             u__mem(klonv,ntaver)   ! ntaver defined in MAR_SL.inc
c #AT real             uT_mem(klonv,ntaver)   !
c #AS real             us_mem(klonv,ntaver)   !
c #AM common/S_eSBLmem/u__mem                 !
c #AT.                ,uT_mem                 !
c #AS.                ,us_mem                 !

C +--OUTPUT for Stand Alone NetCDF File
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #NC real          SOsoKL(klonv)             ! Absorbed Solar Radiation
c #NC real          IRsoKL(klonv)             ! Absorbed IR    Radiation
c #NC real          HSsoKL(klonv)             ! Absorbed Sensible Heat Flux
c #NC real          HLsoKL(klonv)             ! Absorbed Latent   Heat Flux
c #NC real          HLs_KL(klonv)             ! Evaporation
c #NC real          HLv_KL(klonv)             ! Transpiration
c #NC common/DumpNC/SOsoKL,IRsoKL
c #NC.             ,HSsoKL,HLsoKL
c #NC.             ,HLs_KL,HLv_KL

c #NC real          SOsoNC(mx,my,nvx)         ! Absorbed Solar Radiation
c #NC real          IRsoNC(mx,my,nvx)         ! Absorbed IR    Radiation
c #NC real          HSsoNC(mx,my,nvx)         ! Absorbed Sensible Heat Flux
c #NC real          HLsoNC(mx,my,nvx)         ! Absorbed Latent   Heat Flux
c #NC real          HLs_NC(mx,my,nvx)         ! Evaporation
c #NC real          HLv_NC(mx,my,nvx)         ! Transpiration
c #NC real          eta_NC(mx,my,nvx)         ! Soil Humidity
c #NC common/writNC/SOsoNC,IRsoNC             !
c #NC.             ,HSsoNC,HLsoNC             !
c #NC.             ,HLs_NC,HLv_NC,eta_NC      !

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx integer             iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1
! #wx common/SISVAT_EV/   iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1


C +--Internal  Variables
C +  ===================

      logical StandA
      logical glfFIX

      integer                  ijnmax,nvcmax  ! Control Indices Distribution
      common  /SISVAT_MAR_Loc/ ijnmax,nvcmax  ! Control Indices Distribution
      integer k2i(klonv)                      ! Distributed i      Index
      integer k2j(klonv)                      ! Distributed j      Index
      integer k2n(klonv)                      ! Distributed mosaic Index
c #VR integer               ij0ver(mx,my,mw)  ! Verification of Vectorization
c #VR integer               ij_ver(mx,my,mw)  ! Verification of Vectorization
c #VR integer           ij2,ijdver(mx,my,mw)  ! Verification of Vectorization

      character*1   cha  ,chb
      integer iwr  ,ipt  ,l,nvcmax2,ijnmax2
      integer ikl  ,isl  ,isn
      integer ijn  ,ij   ,nnn
      integer nvc  ,nkl  ,n     ,nt

      real     slopx ,slopy                   ! Surf.Slope, x, y
      real     czemin                         ! Minimum accepted 
C +                                           ! cos(Solar zenith.Dist.)
      real     Upw_IR(mx,my)                  ! Upward IR Flux
      real     IR_aux                         ! Upward IR Flux  (dummy)

      real     uqstar                         ! u*q*
      real     rhAir                          ! Air    Densitity
      real     Ua_min                         ! Minimum Air Velocity
      real     rr__DR(mx,my,mw)               ! Desagregated  Rain    
      real     hfra  (mx,my,mw)               ! Frazil Thickness
      real     Rnof  (mx,my,mw)               ! RunOFF Intensity
      real     d_snow,SnowOK                  ! Snow Precip.: Total       
      real     dbsnow                         ! Snow Precip.: from Drift
c #SZ real     dsastr(mx,my)                  ! z0(Sastrugi): Variation

      real     WVaLim(mx,my)                  !

      real                    FixSST,VarSST   ! SST forcing switch
      real                           SSTnud   ! SST Nudging Rate
      common  /SISVAT_MAR_ocn/FixSST,VarSST   !
     .                              ,SSTnud   !

c #SI real     ifra_t                         !
cXF
c #SI real     SrfSIC,SIc0OK                  ! Oceanic Fraction: previous
c #SI real     FraOcn,SIceOK                  ! Oceanic Fraction
c #SI real     TocnSI                         ! Ocn Temp.=> S-Ice Covered
c #SI real     OcnMin                         ! Oceanic Fraction: Minimum
c #SI real     dzSIce(4)                      ! Sea-Ice Layers    Thickness
c #SI real     SIcMIN                         ! Sea-Ice Layer Min Thickness
c #SI real     SIc_OK(2)                      ! Sea-Ice Switch
c #SN real     c1_zuo,c2_zuo,c3_zuo           ! Run Off Parameters
c #SN real     SnowWE                         ! Snow Water Equivalent[m w.e.]
c #SN real     rosNEW                         ! Added Snow Density    [kg/m3]
c #SN real     S_Eros,SnEros                  ! Snow Erosion (status) = (1,0)

c #BW integer  noUNIT
c #BW real     BlowST,SnowSB

c #WR integer  ifrVER(mx,my)                  ! Verification Variable: 
                                              ! Total Fraction must be 100%

      real     tairDY_2D(mx,my),qvDY_2D(mx,my)

C +--DATA
C +  ====

      data     StandA       /  .true. /
      data     glfFIX       /  .false./
      data     cha/'-'/
      data     chb/':'/

      data     czemin       /   1.e-3 /

c #SI data     TocnSI       / 270.70  /       ! Ocn Temp.=> S-Ice Covered
c #SI data     OcnMin       /   0.05  /       ! Oceanic Fraction: Minimum
c #SI data     dzSIce /0.5,0.05,0.001,0.0/    ! Sea-Ice Layers    Thickness
c #SI data     SIcMIN /0.1/                   ! Sea-Ice Layer Min Thickness
c #SI data     SIc_OK /1.0,0.00/              ! Sea-Ice Switch
C +
c #SN data    c1_zuo/12.960e+4/,c2_zuo/2.160e+6/,c3_zuo/1.400e+2/ ! Zuoriginal
C #SN data    c1_zuo/ 2.796e+4/,c2_zuo/2.160e+6/,c3_zuo/1.400e+2/ !     Tuning
C +...        Run Off Parameters
C +           86400*1.5 day     ...*25 days (Modif. ETH Camp: 86400*0.3day)
C +           (Zuo and Oerlemans 1996, J.Glacio. 42, 305--317)


C +--SISVAT Time             Variable
C +  ================================

          dt__SV = dtPhys


C +   ++++++++++++++++  INITIALISATION: BEGIN +++
      IF (.not.INI_SV)                                            THEN
C +   ++++++++++++++++


C +--OUTPUT point (i,j,n) coordinates
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          iwr_SV = 1
          jwr_SV = 1
          nwr_SV = 1

C +--Level of negligible blown Snow Particles Concentration ( ~ 25 magl)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE        kB    =mz 
 11      CONTINUE
c #AE    IF (zsigma(kB    ).GT. 25..OR.kB    .LE.1)             GO TO 10
c #AE        kB    =kB    -1
c #AE                                                           GO TO 11
 10      CONTINUE
c #AE        write(6,1000)             kB
 1000        format(/,' BS : Level of negligible '
     .                     ,'blown Snow Particles Concentration is',i4
     .                     ,' (i.e., ~  25. magl)',/)

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx  iSV_v1= imez     ! Snow Erosion Statistics: Grid Point Coordinate
! #wx  jSV_v1= jmez     ! Id.
! #wx  nSV_v1= 1        ! Id.
! #wx  lSV_v1= 1        ! Snow Erosion Statistics: OUTPUT SWITCH (IF   >   0)
                        !                          .LE. 1 Blowing Snow
                        !                          .LE. 2 Blowing Snow (FULL)
                        !                          .EQ. 3 Snow    Agregation


C +--SISVAT Time Independant Variables
C +  =================================

c #sa                   StandA=.false.
        IF (VSISVAT.AND.StandA)                                   THEN
          write(6,600)
 600      format(/,'### MAR_SISVAT CRASH,',
     .                      ' STAND ALONE LABEL #sa is ON ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
          stop
        END IF

        IF (mw.ne.nvx)                                            THEN
          write(6,601) mw,nvx
 601      format(/,'### MAR_SISVAT CRASH, mw =',i6,
     .                            ' .NE. nvx =',i6,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
          stop
        END IF

c #SN   IF (mw.ne.nsx)                                            THEN
c #SN     write(6,602) mw,nsx
 602      format(/,'### MAR_SISVAT CRASH, mw =',i6,
     .                            ' .NE. nvx =',i6,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
c #SN     stop
c #SN   END IF

        IF (nsol+1.ne.llx)                                        THEN
          write(6,603)  nsol+1,llx
 603      format(/,'### MAR_SISVAT CRASH, ns =',i6,
     .                            ' .NE. nvx =',i6,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
          stop
        END IF

        IF (nb_wri.gt.mz      )                                   THEN
          write(6,604) nb_wri,mz
 604      format(/,'### MAR_SISVAT CRASH, nb_wri =',i6,
     .                            ' .GT. mz      =',i3,' ',2x,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
c         stop ! ERRRO if mw =5
        END IF

        IF (nb_wri.gt.mw *iptx)                                   THEN
          write(6,605) nb_wri,mw ,iptx
 605      format(/,'### MAR_SISVAT CRASH, nb_wri =',i6,
     .                            ' .GT. mw *iptx=',i3,'*',i2,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
          stop
        END IF

c #SN   IF (nb_wri.gt.nsx*iptx)                                   THEN
c #SN     write(6,606) nb_wri,nsx,iptx
 606      format(/,'### MAR_SISVAT CRASH, nb_wri =',i6,
     .                            ' .GT. nsx*iptx=',i3,'*',i2,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
c #SN     stop
c #SN   END IF

!c #SN   IF (mz    .LT.nsno    )                                   THEN
!c #SN     write(6,607) mzz   ,nsno     
 607      format(/,'### MAR_SISVAT CRASH, mz     =',i6,
     .                            ' .GT. nsno    =',i3,' ',2x,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
!c #SN     stop
!c #SN   END IF

c #BS   IF (klonv.ne.256)                                          THEN
c #BS     write(6,608) klonv
 608      format(/,'#BS MAR_SISVAT CRASH, klonv =',i6,'.ne.256 ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
c #BS     stop
c #BS   END IF


C +     ****************
        call  SISVAT_ini
C +     ****************


C +--Grids Correspondance
C +  --------------------

c #sa   DO isl = -nsol,0
c #sa     deptTV(1-isl)= dz_dSV(isl)
c #sa   END DO

            ntime  = 0

            ijnmax = mx2* my2* nvx
        IF      (mod(ijnmax ,klonv).eq.0)                         THEN
            nvcmax = ijnmax /klonv
        ELSE
            nvcmax = ijnmax /klonv + 1
        END IF
C +
C +
C +--Surface Fall Line Slope
C +  -----------------------
C +
c #SN   IF (SnoMod)                                               THEN
          IF (mx.eq.1.AND.my.eq.1)                                THEN
c #SN       SWfSNo(1,1)=                             ! Normalized Decay of the
c #SN.       exp(-dt__SV                             ! Surficial Water Content
c #SN.          /(c1_zuo                             !(Zuo and Oerlemans 1996,
c #SN.           +c2_zuo*exp(-c3_zuo*slopTV(1,1))))  ! J.Glacio. 42, 305--317)
          ELSE
            DO j=jp11,my1
            DO i=ip11,mx1
            slopx      =(sh(ip1(i),j)-sh(im1(i),j))*dxinv2
            slopy      =(sh(i,jp1(j))-sh(i,jm1(j)))*dyinv2
            slopTV(i,j)= sqrt(slopx *slopx + slopy *slopy)
c #SN       SWfSNo(i,j)=                             ! Normalized Decay of the
c #SN.       exp(-dt__SV                             ! Surficial Water Content
c #SN.          /(c1_zuo                             !(Zuo and Oerlemans 1996,
c #SN.           +c2_zuo*exp(-c3_zuo*slopTV(i,j))))  ! J.Glacio. 42, 305--317)
c #SN       slopGE(i,j)=    cos(atan(slopTV(i,j)))
            END DO
            END DO
          END IF
c #SN   END IF


C +--Initialization of Surface Types
C +  ===============================

        IF (itexpe.EQ.0)                                          THEN
          DO j=jp11,my1
          DO i=ip11,mx1
            IF (maskSL(i,j).eq. 1)                                THEN
                nSLsrf(i,j)   = 1                           ! Ocean Grid Pt
                SLsrfl(i,j,1) = 1.
              IF(mw.gt.1)                                         THEN
              DO n=min(2,mw),nvx
                SLsrfl(i,j,n) = 0.
              END DO
              END IF
            ELSE
                nSLsrf(i,j)   = nvx                         ! Land  Grid Pt
              DO n=1,nvx
                SLsrfl(i,j,n) = ifraTV(i,j,n)
                SLsrfl(i,j,n) = SLsrfl(i,j,n) * 0.01
              END DO
            END IF


C +--Initialization of z0(Sastrugi)
C +  ==============================

! Influence of the Angle(Wind,Sastrugi) (Andreas, 1995, CCREL report 95-16)
! -------------------------------------------------------------------------

c #ZA           ua_0BS(i,j)=uairDY(i,j,mz) 
c #ZA           va_0BS(i,j)=vairDY(i,j,mz) 


!  Sastrugi Height
!  ---------------

          DO n=1,mw
c #SZ           Z0SaBS(i,j,n)    = 0.
c #ZM       DO nt=1,ntavSL
c #ZM           SLn_z0(i,j,n,nt) = 0.5e-6
c #ZM           SLn_b0(i,j,n,nt) = 0.5e-6
c #ZM           SLn_r0(i,j,n,nt) = 0.5e-6
c #ZM       END DO
          END DO
          END DO
          END DO

        END IF


! Influence of the Angle(Wind,Sastrugi) (Andreas, 1995, CCREL report 95-16)
! -------------------------------------------------------------------------

c #ZA           FracBS=exp(-dt__SV/43200.)


C +--Initialization of z0(Orography Roughness)
C +  =========================================

c #OR    DO k=1,mw
c #OR    DO j=1,my
c #OR    DO i=1,mx
c #OR       SL_z0 (i,j,k) = min(SL_z0 (i,j,k),zsigma(mz)/3.)
c #OR       SLzoro(i,j,k) = min(SLzoro(i,j,k),zsigma(mz)/3.)
c #OR    END DO
c #OR    END DO
c #OR    END DO


C +--Ocean Status
C +  ============

c #SI         VarSST        =   0.
c #OP         VarSST        =   1.
              FixSST        =   1.-VarSST
              SSTnud        = exp(-dt__SV/2.592e6)  ! SST    Nudging:
C +...                                              ! e-folding time: 30 Days
C +
c #SI   IF (itexpe.EQ.0)                                          THEN
c #SI     DO j=jp11,my1
c #SI     DO i=ip11,mx1
c #SI       IF (maskSL(i,j).gt.0.AND.ifraTV(i,j,1).lt.100)        THEN
c #SI           write(6,6000)i,j,(ifraTV(i,j,n),n=1,nvx)
 6000           format(' WARNING on Grid Point',2i4,' Mosaic = (',3i4,
     .                 '): ISLANDS must(will) be excluded')
c #SI         DO n=1,nvx
c #SI           ifraTV(i,j,n) =   0
c #SI           ivegTV(i,j,n) =   0
c #SI         END DO
c #SI           ifraTV(i,j,1) = 100
c #SI       END IF
c #SI     END DO
c #SI     END DO


C +--Prescription from SST
C +  ---------------------

c #SI                                     Tfr_LB = TocnSI
c #RE                                     Tfr_LB = 271.35 + epsi
c #SI     DO j=jp11,my1
c #SI     DO i=ip11,mx1
c #SI        FraOcn          =    (TsolTV(i,j,1,1)-Tfr_LB)/TSIdSV! Open Ocean
c #IP        FraOcn          =  1.-sicsIB(i,j)                   ! Prescribed
c #SI        FraOcn          = min(  unun,FraOcn)                !      Fract.
c #SI        FraOcn          = max(OcnMin,FraOcn)                !
c #SI        SLsrfl(i,j,1)   =  (1-maskSL(i,j))  * SLsrfl(i,j,1) ! New  Ocean
c #SI.                          +  maskSL(i,j)   * FraOcn        !
c #SI        SrfSIC          =                     SLsrfl(i,j,2) ! Old  Sea Ice
c #SI        SIc0OK          = max(zero, sign(unun,SrfSIC-epsi)) !
c #SI        SLsrfl(i,j,2)   =  (1-maskSL(i,j))  * SLsrfl(i,j,2) ! New  Sea Ice
c #SI.                          +  maskSL(i,j)*(1.-FraOcn)       !
c #SI        SIceOK          = max(zero, sign(unun,SLsrfl(i,j,2) !
c #SI.                                                   -epsi)) !
c #SI        ifra_t          =     ifraTV(i,j,1) + ifraTV(i,j,2) ! OCN  Fract.
c #SI        ifraTV(i,j,1)   =     SLsrfl(i,j,1) * 100.          !
c #SI        ifraTV(i,j,1)   = min(ifraTV(i,j,1) , ifra_t)       !
c #SI        ifraTV(i,j,2)   =     ifra_t        - ifraTV(i,j,1) !

C +--Sea-Ice Vertical Discretization
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SI        nssSNo(i,j,2)   =  
c #SI.       nssSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(nssSNo(i,j,2)   *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        nisSNo(i,j,2)   =  
c #SI.       nisSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(nisSNo(i,j,2)   *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI        issSNo(i,j,2)   =                    nisSNo(i,j,2)

c #SI       DO l=1,nsno
c #SI        dzsSNo(i,j,2,l) =
c #SI.       dzsSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(dzsSNo(i,j,2,l) *    SIc0OK
c #SI.      +dzSIce(min(4,l))*(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        tisSNo(i,j,2,l) =
c #SI.       tisSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(tisSNo(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,1) *(1.-SIc0OK)       )*maskSL(i,j)

c #SI        rosSNo(i,j,2,l) =
c #SI.       rosSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(rosSNo(i,j,2,l) *    SIc0OK
c #SI.      +ro_Ice          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        g1sSNo(i,j,2,l) =
c #SI.       g1sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g1sSNo(i,j,2,l) *    SIc0OK
c #SI.      +G1_dSV          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        g2sSNo(i,j,2,l) =
c #SI.       g2sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g2sSNo(i,j,2,l) *    SIc0OK
c #SI.      +30.             *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        nhsSNo(i,j,2,l) =
c #SI.       nhsSNo(i,j,2,l)                  *(1-maskSL(i,j))
C #SI.new  +(nhsSNo(i,j,2,l) *    SIc0OK
C #SI.new   +istdSV(2)       *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI.     + istdSV(2)       *                    maskSL(i,j)
c #SI       END DO
c #SI       DO l=1,llx
c #SI        TsolTV(i,j,2,l) =
c #SI.       TsolTV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(TsolTV(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,l) *(1.-SIc0OK)       )*maskSL(i,j)

c #SI        eta_TV(i,j,2,l) =
c #SI.       eta_TV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     + eta_TV(i,j,2,l) *    SIc0OK  *       maskSL(i,j)
C +...                            No Pore in Ice => No Water
c #SI       END DO

c #WI        write(6,6001) jdarGE,labmGE(mmarGE),iyrrGE
c #WI.                    ,jhurGE,minuGE,jsecGE ,TsolTV(i,j,1,1)
c #WI.                    ,FraOcn,ifraTV(i,j,1) ,TsolTV(i,j,2,1)
c #WI.                    ,       nisSNo(i,j,2) ,nssSNo(i,j,2)
 6001        format(/,98('_'),
     .              /,i3,'-',a3,'-',i4,3(':',i2),
     .                2x,'T OCN = ',f7.3,4x,'% OCN = ',f7.3,'(',i3,')',
     .                2x,'T ICE = ',f7.3,
     .             /,42x,'NbIce = ',i3, 11x,'NbSno = ',i3)

c #SI     END DO
c #SI     END DO
c #SI   END IF


C +--Soil Upward IR Flux
C +  ===================

        IF (itexpe.EQ.0)                                          THEN
          DO j=jp11,my1
          DO i=ip11,mx1
            IR_aux        =
     .     -eps0SL(i,j)* stefan*TairSL(i,j)*TairSL(i,j)    ! Upward IR Flux
     .                         *TairSL(i,j)*TairSL(i,j)    !
          DO n=   1,nvx
            IRsoil(i,j,n) =     IR_aux
          END DO


C +--Water Vapor Flux Limitor
C +  ========================

c #VX     DO n=   1,nLimit
c #VX       WV__SL(i,j,n) =     1.
c #VX     END DO

          END DO
          END DO


C +--SBL  Characteristics
C +  ====================

c #AA     DO nt=  1,ntaver
c #AA     DO j=   1,my
c #AA     DO i=   1,mx
c #AW       V_0aSL(i,j,  nt) =  ssvSL(i,j,mz)
c #AH     DO n=   1,nvx
c #AH       dT0aSL(i,j,n,nt) = tairDY(i,j,mz)-tsrfSL(i,j,n)
c #AH     END DO
c #AA     END DO
c #AA     END DO
c #AA     END DO

        END IF


C +--OUTPUT Files Definition
C +  =======================

! #v0   open(unit=50,status='unknown',file='PHY_SISVAT.v0')
! #v0   rewind    50
    
        IF (mmy.LE.1.AND.mw.GT.mw0)                               THEN
            open(unit=51,status='unknown',file='Dsagrr.OUT')
            rewind    51
            write(51,5100) 
 5100       format(/,' Simple Disagregation Model',
     .             /,' ==========================')
        END IF

           iwr = 0
        DO ipt = 1,iptx
           IF (IOi_TV(ipt).EQ.0) IOi_TV(ipt)=imez
           IF (IOj_TV(ipt).EQ.0) IOi_TV(ipt)=jmez
        DO n   = 1,nvx
           iwr = 1+iwr
          IF (iwr.LE.nb_wri)                                      THEN
           no__SV(iwr) = 0
           i___SV(iwr) = IOi_TV(ipt)
           j___SV(iwr) = IOj_TV(ipt)
           n___SV(iwr) = n
          END IF
        END DO
        END DO


C +--Initialization of V10 Interpolation
C +  ===================================

        if   (zsigma(1).GT.10.          )                           THEN
          k = 0
  301     CONTINUE
          k = k + 1
            if (zsigma(k).LT.10.OR.k.gt.mz)                    GO TO 300
                                                               GO TO 301
  300     CONTINUE
          kSBL = k

          IF (kSBL.EQ.mz)                                           THEN
              rSBL10 = log(10.           / 0.002)    ! 0.002: typical Z0
     .                /log(zsigma(kSBL)  / 0.002)    !

          ELSE
              rSBL10 =    (10.           - zsigma(kSBL))
     .                /   (zsigma(kSBL-1)- zsigma(kSBL))
          END IF
        ELSE
              kSBL   =     mz
              rSBL10 =      1.
        END IF


C +   ++++++
      END IF
C +   ++++++       +++  INITIALISATION:  END  +++


C +--Preparation    of V10 Interpolation
C +  ===================================

        IF (kSBL.EQ.mz)                                             THEN
          DO j=1,my
          DO i=1,mx
            VV__10(i,j) = rSBL10 *  ssvSL(i,j,kSBL)
          ENDDO
          ENDDO
        ELSE
          DO j=1,my
          DO i=1,mx
            VV__10(i,j) =           ssvSL(i,j,kSBL)
     .                  + rSBL10 * (ssvSL(i,j,kSBL-1)-ssvSL(i,j,kSBL))
          ENDDO
          ENDDO
        END IF


C +--Preparation    of OUTPUT
C +  ========================

        DO n=   1,nvx
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz1(i,j,n) = 0.
        END DO
        END DO
        END DO
        DO iwr = 1,nb_wri
          WKxyz1(i___SV(iwr),j___SV(iwr),n___SV(iwr)) = iwr
        END DO


C +--Update Sea-Ice    Fraction
C +  ==========================

c #IP IF (             reaLBC                    )                THEN

C +          ******
c #IP   call INIsic(ihamr_SIS,nhamr_SIS,newsicSI )
C +          ******

c #IP END IF


C +--Update Green Leaf Fraction
C +  ==========================

c #GP                                      glfFIX = .true.
c #sa IF (vegmod .AND. reaLBC .AND.  .NOT. glfFIX)                THEN
C +
C +          ******
c #sa   call INIglf(ihamr_SIS,nhamr_SIS,newglfSIS)
C +          ******
C +
c #sa END IF


C +--SISVAT Time   Dependant Variables
C +  =================================

C +--Water Vapor Flux Limitor
C +  ------------------------

c #VX DO n=1,nLimit-1
c #VX DO j=jp11,my1
c #VX DO i=ip11,mx1
c #VX   WV__SL(i,j,n) = WV__SL(i,j,n+1)
c #VX END DO
c #VX END DO
c #VX END DO

c #VX DO j=jp11,my1
c #VX DO i=ip11,mx1
c #VX   uqstar    = max(abs(SLuqs(i,j)),epsi)*sign(1.,SLuqs(i,j))
c #VX   WV__SL(i,j,n) 
c #VX. = TUkvh(i,j,mmz1) *(  qvDY(i,j,km2(mz))-  qvDY(i,j,mmz1))
c #VX. /(uqstar          *(zsigma(    km2(mz))-zsigma(    mmz1)))
c #VX END DO
c #VX END DO

c #VX DO j=jp11,my1
c #VX DO i=ip11,mx1
c #VX     WVaLim(i,j) = 0.
c #VX   DO n=1,nLimit
c #VX     WVaLim(i,j) = WVaLim(i,j)+WV__SL(i,j,n)
c #VX   ENDDO
c #VX     WVaLim(i,j) = WVaLim(i,j)/nLimit
c #VX END DO
c #VX END DO


C +--Grid Averages
C +  -------------

      DO j=jp11,my1
      DO i=ip11,mx1
c #WR   ifrVER(i,j)   = 0
CCCCC   RAdsol(i,j)   = sol_SL(i,j)/(1.d0-albeSL(i,j))     ! => downward Solar
        albeSL(i,j)   = 0.
        eps0SL(i,j)   = 0.
        Upw_IR(i,j)   = 0.
         SLlmo(i,j)   = 0.
         SLuus(i,j)   = 0.
         SLuts(i,j)   = 0.
         SLuqs(i,j)   = 0.
c #HY   uss_HY(i,j)   = 0.
c #HY   qsrfHY(i,j)   = 0.
        TairSL(i,j)   = 0.
        draiTV(i,j)   = 0.
c #TC     uqTC(i,j,1) = 0.
c #TC     qsTC(i,j,1) = 0.


C +--Sastrugi Height decreased by Precipitation if V < 6 m/s (Kotlyakov, 1961)
C + --------------------------------------------------------------------------

c #SZ   dsastr(i,j) =       max(0.00,(snowHY(i,j)-sno0HY(i,j))
c #SZ. /max(0.05,0.104*sqrt(max(0.00, VV__10(i,j)-6.00       ))))


! Influence of the Angle(Wind,Sastrugi) (Andreas, 1995, CCREL report 95-16)
! -------------------------------------------------------------------------

c #ZA   S_Eros     = max(zero,sign(unun,-uss_HY(i,j)-eps9))
c #ZA   SnEros     = max(zero,sign(unun, uss_HY(i,j)+eps9))
c #ZA   VVs_BS(i,j) =    
c #ZA.           SnEros* VVs_BS(i,j)
c #ZA.         + S_Eros*(VVs_BS(i,j)   * FracBS +
c #ZA.                                   VV__10(i,j))
c #ZA   RRs_BS(i,j) =    
c #ZA.           SnEros* RRs_BS(i,j)
c #ZA.         + S_Eros*(RRs_BS(i,j)   * FracBS + 1.0             )
c #ZA   DDs_BS(i,j) =    
c #ZA.           SnEros* DDs_BS(i,j)
c #ZA.         + S_Eros* DDs_BS(i,j)   * FracBS 
c #ZA.         +       ((vairDY(i,j,mz)*(uairDY(i,j,mz) -ua_0BS(i,j))
c #ZA.                  -uairDY(i,j,mz)*(vairDY(i,j,mz) -va_0BS(i,j))))
c #ZA.   /(degrad*max(0.3,ssvSL(i,j,mz)*  ssvSL(i,j,mz)))
      END DO
      END DO
c #ZA DO j=jp11,my1
c #ZA DO i=ip11,mx1
c #ZA    IF (DDs_BS(i,j).GT.360.) DDs_BS(i,j) = DDs_BS(i,j) - 360.
c #ZA    IF (DDs_BS(i,j).LT.  0.) DDs_BS(i,j) = DDs_BS(i,j) + 360.
c #ZA END DO
c #ZA END DO


C +--Simple "Mosaic" Rain Disagregation Model
C +  ----------------------------------------

      IF (mmy.LE.1.AND.mw.gt.mw0)                                 THEN !

C +--White Noise Generator
C +  ~~~~~~~~~~~~~~~~~~~~~
        IF (jhurGE.EQ.6.AND.minuGE.EQ.0.AND.jsecGE.EQ.0)          THEN
          rtime=      tairDY(imez,jmez,mz)*1.e3
          ntime= int(rtime)
          rtime=    (rtime -ntime)        *1.e3
          ntime=     rtime
          ntime= mod(ntime ,mw)+1
        END IF

C +--Averaged Soil Humidity
C +  ~~~~~~~~~~~~~~~~~~~~~~
        DO j=1,my
        DO i=1,mx
          WKxy1( i,j) = 0.                            ! Averaged Soil Humidity
        DO n=1,mw                                     !
        DO k=-nsol,0                                  !
          WKxy1( i,j) = WKxy1( i,j)                   !
     .                +eta_TV( i,j,n,1-k)*dz_dSV(k)   !
        END DO                                        !
        END DO                                        !
          WKxy1( i,j) = WKxy1( i,j) / (mw*zz_dSV)     !

C +--Rain Distribution !  Rain Persistance over "wetter" surfaces
C +  ~~~~~~~~~~~~~~~~~ ! (Taylor et al., 1997, MWR 125, pp.2211-2227)
          WKxy2( i,j)   = 0.                          ! Normalization Factor
        DO n=1,mw                                     !
          rr__DR(i,j,n) =  (mod( mw-n+ntime,mw) + 1)  ! Rain Distribution Arg.
     .     /(mw*WKxy1( i,j)     *WKxy1( i,j))         ! dry ===> sparse Rain
     .     *    eta_TV(i,j,n,1) /WKxy1( i,j)          ! Persistance   Impact
          rr__DR(i,j,n) =   min( rr__DR(i,j,n)        ! 
     .                          ,argmax*0.1   )       ! 
          rr__DR(i,j,n) =   exp(-rr__DR(i,j,n))       ! Rain Distribution
          k             =      ( n -1   ) / mw0       ! mw0 basic Mosaics
          k             =        k        * mw0 + 1   !
          rr__DR(i,j,n) =        rr__DR(i,j,k)        ! Rain Distribution Arg.
          WKxy2( i,j)   =        WKxy2( i,j)          ! Normalization Factor
     .                  +        rr__DR(i,j,n)        ! 
        END DO                                        !

        END DO
        END DO

        DO j=1,my
        DO i=1,mx
        DO n=1,mw
          rr__DR(i,j,n) = rr__DR(i,j,n)  *mw
     .                   /WKxy2( i,j)
        END DO
        END DO
        END DO

        IF(mod(jdarGE,3).EQ.0.AND.jhurGE.EQ.6.AND.
     .                            minuGE.EQ.0.AND.
     .                            jsecGE.EQ.0.AND.
     .     mmy          .LE.1                     )                 THEN
          DO i=1,mx
            IF      (isolSL(i,1).gt.2)                              THEN
              write(51,5101) jdarGE, labmGE(mmarGE) ,iyrrGE,jhurGE,
     .                       i     ,(eta_TV(i,1,n,1),n=1,mw)
 5101         format(i3,'-',a3,'-',i4,':',i2,i6,15f6.3,/,(21x,15f6.3))
              write(51,5102) 
     .        ntime,  isolSL(i,1)  ,(rr__DR(i,1,n)  ,n=1,mw)
 5102         format(i12,3x                 ,i6,15f6.2,/,(21x,15f6.2))
            END IF
          END DO
              write(51,5103)
 5103         format(111('-'))
        END IF
      ELSE
        DO j=1,my
        DO i=1,mx
        DO n=1,mw
          rr__DR(i,j,n) = 1.
        END DO
        END DO
        END DO
      END IF

c     - Interpolation of temp. and spec. hum. on sub_grid - *CL*
c     --------------------------------------------------------------

      do i=1,mx; do j=1,my
       do n=1,nsx
        tairDY_int(i,j,n) = tairDY(i,j,mz)
          qvDY_int(i,j,n) =   qvDY(i,j,mz)
           tairDY_2D(i,j) = tairDY(i,j,mz)
             qvDY_2D(i,j)   = qvDY(i,j,mz)
       enddo
      enddo; enddo

      IF (mw .eq. 5) then
C +       ************************************************************
          call interp_subpix(tairDY_2D,tairDY_int,1,-0.01,0.05
     .                       ,gradTM)
C +       ************************************************************

C +       ************************************************************
          call interp_subpix(qvDY_2D,qvDY_int,2,-1.0,1.0
     .                       ,gradQM)
C +       ************************************************************
      ENDIF


C +--Grid  Point   Dependant Variables
C +  ---------------------------------

C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR         ij2           = 0
c #VR     DO n=   1,mw
c #VR     DO j=jp11,my1
c #VR     DO i=ip11,mx1
c #VR         ij0ver(i,j,n) = 0
c #VR         ij_ver(i,j,n) = 0
c #VR         ijdver(i,j,n) = 0
c #VR     END DO
c #VR     END DO
c #VR     END DO

C +--SISVAT Variables Update
C +  ^^^^^^^^^^^^^^^^^^^^^^^

cXF
       ijnmax2=0
       do i=ip11,mx1
        do j=jp11,my1
         do n=1,mw
          if(SLsrfl(i,j,n)>0) ijnmax2=ijnmax2+1
         enddo
        enddo
       enddo
      
       IF (mod(ijnmax2 ,klonv).eq.0) THEN
             nvcmax2 = ijnmax2 /klonv
       ELSE
             nvcmax2 = ijnmax2 /klonv + 1
       END IF

       IF(mx==1) nvcmax2=1 
cXF
              ijn         = 0
              nnn         = 0
      DO      nvc         = 1,nvcmax2
              nnn         = nnn+klonv

          DO  ikl         = 1,klonv
2000          continue
              ijn         =           ijn      + 1
                n         = nvx - mod(ijn,nvx)
              ij          = 1   +    (ijn-  1)/nvx
               j          = my1 - mod(ij ,my2)
              i           = ip11+    (ij -  1)/my2
              i           =       min(mx1,  i)
              if (SLsrfl(i,j,n)==0) goto 2000
              k2i(ikl)    = i
              k2j(ikl)    = j
              k2n(ikl)    = n
           ENDDO
 
           DO  ikl = 1,klonv
                      i   = k2i(ikl)
                      j   = k2j(ikl)
                      n   = k2n(ikl)
              ii__SV(ikl) = i                              ! Work pt. i Coord.
              jj__SV(ikl) = j                              ! Work pt. j Coord.
              nn__SV(ikl) = n                              ! Work pt. n Coord.

! #wz         IF (ikl.EQ.1.AND.jsecGE.EQ.0) 
! #wz.        write(6,6659) 
 6659         format(20x,'   dsn_SV   us__SV   Z0SaSi   Z0Sa_N'
     .                  ,'   Z0SaSV   Z0m_Sn   Z0m_SV')

C +--Atmospheric Forcing                                    (INPUT)
C +  ^^^^^^^^^^^^^^^^^^^                                     ^^^^^
              zSBLSV      =    z__SBL                      ! [m]
              za__SV(ikl) =   (gplvDY(i,j,mz)              !
     .                        -gplvDY(i,j,mzz)) *grvinv    ! [m]
              VV__SV(ikl) =     ssvSL(i,j,mz)              !
              VV10SV(ikl) =    VV__10(i,j)                 !
c #ZA         VVs_SV(ikl) =    VVs_BS(i,j)/RRs_BS(i,j)     !
c #ZA         DDs_SV(ikl) =       max(zero,DDs_BS(i,j)-180.)
c #ZA.        +180.*min(unun,zero-min(zero,DDs_BS(i,j)-180.))
c #ZA.                           +min(zero,DDs_BS(i,j)-180.)
              Ua_min      =  epsi                          !
c #VM         Ua_min      =  0.2 * sqrt(za__SV(ikl)   )    !
              VV__SV(ikl) =  max(Ua_min, ssvSL(i,j,mz))    !
              TaT_SV(ikl) =tairDY_int(i,j,n)               !
              ExnrSV(ikl) =      pkDY(i,j,mz)              !
              rhT_SV(ikl) =   (pstDYn(i,j)   +ptopDY)*1.e3 ! [kg/m3] *CL*
     .                       /(tairDY_int(i,j,n)*RDryAi)   !
              QaT_SV(ikl) =  qvDY_int(i,j,n)               !
c #VX         dQa_SV(ikl) =  max(0.,1.-WVaLim(i,j))        ! Water  Vapor
c #VX.                        * dtDiff/zsigma(mz)          ! Flux Limitor
              qsnoSV(ikl) =      0.                        !
c #HY.                 +min(demi,qsHY(i,j,mz)              !
c #TC.                       +   qxTC(i,j,mz,1)            !
c #HY.                                         )           !

C +--Energy Fluxes                                          (INPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^
              coszSV(ikl) = max(czemin,czenGE(i,j))        ! cos(zenith.Dist.)
              sol_SV(ikl) =            RAdsol(i,j)         !    downward Solar
              IRd_SV(ikl) =            RAd_ir(i,j)         !    downward IR

C +--Water  Fluxes                                          (INPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^
c #HY         drr_SV(ikl) =(rainHY(i,j)-rai0HY(i,j))*1.e3  ! [m/s] -> [mm/s] 
c #HY.                    * rr__DR(i,j,n)           /dtPhys!          [kg/m2/s]
c #HY         d_snow      = snowHY(i,j)-sfa0HY(i,j)        ! Only SnowFall
c #HY         dsn_SV(ikl) = d_snow                  *1.e3  ! Erosion NOT incl.
c #HY.                                              /dtPhys!
c #HY         SnowOK      =                                ! Correction
c #HY.     max(zero,sign(unun,         qsHY(i,j,mz)-epsi)) !
c #HY.    *max(zero,sign(unun,TfSnow-tairDY_int(i,j,n)-epsi)) !
c #HY         dsn_SV(ikl) = dsn_SV(ikl)+drr_SV(ikl)*SnowOK !
c #HY         drr_SV(ikl) = drr_SV(ikl)        *(1.-SnowOK)!
c #BS         dbsnow      =-SLussl(i,j,n)                  ! Erosion
c #BS.                     *dtPhys     *rhT_SV(ikl)        !
! #BS         dsnbSV(ikl) =min(max(zero,dbsnow)            !
! #BS.                    /    max(epsi,d_snow),unun)      !
c #BS         dsnbSV(ikl) =1.0-min(qsHY(i,j,kB)            ! kB level ~ 25 magl
c #BS.                        /max(qsHY(i,j,mz),eps9),unun)!(BS negligib.at kB)
!             dsnbSV is used and modified in SISVAT_BSn,
!                  then used for Buffer Layer Update
c #BS         dbs_SV(ikl) = blowSN(i,j,n)                  !          [kg/m2]

C +--Soil/Canopy                                            (INPUT)
C +  ^^^^^^^^^^^                                             ^^^^^
              LSmask(ikl)= 1  - maskSL(i,j)                ! Land/Sea   Mask
              isotSV(ikl)     = isolTV(i,j)                ! Soil       Type
              iWaFSV(ikl)     = iWaFTV(i,j)                ! Soil Drainage
c #SN         slopSV(ikl)= atan(slopTV(i,j))               ! Fall Line Slope
              alb0SV(ikl)     = AlbSTV(i,j)                ! Soil Albedo
              ivgtSV(ikl)     = ivegTV(i,j,n)              ! Vegetation Type
              LAI0SV(ikl)     = alaiTV(i,j,n)              ! LAI
              glf0SV(ikl)     = glf_TV(i,j,n)              ! Green Leaf Frac.

C +--Energy Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              cld_SV(ikl) =     cld_SL(i,j)                ! Cloudiness
              IRs_SV(ikl) =     IRsoil(i,j,n)              ! Soil upward IR
              LMO_SV(ikl) =     SLlmol(i,j,n)              ! Monin-Obukhov L.
              us__SV(ikl) =     SLuusl(i,j,n)              ! Frict. Velocity
              uts_SV(ikl) =     SLutsl(i,j,n)              ! u*T*

C +--Water  Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              uqs_SV(ikl) =     SLuqsl(i,j,n)              ! u*q*
              uss_SV(ikl) =     SLussl(i,j,n)              ! u*s*
c #AE         usthSV(ikl) =     SaltSN(i,j,n)              ! u*_th

C +--Soil/Canopy                                            (INPUT/OUTPUT)
C +  ^^^^^^^^^^^                                             ^^^^^^^^^^^^
              Z0m_SV(ikl) =      SL_z0(i,j,n)              ! Moment.Roughn.L.
              Z0h_SV(ikl) =      SL_r0(i,j,n)              ! Heat   Roughn.L.
c #OR         Z0roSV(ikl) =     SLzoro(i,j,n)              ! Orogr. Roughn.L.
              TvegSV(ikl) =     TvegTV(i,j,n)              ! Vegetation Temp.
              snCaSV(ikl) =     CaSnTV(i,j,n)              ! Canopy SnowCover
              rrCaSV(ikl) =     CaWaTV(i,j,n)              ! Canopy RainWater
              psivSV(ikl) =     psivTV(i,j,n)              ! Vegetation Pot.
            DO isl =   -nsol,0
              TsisSV(ikl,isl) = TsolTV(i,j,n,1-isl)        ! Soil Temperature
              eta_SV(ikl,isl) = eta_TV(i,j,n,1-isl)        ! Soil Humidity
            END DO
c #vL     ENDDO

C +--Snow Roughness                                         (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^^                                          ^^^^^^^^^^^^
c #vL     DO  ikl = 1,klonv
c #vL         i   = k2i(ikl)
c #vL         j   = k2j(ikl)
c #vL         n   = k2n(ikl)

C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR        IF (ijn.LE.ijnmax)                       THEN !
c #VR         ij0ver(i,j,n) = ij0ver(i,j,n) + 1            !
c #VR         ijdver(i,j,n) = ijdver(i,j,n) + ij           !
c #VR        ENDIF                                         !

c #ZM         Z0mmSV(ikl) =     0.                         !
c #ZM         Z0emSV(ikl) =     0.                         !
c #ZM         Z0hmSV(ikl) =     0.                         !
c #ZM       DO nt=   1,ntavSL                              !
c #ZM         Z0mmSV(ikl) =     Z0mmSV(ikl)                !
c #ZM.                    +     SLn_z0(i,j,n,nt)           !
c #ZM         Z0emSV(ikl) =     Z0emSV(ikl)                !
c #ZM.                    +     SLn_b0(i,j,n,nt)           !
c #ZM         Z0hmSV(ikl) =     Z0hmSV(ikl)                !
c #ZM.                    +     SLn_r0(i,j,n,nt)           !
c #ZM       ENDDO                                          !
c #ZM         Z0mmSV(ikl) = min(Z0mmSV(ikl)  /ntavSL       !  z0(Mom., Box Av.)
c #ZM.                         ,zsigma(mz)   /    3.)      !
c #ZM         Z0emSV(ikl) =     Z0emSV(ikl)  /ntavSL       !  z0(Eros, Box Av.)
c #ZM         Z0hmSV(ikl) =     Z0hmSV(ikl)  /ntavSL       !  z0(Heat, Box Av.)

c #SZ         Z0SaSV(ikl) =     Z0SaBS(i,j,n)              !  z0(Sastrugi  h)
c #SZ         dz0_SV(ikl) = .01*dsastr(i,j)  *max(2-n,0)   ! dz0(Sastrugi dh)

C +--V,  dT(a-s)    Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AA       DO nt=1,ntaver
c #AW         V__mem(ikl,nt)     = V_0aSL(i,j,  nt)
c #AH         T__mem(ikl,nt)     = dT0aSL(i,j,n,nt)
c #AA       ENDDO

c #AA       DO nt=   1,ntaver-1
c #AW         V__mem(ikl,nt    ) = V__mem(ikl,nt+1)
c #AH         T__mem(ikl,nt    ) = T__mem(ikl,nt+1)
c #AA       ENDDO
c #AW         V__mem(ikl,ntaver) = VV__SV(ikl)
c #AH         T__mem(ikl,ntaver) = TaT_SV(ikl)-tsrfSL(i,j,n)

c #AW         VVmmem(ikl)        = 0.0
c #AH         dTmmem(ikl)        = 0.0
c #AA       DO nt=1,ntaver
c #AW         VVmmem(ikl)        = VVmmem(ikl)+V__mem(ikl,nt)
c #AH         dTmmem(ikl)        = dTmmem(ikl)+T__mem(ikl,nt)
c #AA       ENDDO
c #AW         VVmmem(ikl)        = VVmmem(ikl)/ntaver
c #AH         dTmmem(ikl)        = dTmmem(ikl)/ntaver

C +--u*, u*T*, u*s* Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM       DO nt=1,ntaver
c #AM         u__mem(ikl,nt)     = u_0aSL(i,j,n,nt)
c #AT         uT_mem(ikl,nt)     = uT0aSL(i,j,n,nt)
c #AS         us_mem(ikl,nt)     = us0aSL(i,j,n,nt)
c #AM       ENDDO
c #vL     ENDDO

c #vB     DO  ikl = 1,klonv
c #BS         Z0emBS(k2i(ikl),k2j(ikl),k2n(ikl)) = Z0emSV(ikl)
c #vB     ENDDO

C +--Snow Pack                                              (INPUT/OUTPUT)
C +  ^^^^^^^^^                                               ^^^^^^^^^^^^
c #vS     DO  ikl = 1,klonv
c #vS         i   = k2i(ikl)
c #vS         j   = k2j(ikl)
c #vS         n   = k2n(ikl)
c #SN         BufsSV(ikl)     = snohSN(i,j,n)              ! Snow Buffer Lay.
c #SN         dsn_SV(ikl)     = dsn_SV(ikl)                !
c #SN.                     +max(BufsSV(ikl)-SMndSV,0.)     !
c #SN.                     /    dt__SV                     !
c #SN         BufsSV(ikl) = min(BufsSV(ikl),SMndSV   )     !
c #SN         BrosSV(ikl)     = BrosSN(i,j,n)              ! Snow Buffer dens.
c #SN         BG1sSV(ikl)     = BG1sSN(i,j,n)              ! Snow Buffer D./S.
c #SN         BG2sSV(ikl)     = BG2sSN(i,j,n)              ! Snow Buffer S./S.
c #SN         isnoSV(ikl)     = nssSNo(i,j,n)              ! Nb Snow/Ice Lay.
c #SN         ispiSV(ikl)     = issSNo(i,j,n)              ! Nb Supr.Ice Lay.
c #SN         iiceSV(ikl)     = nisSNo(i,j,n)              ! Nb      Ice Lay.
c #SN         zWEcSV(ikl)     = zWEcSN(i,j,n)              ! Non-Erod.*Thick.
c #SN         rusnSV(ikl)     = SWaSNo(i,j,n)              ! Surficial Water
c #SN         SWS_SV(ikl)     = SWSSNo(i,j,n)              ! Surficial Wat.St.
c #SN         SWf_SV(ikl)     = SWfSNo(i,j)                ! Normalized Decay
c #vS     ENDDO
c #SN     DO  isn = 1,nsno
c #vS     DO  ikl = 1,klonv
c #vS         i   = k2i(ikl)
c #vS         j   = k2j(ikl)
c #vS         n   = k2n(ikl)
c #SN         istoSV(ikl,isn) = nhsSNo(i,j,n,isn)          !            [-]
c #SN         dzsnSV(ikl,isn) = dzsSNo(i,j,n,isn)          !            [m]
c #SN         ro__SV(ikl,isn) = rosSNo(i,j,n,isn)          !        [kg/m3]
c #SN         eta_SV(ikl,isn) = wasSNo(i,j,n,isn)          !        [m3/m3]
c #SN         TsisSV(ikl,isn) = tisSNo(i,j,n,isn)          !            [K]
c #SN         G1snSV(ikl,isn) = max(-G1_dSV,min(G1_dSV,    !
c #SN.                          g1sSNo(i,j,n,isn)))        ! [-]        [-]
c #SN         G2snSV(ikl,isn) = max(-G1_dSV,min(G1_dSV,    !
c #SN.                          g2sSNo(i,j,n,isn)))        ! [-] [0.0001 m]
c #SN         agsnSV(ikl,isn) = agsSNo(i,j,n,isn)          !          [day]
c #vS     END DO
c #SN     END DO

! Grid Point                                                (OUTPUT)
! ^^^^^^^^^^                                                 ^^^^^^
! #wx                                                  kSV_v1=0

c #vL     DO  ikl = 1,klonv
c #vL         i   = k2i(ikl)
c #vL         j   = k2j(ikl)
c #vL         n   = k2n(ikl)
c #SI         HFraSV(ikl)     = 0.                         ! Frazil Thickness

C +--RunOFF Intensity                                       (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^^^^                                        ^^^^^^^^^^^^
              RnofSV(ikl)     = 0.                         ! RunOFF Intensity

! Grid Point                                                (OUTPUT)
! ^^^^^^^^^^                                                 ^^^^^^
! #wx         IF (i.eq.iSV_v1.AND.j.eq.jSV_v1.AND.n.EQ.nSV_v1)
! #wx.                                                 kSV_v1=ikl

              lwriSV(ikl)     = WKxyz1(i,j,n)

c #BW      IF(lwriSV(ikl).ne.0.AND.iterun.gt.0)                    THEN
c #BW         noUNIT =   no__SV(lwriSV(ikl))
c #BW         write(noUNIT,5012)
 5012         format(/,1x)
c #BW         write(noUNIT,5013)
 5013         format(' -----+--------+--------+--------+--------+',
     .             '--------+--------+--------+--------+--------+',
     .             '--------+')
c #BW         write(noUNIT,5014)
 5014         format('    n |     z  |     qs |      V |        |',
     .             '     T  | TKE^0.5|        |        |        |',
     .             '        |',
     .             /,'      |    [m] | [g/kg] |  [m/s] |        |',
     .             '    [K] |  [m/s] |        |        |        |',
     .             '        |')
c #BW           BlowST=0.
c #BW           k=0
 5011         CONTINUE
c #BW           k=k+1
c #BW         IF (                  k         .gt. mz )      GO TO 5010
c #BW         IF (grvinv*gplvDY(i,j,k)-sh(i,j).lt.100.)            THEN
c #BW           BlowST=BlowST+ssvSL(i,j,k)*qsHY(i,j,k)
c #BW.                       *pstDY(i,j)*dsigm1(    k)*1.e3*grvinv
c #BW           write(noUNIT,5015) mzz-k,grvinv*gplvDY(i,j,k)-sh(i,j),
c #BW.            1.e3*qsHY(i,j,k),ssvSL(i,j,k),tairDY(i,j,k),
c #BW.                                     sqrt(ect_TE(i,j,k))
 5015           format(i5,' |',f7.2,' |',f7.3,' |',f7.2,' |',
     .                  8x,'|',f7.2,' |',f7.3,' |', 4(8x,'|'))
c #BW         END IF
c #BW         GO TO 5011
 5010         CONTINUE

c #BW           SnowSB =   snohSN(i,j,n)
c #BW         IF        (  nssSNo(i,j,n) .GT.     0      )         THEN
c #BW         DO isn=max(0,nssSNo(i,j,n))   ,nssSNo(i,j,n)
c #BW           SnowSB =   SnowSB 
c #BW.                +    dzsSNo(i,j,n,isn)*rosSNo(i,j,n,isn)
c #BW         END DO
c #BW         END IF

c #BW         write(noUNIT,5016) BlowST,SnowSB
 5016         format(' * TRANSPORT = ',e12.3,' kg/m/s'  ,  8x,'|',
     .               ' * BUDGET    = ',f12.6,' mm w.e.|',2(8x,'|'))
c #BW         write(noUNIT,5013)
c #BW      END IF

! OUTPUT, for Stand-Alone VERIFICATION
! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! #v0       IF (i  .ge.  1.and.i  .le. mx)                         THEN
! #v0         write(50,5001) iterun,i,j,n,nvc,ikl,
! #v0.                   za__SV(ikl),VV__SV(ikl),TaT_SV(ikl),
! #v0.                   rhT_SV(ikl),QaT_SV(ikl),qsnoSV(ikl),
! #v0.                   coszSV(ikl),sol_SV(ikl),IRd_SV(ikl),
! #v0.                   drr_SV(ikl),dsn_SV(ikl),dbs_SV(ikl),
! #v0.                   LSmask(ikl),isotSV(ikl),alb0SV(ikl),
! #v0.                   IRs_SV(ikl),
! #v0.                   ivgtSV(ikl),LAI0SV(ikl),glf0SV(ikl),
! #v0.                   TvegSV(ikl),LMO_SV(ikl),us__SV(ikl),
! #v0.                   uqs_SV(ikl),uts_SV(ikl),uss_SV(ikl),
! #v0.                   snCaSV(ikl),rrCaSV(ikl),psivSV(ikl)
 5001         format(/,'c #INFO   iterun          = ',i15  ,
     .               /,'c #INFO   i,j,n           = ',3i5  ,
     .               /,'c #INFO   nvc             = ',i15  ,
     .               /,'c #INFO   ikl             = ',i15  ,
     .               /,'          za__SV(ikl)     = ',e15.6,
     .               /,'          VV__SV(ikl)     = ',e15.6,
     .               /,'          TaT_SV(ikl)     = ',e15.6,
     .               /,'          rhT_SV(ikl)     = ',e15.6,
     .               /,'          QaT_SV(ikl)     = ',e15.6,
     .               /,'          qsnoSV(ikl)     = ',e15.6,
     .               /,'          coszSV(ikl)     = ',e15.6,
     .               /,'          sol_SV(ikl)     = ',e15.6,
     .               /,'          IRd_SV(ikl)     = ',e15.6,
     .               /,'          drr_SV(ikl)     = ',e15.6,
     .               /,'          dsn_SV(ikl)     = ',e15.6,
     .               /,'          dbs_SV(ikl)     = ',e15.6,
     .               /,'          LSmask(ikl)     = ',i15  ,
     .               /,'          isotSV(ikl)     = ',i15  ,
     .               /,'          alb0SV(ikl)     = ',e15.6,
     .               /,'          IRs_SV(ikl)     = ',e15.6,
     .               /,'          ivgtSV(ikl)     = ',i15  ,
     .               /,'          LAI0SV(ikl)     = ',e15.6,
     .               /,'          glf0SV(ikl)     = ',e15.6,
     .               /,'          TvegSV(ikl)     = ',e15.6,
     .               /,'          LMO_SV(ikl)     = ',e15.6,
     .               /,'          us__SV(ikl)     = ',e15.6,
     .               /,'          uqs_SV(ikl)     = ',e15.6,
     .               /,'          uts_SV(ikl)     = ',e15.6,
     .               /,'          uss_SV(ikl)     = ',e15.6,
     .               /,'          snCaSV(ikl)     = ',e15.6,
     .               /,'          rrCaSV(ikl)     = ',e15.6,
     .               /,'          psivSV(ikl)     = ',e15.6)
! #v0         DO isl = -nsol,0
! #v0           write(50,5002)    isl,TsisSV(ikl,isl),
! #v0.                            isl,eta_SV(ikl,isl)
 5002           format('          TsisSV(ikl,',i2,')  = ',e15.6,
     .                 '          eta_SV(ikl,',i2,')  = ',e15.6)
! #v0         END DO
! #v0         DO isl =       1,nsno
! #v0           write(50,5003)    isl,TsisSV(ikl,isl),
! #v0.                            isl,dzsnSV(ikl,isl)
 5003           format('          TsisSV(ikl,',i2,')  = ',e15.6,
     .                 '          dzsnSV(ikl,',i2,')  = ',e15.6)
! #v0         END DO
! #v0       END IF
          END DO

C +--SISVAT Execution
C +  ^^^^^^^^^^^^^^^^
          write(daHost,'(i2,a3,i4,i3,2(a1,i2))')
     .          jdarGE,labmGE(mmarGE),iyrrGE,
     .          jhurGE,chb,minuGE,chb,jsecGE

! #wz     write(6,6660) jdarGE,mmarGE,iyrrGE,jhurGE,minuGE,jsecGE
 6660     format(2(i2,'-'),2i4,2(':',i2),3x,$)

C +       ************
          call  SISVAT
C +       ************


C +--MAR    Variables Update
C +  ^^^^^^^^^^^^^^^^^^^^^^^
        IF   (nvc.lt.nvcmax)                                      THEN
          DO  ikl = 1,klonv
              i   = k2i(ikl)
              j   = k2j(ikl)
              n   = k2n(ikl)

C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR         ij2             = ij2         + 1
c #VR         ijdver(i,j,n)   = ijdver(i,j,n) - ij2
c #VR         ij_ver(i,j,n)   = ij_ver(i,j,n) + 1

C +--Energy Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              IRsoil(i,j,n)       = IRs_SV(ikl)            ! Soil upward IR
              SLlmol(i,j,n)       = LMO_SV(ikl)            ! Monin-Obukhov L.
              SLuusl(i,j,n)       = us__SV(ikl)            ! Frict. Velocity
              SLutsl(i,j,n)       = uts_SV(ikl)            ! u*T*
              SLdSdT(i,j,n)       = dSdTSV(ikl)            ! Sens.H.Flux T-Der.

C +--Energy Fluxes                                          (OUTPUT/NetCDF)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^^
c #NC         SOsoNC(i,j,n)       = SOsoKL(ikl)            ! Absorb.Sol.Rad.
c #NC         IRsoNC(i,j,n)       = IRsoKL(ikl)            ! Absorb.IR  Rad.
c #NC         HSsoNC(i,j,n)       = HSsoKL(ikl)            ! HS
c #NC         HLsoNC(i,j,n)       = HLsoKL(ikl)            ! HL
c #NC         HLs_NC(i,j,n)       = HLs_KL(ikl)            ! Evaporation
c #NC         HLv_NC(i,j,n)       = HLv_KL(ikl)            ! Transpiration

C +--Water  Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              SLuqsl(i,j,n)       = uqs_SV(ikl)            ! u*q*
              SLdLdT(i,j,n)       = dLdTSV(ikl)            ! Latn.H.Flux T-Der.
              SLussl(i,j,n)       = 0.                     ! 
c #BS         SLussl(i,j,n)       =                        ! MAX        Erosion 
c #BS.       (blowSN(i,j,n)- dbs_SV(ikl))                  !-unconsumed Erosion
c #BS.                     /(dtPhys*rhT_SV(ikl))           ! ==> actual u*s*
c #vL     ENDDO
c #vL     DO  ikl = 1,klonv
c #vL         i   = k2i(ikl)
c #vL         j   = k2j(ikl)
c #vL         n   = k2n(ikl)
c #BS         blowSN(i,j,n)= dtPhys*uss_SV(ikl)            ! NEW  MAX   Erosion
c #BS.                             *rhT_SV(ikl)            ! rho u*s* dt[kg/m2]
c #AE         SaltSN(i,j,n)       = usthSV(ikl)            ! u*_th

C +--Soil/Canopy                                            (INPUT/OUTPUT)
C +  ^^^^^^^^^^^                                             ^^^^^^^^^^^^
               SL_z0(i,j,n)       = Z0m_SV(ikl)            ! Moment.Roughn.L.
               SL_r0(i,j,n)       = Z0h_SV(ikl)            ! Heat   Roughn.L.
               cdmSL(i,j,n)       = rCDmSV(ikl)            ! sq.root Contr.Drag
               cdhSL(i,j,n)       = rCDhSV(ikl)            ! sq.root Contr.Drag
              TvegTV(i,j,n)       = TvegSV(ikl)            ! Vegetation Temp.
              CaSnTV(i,j,n)       = snCaSV(ikl)            ! Canopy SnowCover
              CaWaTV(i,j,n)       = rrCaSV(ikl)            ! Canopy RainWater
              psivTV(i,j,n)       = psivSV(ikl)            ! Vegetation Pot.
            DO isl =   -nsol,0                             !
              eta_TV(i,j,n,1-isl) = eta_SV(ikl,isl)        ! Soil Humidity
              TsolTV(i,j,n,1-isl) = TsisSV(ikl,isl)        ! Soil Temperature
            END DO                                         !
c #vL     END DO

C +--Snow Roughness                                         (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^^                                          ^^^^^^^^^^^^
c #vZ     DO  ikl = 1,klonv
c #vZ         i =  k2i(ikl)
c #vZ         j =  k2j(ikl)
c #vZ         n =  k2n(ikl)
c #ZM       DO nt=   1,ntavSL-1                            !
c #ZM         SLn_z0(i,j,n,nt)    = SLn_z0(i,j,n,nt+1)     !
c #ZM         SLn_b0(i,j,n,nt)    = SLn_b0(i,j,n,nt+1)     !
c #ZM         SLn_r0(i,j,n,nt)    = SLn_r0(i,j,n,nt+1)     !
c #ZM       ENDDO                                          !
c #vZ     ENDDO
c #vL     DO  ikl = 1,klonv
c #vL         i   = k2i(ikl)
c #vL         j   = k2j(ikl)
c #vL         n   = k2n(ikl)
c #ZM         SLn_z0(i,j,n,ntavSL)= Z0mnSV(ikl)            ! z0(Momentum)
c #ZM         SLn_b0(i,j,n,ntavSL)= Z0enSV(ikl)            ! z0(Mom., Erosion)
c #ZM         SLn_r0(i,j,n,ntavSL)= Z0hnSV(ikl)            ! z0(Heat)

c #SZ         Z0SaBS(i,j,n)       = Z0SaSV(ikl)            ! z0(Sastrugi  h)

C +--V,  dT(a-s)    Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AA       DO nt=1,ntaver
c #AW         V_0aSL(i,j,  nt)    = V__mem(ikl,nt)
c #AH         dT0aSL(i,j,n,nt)    = T__mem(ikl,nt)
c #AA       ENDDO

C +--u*, u*T*, u*s* Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM       DO nt=1,ntaver
c #AM         u_0aSL(i,j,n,nt)    = u__mem(ikl,nt)
c #AT         uT0aSL(i,j,n,nt)    = uT_mem(ikl,nt)
c #AS         us0aSL(i,j,n,nt)    = us_mem(ikl,nt)
c #AM       ENDDO
c #vL     END DO

C +--Dust   Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^
c #vD     DO  ikl = 1,klonv
c #vD         i =  k2i(ikl)
c #vD         j =  k2j(ikl)
c #vD         n =  k2n(ikl)

c #BD         SLubsl(i,j,n)       =(1-min(1,isnoSV(ikl)))  ! Snow Free  Surface 
c #BD.                             *uss_SV(ikl)            ! DUST       Erosion
c #BD.                *max(1,(2-mmy)*3)                    ! Tuning Factor (2D)
c #vD     END DO

C +--Snow Pack                                              (INPUT/OUTPUT)
C +  ^^^^^^^^^                                               ^^^^^^^^^^^^
c #vS     DO  ikl = 1,klonv
c #vS         i =  k2i(ikl)
c #vS         j =  k2j(ikl)
c #vS         n =  k2n(ikl)
c #SN         snohSN(i,j,n)       = BufsSV(ikl)            ! Snow Buffer Lay.
c #SN         BrosSN(i,j,n)       = BrosSV(ikl)            ! Snow Buffer dens.
c #SN         BG1sSN(i,j,n)       = BG1sSV(ikl)            ! Snow Buffer D./S.
c #SN         BG2sSN(i,j,n)       = BG2sSV(ikl)            ! Snow Buffer S./S.
c #SN         nssSNo(i,j,n)       = isnoSV(ikl)            ! Nb Snow/Ice Lay.
c #SN         issSNo(i,j,n)       = ispiSV(ikl)            ! Nb Supr.Ice Lay.
c #SN         nisSNo(i,j,n)       = iiceSV(ikl)            ! Nb      Ice Lay.
c #SN         zWE_SN(i,j,n)       = zWE_SV(ikl)            ! Current  *Thick.
c #SN         zWEcSN(i,j,n)       = zWEcSV(ikl)            ! Non-Erod.*Thick.
c #SN         hSalSN(i,j,n)       = hSalSV(ikl)            ! Salt.Layer Height
c #SN         SWaSNo(i,j,n)       = rusnSV(ikl)            ! Surficial Water  
c #SN         SWSSNo(i,j,n)       = SWS_SV(ikl)            ! Surficial Wat.St.
c #vS     END DO
c #SN     DO  isn = 1,nsno
c #vS     DO  ikl = 1,klonv
c #vS         i =  k2i(ikl)
c #vS         j =  k2j(ikl)
c #vS         n =  k2n(ikl)
c #SN         nhsSNo(i,j,n,isn)   = istoSV(ikl,isn)        !            [-]
c #SN         dzsSNo(i,j,n,isn)   = dzsnSV(ikl,isn)        !            [m]
c #SN         rosSNo(i,j,n,isn)   = ro__SV(ikl,isn)        !        [kg/m3]
c #SN         wasSNo(i,j,n,isn)   = eta_SV(ikl,isn)        !        [m3/m3]
c #SN         tisSNo(i,j,n,isn)   = TsisSV(ikl,isn)        !            [K]
c #SN         g1sSNo(i,j,n,isn)   = G1snSV(ikl,isn)        ! [-]        [-]
c #SN         g2sSNo(i,j,n,isn)   = G2snSV(ikl,isn)        ! [-] [0.0001 m]
c #SN         agsSNo(i,j,n,isn)   = agsnSV(ikl,isn)        !          [day]
c #vS     END DO
c #SN     END DO

c #vL     DO  ikl = 1,klonv
              i =  k2i(ikl)
              j =  k2j(ikl)
              n =  k2n(ikl)
c #IB         WKxyz2(i,j,n)       = wes_SV(ikl)            ! Depo. / Subli.
c #IB         WKxyz3(i,j,n)       = wem_SV(ikl)            ! Melting
c #IB         WKxyz4(i,j,n)       = wer_SV(ikl)            ! Refreezing

C +--Radiative Properties                                         (OUTPUT)
C +  ^^^^^^^^^^^^^^^^^^^^                                          ^^^^^^
              albxSL(i,j,n)       = alb_SV(ikl)            ! Mosaic Albedo
c #AO.                          *(1-maskSL(i,j))           !
c #AO.                          +    albAO(i,j,n)          ! Mosaic AlbedoNEMO
c #AO.                          *   maskSL(i,j)            !               
              WKxyz6(i,j,n)       = emi_SV(ikl)            ! Mosaic Emissivity
              WKxyz7(i,j,n)       = IRu_SV(ikl)            ! Mosaic Upw.IR
              WKxyz8(i,j,n)       = qSalSV(ikl)            ! Saltating Partic.
              hfra  (i,j,n)       = HFraSV(ikl)            ! Frazil  Thickness
              Rnof  (i,j,n)       = RnofSV(ikl)            ! Run OFF Intensity

          END DO

        ELSE
              nkl = ijnmax2 - nnn - klonv
          DO  ikl = 1,max(1,nkl)
              i   = k2i(ikl)
              j   = k2j(ikl)
              n   = k2n(ikl)

C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR         ij2             = ij2         + 1
c #VR         ijdver(i,j,n)   = ijdver(i,j,n) - ij2
c #VR         ij_ver(i,j,n)   = ij_ver(i,j,n) + 1

C +--Energy Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              IRsoil(i,j,n)       = IRs_SV(ikl)            ! Soil upward IR
              SLlmol(i,j,n)       = LMO_SV(ikl)            ! Monin-Obukhov L.
              SLuusl(i,j,n)       = us__SV(ikl)            ! Frict. Velocity
              SLutsl(i,j,n)       = uts_SV(ikl)            ! u*T*
              SLdSdT(i,j,n)       = dSdTSV(ikl)            ! Sens.H.Flux T-Der.

C +--Energy Fluxes                                          (OUTPUT/NetCDF)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^^
c #NC         SOsoNC(i,j,n)       = SOsoKL(ikl)            ! Absorb.Sol.Rad.
c #NC         IRsoNC(i,j,n)       = IRsoKL(ikl)            ! Absorb.IR  Rad.
c #NC         HSsoNC(i,j,n)       = HSsoKL(ikl)            ! HS
c #NC         HLsoNC(i,j,n)       = HLsoKL(ikl)            ! HL
c #NC         HLs_NC(i,j,n)       = HLs_KL(ikl)            ! Evaporation
c #NC         HLv_NC(i,j,n)       = HLv_KL(ikl)            ! Transpiration

C +--Water  Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              SLuqsl(i,j,n)       = uqs_SV(ikl)            ! u*q*
              SLdLdT(i,j,n)       = dLdTSV(ikl)            ! Latn.H.Flux T-Der.
              SLussl(i,j,n)       = 0.                     ! 
c #BS         SLussl(i,j,n)       =                        ! MAX        Erosion 
c #BS.       (blowSN(i,j,n)- dbs_SV(ikl))                  !-unconsumed Erosion
c #BS.                     /(dtPhys*rhT_SV(ikl))           ! ==> actual u*s*
c #vL     ENDDO
c #vL     DO  ikl = 1,  nkl
c #vL         i   = k2i(ikl)
c #vL         j   = k2j(ikl)
c #vL         n   = k2n(ikl)
c #BS         blowSN(i,j,n)= dtPhys*uss_SV(ikl)            ! NEW  MAX   Erosion
c #BS.                             *rhT_SV(ikl)            ! rho u*s* dt[kg/m2]
c #AE         SaltSN(i,j,n)       = usthSV(ikl)            ! u*_th

C +--Soil/Canopy                                            (INPUT/OUTPUT)
C +  ^^^^^^^^^^^                                             ^^^^^^^^^^^^
               SL_z0(i,j,n)       = Z0m_SV(ikl)            ! Moment.Roughn.L.
               SL_r0(i,j,n)       = Z0h_SV(ikl)            ! Heat   Roughn.L.
               cdmSL(i,j,n)       = rCDmSV(ikl)            ! sq.root Contr.Drag
               cdhSL(i,j,n)       = rCDhSV(ikl)            ! sq.root Contr.Drag
              TvegTV(i,j,n)       = TvegSV(ikl)            ! Vegetation Temp.
              CaSnTV(i,j,n)       = snCaSV(ikl)            ! Canopy SnowCover
              CaWaTV(i,j,n)       = rrCaSV(ikl)            ! Canopy RainWater
              psivTV(i,j,n)       = psivSV(ikl)            ! Vegetation Pot.
            DO isl =   -nsol,0                             !
              eta_TV(i,j,n,1-isl) = eta_SV(ikl,isl)        ! Soil Humidity
              TsolTV(i,j,n,1-isl) = TsisSV(ikl,isl)        ! Soil Temperature
            END DO                                         !
c #vL     END DO

C +--Snow Roughness                                         (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^^                                          ^^^^^^^^^^^^
c #vZ     DO  ikl = 1, nkl
c #vZ         i =  k2i(ikl)
c #vZ         j =  k2j(ikl)
c #vZ         n =  k2n(ikl)
c #ZM       DO nt=   1,ntavSL-1                            !
c #ZM         SLn_z0(i,j,n,nt)    = SLn_z0(i,j,n,nt+1)     !
c #ZM         SLn_b0(i,j,n,nt)    = SLn_b0(i,j,n,nt+1)     !
c #ZM         SLn_r0(i,j,n,nt)    = SLn_r0(i,j,n,nt+1)     !
c #ZM       ENDDO                                          !
c #vZ     ENDDO
c #vL     DO  ikl = 1,  nkl
c #vL         i   = k2i(ikl)
c #vL         j   = k2j(ikl)
c #vL         n   = k2n(ikl)
c #ZM         SLn_z0(i,j,n,ntavSL)= Z0mnSV(ikl)            ! z0(Momentum)
c #ZM         SLn_b0(i,j,n,ntavSL)= Z0enSV(ikl)            ! z0(Mom., Erosion)
c #ZM         SLn_r0(i,j,n,ntavSL)= Z0hnSV(ikl)            ! z0(Heat)

c #SZ         Z0SaBS(i,j,n)       = Z0SaSV(ikl)            ! z0(Sastrugi  h)

C +--V,  dT(a-s)    Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AA       DO nt=1,ntaver
c #AW         V_0aSL(i,j,  nt)    = V__mem(ikl,nt)
c #AH         dT0aSL(i,j,n,nt)    = T__mem(ikl,nt)
c #AA       ENDDO

C +--u*, u*T*, u*s* Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM       DO nt=1,ntaver
c #AM         u_0aSL(i,j,n,nt)    = u__mem(ikl,nt)
c #AT         uT0aSL(i,j,n,nt)    = uT_mem(ikl,nt)
c #AS         us0aSL(i,j,n,nt)    = us_mem(ikl,nt)
c #AM       ENDDO
c #vL     END DO

C +--Dust   Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^
c #vD     DO  ikl = 1, nkl
c #vD         i =  k2i(ikl)
c #vD         j =  k2j(ikl)
c #vD         n =  k2n(ikl)

c #BD         SLubsl(i,j,n)       =(1-min(1,isnoSV(ikl)))  ! Snow Free  Surface 
c #BD.                             *uss_SV(ikl)            ! DUST       Erosion
c #BD.                *max(1,(2-mmy)*3)                    ! Tuning Factor (2D)
c #vD     END DO

C +--Snow Pack                                              (INPUT/OUTPUT)
C +  ^^^^^^^^^                                               ^^^^^^^^^^^^
c #vS     DO  ikl = 1, nkl
c #vS         i =  k2i(ikl)
c #vS         j =  k2j(ikl)
c #vS         n =  k2n(ikl)
c #SN         snohSN(i,j,n)       = BufsSV(ikl)            ! Snow Buffer Lay.
c #SN         BrosSN(i,j,n)       = BrosSV(ikl)            ! Snow Buffer dens.
c #SN         BG1sSN(i,j,n)       = BG1sSV(ikl)            ! Snow Buffer D./S.
c #SN         BG2sSN(i,j,n)       = BG2sSV(ikl)            ! Snow Buffer S./S.
c #SN         nssSNo(i,j,n)       = isnoSV(ikl)            ! Nb Snow/Ice Lay.
c #SN         issSNo(i,j,n)       = ispiSV(ikl)            ! Nb Supr.Ice Lay.
c #SN         nisSNo(i,j,n)       = iiceSV(ikl)            ! Nb      Ice Lay.
c #SN         zWE_SN(i,j,n)       = zWE_SV(ikl)            ! Current  *Thick.
c #SN         zWEcSN(i,j,n)       = zWEcSV(ikl)            ! Non-Erod.*Thick.
c #SN         hSalSN(i,j,n)       = hSalSV(ikl)            ! Salt.Layer Height
c #SN         SWaSNo(i,j,n)       = rusnSV(ikl)            ! Surficial Water  
c #SN         SWSSNo(i,j,n)       = SWS_SV(ikl)            ! Surficial Wat.St.
c #vS     END DO
c #SN     DO  isn = 1,nsno
c #vS     DO  ikl = 1, nkl
c #vS         i =  k2i(ikl)
c #vS         j =  k2j(ikl)
c #vS         n =  k2n(ikl)
c #SN         nhsSNo(i,j,n,isn)   = istoSV(ikl,isn)        !            [-]
c #SN         dzsSNo(i,j,n,isn)   = dzsnSV(ikl,isn)        !            [m]
c #SN         rosSNo(i,j,n,isn)   = ro__SV(ikl,isn)        !        [kg/m3]
c #SN         wasSNo(i,j,n,isn)   = eta_SV(ikl,isn)        !        [m3/m3]
c #SN         tisSNo(i,j,n,isn)   = TsisSV(ikl,isn)        !            [K]
c #SN         g1sSNo(i,j,n,isn)   = G1snSV(ikl,isn)        ! [-]        [-]
c #SN         g2sSNo(i,j,n,isn)   = G2snSV(ikl,isn)        ! [-] [0.0001 m]
c #SN         agsSNo(i,j,n,isn)   = agsnSV(ikl,isn)        !          [day]
c #vS     END DO
c #SN     END DO

c #vL     DO  ikl = 1, nkl
              i =  k2i(ikl)
              j =  k2j(ikl)
              n =  k2n(ikl)
c #IB         WKxyz2(i,j,n)       = wes_SV(ikl)            ! Depo. / Subli.
c #IB         WKxyz3(i,j,n)       = wem_SV(ikl)            ! Melting
c #IB         WKxyz4(i,j,n)       = wer_SV(ikl)            ! Refreezing

C +--Radiative Properties                                         (OUTPUT)
C +  ^^^^^^^^^^^^^^^^^^^^                                          ^^^^^^
              albxSL(i,j,n)       = alb_SV(ikl)            ! Mosaic Albedo MAR
c #AO.                          *(1-maskSL(i,j))           !
c #AO.                          +    albAO(i,j,n)          ! Mosaic AlbedoNEMO
c #AO.                          *   maskSL(i,j)            !               
              WKxyz6(i,j,n)       = emi_SV(ikl)            ! Mosaic Emissivity
              WKxyz7(i,j,n)       = IRu_SV(ikl)            ! Mosaic Upw.IR
              WKxyz8(i,j,n)       = qSalSV(ikl)            ! Saltating Partic.
              hfra  (i,j,n)       = HFraSV(ikl)            ! Frazil  Thickness
              Rnof  (i,j,n)       = RnofSV(ikl)            ! Run OFF Intensity

          END DO

        END IF

      END DO


C +--Surface Temperature: Prescription of relevant Medium (Snow, precribed SST)
C +  ==========================================================================

      DO j=jp11,my1
      DO i=ip11,mx1
            DO isl =   -nsol,0                             !


C +--Open Ocean
C +  ----------

              eta_TV(i,j,1,1-isl) =                        !
     .        eta_TV(i,j,1,1-isl) *(1-maskSL(i,j))         !
     .                              + maskSL(i,j)          ! Sea: Humidity:=1
              TsolTV(i,j,1,1-isl) =                        !
     .       (TsolTV(i,j,1,1-isl) *(1-maskSL(i,j))         ! Soil Temperature
     .       +sst_LB(i,j)         *   maskSL(i,j))         ! Prescribed   SST
c #OP.                                            * FixSST !
c #OP.      +(TsolTV(i,j,1,1-isl)                          !
c #op.      +(sst_LB(i,j)                                  !~Prescribed   SST
c #op.       -TsolTV(i,j,1,1-isl))*   maskSL(i,j) * SSTnud ! (Nudging)
c #OP.                                           )* VarSST ! Interactive  SST


C +--Sea Ice
C +  -------

c #AO         eta_TV(i,j,2,1-isl) =                        !
c #AO.        eta_TV(i,j,2,1-isl) *(1-maskSL(i,j))         ! Sea: Humidity:=0
c #AO         TsolTV(i,j,2,1-isl) =                        !
c #AO.       (TsolTV(i,j,2,1-isl) *(1-maskSL(i,j))         ! Soil Temperature
c #AO.       +271.2               *   maskSL(i,j))         ! Prescribed    ST
            END DO
c #AO       DO isl =         0,nsno                        !
c #AO         tisSNo(i,j,2,isl)   =
c #AO.        srftAO(i,j,2)       *   maskSL(i,j)          ! Prescribed   SIT
c #AO       END DO
      ENDDO
      ENDDO


      DO n=1,mw
      DO j=jp11,my1
      DO i=ip11,mx1
              tsrfSL(i,j,n)       =                        ! Surf.Temperature
     .        TsolTV(i,j,n,1)                              !
c #SN.                           *(1-min(1,nssSNo(i,j,n))) !
c #SN.       +tisSNo(i,j,n,          max(1,nssSNo(i,j,n))) !
c #SN.                           *   min(1,nssSNo(i,j,n))  !
C +                                                        !
c #NC         eta_NC(i,j,n)       = 0.                     !
c #NC         DO isl = -nsol,0                             !
c #NC         eta_NC(i,j,n)       = eta_NC(i,j,n)          ! Soil Moisture
c #NC.       +eta_TV(i,j,n,1-isl) * dz_dSV(    isl)        !              
c #NC         END DO                                       !
      ENDDO
      ENDDO
      ENDDO


C +--Mosaic Cleaning
C +  ===============

      DO j=jp11,my1
      DO i=ip11,mx1
c #SN   IF (maskSL(i,j  ).EQ.   1)                                  THEN
c #SN       nssSNo(i,j,1    ) = 0
c #SN       issSNo(i,j,1    ) = 0
c #SN       nisSNo(i,j,1    ) = 0
c #SN     DO ISL=1,nsno
c #SN       tisSNo(i,j,1,isl) = 0.
c #SN       dzsSNo(i,j,1,isl) = 0.
c #SN       rosSNo(i,j,1,isl) = 0.
c #SN       wasSNo(i,j,1,isl) = 0.
c #SN       g1sSNo(i,j,1,isl) = 0.
c #SN       g2sSNo(i,j,1,isl) = 0.
c #SN       agsSNo(i,j,1,isl) = 0.
c #SN       nhsSNo(i,j,1,isl) = 0.
c #SN     ENDDO
c #SN   ENDIF
        IF (SLsrfl(i,j,2).LT.eps9)                                  THEN
            tsrfSL(i,j,2)     = tsrfSL(i,j,1)
          DO isl=1,nsol+1
            TsolTV(i,j,2,isl) = TsolTV(i,j,1,isl)
          ENDDO    ! #n2
c #SN       nssSNo(i,j,2    ) = nssSNo(i,j,1    ) * (1 - maskSL(i,j))
c #SN       issSNo(i,j,2    ) = issSNo(i,j,1    ) * (1 - maskSL(i,j))
c #SN       nisSNo(i,j,2    ) = nisSNo(i,j,1    ) * (1 - maskSL(i,j))
c #SN     DO isl=1,nsno       !
c #SN       tisSNo(i,j,2,isl) = tisSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       dzsSNo(i,j,2,isl) = dzsSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       rosSNo(i,j,2,isl) = rosSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       wasSNo(i,j,2,isl) = wasSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       g1sSNo(i,j,2,isl) = g1sSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       g2sSNo(i,j,2,isl) = g2sSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       agsSNo(i,j,2,isl) = agsSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       nhsSNo(i,j,2,isl) = nhsSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN     ENDDO    ! #n2
        ENDIF      ! #n2
      ENDDO
      ENDDO


C +--Grid Averages / Diagnostics
C +  ===========================

C +--Grid Averages                                                (OUTPUT)
C +  ^^^^^^^^^^^^^                                                 ^^^^^^
      DO  n=1,mw
      DO  j=jp11,my1
      DO  i=ip11,mx1
c #IB         wes_IB(i,j,n)     = - WKxyz2(i,j,n)          !
c #IB.                            + wes_IB(i,j,n)          ! Depo. / Subli.
c #IB         wem_IB(i,j,n)       = WKxyz3(i,j,n)          ! 
c #IB.                            + wem_IB(i,j,n)          ! Melting
c #IB         wer_IB(i,j,n)       = WKxyz4(i,j,n)          ! 
c #IB.                            + wer_IB(i,j,n)          ! Refreezing
c #IB         wee_IB(i,j,n)     = - SLuqsl(i,j,n)          !
c #IB.            * 1.e3 * dt__SV * rolvDY(i,j,mz)         !
c #IB.                            + wee_IB(i,j,n)          ! Evapotranspiration
c #IB         weu_IB(i,j,n)       = Rnof  (i,j,n)*dt__SV   ! 
c #IB.                            + weu_IB(i,j,n)          ! Refreezing

c #WR         ifrVER(i,j)         = ifrVER(i,j)            !
c #WR.                            + ifraTV(i,j,n)          !
              albeSL(i,j)         = albeSL(i,j)            ! Grid   Albedo
     .            + SLsrfl(i,j,n) * albxSL(i,j,n)          ! Mosaic Albedo
              eps0SL(i,j)         = eps0SL(i,j)            ! Grid   Emissivity
     .            + SLsrfl(i,j,n) * WKxyz6(i,j,n)          ! Mosaic Emissivity
              Upw_IR(i,j)         = Upw_IR(i,j)            !
     .            + SLsrfl(i,j,n) * WKxyz7(i,j,n)          ! Mosaic Upw.IR
               SLlmo(i,j)         =  SLlmo(i,j)            !
     .            + SLsrfl(i,j,n) * SLlmol(i,j,n)          ! Mosaic Mon.Ob.
               SLuus(i,j)         =  SLuus(i,j)            ! Grid   u*
     .            + SLsrfl(i,j,n) * SLuusl(i,j,n)          ! Mosaic u*
               SLuts(i,j)         =  SLuts(i,j)            ! Grid   u*T*
     .            + SLsrfl(i,j,n) * SLutsl(i,j,n)          ! Mosaic u*T*
               SLuqs(i,j)         =  SLuqs(i,j)            ! Grid   u*q*
     .            + SLsrfl(i,j,n) * SLuqsl(i,j,n)          ! Mosaic u*q*
c #BS          uss_HY(i,j)        = uss_HY(i,j)            ! Grid   u*s*
c #BS.            + SLsrfl(i,j,n) * SLussl(i,j,n)          ! Mosaic u*s*
C +...NO !    SLussl(i,j,n)       = uss_SV(ikl)            !        u*s*
C +           Upper Update = wrong Source of Atmospher.Snow!
c #BS         qsrfHY(i,j)         = qsrfHY(i,j)            ! Salt.Part.Concent.
c #BS.            + SLsrfl(i,j,n) * WKxyz8(i,j,n)          ! 
c #BS.                    *   min(1,nssSNo(i,j,n))         !
c #PO         HFraPO(i,j)         = HFraPO(i,j)            ! Frazil  Thickness
c #PO.            + SLsrfl(i,j,n) * HFra  (i,j,n)          ! 
              TairSL(i,j)         = TairSL(i,j)            ! Surface Air
     .            +SLsrfl(i,j,n)  * tsrfSL(i,j,n)          !         Temperatur
              draiTV(i,j)         = draiTV(i,j)            ! Run OFF Intensity
     .            + SLsrfl(i,j,n) * Rnof  (i,j,n)          ! 
c #TC           uqTC(i,j,1)       =   uqTC(i,j,1)          ! Grid   u*b*
c #TC.            + SLsrfl(i,j,n) * SLubsl(i,j,n)          ! Mosaic u*b*
c #TC           qsTC(i,j,1)       =   qsTC(i,j,1)          ! Salt.Part.Concent.
c #TC.            + SLsrfl(i,j,n) * WKxyz8(i,j,n)          ! 
c #TC.                    *(1-min(1,nssSNo(i,j,n)))        !
      ENDDO
      ENDDO
      ENDDO

      DO j=jp11,my1
      DO i=ip11,mx1
c #HY   sno0HY(i,j) = snowHY(i,j)                          !
        pktaSL(i,j) = TairSL(i,j)                          !
     .    /exp(cap*log(pstDY(i,j)+ptopDY))                 !
         tviRA(i,j) = sqrt(sqrt(Upw_IR(i,j)/stefan))       ! Brightness Temp.        \VER
         rhAir      = rolvDY(i,j,mz) *1.e3                 ! Air    Densitity
        hsenSL(i,j) = -SLuts(i,j)  *  rhAir       *cp      ! Sensible Heat Flux
        qvapSL(i,j) = qvsiDY(i,j,mzz)                      ! Surf.Specif.Humid.      \VER
                                                           ! to adapt over soil
        hlatSL(i,j) = -SLuqs(i,j)  *  rhAir       *Lv_H2O  ! Latent   Heat Flux
        evapTV(i,j) = evapTV(i,j)                          ! Total    Evaporat.
     .                -SLuqs(i,j)  *  rhAir       *dt__SV  ! [mm w.e.]
        runoTV(i,j) = runoTV(i,j)  +  draiTV(i,j) *dt__SV  ! Integrated Run OFF
        firmSL(i,j) = Upw_IR(i,j)   
      END DO
      END DO


C +--Blown Snow/Dust Accumulation
C +  ============================

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx IF                            (lSV_v1.EQ.2)
! #wx.  write(6,6011)                uss_HY(iSV_v1,jSV_v1)  *1.e3
 6011   format(10x,'After SISVAT(1): us* [mm/s] =',f9.3)

c #BS DO i=ip11,mx1
c #BS DO j=   1,my
c #BS        WKxy6(i     ,j     ) =
c #BS&      uss_HY(im1(i),j     )+2.0*uss_HY(i     ,j     )
c #BS& +    uss_HY(ip1(i),j     )
c #BS ENDDO
c #BS ENDDO

c #BS DO j=jp11,my1
c #BS DO i=ip11,mx1
c #BS        WKxy5(i     ,j     ) =    WKxy6(i     ,jm1(j))
c #BS        WKxy7(i     ,j     ) =    WKxy6(i     ,jp1(j))
c #BS ENDDO
c #BS ENDDO

c #BS DO j=jp11,my1
c #BS DO i=ip11,mx1
c #BS       uss_HY(i     ,j     ) =
c #BS.       WKxy7(i     ,j     )
c #BS.     + WKxy6(i     ,j     ) +    WKxy6(i     ,j     )
c #BS.     + WKxy5(i     ,j     )

!  Previous three Loops Stand for the following unvectorized Loop:
!       WKxy2(i,j) = uss_HY(im1(i),jp1(j)) 
!    .         +2.d0*uss_HY(i     ,jp1(j)) +     uss_HY(ip1(i),jp1(j))
!    .         +2.d0*uss_HY(im1(i),j)      
!    .         +4.d0*uss_HY(i     ,j)      +2.d0*uss_HY(ip1(i),j)
!    .         +     uss_HY(im1(i),jm1(j)) 
!    .         +2.d0*uss_HY(i     ,jm1(j)) +     uss_HY(ip1(i),jm1(j))
c #BS END DO
c #BS END DO

c #BD DO i=1,mx
c #BD DO j=1,my
c #BD   WKxy3(i,j) = uqTC(im1(i),jp1(j),1) 
c #BD.         +2.d0*uqTC(i     ,jp1(j),1) +     uqTC(ip1(i),jp1(j),1)
c #BD.         +2.d0*uqTC(im1(i),j     ,1)
c #BD.         +4.d0*uqTC(i     ,j     ,1) +2.d0*uqTC(ip1(i),j     ,1)
c #BD.         +     uqTC(im1(i),jm1(j),1) 
c #BD.         +2.d0*uqTC(i     ,jm1(j),1) +     uqTC(ip1(i),jm1(j),1)
c #BD END DO
c #BD END DO

c #AE DO i=1,mx
c #AE DO j=1,my
c #BS   uss_HY(i,j)  = uss_HY(i,j)          * 62.5e-3
c #BS   snowHY(i,j)  = snowHY(i,j) + dt__SV * rolvDY(i,j,mz)*uss_HY(i,j)

c #BD     uqTC(i,j,1)=  WKxy3(i,j)          * 62.5e-3
c #AE END DO
c #AE END DO

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx IF                            (lSV_v1.EQ.2)
! #wx.  write(6,6012)                uss_HY(iSV_v1,jSV_v1)  *1.e3
 6012   format(10x,'After SISVAT(2): us* [mm/s] =',f9.3)


C +--Formation of Lakes                                                              \VER
C +  ==================




C +--Sea-Ice Ice Floe Size
C +  =====================

C +--Prescription from SST
C +  ---------------------

c #SI IF (VarSST.le.epsi)                                           THEN
c #SI   DO j=jp11,my1
c #SI   DO i=ip11,mx1
c #SI        FraOcn          =    (TsolTV(i,j,1,1)-Tfr_LB)/TSIdSV! Prescribed
C +                                                              ! from SST
c #IP        FraOcn          =  1.-sicsIB(i,j)                   ! Prescribed
C +                                                              ! from SSM/I
c #SI        FraOcn          = min(  unun,FraOcn)                ! UpperLimit
c #SI        FraOcn          = max(OcnMin,FraOcn)                ! LowerLimit
c #SI        SLsrfl(i,j,1)   =  (1-maskSL(i,j))  * SLsrfl(i,j,1) ! New Ocean
c #SI.                          +  maskSL(i,j)   * FraOcn        !
c #SI        SrfSIC          =                     SLsrfl(i,j,2) ! Old Sea Ice
c #SI        SIc0OK          = max(zero, sign(unun,SrfSIC-epsi)) !
c #SI        SLsrfl(i,j,2)   =  (1-maskSL(i,j))  * SLsrfl(i,j,2) ! New Sea Ice
c #SI.                          +  maskSL(i,j)*(1.-FraOcn)       !
c #SI        SIceOK          = max(zero, sign(unun,SLsrfl(i,j,2) !
c #SI.                                                   -epsi)) !
c #SI        ifra_t          =     ifraTV(i,j,1) + ifraTV(i,j,2) ! OCN Fraction
c #SI        ifraTV(i,j,1)   =     SLsrfl(i,j,1) * 100.          !
c #SI        ifraTV(i,j,1)   = min(ifraTV(i,j,1) , ifra_t)       !
c #SI        ifraTV(i,j,2)   =     ifra_t        - ifraTV(i,j,1) !

C +--Sea-Ice Vertical Discretization
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SI        nssSNo(i,j,2)   =  
c #SI.       nssSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(max(1
c #SI.      ,nssSNo(i,j,2))  *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        nisSNo(i,j,2)   =  
c #SI.       nisSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(max(1
c #SI.      ,nisSNo(i,j,2))  *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI        issSNo(i,j,2)   =                    nisSNo(i,j,2)
C +
c #SI     DO l=1,nsno
c #SI        dzsSNo(i,j,2,l) =
c #SI.       dzsSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(max
c #SI.      (SIc_OK(min(2,l))*    SIcMIN
c #SI.      ,dzsSNo(i,j,2,l))*    SIc0OK
c #SI.      +dzSIce(min(4,l))*(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        tisSNo(i,j,2,l) =
c #SI.       tisSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(tisSNo(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,1) *(1.-SIc0OK)       )*maskSL(i,j)
C +
c #SI        rosSNo(i,j,2,l) =
c #SI.       rosSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(max
c #SI.      (SIc_OK(min(2,l))*    ro_Ice
c #SI.      ,rosSNo(i,j,2,l))*    SIc0OK
c #SI.      +ro_Ice          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        g1sSNo(i,j,2,l) =
c #SI.       g1sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g1sSNo(i,j,2,l) *    SIc0OK
c #SI.      +G1_dSV          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        g2sSNo(i,j,2,l) =
c #SI.       g2sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g2sSNo(i,j,2,l) *    SIc0OK
c #SI.      +30.             *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        nhsSNo(i,j,2,l) =
c #SI.       nhsSNo(i,j,2,l)                  *(1-maskSL(i,j))
C #SI.new  +(nhsSNo(i,j,2,l) *    SIc0OK
C #SI.new   +istdSV(2)       *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI.     + istdSV(2)       *                    maskSL(i,j)
c #SI     END DO
c #SI     DO l=1,llx
c #SI        TsolTV(i,j,2,l) =
c #SI.       TsolTV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(TsolTV(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,l) *(1.-SIc0OK)       )*maskSL(i,j)
C +
c #SI        eta_TV(i,j,2,l) =
c #SI.       eta_TV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     + eta_TV(i,j,2,l) *    SIc0OK  *       maskSL(i,j)
C +...                            No Pore in Ice => No Water
c #SI     END DO
C +
c #WI        write(6,6001) jdarGE,labmGE(mmarGE),iyrrGE
c #WI.                    ,jhurGE,minuGE,jsecGE ,TsolTV(i,j,1,1)
c #WI.                    ,FraOcn,ifraTV(i,j,1) ,TsolTV(i,j,2,1)
c #WI.                    ,       nisSNo(i,j,2) ,nssSNo(i,j,2)
C +
c #SI   END DO
c #SI   END DO
c #SI END IF

C +--Otherwise SST and FrLead have been computed in the Sea-Ice Polynya Model
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +--Rainfall, Snowfall Time Integral at previous Time Step
C +  ------------------------------------------------------

c #HY   DO j=1,my
c #HY   DO i=1,mx
c #HY                       rai0HY(i,j)=rainHY(i,j)    ! Rainfall Time Integral
c #HY                       sfa0HY(i,j)=snowHY(i,j)    ! Snowfall Time Integral
c #HY   END DO                                         ! Erosion  skipped
c #HY   END DO


!  Wind Horizontal Components         at previous Time Step
!  --------------------------------------------------------

c #ZA   DO j=1,my
c #ZA   DO i=1,mx
c #ZA                       ua_0BS(i,j)=uairDY(i,j,mz) ! 
c #ZA                       va_0BS(i,j)=vairDY(i,j,mz) ! 
c #ZA   END DO                                         ! 
c #ZA   END DO


C +--Additional OUTPUT for VERIFICATION
C +  ----------------------------------

c #WR DO j=jp11,my1
c #WR DO i=ip11,mx1
c #WR   IF (ifrVER(i,j).ne.100) write(6,660) isolSL(i,j),i,j,ifrVER(i,j)
c #WR.                                     ,(ifraTV(i,j,n),n=1,nvx)
 660    format(' WARNING: Mosaic',i2,' (',2i4,') = ',i4,i6,2i4)
c #WR END DO
c #WR END DO

c #WR i = imez + 10.*111.111e3/dx
c #WR j = jmez
c #WR write(6,6060) itexpe,jdarGE,labmGE(mmarGE),iyrrGE
c #WR.                    ,jhurGE,minuGE        ,GElatr(i,j)/degrad
c #WR.             ,tairDY(i,j,mz),virDY(i,j,mz),1.e3*rolvDY(i,j,mz)
c #WR.             ,hsenSL(i,j)  ,hlatSL(i,j),-86400.0*SLuqs(i,j)
c #WR.        ,1.e3*rainHY(i,j)  ,evapTV(i,j),        runoTV(i,j)
 6060 format(i6,i3,'-',a3,'-',i4,':',i2,':',i2,f6.2,'?N',
     .       f9.3,' K',f6.3,f6.3,' kg/m3',2(f6.1,' W/m2'),
     .       f6.3,' mm/day',3(f9.3,' mm'))

C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR   write(6,6100)
 6100   format(/,'Verification of Vectorization: Before CALL')
c #VR   DO n=mw,1,-1
c #VR   DO j=my,1,-1
c #VR   write(6,6110) (ij0ver(i,j,n),i=1,mx)
 6110   format(132i1)
c #VR   ENDDO
c #VR   write(6,6103)
 6103   format(1x)
c #VR   ENDDO

c #VR   write(6,6101)
 6101   format(/,'Verification of Vectorization: After  CALL')
c #VR   DO n=mw,1,-1
c #VR   DO j=my,1,-1
c #VR   write(6,6110) (ij_ver(i,j,n),i=1,mx)
c #VR   ENDDO
c #VR   write(6,6103)
c #VR   ENDDO

c #VR   DO n=1,mw
c #VR   DO j=1,my
c #VR   DO i=1,mx
c #VR     IF (ijdver(i,j,n).NE.0 .AND. ij_ver(i,j,n).NE.1)
c #VR.      write(6,6102) i,j,n,ijdver(i,j,n)
 6102       format(' Vectorization ERROR on',3i4,'   (',i6,')')
c #VR   ENDDO
c #VR   ENDDO
c #VR   ENDDO


C +--Work Array Reset
C +  ================

        DO j=1,my
        DO i=1,mx
          WKxy1( i,j)   = 0.
          WKxy2( i,j)   = 0.
          WKxy3( i,j)   = 0.
          WKxy5( i,j)   = 0.
          WKxy6( i,j)   = 0.
          WKxy7( i,j)   = 0.
        END DO
        END DO

        DO k=1,mw
        DO j=1,my
        DO i=1,mx
          WKxyz1(i,j,k) = 0.
          WKxyz2(i,j,k) = 0.
          WKxyz3(i,j,k) = 0.
          WKxyz4(i,j,k) = 0.
          WKxyz5(i,j,k) = 0.
          WKxyz6(i,j,k) = 0.
          WKxyz7(i,j,k) = 0.
          WKxyz8(i,j,k) = 0.
        END DO
        END DO
        END DO

      IF (.not.INI_SV)
     .         INI_SV = .true.

      return
      end


      subroutine PHY_SISVAT_MP(ihamr_SIS,nhamr_SIS)

C +------------------------------------------------------------------------+
C | MAR          SISVAT_Driver                        Thu 10-Nov-2011  MAR |
C |   SubRoutine PHY_SISVAT    interfaces MAR        with        the       |
C |              Soil/Ice Snow Vegetation Atmosphere Transfer Scheme       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT: ihamr_SIS: Time Digital Filter Status                         |
C |   ^^^^^  nhamr_SIS: Time Digital Filter Set Up                         |
C |                                                                        |
C |   INPUT    (via common block)                                          |
C |   ^^^^^     VegMod: SISVAT    is set up when .T.                       |
C |             SnoMod: Snow Pack is set up when .T.                       |
C |             reaLBC: Update Bound.Condit.when .T.                       |
C |             iterun: Run Iterations Counter                             |
C |                                                                        |
C |   INPUT    (via common block)                                          |
C |   ^^^^^     xxxxTV: SISVAT/MAR interfacing variables                   |
C |                                                                        |
C | # CAUTION: #sa: Stand Alone Preprocessing Label must be removed        |
C | # ^^^^^^^       when SISVAT is coupled with MAR                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT PHYSICS                                |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^                                |
C | #                        #HY                                           |
C | #                        #SN: Snow         Model                       |
C | #                        #BS: Blowing Snow Parameterization            |
C | #                        #SI  Sea-Ice      Parameterization            |
C | #                        #GP  LAI and GLF  Variations not specified    |
C | #                        #OP  SST       is interactive                 |
C |                                                                        |
C | #                        #DS: diffuse radiation differing from direct  |
C |                              (variable RADsod must still be included)  |
C |                                                                        |
C |   Preprocessing  Option: SISVAT PHYSICS: Col de Porte                  |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^                  |
C | #                        #CP: SBL,                       Col de Porte  |
C | #                        #cp  Solar Radiation,           Col de Porte  |
C | #                        #AG: Snow Ageing,               Col de Porte  |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # ANI.yyyymmdd.LAB.nc  | #NC: OUTPUT on NetCDF File (Stand Alone EXP.) |
C |                        |                                               |
C | # SISVAT_iii_jjj_n     | #E0: OUTPUT on ASCII  File (SISVAT Variables) |
C | #                      |(#E0  MUST BE PREPROCESSED BEFORE #e1 & #e2 !) |
C | # SISVAT_iii_jjj_n     ! #e1: OUTPUT/Verification: Energy Conservation |
C | # SISVAT_iii_jjj_n     ! #e2: OUTPUT/Verification: Energy Consrv.2e pt.|
C |                        |                           (no premature stop) |
C |                        |                                               |
C | # SISVAT_iii_jjj_n     | #m0: OUTPUT/Verification: H2O    Conservation |
C | # SISVAT_iii_jjj_n     | #m1: OUTPUT/Verification: * Mass Conservation |
C | # SISVAT_iii_jjj_n     | #m2: OUTPUT/Verification: SeaIce Conservation |
C |                        |                                               |
C | # SISVAT_zSn.vz        | #vz: OUTPUT/Verification: Snow Layers Agrega. |
C |                        |      unit 41, SubRoutine  SISVAT_zSn **ONLY** |
C | # SISVAT_qSo.vw        | #vw: OUTPUT/Verif+Detail: H2O    Conservation |
C |                        |      unit 42, SubRoutine  SISVAT_qSo **ONLY** |
C | # SISVAT_qSn.vm        | #vm: OUTPUT/Verification: Energy/Water Budget |
C |                        |      unit 43, SubRoutine  SISVAT_qSn **ONLY** |
C | # SISVAT_qSn.vu        | #vu: OUTPUT/Verification: Slush  Parameteriz. |
C |                        |      unit 44, SubRoutine  SISVAT_qSn **ONLY** |
C | # SISVAT_wEq.ve        | #ve: OUTPUT/Verification: Snow/Ice Water Eqv. |
C |                        |      unit 45, SubRoutine  SISVAT_wEq **ONLY** |
C | # SnOptP____.va        | #va: OUTPUT/Verification: Albedo Parameteriz. |
C |                        |      unit 46, SubRoutine  SnOptP     **ONLY** |
C | # SISVAT_GSn.vp        | #vp: OUTPUT/Verification: Snow   Properties   |
C |                        |      unit 47, SubRoutines SISVAT_zSn, _GSn    |
C | # PHY_SISVAT.v0        | #v0: OUTPUT/Verification: DUMP                |
C |                        |      unit 50, SubRoutine  PHY_SISVAT **ONLY** |
C |                        |                                               |
C | # stdout               | #s0: OUTPUT of Snow Buffer Layer              |
C |                        |      unit  6, SubRoutine  SISVAT     **ONLY** |
C | # stdout               | #wx: OUTPUT/Verification: specified i,j,k,n   |
C | # stdout               | #wz: OUTPUT of Roughness Length (Blown Snow)  |
C |                        |      unit  6, SubRoutines SISVAT, PHY_SISVAT  |
C |                        |                                               |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARCTR.inc"
      include  "MARphy.inc"

      include  "MARdim.inc"
      integer   mw0
      parameter(mw0=3)
      include  "MARgrd.inc"
      include  "MAR_GE.inc"

      include  "MAR_RA.inc"

      include  "MAR_LB.inc"
      include  "MAR_DY.inc"
c #HY include  "MAR_HY.inc"
c #BW include  "MAR_TE.inc"
      include  "MAR_TU.inc"

c #TC include  "MAR_TC.inc"

      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"

      include  "MAR_SL.inc"
c #AO include  "MAR_AO.inc"
      include  "MAR_TV.inc"
      include  "MAR_BS.inc"
c #SN include  "MARsSN.inc"
c #IB include  "MAR_IB.inc"

      include  "MARsIB.inc"
c #PO include  "MAR_PO.inc"

      include  "MAR_WK.inc"

      integer   ihamr_SIS ,nhamr_SIS          ! Hamming Filter Counters
      integer   newglfSIS                     !
      integer   newsicSI                      !

      real          rtime
      integer       ntime
      common/c_time/ntime


C +--INTERFACE Variables
C +  ===================

      include  "MARxSV.inc"
      include  "MARySV.inc"


C +--Level of negligible blown Snow Particles Concentration
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE integer                 kB
c #AE common  /SISVAT_MAR__BS/kB

C +--10-m Level
C +  ~~~~~~~~~~
        integer                  kSBL
        common /PHY_SISVAT_SBLi/ kSBL
        real                     rSBL10,VV__10(mx,my)
        common /PHY_SISVAT_SBLr/ rSBL10

C +--V,  dT(a-s)    Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AW real             V__mem(klonv,ntaver)   ! ntaver defined in MAR_SL.inc
c #AW real             VVmmem(klonv)          !
c #AW common/SVeSBLmem/V__mem,VVmmem          !
c #AH real             T__mem(klonv,ntaver)   !
c #AH real             dTmmem(klonv)          !
c #AH common/STeSBLmem/T__mem,dTmmem          !

!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/,
!$OMP./SVeSBLmem/,/STeSBLmem/)

C +--u*, u*T*, u*s* Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM real             u__mem(klonv,ntaver)   ! ntaver defined in MAR_SL.inc
c #AT real             uT_mem(klonv,ntaver)   !
c #AS real             us_mem(klonv,ntaver)   !
c #AM common/S_eSBLmem/u__mem                 !
c #AT.                ,uT_mem                 !
c #AS.                ,us_mem                 !

C +--OUTPUT for Stand Alone NetCDF File
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #NC real          SOsoKL(klonv)             ! Absorbed Solar Radiation
c #NC real          IRsoKL(klonv)             ! Absorbed IR    Radiation
c #NC real          HSsoKL(klonv)             ! Absorbed Sensible Heat Flux
c #NC real          HLsoKL(klonv)             ! Absorbed Latent   Heat Flux
c #NC real          HLs_KL(klonv)             ! Evaporation
c #NC real          HLv_KL(klonv)             ! Transpiration
c #NC common/DumpNC/SOsoKL,IRsoKL
c #NC.             ,HSsoKL,HLsoKL
c #NC.             ,HLs_KL,HLv_KL

c #NC real          SOsoNC(mx,my,nvx)         ! Absorbed Solar Radiation
c #NC real          IRsoNC(mx,my,nvx)         ! Absorbed IR    Radiation
c #NC real          HSsoNC(mx,my,nvx)         ! Absorbed Sensible Heat Flux
c #NC real          HLsoNC(mx,my,nvx)         ! Absorbed Latent   Heat Flux
c #NC real          HLs_NC(mx,my,nvx)         ! Evaporation
c #NC real          HLv_NC(mx,my,nvx)         ! Transpiration
c #NC real          eta_NC(mx,my,nvx)         ! Soil Humidity
c #NC common/writNC/SOsoNC,IRsoNC             !
c #NC.             ,HSsoNC,HLsoNC             !
c #NC.             ,HLs_NC,HLv_NC,eta_NC      !

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx integer             iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1
! #wx common/SISVAT_EV/   iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1


C +--Internal  Variables
C +  ===================

      logical StandA
      logical glfFIX

      integer                  ijnmax,nvcmax  ! Control Indices Distribution
      common  /SISVAT_MAR_Loc/ ijnmax,nvcmax  ! Control Indices Distribution
      integer k2i(klonv)                      ! Distributed i      Index
      integer k2j(klonv)                      ! Distributed j      Index
      integer k2n(klonv)                      ! Distributed mosaic Index
c #VR integer               ij0ver(mx,my,mw)  ! Verification of Vectorization
c #VR integer               ij_ver(mx,my,mw)  ! Verification of Vectorization
c #VR integer           ij2,ijdver(mx,my,mw)  ! Verification of Vectorization

      character*1   cha  ,chb
      integer iwr  ,ipt  ,l,nvcmax2,ijnmax2,itPhys
      integer ikl  ,isl  ,isn
      integer ijn  ,ij   ,nnn
      integer nvc  ,nkl  ,n     ,nt

      real     slopx ,slopy                   ! Surf.Slope, x, y
      real     czemin                         ! Minimum accepted 
C +                                           ! cos(Solar zenith.Dist.)
      real     Upw_IR(mx,my)                  ! Upward IR Flux
      real     IR_aux                         ! Upward IR Flux  (dummy)

      real     uqstar                         ! u*q*
      real     rhAir                          ! Air    Densitity
      real     Ua_min                         ! Minimum Air Velocity
      real     rr__DR(mx,my,mw)               ! Desagregated  Rain    
      real     hfra  (mx,my,mw)               ! Frazil Thickness
      real     Rnof  (mx,my,mw)               ! RunOFF Intensity
      real     d_snow,SnowOK                  ! Snow Precip.: Total
      real     dbsnow                         ! Snow Precip.: from Drift
c #SZ real     dsastr(mx,my)                  ! z0(Sastrugi): Variation

      real     WVaLim(mx,my)                  !

      real                    FixSST,VarSST   ! SST forcing switch
      real                           SSTnud   ! SST Nudging Rate
      common  /SISVAT_MAR_ocn/FixSST,VarSST   !
     .                              ,SSTnud   !

c #SI real     ifra_t                         !
cXF
c #SI real     SrfSIC,SIc0OK                  ! Oceanic Fraction: previous
c #SI real     FraOcn,SIceOK                  ! Oceanic Fraction
c #SI real     TocnSI                         ! Ocn Temp.=> S-Ice Covered
c #SI real     OcnMin                         ! Oceanic Fraction: Minimum
c #SI real     dzSIce(4)                      ! Sea-Ice Layers    Thickness
c #SI real     SIcMIN                         ! Sea-Ice Layer Min Thickness
c #SI real     SIc_OK(2)                      ! Sea-Ice Switch
c #SN real     c1_zuo,c2_zuo,c3_zuo           ! Run Off Parameters
c #SN real     SnowWE                         ! Snow Water Equivalent[m w.e.]
c #SN real     rosNEW                         ! Added Snow Density    [kg/m3]
c #SN real     S_Eros,SnEros                  ! Snow Erosion (status) = (1,0)

c #BW integer  noUNIT
c #BW real     BlowST,SnowSB

c #WR integer  ifrVER(mx,my)                  ! Verification Variable: 
                                              ! Total Fraction must be 100%

      real     tairDY_2D(mx,my),qvDY_2D(mx,my)

C +--DATA
C +  ====

      data     StandA       /  .true. /
      data     glfFIX       /  .false./
      data     cha/'-'/
      data     chb/':'/

      data     czemin       /   1.e-3 /

c #SI data     TocnSI       / 270.70  /       ! Ocn Temp.=> S-Ice Covered
c #SI data     OcnMin       /   0.05  /       ! Oceanic Fraction: Minimum
c #SI data     dzSIce /0.5,0.05,0.001,0.0/    ! Sea-Ice Layers    Thickness
c #SI data     SIcMIN /0.1/                   ! Sea-Ice Layer Min Thickness
c #SI data     SIc_OK /1.0,0.00/              ! Sea-Ice Switch
C +
c #SN data    c1_zuo/12.960e+4/,c2_zuo/2.160e+6/,c3_zuo/1.400e+2/ ! Zuoriginal
C #SN data    c1_zuo/ 2.796e+4/,c2_zuo/2.160e+6/,c3_zuo/1.400e+2/ !     Tuning
C +...        Run Off Parameters
C +           86400*1.5 day     ...*25 days (Modif. ETH Camp: 86400*0.3day)
C +           (Zuo and Oerlemans 1996, J.Glacio. 42, 305--317)


C +--SISVAT Time             Variable
C +  ================================

          dt__SV = dt ! dtPhys


C +   ++++++++++++++++  INITIALISATION: BEGIN +++
      IF (.not.INI_SV)                                            THEN
C +   ++++++++++++++++


C +--OUTPUT point (i,j,n) coordinates
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          iwr_SV = 1
          jwr_SV = 1
          nwr_SV = 1

C +--Level of negligible blown Snow Particles Concentration ( ~ 25 magl)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE        kB    =mz 
 11      CONTINUE
c #AE    IF (zsigma(kB    ).GT. 25..OR.kB    .LE.1)             GO TO 10
c #AE        kB    =kB    -1
c #AE                                                           GO TO 11
 10      CONTINUE
c #AE        write(6,1000)             kB
 1000        format(/,' BS : Level of negligible '
     .                     ,'blown Snow Particles Concentration is',i4
     .                     ,' (i.e., ~  25. magl)',/)

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx  iSV_v1= imez     ! Snow Erosion Statistics: Grid Point Coordinate
! #wx  jSV_v1= jmez     ! Id.
! #wx  nSV_v1= 1        ! Id.
! #wx  lSV_v1= 1        ! Snow Erosion Statistics: OUTPUT SWITCH (IF   >   0)
                        !                          .LE. 1 Blowing Snow
                        !                          .LE. 2 Blowing Snow (FULL)
                        !                          .EQ. 3 Snow    Agregation


C +--SISVAT Time Independant Variables
C +  =================================

c #sa                   StandA=.false.
        IF (VSISVAT.AND.StandA)                                   THEN
          write(6,600)
 600      format(/,'### MAR_SISVAT CRASH,',
     .                      ' STAND ALONE LABEL #sa is ON ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
          stop
        END IF

        IF (mw.ne.nvx)                                            THEN
          write(6,601) mw,nvx
 601      format(/,'### MAR_SISVAT CRASH, mw =',i6,
     .                            ' .NE. nvx =',i6,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
          stop
        END IF

c #SN   IF (mw.ne.nsx)                                            THEN
c #SN     write(6,602) mw,nsx
 602      format(/,'### MAR_SISVAT CRASH, mw =',i6,
     .                            ' .NE. nvx =',i6,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
c #SN     stop
c #SN   END IF

        IF (nsol+1.ne.llx)                                        THEN
          write(6,603)  nsol+1,llx
 603      format(/,'### MAR_SISVAT CRASH, ns =',i6,
     .                            ' .NE. nvx =',i6,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
          stop
        END IF

        IF (nb_wri.gt.mz      )                                   THEN
          write(6,604) nb_wri,mz
 604      format(/,'### MAR_SISVAT CRASH, nb_wri =',i6,
     .                            ' .GT. mz      =',i3,' ',2x,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
          stop
        END IF

        IF (nb_wri.gt.mw *iptx)                                   THEN
          write(6,605) nb_wri,mw ,iptx
 605      format(/,'### MAR_SISVAT CRASH, nb_wri =',i6,
     .                            ' .GT. mw *iptx=',i3,'*',i2,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
c          stop
        END IF

c #SN   IF (nb_wri.gt.nsx*iptx)                                   THEN
c #SN     write(6,606) nb_wri,nsx,iptx
 606      format(/,'### MAR_SISVAT CRASH, nb_wri =',i6,
     .                            ' .GT. nsx*iptx=',i3,'*',i2,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
c #SN     stop
c #SN   END IF

!c #SN   IF (mz    .LT.nsno    )                                   THEN
!c #SN     write(6,607) mzz   ,nsno     
 607      format(/,'### MAR_SISVAT CRASH, mz     =',i6,
     .                            ' .GT. nsno    =',i3,' ',2x,' ###',
     .           /,'    ?!&~@|@[#@#]=!!!',23x,'EMERGENCY STOP')
!c #SN     stop
!c #SN   END IF

c #BS   IF (klonv.ne.256)                                          THEN
c #BS     write(6,608) klonv
 608      format(/,'#BS MAR_SISVAT CRASH, klonv =',i6,'.ne.256 ###',
     .           /,'    ?!&~@|@[#@#]=!!!',15x,'EMERGENCY STOP')
c #BS     stop
c #BS   END IF


C +     ****************
        call  SISVAT_ini
C +     ****************


C +--Grids Correspondance
C +  --------------------

c #sa   DO isl = -nsol,0
c #sa     deptTV(1-isl)= dz_dSV(isl)
c #sa   END DO

            ntime  = 0

            ijnmax = mx2* my2* nvx
        IF      (mod(ijnmax ,klonv).eq.0)                         THEN
            nvcmax = ijnmax /klonv
        ELSE
            nvcmax = ijnmax /klonv + 1
        END IF
C +
C +
C +--Surface Fall Line Slope
C +  -----------------------
C +
c #SN   IF (SnoMod)                                               THEN
          IF (mx.eq.1.AND.my.eq.1)                                THEN
c #SN       SWfSNo(1,1)=                             ! Normalized Decay of the
c #SN.       exp(-dt__SV                             ! Surficial Water Content
c #SN.          /(c1_zuo                             !(Zuo and Oerlemans 1996,
c #SN.           +c2_zuo*exp(-c3_zuo*slopTV(1,1))))  ! J.Glacio. 42, 305--317)
          ELSE
            DO j=jp11,my1
            DO i=ip11,mx1
            slopx      =(sh(ip1(i),j)-sh(im1(i),j))*dxinv2
            slopy      =(sh(i,jp1(j))-sh(i,jm1(j)))*dyinv2
            slopTV(i,j)= sqrt(slopx *slopx + slopy *slopy)
c #SN       SWfSNo(i,j)=                             ! Normalized Decay of the
c #SN.       exp(-dt__SV                             ! Surficial Water Content
c #SN.          /(c1_zuo                             !(Zuo and Oerlemans 1996,
c #SN.           +c2_zuo*exp(-c3_zuo*slopTV(i,j))))  ! J.Glacio. 42, 305--317)
c #SN       slopGE(i,j)=    cos(atan(slopTV(i,j)))
            END DO
            END DO
          END IF
c #SN   END IF


C +--Initialization of Surface Types
C +  ===============================

        IF (itexpe.EQ.0)                                          THEN
          DO j=jp11,my1
          DO i=ip11,mx1
            IF (maskSL(i,j).eq. 1)                                THEN
                nSLsrf(i,j)   = 1                           ! Ocean Grid Pt
                SLsrfl(i,j,1) = 1.
              IF(mw.gt.1)                                         THEN
              DO n=min(2,mw),nvx
                SLsrfl(i,j,n) = 0.
              END DO
              END IF
            ELSE
                nSLsrf(i,j)   = nvx                         ! Land  Grid Pt
              DO n=1,nvx
                SLsrfl(i,j,n) = ifraTV(i,j,n)
                SLsrfl(i,j,n) = SLsrfl(i,j,n) * 0.01
              END DO
            END IF


C +--Initialization of z0(Sastrugi)
C +  ==============================

! Influence of the Angle(Wind,Sastrugi) (Andreas, 1995, CCREL report 95-16)
! -------------------------------------------------------------------------

c #ZA           ua_0BS(i,j)=uairDY(i,j,mz) 
c #ZA           va_0BS(i,j)=vairDY(i,j,mz) 


!  Sastrugi Height
!  ---------------

          DO n=1,mw
c #SZ           Z0SaBS(i,j,n)    = 0.
c #ZM       DO nt=1,ntavSL
c #ZM           SLn_z0(i,j,n,nt) = 0.5e-6
c #ZM           SLn_b0(i,j,n,nt) = 0.5e-6
c #ZM           SLn_r0(i,j,n,nt) = 0.5e-6
c #ZM       END DO
          END DO
          END DO
          END DO

        END IF


! Influence of the Angle(Wind,Sastrugi) (Andreas, 1995, CCREL report 95-16)
! -------------------------------------------------------------------------

c #ZA           FracBS=exp(-dt__SV/43200.)


C +--Initialization of z0(Orography Roughness)
C +  =========================================

c #OR    DO k=1,mw
c #OR    DO j=1,my
c #OR    DO i=1,mx
c #OR       SL_z0 (i,j,k) = min(SL_z0 (i,j,k),zsigma(mz)/3.)
c #OR       SLzoro(i,j,k) = min(SLzoro(i,j,k),zsigma(mz)/3.)
c #OR    END DO
c #OR    END DO
c #OR    END DO


C +--Ocean Status
C +  ============

c #SI         VarSST        =   0.
c #OP         VarSST        =   1.
              FixSST        =   1.-VarSST
              SSTnud        = exp(-dt__SV/2.592e6)  ! SST    Nudging:
C +...                                              ! e-folding time: 30 Days
C +
c #SI   IF (itexpe.EQ.0)                                          THEN
c #SI     DO j=jp11,my1
c #SI     DO i=ip11,mx1
c #SI       IF (maskSL(i,j).gt.0.AND.ifraTV(i,j,1).lt.100)        THEN
c #SI           write(6,6000)i,j,(ifraTV(i,j,n),n=1,nvx)
 6000           format(' WARNING on Grid Point',2i4,' Mosaic = (',3i4,
     .                 '): ISLANDS must(will) be excluded')
c #SI         DO n=1,nvx
c #SI           ifraTV(i,j,n) =   0
c #SI           ivegTV(i,j,n) =   0
c #SI         END DO
c #SI           ifraTV(i,j,1) = 100
c #SI       END IF
c #SI     END DO
c #SI     END DO


C +--Prescription from SST
C +  ---------------------

c #SI                                     Tfr_LB = TocnSI
c #RE                                     Tfr_LB = 271.35 + epsi
c #SI     DO j=jp11,my1
c #SI     DO i=ip11,mx1
c #SI        FraOcn          =    (TsolTV(i,j,1,1)-Tfr_LB)/TSIdSV! Open Ocean
c #IP        FraOcn          =  1.-sicsIB(i,j)                   ! Prescribed
c #SI        FraOcn          = min(  unun,FraOcn)                !      Fract.
c #SI        FraOcn          = max(OcnMin,FraOcn)                !
c #SI        SLsrfl(i,j,1)   =  (1-maskSL(i,j))  * SLsrfl(i,j,1) ! New  Ocean
c #SI.                          +  maskSL(i,j)   * FraOcn        !
c #SI        SrfSIC          =                     SLsrfl(i,j,2) ! Old  Sea Ice
c #SI        SIc0OK          = max(zero, sign(unun,SrfSIC-epsi)) !
c #SI        SLsrfl(i,j,2)   =  (1-maskSL(i,j))  * SLsrfl(i,j,2) ! New  Sea Ice
c #SI.                          +  maskSL(i,j)*(1.-FraOcn)       !
c #SI        SIceOK          = max(zero, sign(unun,SLsrfl(i,j,2) !
c #SI.                                                   -epsi)) !
c #SI        ifra_t          =     ifraTV(i,j,1) + ifraTV(i,j,2) ! OCN  Fract.
c #SI        ifraTV(i,j,1)   =     SLsrfl(i,j,1) * 100.          !
c #SI        ifraTV(i,j,1)   = min(ifraTV(i,j,1) , ifra_t)       !
c #SI        ifraTV(i,j,2)   =     ifra_t        - ifraTV(i,j,1) !

C +--Sea-Ice Vertical Discretization
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SI        nssSNo(i,j,2)   =  
c #SI.       nssSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(nssSNo(i,j,2)   *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        nisSNo(i,j,2)   =  
c #SI.       nisSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(nisSNo(i,j,2)   *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI        issSNo(i,j,2)   =                    nisSNo(i,j,2)

c #SI       DO l=1,nsno
c #SI        dzsSNo(i,j,2,l) =
c #SI.       dzsSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(dzsSNo(i,j,2,l) *    SIc0OK
c #SI.      +dzSIce(min(4,l))*(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        tisSNo(i,j,2,l) =
c #SI.       tisSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(tisSNo(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,1) *(1.-SIc0OK)       )*maskSL(i,j)

c #SI        rosSNo(i,j,2,l) =
c #SI.       rosSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(rosSNo(i,j,2,l) *    SIc0OK
c #SI.      +ro_Ice          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        g1sSNo(i,j,2,l) =
c #SI.       g1sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g1sSNo(i,j,2,l) *    SIc0OK
c #SI.      +G1_dSV          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        g2sSNo(i,j,2,l) =
c #SI.       g2sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g2sSNo(i,j,2,l) *    SIc0OK
c #SI.      +30.             *(1.-SIc0OK)*SIceOK)*maskSL(i,j)

c #SI        nhsSNo(i,j,2,l) =
c #SI.       nhsSNo(i,j,2,l)                  *(1-maskSL(i,j))
C #SI.new  +(nhsSNo(i,j,2,l) *    SIc0OK
C #SI.new   +istdSV(2)       *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI.     + istdSV(2)       *                    maskSL(i,j)
c #SI       END DO
c #SI       DO l=1,llx
c #SI        TsolTV(i,j,2,l) =
c #SI.       TsolTV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(TsolTV(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,l) *(1.-SIc0OK)       )*maskSL(i,j)

c #SI        eta_TV(i,j,2,l) =
c #SI.       eta_TV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     + eta_TV(i,j,2,l) *    SIc0OK  *       maskSL(i,j)
C +...                            No Pore in Ice => No Water
c #SI       END DO

c #WI        write(6,6001) jdarGE,labmGE(mmarGE),iyrrGE
c #WI.                    ,jhurGE,minuGE,jsecGE ,TsolTV(i,j,1,1)
c #WI.                    ,FraOcn,ifraTV(i,j,1) ,TsolTV(i,j,2,1)
c #WI.                    ,       nisSNo(i,j,2) ,nssSNo(i,j,2)
 6001        format(/,98('_'),
     .              /,i3,'-',a3,'-',i4,3(':',i2),
     .                2x,'T OCN = ',f7.3,4x,'% OCN = ',f7.3,'(',i3,')',
     .                2x,'T ICE = ',f7.3,
     .             /,42x,'NbIce = ',i3, 11x,'NbSno = ',i3)

c #SI     END DO
c #SI     END DO
c #SI   END IF


C +--Soil Upward IR Flux
C +  ===================

        IF (itexpe.EQ.0)                                          THEN
          DO j=jp11,my1
          DO i=ip11,mx1
            IR_aux        =
     .     -eps0SL(i,j)* stefan*TairSL(i,j)*TairSL(i,j)    ! Upward IR Flux
     .                         *TairSL(i,j)*TairSL(i,j)    !
          DO n=   1,nvx
            IRsoil(i,j,n) =     IR_aux
          END DO


C +--Water Vapor Flux Limitor
C +  ========================

c #VX     DO n=   1,nLimit
c #VX       WV__SL(i,j,n) =     1.
c #VX     END DO

          END DO
          END DO


C +--SBL  Characteristics
C +  ====================

c #AA     DO nt=  1,ntaver
c #AA     DO j=   1,my
c #AA     DO i=   1,mx
c #AW       V_0aSL(i,j,  nt) =  ssvSL(i,j,mz)
c #AH     DO n=   1,nvx
c #AH       dT0aSL(i,j,n,nt) = tairDY(i,j,mz)-tsrfSL(i,j,n)
c #AH     END DO
c #AA     END DO
c #AA     END DO
c #AA     END DO

        END IF


C +--OUTPUT Files Definition
C +  =======================

! #v0   open(unit=50,status='unknown',file='PHY_SISVAT.v0')
! #v0   rewind    50
    
        IF (mmy.LE.1.AND.mw.GT.mw0)                               THEN
            open(unit=51,status='unknown',file='Dsagrr.OUT')
            rewind    51
            write(51,5100) 
 5100       format(/,' Simple Disagregation Model',
     .             /,' ==========================')
        END IF

           iwr = 0
        DO ipt = 1,iptx
           IF (IOi_TV(ipt).EQ.0) IOi_TV(ipt)=imez
           IF (IOj_TV(ipt).EQ.0) IOi_TV(ipt)=jmez
        DO n   = 1,nvx
           iwr = 1+iwr
          IF (iwr.LE.nb_wri)                                      THEN
           no__SV(iwr) = 0
           i___SV(iwr) = IOi_TV(ipt)
           j___SV(iwr) = IOj_TV(ipt)
           n___SV(iwr) = n
          END IF
        END DO
        END DO


C +--Initialization of V10 Interpolation
C +  ===================================

        if   (zsigma(1).GT.10.          )                           THEN
          k = 0
  301     CONTINUE
          k = k + 1
            if (zsigma(k).LT.10.OR.k.gt.mz)                    GO TO 300
                                                               GO TO 301
  300     CONTINUE
          kSBL = k

          IF (kSBL.EQ.mz)                                           THEN
              rSBL10 = log(10.           / 0.002)    ! 0.002: typical Z0
     .                /log(zsigma(kSBL)  / 0.002)    !

          ELSE
              rSBL10 =    (10.           - zsigma(kSBL))
     .                /   (zsigma(kSBL-1)- zsigma(kSBL))
          END IF
        ELSE
              kSBL   =     mz
              rSBL10 =      1.
        END IF


C +   ++++++
      END IF
C +   ++++++       +++  INITIALISATION:  END  +++


C +--Preparation    of V10 Interpolation
C +  ===================================

        IF (kSBL.EQ.mz)                                             THEN
          DO j=1,my
          DO i=1,mx
            VV__10(i,j) = rSBL10 *  ssvSL(i,j,kSBL)
          ENDDO
          ENDDO
        ELSE
          DO j=1,my
          DO i=1,mx
            VV__10(i,j) =           ssvSL(i,j,kSBL)
     .                  + rSBL10 * (ssvSL(i,j,kSBL-1)-ssvSL(i,j,kSBL))
          ENDDO
          ENDDO
        END IF


C +--Preparation    of OUTPUT
C +  ========================

        DO n=   1,nvx
        DO j=jp11,my1
        DO i=ip11,mx1
          WKxyz1(i,j,n) = 0.
        END DO
        END DO
        END DO
        DO iwr = 1,nb_wri
          WKxyz1(i___SV(iwr),j___SV(iwr),n___SV(iwr)) = iwr
        END DO


C +--Update Sea-Ice    Fraction
C +  ==========================

c #IP IF (             reaLBC                    )                THEN

C +          ******
c #IP   call INIsic(ihamr_SIS,nhamr_SIS,newsicSI )
C +          ******

c #IP END IF


C +--Update Green Leaf Fraction
C +  ==========================

c #GP                                      glfFIX = .true.
c #sa IF (vegmod .AND. reaLBC .AND.  .NOT. glfFIX)                THEN
C +
C +          ******
c #sa   call INIglf(ihamr_SIS,nhamr_SIS,newglfSIS)
C +          ******
C +
c #sa END IF


C +--SISVAT Time   Dependant Variables
C +  =================================

C +--Water Vapor Flux Limitor
C +  ------------------------

c #VX DO n=1,nLimit-1
c #VX DO j=jp11,my1
c #VX DO i=ip11,mx1
c #VX   WV__SL(i,j,n) = WV__SL(i,j,n+1)
c #VX END DO
c #VX END DO
c #VX END DO

c #VX DO j=jp11,my1
c #VX DO i=ip11,mx1
c #VX   uqstar    = max(abs(SLuqs(i,j)),epsi)*sign(1.,SLuqs(i,j))
c #VX   WV__SL(i,j,n) 
c #VX. = TUkvh(i,j,mmz1) *(  qvDY(i,j,km2(mz))-  qvDY(i,j,mmz1))
c #VX. /(uqstar          *(zsigma(    km2(mz))-zsigma(    mmz1)))
c #VX END DO
c #VX END DO

c #VX DO j=jp11,my1
c #VX DO i=ip11,mx1
c #VX     WVaLim(i,j) = 0.
c #VX   DO n=1,nLimit
c #VX     WVaLim(i,j) = WVaLim(i,j)+WV__SL(i,j,n)
c #VX   ENDDO
c #VX     WVaLim(i,j) = WVaLim(i,j)/nLimit
c #VX END DO
c #VX END DO

C +--Simple "Mosaic" Rain Disagregation Model
C +  ----------------------------------------

      IF (mmy.LE.1.AND.mw.gt.mw0)                                 THEN !

C +--White Noise Generator
C +  ~~~~~~~~~~~~~~~~~~~~~
        IF (jhurGE.EQ.6.AND.minuGE.EQ.0.AND.jsecGE.EQ.0)          THEN
          rtime=      tairDY(imez,jmez,mz)*1.e3
          ntime= int(rtime)
          rtime=    (rtime -ntime)        *1.e3
          ntime=     rtime
          ntime= mod(ntime ,mw)+1
        END IF

C +--Averaged Soil Humidity
C +  ~~~~~~~~~~~~~~~~~~~~~~
        DO j=1,my
        DO i=1,mx
          WKxy1( i,j) = 0.                            ! Averaged Soil Humidity
        DO n=1,mw                                     !
        DO k=-nsol,0                                  !
          WKxy1( i,j) = WKxy1( i,j)                   !
     .                +eta_TV( i,j,n,1-k)*dz_dSV(k)   !
        END DO                                        !
        END DO                                        !
          WKxy1( i,j) = WKxy1( i,j) / (mw*zz_dSV)     !

C +--Rain Distribution !  Rain Persistance over "wetter" surfaces
C +  ~~~~~~~~~~~~~~~~~ ! (Taylor et al., 1997, MWR 125, pp.2211-2227)
          WKxy2( i,j)   = 0.                          ! Normalization Factor
        DO n=1,mw                                     !
          rr__DR(i,j,n) =  (mod( mw-n+ntime,mw) + 1)  ! Rain Distribution Arg.
     .     /(mw*WKxy1( i,j)     *WKxy1( i,j))         ! dry ===> sparse Rain
     .     *    eta_TV(i,j,n,1) /WKxy1( i,j)          ! Persistance   Impact
          rr__DR(i,j,n) =   min( rr__DR(i,j,n)        ! 
     .                          ,argmax*0.1   )       ! 
          rr__DR(i,j,n) =   exp(-rr__DR(i,j,n))       ! Rain Distribution
          k             =      ( n -1   ) / mw0       ! mw0 basic Mosaics
          k             =        k        * mw0 + 1   !
          rr__DR(i,j,n) =        rr__DR(i,j,k)        ! Rain Distribution Arg.
          WKxy2( i,j)   =        WKxy2( i,j)          ! Normalization Factor
     .                  +        rr__DR(i,j,n)        ! 
        END DO                                        !

        END DO
        END DO

        DO j=1,my
        DO i=1,mx
        DO n=1,mw
          rr__DR(i,j,n) = rr__DR(i,j,n)  *mw
     .                   /WKxy2( i,j)
        END DO
        END DO
        END DO

        IF(mod(jdarGE,3).EQ.0.AND.jhurGE.EQ.6.AND.
     .                            minuGE.EQ.0.AND.
     .                            jsecGE.EQ.0.AND.
     .     mmy          .LE.1                     )                 THEN
          DO i=1,mx
            IF      (isolSL(i,1).gt.2)                              THEN
              write(51,5101) jdarGE, labmGE(mmarGE) ,iyrrGE,jhurGE,
     .                       i     ,(eta_TV(i,1,n,1),n=1,mw)
 5101         format(i3,'-',a3,'-',i4,':',i2,i6,15f6.3,/,(21x,15f6.3))
              write(51,5102) 
     .        ntime,  isolSL(i,1)  ,(rr__DR(i,1,n)  ,n=1,mw)
 5102         format(i12,3x                 ,i6,15f6.2,/,(21x,15f6.2))
            END IF
          END DO
              write(51,5103)
 5103         format(111('-'))
        END IF
      ELSE
        DO j=1,my
        DO i=1,mx
        DO n=1,mw
          rr__DR(i,j,n) = 1.
        END DO
        END DO
        END DO
      END IF

c     - Interpolation of temp. and spec. hum. on sub_grid - *CL*
c     --------------------------------------------------------------

      do i=1,mx; do j=1,my
       do n=1,nsx
        tairDY_int(i,j,n) = tairDY(i,j,mz)
          qvDY_int(i,j,n) =   qvDY(i,j,mz)
           tairDY_2D(i,j) = tairDY(i,j,mz)
             qvDY_2D(i,j)   = qvDY(i,j,mz)
       enddo
      enddo; enddo

      IF (mw .eq. 5) then
C +       ************************************************************
          call interp_subpix(tairDY_2D,tairDY_int,1,-0.01,0.05
     .                       ,gradTM)
C +       ************************************************************

C +       ************************************************************
          call interp_subpix(qvDY_2D,qvDY_int,2,-1.0,1.0
     .                       ,gradQM)
C +       ************************************************************
      ENDIF


C +--Grid Averages
C +  -------------

!$omp PARALLEL DO default(shared)
!$omp.  private(i,j,k,n,l,ikl,isl,isn,nt,Ua_min,d_snow,SnowOK,
!$omp.          rhAir,FraOcn,SrfSIC,SIc0OK,SIceOK,ifra_t,
!$omp.          S_Eros,SnEros,dbsnow)
!$omp. copyin(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)
      DO j=jp11,my1
      DO i=ip11,mx1

                                 dt__SV = dt/real(ntphys)
      if(isolSL(i,j)<=2)         dt__SV = dt ! sea or ice
      if(tairDY(i,j,mz)<=270.13) dt__SV = dt ! T < -3C

c #BS                            dt__SV = min(dt/2.,dt__SV)
                                 dt__SV = min(dt   ,dt__SV)

C +--Surface Fall Line Slope
C +  -----------------------
C +
c #SN   IF (SnoMod)                                               THEN
c #SN     IF (mx.eq.1.AND.my.eq.1)                                THEN
c #SN       SWfSNo(1,1)=                             ! Normalized Decay of the
c #SN.       exp(-dt__SV                             ! Surficial Water Content
c #SN.          /(c1_zuo                             !(Zuo and Oerlemans 1996,
c #SN.           +c2_zuo*exp(-c3_zuo*slopTV(1,1))))  ! J.Glacio. 42, 305--317)
c #SN     ELSE
c #SN       SWfSNo(i,j)=                             ! Normalized Decay of the
c #SN.       exp(-dt__SV                             ! Surficial Water Content
c #SN.          /(c1_zuo                             !(Zuo and Oerlemans 1996,
c #SN.           +c2_zuo*exp(-c3_zuo*slopTV(i,j))))  ! J.Glacio. 42, 305--317)
c #SN     END IF
c #SN   END IF

      DO      itPhys=1,max(1,nint(dt/dt__SV))
c #WR   ifrVER(i,j)   = 0

CCCCC   RAdsol(i,j)   = sol_SL(i,j)/(1.d0-albeSL(i,j))     ! => downward Solar
cXF BUG BUG BUG !!!!!!
        albeSL(i,j)   = 0.
        eps0SL(i,j)   = 0.
        Upw_IR(i,j)   = 0.
         SLlmo(i,j)   = 0.
         SLuus(i,j)   = 0.
         SLuts(i,j)   = 0.
         SLuqs(i,j)   = 0.
c #HY   uss_HY(i,j)   = 0.
c #HY   qsrfHY(i,j)   = 0.
        TairSL(i,j)   = 0.
        draiTV(i,j)   = 0.
c #TC     uqTC(i,j,1) = 0.
c #TC     qsTC(i,j,1) = 0.


C +--Sastrugi Height decreased by Precipitation if V < 6 m/s (Kotlyakov, 1961)
C + --------------------------------------------------------------------------

c #SZ   dsastr(i,j) =       max(0.00,(snowHY(i,j)-sno0HY(i,j))
c #SZ. /max(0.05,0.104*sqrt(max(0.00, VV__10(i,j)-6.00       ))))


! Influence of the Angle(Wind,Sastrugi) (Andreas, 1995, CCREL report 95-16)
! -------------------------------------------------------------------------

c #ZA   S_Eros     = max(zero,sign(unun,-uss_HY(i,j)-eps9))
c #ZA   SnEros     = max(zero,sign(unun, uss_HY(i,j)+eps9))
c #ZA   VVs_BS(i,j) =    
c #ZA.           SnEros* VVs_BS(i,j)
c #ZA.         + S_Eros*(VVs_BS(i,j)   * FracBS +
c #ZA.                                   VV__10(i,j))
c #ZA   RRs_BS(i,j) =    
c #ZA.           SnEros* RRs_BS(i,j)
c #ZA.         + S_Eros*(RRs_BS(i,j)   * FracBS + 1.0             )
c #ZA   DDs_BS(i,j) =    
c #ZA.           SnEros* DDs_BS(i,j)
c #ZA.         + S_Eros* DDs_BS(i,j)   * FracBS 
c #ZA.         +       ((vairDY(i,j,mz)*(uairDY(i,j,mz) -ua_0BS(i,j))
c #ZA.                  -uairDY(i,j,mz)*(vairDY(i,j,mz) -va_0BS(i,j))))
c #ZA.   /(degrad*max(0.3,ssvSL(i,j,mz)*  ssvSL(i,j,mz)))

c #ZA    IF (DDs_BS(i,j).GT.360.) DDs_BS(i,j) = DDs_BS(i,j) - 360.
c #ZA    IF (DDs_BS(i,j).LT.  0.) DDs_BS(i,j) = DDs_BS(i,j) + 360.


C +--Grid  Point   Dependant Variables
C +  ---------------------------------

C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR         ij2           = 0
c #VR     DO n=   1,mw
c #VR         ij0ver(i,j,n) = 0
c #VR         ij_ver(i,j,n) = 0
c #VR         ijdver(i,j,n) = 0
c #VR     END DO

C +--SISVAT Variables Update
C +  ^^^^^^^^^^^^^^^^^^^^^^^

         DO n=1,mw
         IF (SLsrfl(i,j,n).ne.0) THEN
           DO  ikl = 1,klonv
              k2i(ikl)    = i
              k2j(ikl)    = j
              k2n(ikl)    = n
              ii__SV(ikl) = i                              ! Work pt. i Coord.
              jj__SV(ikl) = j                              ! Work pt. j Coord.
              nn__SV(ikl) = n                              ! Work pt. n Coord.

! #wz         IF (ikl.EQ.1.AND.jsecGE.EQ.0) 
! #wz.        write(6,6659) 
 6659         format(20x,'   dsn_SV   us__SV   Z0SaSi   Z0Sa_N'
     .                  ,'   Z0SaSV   Z0m_Sn   Z0m_SV')

C +--Atmospheric Forcing                                    (INPUT)
C +  ^^^^^^^^^^^^^^^^^^^                                     ^^^^^
              zSBLSV      =    z__SBL                      ! [m]
              za__SV(ikl) =   (gplvDY(i,j,mz)              !
     .                        -gplvDY(i,j,mzz)) *grvinv    ! [m]
              VV__SV(ikl) =     ssvSL(i,j,mz)              !
              VV10SV(ikl) =    VV__10(i,j)                 !
c #ZA         VVs_SV(ikl) =    VVs_BS(i,j)/RRs_BS(i,j)     !
c #ZA         DDs_SV(ikl) =       max(zero,DDs_BS(i,j)-180.)
c #ZA.        +180.*min(unun,zero-min(zero,DDs_BS(i,j)-180.))
c #ZA.                           +min(zero,DDs_BS(i,j)-180.)
              Ua_min      =  epsi                          !
c #VM         Ua_min      =  0.2 * sqrt(za__SV(ikl)   )    !
              VV__SV(ikl) =  max(Ua_min, ssvSL(i,j,mz))    !
              TaT_SV(ikl) =    tairDY_int(i,j,n)           !
              ExnrSV(ikl) =      pkDY(i,j,mz)              !
              rhT_SV(ikl) =   (pstDYn(i,j)   +ptopDY)*1.e3 ! [kg/m3] *CL*
     .                       /(tairDY_int(i,j,n)*RDryAi)   !
              QaT_SV(ikl) =  qvDY_int(i,j,n)               !
c #VX         dQa_SV(ikl) =  max(0.,1.-WVaLim(i,j))        ! Water  Vapor
c #VX.                        * dtDiff/zsigma(mz)          ! Flux Limitor
              qsnoSV(ikl) =      0.                        !
c #HY.                 +min(demi,qsHY(i,j,mz)              !
c #TC.                       +   qxTC(i,j,mz,1)            !
c #HY.                                         )           !

C +--Energy Fluxes                                          (INPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^
              coszSV(ikl) = max(czemin,czenGE(i,j))        ! cos(zenith.Dist.)
              sol_SV(ikl) =            RAdsol(i,j)         !    downward Solar
              IRd_SV(ikl) =            RAd_ir(i,j)         !    downward IR

C +--Water  Fluxes                                          (INPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^
c #HY         drr_SV(ikl) =(rainHY(i,j)-rai0HY(i,j))*1.e3  ! [m/s] -> [mm/s] 
c #HY.                    * rr__DR(i,j,n)           /dt__SV!          [kg/m2/s]
c #HY         d_snow      = snowHY(i,j)-sfa0HY(i,j)        ! Only SnowFall
c #HY         dsn_SV(ikl) = d_snow                  *1.e3  ! Erosion NOT incl.
c #HY.                                              /dt__SV!
c #HY         SnowOK      =                                ! Correction
c #HY.     max(zero,sign(unun,         qsHY(i,j,mz)-epsi)) !
c #HY.    *max(zero,sign(unun,TfSnow-tairDY_int(i,j,n)-epsi)) !
c #HY         dsn_SV(ikl) = dsn_SV(ikl)+drr_SV(ikl)*SnowOK !
c #HY         drr_SV(ikl) = drr_SV(ikl)        *(1.-SnowOK)!
c #BS         dbsnow      =-SLussl(i,j,n)                  ! Erosion
c #BS.                     *dt__SV     *rhT_SV(ikl)        !
! #BS         dsnbSV(ikl) =min(max(zero,dbsnow)            !
! #BS.                    /    max(epsi,d_snow),unun)      !
c #BS         dsnbSV(ikl) =1.0-min(qsHY(i,j,kB)            ! kB level ~ 25 magl
c #BS.                        /max(qsHY(i,j,mz),eps9),unun)!(BS negligib.at kB)
!             dsnbSV is used and modified in SISVAT_BSn,
!                  then used for Buffer Layer Update
c #BS         dbs_SV(ikl) = blowSN(i,j,n)                  !          [kg/m2]

C +--Soil/Canopy                                            (INPUT)
C +  ^^^^^^^^^^^                                             ^^^^^
              LSmask(ikl)= 1  - maskSL(i,j)                ! Land/Sea   Mask
              isotSV(ikl)     = isolTV(i,j)                ! Soil       Type
              iWaFSV(ikl)     = iWaFTV(i,j)                ! Soil Drainage
c #SN         slopSV(ikl)= atan(slopTV(i,j))               ! Fall Line Slope
              alb0SV(ikl)     = AlbSTV(i,j)                ! Soil Albedo
              ivgtSV(ikl)     = ivegTV(i,j,n)              ! Vegetation Type
              LAI0SV(ikl)     = alaiTV(i,j,n)              ! LAI
              glf0SV(ikl)     = glf_TV(i,j,n)              ! Green Leaf Frac.

C +--Energy Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              cld_SV(ikl) =     cld_SL(i,j)                ! Cloudiness
              IRs_SV(ikl) =     IRsoil(i,j,n)              ! Soil upward IR
              LMO_SV(ikl) =     SLlmol(i,j,n)              ! Monin-Obukhov L.
              us__SV(ikl) =     SLuusl(i,j,n)              ! Frict. Velocity
              uts_SV(ikl) =     SLutsl(i,j,n)              ! u*T*

C +--Water  Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              uqs_SV(ikl) =     SLuqsl(i,j,n)              ! u*q*
              uss_SV(ikl) =     SLussl(i,j,n)              ! u*s*
c #AE         usthSV(ikl) =     SaltSN(i,j,n)              ! u*_th

C +--Soil/Canopy                                            (INPUT/OUTPUT)
C +  ^^^^^^^^^^^                                             ^^^^^^^^^^^^
              Z0m_SV(ikl) =      SL_z0(i,j,n)              ! Moment.Roughn.L.
              Z0h_SV(ikl) =      SL_r0(i,j,n)              ! Heat   Roughn.L.
c #OR         Z0roSV(ikl) =     SLzoro(i,j,n)              ! Orogr. Roughn.L.
              TvegSV(ikl) =     TvegTV(i,j,n)              ! Vegetation Temp.
              snCaSV(ikl) =     CaSnTV(i,j,n)              ! Canopy SnowCover
              rrCaSV(ikl) =     CaWaTV(i,j,n)              ! Canopy RainWater
              psivSV(ikl) =     psivTV(i,j,n)              ! Vegetation Pot.
            DO isl =   -nsol,0
              TsisSV(ikl,isl) = TsolTV(i,j,n,1-isl)        ! Soil Temperature
              eta_SV(ikl,isl) = eta_TV(i,j,n,1-isl)        ! Soil Humidity
            END DO
c #vL     ENDDO

C +--Snow Roughness                                         (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^^                                          ^^^^^^^^^^^^
c #vL     DO  ikl = 1,klonv
C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR        IF (ijn.LE.ijnmax)                       THEN !
c #VR         ij0ver(i,j,n) = ij0ver(i,j,n) + 1            !
c #VR         ijdver(i,j,n) = ijdver(i,j,n) + ij           !
c #VR        ENDIF                                         !

c #ZM         Z0mmSV(ikl) =     0.                         !
c #ZM         Z0emSV(ikl) =     0.                         !
c #ZM         Z0hmSV(ikl) =     0.                         !
c #ZM       DO nt=   1,ntavSL                              !
c #ZM         Z0mmSV(ikl) =     Z0mmSV(ikl)                !
c #ZM.                    +     SLn_z0(i,j,n,nt)           !
c #ZM         Z0emSV(ikl) =     Z0emSV(ikl)                !
c #ZM.                    +     SLn_b0(i,j,n,nt)           !
c #ZM         Z0hmSV(ikl) =     Z0hmSV(ikl)                !
c #ZM.                    +     SLn_r0(i,j,n,nt)           !
c #ZM       ENDDO                                          !
c #ZM         Z0mmSV(ikl) = min(Z0mmSV(ikl)  /ntavSL       !  z0(Mom., Box Av.)
c #ZM.                         ,zsigma(mz)   /    3.)      !
c #ZM         Z0emSV(ikl) =     Z0emSV(ikl)  /ntavSL       !  z0(Eros, Box Av.)
c #ZM         Z0hmSV(ikl) =     Z0hmSV(ikl)  /ntavSL       !  z0(Heat, Box Av.)

c #SZ         Z0SaSV(ikl) =     Z0SaBS(i,j,n)              !  z0(Sastrugi  h)
c #SZ         dz0_SV(ikl) = .01*dsastr(i,j)  *max(2-n,0)   ! dz0(Sastrugi dh)

C +--V,  dT(a-s)    Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AA       DO nt=1,ntaver
c #AW         V__mem(ikl,nt)     = V_0aSL(i,j,  nt)
c #AH         T__mem(ikl,nt)     = dT0aSL(i,j,n,nt)
c #AA       ENDDO

c #AA       DO nt=   1,ntaver-1
c #AW         V__mem(ikl,nt    ) = V__mem(ikl,nt+1)
c #AH         T__mem(ikl,nt    ) = T__mem(ikl,nt+1)
c #AA       ENDDO
c #AW         V__mem(ikl,ntaver) = VV__SV(ikl)
c #AH         T__mem(ikl,ntaver) = TaT_SV(ikl)-tsrfSL(i,j,n)

c #AW         VVmmem(ikl)        = 0.0
c #AH         dTmmem(ikl)        = 0.0
c #AA       DO nt=1,ntaver
c #AW         VVmmem(ikl)        = VVmmem(ikl)+V__mem(ikl,nt)
c #AH         dTmmem(ikl)        = dTmmem(ikl)+T__mem(ikl,nt)
c #AA       ENDDO
c #AW         VVmmem(ikl)        = VVmmem(ikl)/ntaver
c #AH         dTmmem(ikl)        = dTmmem(ikl)/ntaver

C +--u*, u*T*, u*s* Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM       DO nt=1,ntaver
c #AM         u__mem(ikl,nt)     = u_0aSL(i,j,n,nt)
c #AT         uT_mem(ikl,nt)     = uT0aSL(i,j,n,nt)
c #AS         us_mem(ikl,nt)     = us0aSL(i,j,n,nt)
c #AM       ENDDO
c #vL     ENDDO

c #vB     DO  ikl = 1,klonv
c #BS         Z0emBS(k2i(ikl),k2j(ikl),k2n(ikl)) = Z0emSV(ikl)
c #vB     ENDDO

C +--Snow Pack                                              (INPUT/OUTPUT)
C +  ^^^^^^^^^                                               ^^^^^^^^^^^^
c #vS     DO  ikl = 1,klonv
c #SN         BufsSV(ikl)     = snohSN(i,j,n)              ! Snow Buffer Lay.
c #SN         dsn_SV(ikl)     = dsn_SV(ikl)                !
c #SN.                     +max(BufsSV(ikl)-SMndSV,0.)     !
c #SN.                     /    dt__SV                     !
c #SN         BufsSV(ikl) = min(BufsSV(ikl),SMndSV   )     !
c #SN         BrosSV(ikl)     = BrosSN(i,j,n)              ! Snow Buffer dens.
c #SN         BG1sSV(ikl)     = BG1sSN(i,j,n)              ! Snow Buffer D./S.
c #SN         BG2sSV(ikl)     = BG2sSN(i,j,n)              ! Snow Buffer S./S.
c #SN         isnoSV(ikl)     = nssSNo(i,j,n)              ! Nb Snow/Ice Lay.
c #SN         ispiSV(ikl)     = issSNo(i,j,n)              ! Nb Supr.Ice Lay.
c #SN         iiceSV(ikl)     = nisSNo(i,j,n)              ! Nb      Ice Lay.
c #SN         zWEcSV(ikl)     = zWEcSN(i,j,n)              ! Non-Erod.*Thick.
c #SN         rusnSV(ikl)     = SWaSNo(i,j,n)              ! Surficial Water
c #SN         SWS_SV(ikl)     = SWSSNo(i,j,n)              ! Surficial Wat.St.
c #SN         SWf_SV(ikl)     = SWfSNo(i,j)                ! Normalized Decay
c #vS     ENDDO
c #SN     DO  isn = 1,nsno
c #vS     DO  ikl = 1,klonv
c #SN         istoSV(ikl,isn) = nhsSNo(i,j,n,isn)          !            [-]
c #SN         dzsnSV(ikl,isn) = dzsSNo(i,j,n,isn)          !            [m]
c #SN         ro__SV(ikl,isn) = rosSNo(i,j,n,isn)          !        [kg/m3]
c #SN         eta_SV(ikl,isn) = wasSNo(i,j,n,isn)          !        [m3/m3]
c #SN         TsisSV(ikl,isn) = tisSNo(i,j,n,isn)          !            [K]
c #SN         G1snSV(ikl,isn) = max(-G1_dSV,min(G1_dSV,    !
c #SN.                          g1sSNo(i,j,n,isn)))        ! [-]        [-]
c #SN         G2snSV(ikl,isn) = max(-G1_dSV,min(G1_dSV,    !
c #SN.                          g2sSNo(i,j,n,isn)))        ! [-] [0.0001 m]
c #SN         agsnSV(ikl,isn) = agsSNo(i,j,n,isn)          !          [day]
c #vS     END DO
c #SN     END DO

! Grid Point                                                (OUTPUT)
! ^^^^^^^^^^                                                 ^^^^^^
! #wx                                                  kSV_v1=0

c #vL     DO  ikl = 1,klonv
c #SI         HFraSV(ikl)     = 0.                         ! Frazil Thickness

C +--RunOFF Intensity                                       (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^^^^                                        ^^^^^^^^^^^^
              RnofSV(ikl)     = 0.                         ! RunOFF Intensity

! Grid Point                                                (OUTPUT)
! ^^^^^^^^^^                                                 ^^^^^^
! #wx         IF (i.eq.iSV_v1.AND.j.eq.jSV_v1.AND.n.EQ.nSV_v1)
! #wx.                                                 kSV_v1=ikl

              lwriSV(ikl)     = WKxyz1(i,j,n)

c #BW      IF(lwriSV(ikl).ne.0.AND.iterun.gt.0)                    THEN
c #BW         noUNIT =   no__SV(lwriSV(ikl))
c #BW         write(noUNIT,5012)
 5012         format(/,1x)
c #BW         write(noUNIT,5013)
 5013         format(' -----+--------+--------+--------+--------+',
     .             '--------+--------+--------+--------+--------+',
     .             '--------+')
c #BW         write(noUNIT,5014)
 5014         format('    n |     z  |     qs |      V |        |',
     .             '     T  | TKE^0.5|        |        |        |',
     .             '        |',
     .             /,'      |    [m] | [g/kg] |  [m/s] |        |',
     .             '    [K] |  [m/s] |        |        |        |',
     .             '        |')
c #BW           BlowST=0.
c #BW           k=0
 5011         CONTINUE
c #BW           k=k+1
c #BW         IF (                  k         .gt. mz )      GO TO 5010
c #BW         IF (grvinv*gplvDY(i,j,k)-sh(i,j).lt.100.)            THEN
c #BW           BlowST=BlowST+ssvSL(i,j,k)*qsHY(i,j,k)
c #BW.                       *pstDY(i,j)*dsigm1(    k)*1.e3*grvinv
c #BW           write(noUNIT,5015) mzz-k,grvinv*gplvDY(i,j,k)-sh(i,j),
c #BW.            1.e3*qsHY(i,j,k),ssvSL(i,j,k),tairDY(i,j,k),
c #BW.                                     sqrt(ect_TE(i,j,k))
 5015           format(i5,' |',f7.2,' |',f7.3,' |',f7.2,' |',
     .                  8x,'|',f7.2,' |',f7.3,' |', 4(8x,'|'))
c #BW         END IF
c #BW         GO TO 5011
 5010         CONTINUE

c #BW           SnowSB =   snohSN(i,j,n)
c #BW         IF        (  nssSNo(i,j,n) .GT.     0      )         THEN
c #BW         DO isn=max(0,nssSNo(i,j,n))   ,nssSNo(i,j,n)
c #BW           SnowSB =   SnowSB 
c #BW.                +    dzsSNo(i,j,n,isn)*rosSNo(i,j,n,isn)
c #BW         END DO
c #BW         END IF

c #BW         write(noUNIT,5016) BlowST,SnowSB
 5016         format(' * TRANSPORT = ',e12.3,' kg/m/s'  ,  8x,'|',
     .               ' * BUDGET    = ',f12.6,' mm w.e.|',2(8x,'|'))
c #BW         write(noUNIT,5013)
c #BW      END IF

! OUTPUT, for Stand-Alone VERIFICATION
! ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
! #v0       IF (i  .ge.  1.and.i  .le. mx)                         THEN
! #v0         write(50,5001) iterun,i,j,n,nvc,ikl,
! #v0.                   za__SV(ikl),VV__SV(ikl),TaT_SV(ikl),
! #v0.                   rhT_SV(ikl),QaT_SV(ikl),qsnoSV(ikl),
! #v0.                   coszSV(ikl),sol_SV(ikl),IRd_SV(ikl),
! #v0.                   drr_SV(ikl),dsn_SV(ikl),dbs_SV(ikl),
! #v0.                   LSmask(ikl),isotSV(ikl),alb0SV(ikl),
! #v0.                   IRs_SV(ikl),
! #v0.                   ivgtSV(ikl),LAI0SV(ikl),glf0SV(ikl),
! #v0.                   TvegSV(ikl),LMO_SV(ikl),us__SV(ikl),
! #v0.                   uqs_SV(ikl),uts_SV(ikl),uss_SV(ikl),
! #v0.                   snCaSV(ikl),rrCaSV(ikl),psivSV(ikl)
 5001         format(/,'c #INFO   iterun          = ',i15  ,
     .               /,'c #INFO   i,j,n           = ',3i5  ,
     .               /,'c #INFO   nvc             = ',i15  ,
     .               /,'c #INFO   ikl             = ',i15  ,
     .               /,'          za__SV(ikl)     = ',e15.6,
     .               /,'          VV__SV(ikl)     = ',e15.6,
     .               /,'          TaT_SV(ikl)     = ',e15.6,
     .               /,'          rhT_SV(ikl)     = ',e15.6,
     .               /,'          QaT_SV(ikl)     = ',e15.6,
     .               /,'          qsnoSV(ikl)     = ',e15.6,
     .               /,'          coszSV(ikl)     = ',e15.6,
     .               /,'          sol_SV(ikl)     = ',e15.6,
     .               /,'          IRd_SV(ikl)     = ',e15.6,
     .               /,'          drr_SV(ikl)     = ',e15.6,
     .               /,'          dsn_SV(ikl)     = ',e15.6,
     .               /,'          dbs_SV(ikl)     = ',e15.6,
     .               /,'          LSmask(ikl)     = ',i15  ,
     .               /,'          isotSV(ikl)     = ',i15  ,
     .               /,'          alb0SV(ikl)     = ',e15.6,
     .               /,'          IRs_SV(ikl)     = ',e15.6,
     .               /,'          ivgtSV(ikl)     = ',i15  ,
     .               /,'          LAI0SV(ikl)     = ',e15.6,
     .               /,'          glf0SV(ikl)     = ',e15.6,
     .               /,'          TvegSV(ikl)     = ',e15.6,
     .               /,'          LMO_SV(ikl)     = ',e15.6,
     .               /,'          us__SV(ikl)     = ',e15.6,
     .               /,'          uqs_SV(ikl)     = ',e15.6,
     .               /,'          uts_SV(ikl)     = ',e15.6,
     .               /,'          uss_SV(ikl)     = ',e15.6,
     .               /,'          snCaSV(ikl)     = ',e15.6,
     .               /,'          rrCaSV(ikl)     = ',e15.6,
     .               /,'          psivSV(ikl)     = ',e15.6)
! #v0         DO isl = -nsol,0
! #v0           write(50,5002)    isl,TsisSV(ikl,isl),
! #v0.                            isl,eta_SV(ikl,isl)
 5002           format('          TsisSV(ikl,',i2,')  = ',e15.6,
     .                 '          eta_SV(ikl,',i2,')  = ',e15.6)
! #v0         END DO
! #v0         DO isl =       1,nsno
! #v0           write(50,5003)    isl,TsisSV(ikl,isl),
! #v0.                            isl,dzsnSV(ikl,isl)
 5003           format('          TsisSV(ikl,',i2,')  = ',e15.6,
     .                 '          dzsnSV(ikl,',i2,')  = ',e15.6)
! #v0         END DO
! #v0       END IF
          END DO

C +--SISVAT Execution
C +  ^^^^^^^^^^^^^^^^
c          write(daHost,'(i2,a3,i4,i3,2(a1,i2))')
c     .          jdarGE,labmGE(mmarGE),iyrrGE,
c     .          jhurGE,chb,minuGE,chb,jsecGE

! #wz     write(6,6660) jdarGE,mmarGE,iyrrGE,jhurGE,minuGE,jsecGE
 6660     format(2(i2,'-'),2i4,2(':',i2),3x,$)



C +       ************
          call  SISVAT
C +       ************


C +--MAR    Variables Update
C +  ^^^^^^^^^^^^^^^^^^^^^^^
          DO  ikl = 1,klonv
C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR         ij2             = ij2         + 1
c #VR         ijdver(i,j,n)   = ijdver(i,j,n) - ij2
c #VR         ij_ver(i,j,n)   = ij_ver(i,j,n) + 1

C +--Energy Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              IRsoil(i,j,n)       = IRs_SV(ikl)            ! Soil upward IR
              SLlmol(i,j,n)       = LMO_SV(ikl)            ! Monin-Obukhov L.
              SLuusl(i,j,n)       = us__SV(ikl)            ! Frict. Velocity
              SLutsl(i,j,n)       = uts_SV(ikl)            ! u*T*
              SLdSdT(i,j,n)       = dSdTSV(ikl)            ! Sens.H.Flux T-Der.

C +--Energy Fluxes                                          (OUTPUT/NetCDF)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^^
c #NC         SOsoNC(i,j,n)       = SOsoKL(ikl)            ! Absorb.Sol.Rad.
c #NC         IRsoNC(i,j,n)       = IRsoKL(ikl)            ! Absorb.IR  Rad.
c #NC         HSsoNC(i,j,n)       = HSsoKL(ikl)            ! HS
c #NC         HLsoNC(i,j,n)       = HLsoKL(ikl)            ! HL
c #NC         HLs_NC(i,j,n)       = HLs_KL(ikl)            ! Evaporation
c #NC         HLv_NC(i,j,n)       = HLv_KL(ikl)            ! Transpiration

C +--Water  Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^                                           ^^^^^^^^^^^^
              SLuqsl(i,j,n)       = uqs_SV(ikl)            ! u*q*
              SLdLdT(i,j,n)       = dLdTSV(ikl)            ! Latn.H.Flux T-Der.
              SLussl(i,j,n)       = 0.                     ! 
c #BS         SLussl(i,j,n)       =                        ! MAX        Erosion 
c #BS.       (blowSN(i,j,n)- dbs_SV(ikl))                  !-unconsumed Erosion
c #BS.                     /(dt__SV*rhT_SV(ikl))           ! ==> actual u*s*
c #vL     ENDDO
c #vL     DO  ikl = 1,klonv
c #BS         blowSN(i,j,n)= dt__SV*uss_SV(ikl)            ! NEW  MAX   Erosion
c #BS.                             *rhT_SV(ikl)            ! rho u*s* dt[kg/m2]
c #AE         SaltSN(i,j,n)       = usthSV(ikl)            ! u*_th

C +--Soil/Canopy                                            (INPUT/OUTPUT)
C +  ^^^^^^^^^^^                                             ^^^^^^^^^^^^
               SL_z0(i,j,n)       = Z0m_SV(ikl)            ! Moment.Roughn.L.
               SL_r0(i,j,n)       = Z0h_SV(ikl)            ! Heat   Roughn.L.
               cdmSL(i,j,n)       = rCDmSV(ikl)            ! sq.root Contr.Drag
               cdhSL(i,j,n)       = rCDhSV(ikl)            ! sq.root Contr.Drag
              TvegTV(i,j,n)       = TvegSV(ikl)            ! Vegetation Temp.
              CaSnTV(i,j,n)       = snCaSV(ikl)            ! Canopy SnowCover
              CaWaTV(i,j,n)       = rrCaSV(ikl)            ! Canopy RainWater
              psivTV(i,j,n)       = psivSV(ikl)            ! Vegetation Pot.
            DO isl =   -nsol,0                             !
              eta_TV(i,j,n,1-isl) = eta_SV(ikl,isl)        ! Soil Humidity
              TsolTV(i,j,n,1-isl) = TsisSV(ikl,isl)        ! Soil Temperature
            END DO                                         !
c #vL     END DO

C +--Snow Roughness                                         (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^^                                          ^^^^^^^^^^^^
c #vZ     DO  ikl = 1,klonv
c #ZM       DO nt=   1,ntavSL-1                            !
c #ZM         SLn_z0(i,j,n,nt)    = SLn_z0(i,j,n,nt+1)     !
c #ZM         SLn_b0(i,j,n,nt)    = SLn_b0(i,j,n,nt+1)     !
c #ZM         SLn_r0(i,j,n,nt)    = SLn_r0(i,j,n,nt+1)     !
c #ZM       ENDDO                                          !
c #vZ     ENDDO
c #vL     DO  ikl = 1,klonv
c #ZM         SLn_z0(i,j,n,ntavSL)= Z0mnSV(ikl)            ! z0(Momentum)
c #ZM         SLn_b0(i,j,n,ntavSL)= Z0enSV(ikl)            ! z0(Mom., Erosion)
c #ZM         SLn_r0(i,j,n,ntavSL)= Z0hnSV(ikl)            ! z0(Heat)

c #SZ         Z0SaBS(i,j,n)       = Z0SaSV(ikl)            ! z0(Sastrugi  h)

C +--V,  dT(a-s)    Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AA       DO nt=1,ntaver
c #AW         V_0aSL(i,j,  nt)    = V__mem(ikl,nt)
c #AH         dT0aSL(i,j,n,nt)    = T__mem(ikl,nt)
c #AA       ENDDO

C +--u*, u*T*, u*s* Time Moving Averages
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM       DO nt=1,ntaver
c #AM         u_0aSL(i,j,n,nt)    = u__mem(ikl,nt)
c #AT         uT0aSL(i,j,n,nt)    = uT_mem(ikl,nt)
c #AS         us0aSL(i,j,n,nt)    = us_mem(ikl,nt)
c #AM       ENDDO
c #vL     END DO

C +--Dust   Fluxes                                          (INPUT/OUTPUT)
C +  ^^^^^^^^^^^^^
c #vD     DO  ikl = 1,klonv

c #BD         SLubsl(i,j,n)       =(1-min(1,isnoSV(ikl)))  ! Snow Free  Surface 
c #BD.                             *uss_SV(ikl)            ! DUST       Erosion
c #BD.                *max(1,(2-mmy)*3)                    ! Tuning Factor (2D)
c #vD     END DO

C +--Snow Pack                                              (INPUT/OUTPUT)
C +  ^^^^^^^^^                                               ^^^^^^^^^^^^
c #vS     DO  ikl = 1,klonv
c #SN         snohSN(i,j,n)       = BufsSV(ikl)            ! Snow Buffer Lay.
c #SN         BrosSN(i,j,n)       = BrosSV(ikl)            ! Snow Buffer dens.
c #SN         BG1sSN(i,j,n)       = BG1sSV(ikl)            ! Snow Buffer D./S.
c #SN         BG2sSN(i,j,n)       = BG2sSV(ikl)            ! Snow Buffer S./S.
c #SN         nssSNo(i,j,n)       = isnoSV(ikl)            ! Nb Snow/Ice Lay.
c #SN         issSNo(i,j,n)       = ispiSV(ikl)            ! Nb Supr.Ice Lay.
c #SN         nisSNo(i,j,n)       = iiceSV(ikl)            ! Nb      Ice Lay.
c #SN         zWE_SN(i,j,n)       = zWE_SV(ikl)            ! Current  *Thick.
c #SN         zWEcSN(i,j,n)       = zWEcSV(ikl)            ! Non-Erod.*Thick.
c #SN         hSalSN(i,j,n)       = hSalSV(ikl)            ! Salt.Layer Height
c #SN         SWaSNo(i,j,n)       = rusnSV(ikl)            ! Surficial Water  
c #SN         SWSSNo(i,j,n)       = SWS_SV(ikl)            ! Surficial Wat.St.
c #vS     END DO
c #SN     DO  isn = 1,nsno
c #vS     DO  ikl = 1,klonv
c #SN         nhsSNo(i,j,n,isn)   = istoSV(ikl,isn)        !            [-]
c #SN         dzsSNo(i,j,n,isn)   = dzsnSV(ikl,isn)        !            [m]
c #SN         rosSNo(i,j,n,isn)   = ro__SV(ikl,isn)        !        [kg/m3]
c #SN         wasSNo(i,j,n,isn)   = eta_SV(ikl,isn)        !        [m3/m3]
c #SN         tisSNo(i,j,n,isn)   = TsisSV(ikl,isn)        !            [K]
c #SN         g1sSNo(i,j,n,isn)   = G1snSV(ikl,isn)        ! [-]        [-]
c #SN         g2sSNo(i,j,n,isn)   = G2snSV(ikl,isn)        ! [-] [0.0001 m]
c #SN         agsSNo(i,j,n,isn)   = agsnSV(ikl,isn)        !          [day]
c #vS     END DO
c #SN     END DO

c #vL     DO  ikl = 1,klonv
c #IB         WKxyz2(i,j,n)       = wes_SV(ikl)            ! Depo. / Subli.
c #IB         WKxyz3(i,j,n)       = wem_SV(ikl)            ! Melting
c #IB         WKxyz4(i,j,n)       = wer_SV(ikl)            ! Refreezing

C +--Radiative Properties                                         (OUTPUT)
C +  ^^^^^^^^^^^^^^^^^^^^                                          ^^^^^^
              albxSL(i,j,n)       = alb_SV(ikl)            ! Mosaic Albedo
c #AO.                          *(1-maskSL(i,j))           !
c #AO.                          +    albAO(i,j,n)          ! Mosaic AlbedoNEMO
c #AO.                          *   maskSL(i,j)            !               
              WKxyz6(i,j,n)       = emi_SV(ikl)            ! Mosaic Emissivity
              WKxyz7(i,j,n)       = IRu_SV(ikl)            ! Mosaic Upw.IR
              WKxyz8(i,j,n)       = qSalSV(ikl)            ! Saltating Partic.
              hfra  (i,j,n)       = HFraSV(ikl)            ! Frazil  Thickness
              Rnof  (i,j,n)       = RnofSV(ikl)            ! Run OFF Intensity

              if(n==1) then
              alb1IB(i,j)         = alb1SV(ikl)
              alb2IB(i,j)         = alb2SV(ikl)
              alb3IB(i,j)         = alb3SV(ikl)
              endif
 
          END DO
          ELSE
              Rnof  (i,j,n)       = 0.
          ENDIF 
      ENDDO

C +--Surface Temperature: Prescription of relevant Medium (Snow, precribed SST)
C +  ==========================================================================

            DO isl =   -nsol,0                             !


C +--Open Ocean
C +  ----------

              eta_TV(i,j,1,1-isl) =                        !
     .        eta_TV(i,j,1,1-isl) *(1-maskSL(i,j))         !
     .                              + maskSL(i,j)          ! Sea: Humidity:=1
              TsolTV(i,j,1,1-isl) =                        !
     .       (TsolTV(i,j,1,1-isl) *(1-maskSL(i,j))         ! Soil Temperature
     .       +sst_LB(i,j)         *   maskSL(i,j))         ! Prescribed   SST
c #OP.                                            * FixSST !
c #OP.      +(TsolTV(i,j,1,1-isl)                          !
c #op.      +(sst_LB(i,j)                                  !~Prescribed   SST
c #op.       -TsolTV(i,j,1,1-isl))*   maskSL(i,j) * SSTnud ! (Nudging)
c #OP.                                           )* VarSST ! Interactive  SST


C +--Sea Ice
C +  -------

c #AO         eta_TV(i,j,2,1-isl) =                        !
c #AO.        eta_TV(i,j,2,1-isl) *(1-maskSL(i,j))         ! Sea: Humidity:=0
c #AO         TsolTV(i,j,2,1-isl) =                        !
c #AO.       (TsolTV(i,j,2,1-isl) *(1-maskSL(i,j))         ! Soil Temperature
c #AO.       +271.2               *   maskSL(i,j))         ! Prescribed    ST
            END DO
c #AO       DO isl =         0,nsno                        !
c #AO         tisSNo(i,j,2,isl)   =
c #AO.        srftAO(i,j,2)       *   maskSL(i,j)          ! Prescribed   SIT
c #AO       END DO


      DO n=1,mw
              tsrfSL(i,j,n)       =                        ! Surf.Temperature
     .        TsolTV(i,j,n,1)                              !
c #SN.                           *(1-min(1,nssSNo(i,j,n))) !
c #SN.       +tisSNo(i,j,n,          max(1,nssSNo(i,j,n))) !
c #SN.                           *   min(1,nssSNo(i,j,n))  !
C +                                                        !
c #NC         eta_NC(i,j,n)       = 0.                     !
c #NC         DO isl = -nsol,0                             !
c #NC         eta_NC(i,j,n)       = eta_NC(i,j,n)          ! Soil Moisture
c #NC.       +eta_TV(i,j,n,1-isl) * dz_dSV(    isl)        !              
c #NC         END DO                                       !
      ENDDO


C +--Mosaic Cleaning
C +  ===============

c #SN   IF (maskSL(i,j  ).EQ.   1)                                  THEN
c #SN       nssSNo(i,j,1    ) = 0
c #SN       issSNo(i,j,1    ) = 0
c #SN       nisSNo(i,j,1    ) = 0
c #SN     DO ISL=1,nsno
c #SN       tisSNo(i,j,1,isl) = 0.
c #SN       dzsSNo(i,j,1,isl) = 0.
c #SN       rosSNo(i,j,1,isl) = 0.
c #SN       wasSNo(i,j,1,isl) = 0.
c #SN       g1sSNo(i,j,1,isl) = 0.
c #SN       g2sSNo(i,j,1,isl) = 0.
c #SN       agsSNo(i,j,1,isl) = 0.
c #SN       nhsSNo(i,j,1,isl) = 0.
c #SN     ENDDO
c #SN   ENDIF
        IF (SLsrfl(i,j,2).LT.eps9)                                  THEN
            tsrfSL(i,j,2)     = tsrfSL(i,j,1)
          DO isl=1,nsol+1
            TsolTV(i,j,2,isl) = TsolTV(i,j,1,isl)
          ENDDO    ! #n2
c #SN       nssSNo(i,j,2    ) = nssSNo(i,j,1    ) * (1 - maskSL(i,j))
c #SN       issSNo(i,j,2    ) = issSNo(i,j,1    ) * (1 - maskSL(i,j))
c #SN       nisSNo(i,j,2    ) = nisSNo(i,j,1    ) * (1 - maskSL(i,j))
c #SN     DO isl=1,nsno       !
c #SN       tisSNo(i,j,2,isl) = tisSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       dzsSNo(i,j,2,isl) = dzsSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       rosSNo(i,j,2,isl) = rosSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       wasSNo(i,j,2,isl) = wasSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       g1sSNo(i,j,2,isl) = g1sSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       g2sSNo(i,j,2,isl) = g2sSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       agsSNo(i,j,2,isl) = agsSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN       nhsSNo(i,j,2,isl) = nhsSNo(i,j,1,isl) * (1 - maskSL(i,j))
c #SN     ENDDO    ! #n2
        ENDIF      ! #n2


C +--Grid Averages / Diagnostics
C +  ===========================

C +--Grid Averages                                                (OUTPUT)
C +  ^^^^^^^^^^^^^                                                 ^^^^^^
      DO  n=1,mw
c #IB         wes_IB(i,j,n)     = - WKxyz2(i,j,n)          !
c #IB.                            + wes_IB(i,j,n)          ! Depo. / Subli.
c #IB         wem_IB(i,j,n)       = WKxyz3(i,j,n)          ! 
c #IB.                            + wem_IB(i,j,n)          ! Melting
c #IB         wer_IB(i,j,n)       = WKxyz4(i,j,n)          ! 
c #IB.                            + wer_IB(i,j,n)          ! Refreezing
c #IB         wee_IB(i,j,n)     = - SLuqsl(i,j,n)          !
c #IB.            * 1.e3 * dt__SV * rolvDY(i,j,mz)         !
c #IB.                            + wee_IB(i,j,n)          ! Evapotranspiration
c #IB         weu_IB(i,j,n)       = Rnof  (i,j,n)*dt__SV   ! 
c #IB.                            + weu_IB(i,j,n)          ! Refreezing

c #WR         ifrVER(i,j)         = ifrVER(i,j)            !
c #WR.                            + ifraTV(i,j,n)          !
              albeSL(i,j)         = albeSL(i,j)            ! Grid   Albedo
     .            + SLsrfl(i,j,n) * albxSL(i,j,n)          ! Mosaic Albedo
              eps0SL(i,j)         = eps0SL(i,j)            ! Grid   Emissivity
     .            + SLsrfl(i,j,n) * WKxyz6(i,j,n)          ! Mosaic Emissivity
              Upw_IR(i,j)         = Upw_IR(i,j)            !
     .            + SLsrfl(i,j,n) * WKxyz7(i,j,n)          ! Mosaic Upw.IR
               SLlmo(i,j)         =  SLlmo(i,j)            !
     .            + SLsrfl(i,j,n) * SLlmol(i,j,n)          ! Mosaic Mon.Ob.
               SLuus(i,j)         =  SLuus(i,j)            ! Grid   u*
     .            + SLsrfl(i,j,n) * SLuusl(i,j,n)          ! Mosaic u*
               SLuts(i,j)         =  SLuts(i,j)            ! Grid   u*T*
     .            + SLsrfl(i,j,n) * SLutsl(i,j,n)          ! Mosaic u*T*
               SLuqs(i,j)         =  SLuqs(i,j)            ! Grid   u*q*
     .            + SLsrfl(i,j,n) * SLuqsl(i,j,n)          ! Mosaic u*q*
c #BS          uss_HY(i,j)        = uss_HY(i,j)            ! Grid   u*s*
c #BS.            + SLsrfl(i,j,n) * SLussl(i,j,n)          ! Mosaic u*s*
C +...NO !    SLussl(i,j,n)       = uss_SV(ikl)            !        u*s*
C +           Upper Update = wrong Source of Atmospher.Snow!
c #BS         qsrfHY(i,j)         = qsrfHY(i,j)            ! Salt.Part.Concent.
c #BS.            + SLsrfl(i,j,n) * WKxyz8(i,j,n)          ! 
c #BS.                    *   min(1,nssSNo(i,j,n))         !
c #PO         HFraPO(i,j)         = HFraPO(i,j)            ! Frazil  Thickness
c #PO.            + SLsrfl(i,j,n) * HFra  (i,j,n)          ! 
              TairSL(i,j)         = TairSL(i,j)            ! Surface Air
     .            +SLsrfl(i,j,n)  * tsrfSL(i,j,n)          !         Temperatur
              draiTV(i,j)         = draiTV(i,j)            ! Run OFF Intensity
     .            + SLsrfl(i,j,n) * Rnof  (i,j,n)          ! 
c #TC           uqTC(i,j,1)       =   uqTC(i,j,1)          ! Grid   u*b*
c #TC.            + SLsrfl(i,j,n) * SLubsl(i,j,n)          ! Mosaic u*b*
c #TC           qsTC(i,j,1)       =   qsTC(i,j,1)          ! Salt.Part.Concent.
c #TC.            + SLsrfl(i,j,n) * WKxyz8(i,j,n)          ! 
c #TC.                    *(1-min(1,nssSNo(i,j,n)))        !
      ENDDO
c #HY   sno0HY(i,j) = snowHY(i,j)                          !
        pktaSL(i,j) = TairSL(i,j)                          !
     .    /exp(cap*log(pstDY(i,j)+ptopDY))                 !
         tviRA(i,j) = sqrt(sqrt(Upw_IR(i,j)/stefan))       ! Brightness Temp.        \VER
         rhAir      = rolvDY(i,j,mz) *1.e3                 ! Air    Densitity
        hsenSL(i,j) = -SLuts(i,j)  *  rhAir       *cp      ! Sensible Heat Flux
        qvapSL(i,j) = qvsiDY(i,j,mzz)                      ! Surf.Specif.Humid.      \VER
                                                           ! to adapt over soil
        hlatSL(i,j) = -SLuqs(i,j)  *  rhAir       *Lv_H2O  ! Latent   Heat Flux
        evapTV(i,j) = evapTV(i,j)                          ! Total    Evaporat.
     .                -SLuqs(i,j)  *  rhAir       *dt__SV  ! [mm w.e.]
        runoTV(i,j) = runoTV(i,j)  +  draiTV(i,j) *dt__SV  ! Integrated Run OFF
        firmSL(i,j) = Upw_IR(i,j)   

C +--Sea-Ice Ice Floe Size
C +  =====================

C +--Prescription from SST
C +  ---------------------

c #SI IF (VarSST.le.epsi)                                           THEN
c #SI        FraOcn          =    (TsolTV(i,j,1,1)-Tfr_LB)/TSIdSV! Prescribed
C +                                                              ! from SST
c #IP        FraOcn          =  1.-sicsIB(i,j)                   ! Prescribed
C +                                                              ! from SSM/I
c #SI        FraOcn          = min(  unun,FraOcn)                ! UpperLimit
c #SI        FraOcn          = max(OcnMin,FraOcn)                ! LowerLimit
c #SI        SLsrfl(i,j,1)   =  (1-maskSL(i,j))  * SLsrfl(i,j,1) ! New Ocean
c #SI.                          +  maskSL(i,j)   * FraOcn        !
c #SI        SrfSIC          =                     SLsrfl(i,j,2) ! Old Sea Ice
c #SI        SIc0OK          = max(zero, sign(unun,SrfSIC-epsi)) !
c #SI        SLsrfl(i,j,2)   =  (1-maskSL(i,j))  * SLsrfl(i,j,2) ! New Sea Ice
c #SI.                          +  maskSL(i,j)*(1.-FraOcn)       !
c #SI        SIceOK          = max(zero, sign(unun,SLsrfl(i,j,2) !
c #SI.                                                   -epsi)) !
c #SI        ifra_t          =     ifraTV(i,j,1) + ifraTV(i,j,2) ! OCN Fraction
c #SI        ifraTV(i,j,1)   =     SLsrfl(i,j,1) * 100.          !
c #SI        ifraTV(i,j,1)   = min(ifraTV(i,j,1) , ifra_t)       !
c #SI        ifraTV(i,j,2)   =     ifra_t        - ifraTV(i,j,1) !

C +--Sea-Ice Vertical Discretization
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SI        nssSNo(i,j,2)   =  
c #SI.       nssSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(max(1
c #SI.      ,nssSNo(i,j,2))  *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        nisSNo(i,j,2)   =  
c #SI.       nisSNo(i,j,2)                    *(1-maskSL(i,j)) 
c #SI.     +(max(1
c #SI.      ,nisSNo(i,j,2))  *    SIc0OK              
c #SI.      +     3          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI        issSNo(i,j,2)   =                    nisSNo(i,j,2)
C +
c #SI     DO l=1,nsno
c #SI        dzsSNo(i,j,2,l) =
c #SI.       dzsSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(max
c #SI.      (SIc_OK(min(2,l))*    SIcMIN
c #SI.      ,dzsSNo(i,j,2,l))*    SIc0OK
c #SI.      +dzSIce(min(4,l))*(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        tisSNo(i,j,2,l) =
c #SI.       tisSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(tisSNo(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,1) *(1.-SIc0OK)       )*maskSL(i,j)
C +
c #SI        rosSNo(i,j,2,l) =
c #SI.       rosSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(max
c #SI.      (SIc_OK(min(2,l))*    ro_Ice
c #SI.      ,rosSNo(i,j,2,l))*    SIc0OK
c #SI.      +ro_Ice          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        g1sSNo(i,j,2,l) =
c #SI.       g1sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g1sSNo(i,j,2,l) *    SIc0OK
c #SI.      +G1_dSV          *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        g2sSNo(i,j,2,l) =
c #SI.       g2sSNo(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(g2sSNo(i,j,2,l) *    SIc0OK
c #SI.      +30.             *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
C +
c #SI        nhsSNo(i,j,2,l) =
c #SI.       nhsSNo(i,j,2,l)                  *(1-maskSL(i,j))
C #SI.new  +(nhsSNo(i,j,2,l) *    SIc0OK
C #SI.new   +istdSV(2)       *(1.-SIc0OK)*SIceOK)*maskSL(i,j)
c #SI.     + istdSV(2)       *                    maskSL(i,j)
c #SI     END DO
c #SI     DO l=1,llx
c #SI        TsolTV(i,j,2,l) =
c #SI.       TsolTV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     +(TsolTV(i,j,2,l) *    SIc0OK
c #SI.      +TsolTV(i,j,1,l) *(1.-SIc0OK)       )*maskSL(i,j)
C +
c #SI        eta_TV(i,j,2,l) =
c #SI.       eta_TV(i,j,2,l)                  *(1-maskSL(i,j))
c #SI.     + eta_TV(i,j,2,l) *    SIc0OK  *       maskSL(i,j)
C +...                            No Pore in Ice => No Water
c #SI     END DO
C +
c #WI        write(6,6001) jdarGE,labmGE(mmarGE),iyrrGE
c #WI.                    ,jhurGE,minuGE,jsecGE ,TsolTV(i,j,1,1)
c #WI.                    ,FraOcn,ifraTV(i,j,1) ,TsolTV(i,j,2,1)
c #WI.                    ,       nisSNo(i,j,2) ,nssSNo(i,j,2)
C +
c #SI END IF

C +--Otherwise SST and FrLead have been computed in the Sea-Ice Polynya Model
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +--Rainfall, Snowfall Time Integral at previous Time Step
C +  ------------------------------------------------------

c #HY                       rai0HY(i,j)=rainHY(i,j)    ! Rainfall Time Integral
c #HY                       sfa0HY(i,j)=snowHY(i,j)    ! Snowfall Time Integral


!  Wind Horizontal Components         at previous Time Step
!  --------------------------------------------------------

c #ZA                       ua_0BS(i,j)=uairDY(i,j,mz) ! 
c #ZA                       va_0BS(i,j)=vairDY(i,j,mz) ! 

C +--Work Array Reset
C +  ================

          WKxy1( i,j)   = 0.
          WKxy2( i,j)   = 0.
          WKxy3( i,j)   = 0.
          WKxy5( i,j)   = 0.
          WKxy6( i,j)   = 0.
          WKxy7( i,j)   = 0.

        DO k=1,mw
          WKxyz1(i,j,k) = 0.
          WKxyz2(i,j,k) = 0.
          WKxyz3(i,j,k) = 0.
          WKxyz4(i,j,k) = 0.
          WKxyz5(i,j,k) = 0.
          WKxyz6(i,j,k) = 0.
          WKxyz7(i,j,k) = 0.
          WKxyz8(i,j,k) = 0.
        END DO

      ENDDO !dt
      ENDDO !i
      ENDDO !j
!$OMP END PARALLEL DO  

      dt__SV=dt 

C +--Blown Snow/Dust Accumulation
C +  ============================

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx IF                            (lSV_v1.EQ.2)
! #wx.  write(6,6011)                uss_HY(iSV_v1,jSV_v1)  *1.e3
 6011   format(10x,'After SISVAT(1): us* [mm/s] =',f9.3)

c #BS DO i=ip11,mx1
c #BS DO j=   1,my
c #BS        WKxy6(i     ,j     ) =
c #BS&      uss_HY(im1(i),j     )+2.0*uss_HY(i     ,j     )
c #BS& +    uss_HY(ip1(i),j     )
c #BS ENDDO
c #BS ENDDO

c #BS DO j=jp11,my1
c #BS DO i=ip11,mx1
c #BS        WKxy5(i     ,j     ) =    WKxy6(i     ,jm1(j))
c #BS        WKxy7(i     ,j     ) =    WKxy6(i     ,jp1(j))
c #BS ENDDO
c #BS ENDDO

c #BS DO j=jp11,my1
c #BS DO i=ip11,mx1
c #BS       uss_HY(i     ,j     ) =
c #BS.       WKxy7(i     ,j     )
c #BS.     + WKxy6(i     ,j     ) +    WKxy6(i     ,j     )
c #BS.     + WKxy5(i     ,j     )

!  Previous three Loops Stand for the following unvectorized Loop:
!       WKxy2(i,j) = uss_HY(im1(i),jp1(j))
!    .         +2.d0*uss_HY(i     ,jp1(j)) +     uss_HY(ip1(i),jp1(j))
!    .         +2.d0*uss_HY(im1(i),j)
!    .         +4.d0*uss_HY(i     ,j)      +2.d0*uss_HY(ip1(i),j)
!    .         +     uss_HY(im1(i),jm1(j))
!    .         +2.d0*uss_HY(i     ,jm1(j)) +     uss_HY(ip1(i),jm1(j))
c #BS END DO
c #BS END DO

c #BD DO i=1,mx
c #BD DO j=1,my
c #BD   WKxy3(i,j) = uqTC(im1(i),jp1(j),1)
c #BD.         +2.d0*uqTC(i     ,jp1(j),1) +     uqTC(ip1(i),jp1(j),1)
c #BD.         +2.d0*uqTC(im1(i),j     ,1)
c #BD.         +4.d0*uqTC(i     ,j     ,1) +2.d0*uqTC(ip1(i),j     ,1)
c #BD.         +     uqTC(im1(i),jm1(j),1)
c #BD.         +2.d0*uqTC(i     ,jm1(j),1) +     uqTC(ip1(i),jm1(j),1)
c #BD END DO
c #BD END DO

c #AE DO i=1,mx
c #AE DO j=1,my
c #BS   uss_HY(i,j)  = uss_HY(i,j)          * 62.5e-3
c #BS   snowHY(i,j)  = snowHY(i,j) + dt__SV * rolvDY(i,j,mz)*uss_HY(i,j)
c #BD     uqTC(i,j,1)=  WKxy3(i,j)          * 62.5e-3
c #AE END DO
c #AE END DO

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx IF                            (lSV_v1.EQ.2)
! #wx.  write(6,6012)                uss_HY(iSV_v1,jSV_v1)  *1.e3
 6012   format(10x,'After SISVAT(2): us* [mm/s] =',f9.3)

C +--Additional OUTPUT for VERIFICATION
C +  ----------------------------------

c #WR DO j=jp11,my1
c #WR DO i=ip11,mx1
c #WR   IF (ifrVER(i,j).ne.100) write(6,660) isolSL(i,j),i,j,ifrVER(i,j)
c #WR.                                     ,(ifraTV(i,j,n),n=1,nvx)
 660    format(' WARNING: Mosaic',i2,' (',2i4,') = ',i4,i6,2i4)
c #WR END DO
c #WR END DO

c #WR i = imez + 10.*111.111e3/dx
c #WR j = jmez
c #WR write(6,6060) itexpe,jdarGE,labmGE(mmarGE),iyrrGE
c #WR.                    ,jhurGE,minuGE        ,GElatr(i,j)/degrad
c #WR.             ,tairDY(i,j,mz),virDY(i,j,mz),1.e3*rolvDY(i,j,mz)
c #WR.             ,hsenSL(i,j)  ,hlatSL(i,j),-86400.0*SLuqs(i,j)
c #WR.        ,1.e3*rainHY(i,j)  ,evapTV(i,j),        runoTV(i,j)
 6060 format(i6,i3,'-',a3,'-',i4,':',i2,':',i2,f6.2,'?N',
     .       f9.3,' K',f6.3,f6.3,' kg/m3',2(f6.1,' W/m2'),
     .       f6.3,' mm/day',3(f9.3,' mm'))

C +--Verification of Vectorization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #VR   write(6,6100)
 6100   format(/,'Verification of Vectorization: Before CALL')
c #VR   DO n=mw,1,-1
c #VR   DO j=my,1,-1
c #VR   write(6,6110) (ij0ver(i,j,n),i=1,mx)
 6110   format(132i1)
c #VR   ENDDO
c #VR   write(6,6103)
 6103   format(1x)
c #VR   ENDDO

c #VR   write(6,6101)
 6101   format(/,'Verification of Vectorization: After  CALL')
c #VR   DO n=mw,1,-1
c #VR   DO j=my,1,-1
c #VR   write(6,6110) (ij_ver(i,j,n),i=1,mx)
c #VR   ENDDO
c #VR   write(6,6103)
c #VR   ENDDO

c #VR   DO n=1,mw
c #VR   DO j=1,my
c #VR   DO i=1,mx
c #VR     IF (ijdver(i,j,n).NE.0 .AND. ij_ver(i,j,n).NE.1)
c #VR.      write(6,6102) i,j,n,ijdver(i,j,n)
 6102       format(' Vectorization ERROR on',3i4,'   (',i6,')')
c #VR   ENDDO
c #VR   ENDDO
c #VR   ENDDO


      IF (.not.INI_SV)
     .         INI_SV = .true.

      return
      end


      block data SISVAT_CdP

C +------------------------------------------------------------------------+
C | MAR          SISVAT_CdP                                14-02-2006  MAR |
C |   SubRoutine SISVAT_CdP contains specific (Col de Porte) constants of  |
C |              Soil/Ice Snow Vegetation Atmosphere Transfer Scheme       |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE
      include "MAR_SV.inc"


C +..BEGIN    "MARdCP.inc"
C +--Col de Porte specific Constants
C +  ===============================

      logical         ColPrt                ! Col de Porte Switch
      common/ColPrt_l/ColPrt


C +--Fractions of total solar irradiances in 3 spectral intervals
C +  ------------------------------------------------------------

      real            Dr_1SN,Dr_2SN,Dr_3SN  ! Direct  Radiation
      real            Df_1SN,Df_2SN,Df_3SN  ! Diffuse Radiation, Clear  Sky
      real            Dfc1SN,Dfc2SN,Dfc3SN  ! Diffuse Radiation, Cloudy Sky
      common/ColPrt_r/Dr_1SN,Dr_2SN,Dr_3SN
     .               ,Df_1SN,Df_2SN,Df_3SN
     .               ,Dfc1SN,Dfc2SN,Dfc3SN

      real            DirSol,DifSol,TotSol,Clouds
      common/ColPrt_v/DirSol,DifSol,TotSol,Clouds

C +..END      "MARdCP.inc"


C +--DATA
C +  ====

c #CP data     ColPrt /.true./

      data     Dr_1SN/0.59    /,Dr_2SN/0.31    /,Dr_3SN/0.10    /
      data     Df_1SN/0.95    /,Df_2SN/0.05    /,Df_3SN/0.00    /
      data     Dfc1SN/0.66    /,Dfc2SN/0.27    /,Dfc3SN/0.07    /
C +...         0.3--0.8micr.m   0.8--1.5micr.m   1.5--2.8micr.m
C +            Fractions of total solar irradiance in 3 spectral intervals
C +***        (see Eric Martin Sept. 1996, CROCUS, Subroutine METEO)


      end


      block data SISVAT_dat

C +------------------------------------------------------------------------+
C | MAR          SISVAT_dat                                12-05-2010  MAR |
C |   SubRoutine SISVAT_dat contains the constants of the                  |
C |              Soil/Ice Snow Vegetation Atmosphere Transfer Scheme       |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE
      include "MAR_SV.inc"


C +..BEGIN    "MARdSV.inc"
C +--SISVAT Global Variables
C +  =======================

      logical       INI_SV               ! Initialisation Switch
      common/SwchSV/INI_SV               ! 
      real          eps_21               ! Arbitrary  very small value
      common/GendSV/eps_21               !


C +--Snow
C +  ----

      integer       istdSV(5)            ! Snow History
      common/SnidSV/istdSV               !

      real          Cn_dSV               ! Snow Heat Capacity          [J/kg/K]
      real          SMndSV               ! Minimum Thickness of new Layers
      real          G1_dSV               ! Conversion 0/99-->0/1 
      real          DDcdSV,DFcdSV,DScdSV ! Snow Grains Optical Diameter [1e-4m]
      real                        ADSdSV ! Snow Grains Actual  Diameter [1e-4m]
      real          So1dSV,So2dSV,So3dSV ! Total Solar Irradiance Fractions [-]
      real          aI1dSV,aI2dSV,aI3dSV ! Bare Ice Albedo                  [-]
      real          ws0dSV               ! Irreducible Water Saturation in Snow
      real          roCdSV               ! Pore Hole Close OFF Density  [kg/m3]
      real          ru_dSV               ! Surficial Water Scale Factor [kg/m2]

      common/Sn_dSV/Cn_dSV,
     .              SMndSV,
     .              G1_dSV,
     .              DDcdSV,DFcdSV,DScdSV,
     .                            ADSdSV,
     .              So1dSV,So2dSV,So3dSV,
     .              aI1dSV,aI2dSV,aI3dSV,
     .              ws0dSV,
     .              roCdSV,
     .              ru_dSV


C +--Ice
C +  ---

      real          CdidSV
      common/IcedSV/CdidSV


C +--Vegetation
C +  ----------

      integer                nvgt
      parameter             (nvgt=12)
      real          DH_dSV(0:nvgt)       ! Displacement            Height   [m]
      real          Z0mdSV(0:nvgt)       ! Roughness  Length for Momentum   [m]
      real          StodSV(0:nvgt)       ! Minimum    Stomatal Resistance [s/m]
      real          rbtdSV(0:nvgt)       ! Roots Fraction Beta Coefficient  [-]
      real          PR_dSV(0:nvgt)       ! Internal Plant      Resistance   [s]
      real          pscdSV               ! Critical Leaf Water Potential    [m]
      real          StxdSV               ! maXimum  Stomatal   Resistance [s/m]
      real          LAIdSV               ! maximum  LAI
      common/Vg_dSV/DH_dSV,Z0mdSV,StodSV,rbtdSV,PR_dSV
     .             ,pscdSV,StxdSV,LAIdSV


C +--Soil
C +  ----

      real          rcwdSV               ! Density * Water Specific Heat
      real          dz_dSV(-nsol:0)      ! Vertical  Discretization
      real          zz_dSV               ! Soil      Thickness
      common/SozdSV/rcwdSV,dz_dSV,zz_dSV !

      integer                nsot
      parameter             (nsot=12)
      real          etadSV(0:nsot)       ! Water Content at Saturation  [m3/m3]
      real          psidSV(0:nsot)       ! Water Succion at Saturation      [m]
      real          Ks_dSV(0:nsot)       ! Hydraulic Conductivity
                                         !               at Saturation    [m/s]
      real          bCHdSV(0:nsot)       ! Clapp-Hornberger Coefficient b   [-]
      common/So_dSV/etadSV,psidSV,Ks_dSV,bCHdSV


C +--Water Bodies
C +  ------------

      real          vK_dSV               ! Diffusivity in Water          [m2/s]
      real          TSIdSV               ! Sea-Ice Fraction: SST Scale      [K]
      common/Wa_dSV/vK_dSV,TSIdSV        !


C +..END      "MARdSV.inc"


C +--Internal Variables
C +  ==================

      integer               ivg,iso
      common/SISVAT_dat_Loc/ivg,iso


C +--General DATA
C +  ============

      data          INI_SV /  .false./   ! Initialisation  Switch
      data          eps_21 /   1.e-21/   ! Arbitrary  very small value


C +--Snow
C +  ----

      data          Cn_dSV /2105.    /   ! Snow Heat Capacity          [J/kg/K]
                                         ! Loth et al. 1993, JGR 98 D6
                                         ! 2.2.2 2e para p.10453
      data          SMndSV /   1.00  /   ! New Snow Layer Min.Thickn. [mm w.e.]
      data          G1_dSV /  99.    /   ! Conversion 0/99-->0/1
                                         ! Sphericity/Dendricity
                                         ! Optical Diameter of:
      data          DDcdSV /   1.    /   ! Dendritic     Crystals    [0.0001 m]
      data          DFcdSV /   4.    /   ! Young Faceted Crystals    [0.0001 m]
      data          DScdSV /   3.    /   ! Small         Crystals    [0.0001 m]
                                         ! Actual  Diameter of:
      data          ADSdSV /   4.    /   ! Small         Crystals    [0.0001 m]
      data          istdSV /1,2,3,4,5/   ! Snow  History: 
                                         ! 1:             faceted cristal
                                         ! 2: liq.watr/no faceted cristal befor
                                         ! 3: liq.watr/   faceted cristal befor
   
C +--Fractions of total Solar Irradiance  in 3 spectral Intervals
C +  (see Feagle and Businger 1981, Int.Geoph.Ser. 25, p.215-222)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #fb data          So1dSV /   0.606 /   !                 0.3--0.8mim Interval
c #fb data          So2dSV /   0.301 /   !                 0.8--1.5mim Interval
c #fb data          So3dSV /   0.093 /   !                 1.5--2.8mim Interval
      data          So1dSV /   0.580 /   ! Tuning ETH camp 0.3--0.8mim Interval
      data          So2dSV /   0.320 /   ! Tuning ETH camp 0.8--1.5mim Interval
      data          So3dSV /   0.100 /   ! Tuning ETH camp 1.5--2.8mim Interval
c #AC data          aI1dSV /   0.55  /   ! Minimum bare ICE albedo
c #GL data          aI1dSV /   0.40  /   ! Minimum bare ICE albedo
      data          aI1dSV /   0.50  /   ! Minimum bare ICE albedo
      data          aI2dSV /   0.575 /   ! Maximum bare ICE albedo
      data          aI3dSV /   0.675 /   ! ICE lense albedo at roCdSV kg/m3
                                         ! and minimum pure snow albedo
      data          ru_dSV /     200./   ! Surficial Water Scale Factor [kg/m2]


C +--Water in Snow
C +  -------------

      data          ws0dSV /   0.07  /   ! Irreducible Water Saturation in Snow
C +                                      ! 0.07      : Coleou et al., 1998, A.Gla.26, 64-68
                                         ! 0.08-0.15 : Greuell & Konzelmann (1994)
cXF
      data          roCdSV / 830.    /   ! Pore Hole Close OFF Density  [kg/m3]
C +                                      ! 800: Greuell & Konzelmann (1994), Glob.Plan.Change 9, 4.5 p.100
C +                                      ! 830: Harper et al. (2012), Nature
cXF

C +--Ice
C +  ---

      data          CdidSV /   2.1   /   ! Conductivity of pure  Ice    [W/m/K]


C +--Vegetation                (SVAT Classification)
C +  -----------------------------------------------


      data     (DH_dSV(ivg),                             ! Displac.  Height [m]
     .                 Z0mdSV(ivg),                      ! Roughness L./Mom [m]
     .                        StodSV(ivg),               ! Min.Stom.Resis.[s/m]
     .                               PR_dSV(ivg),        ! Plant Resistance [s]
     .                                      rbtdSV(ivg), ! Root beta coeff. [-]
     .                                              ivg=0,nvgt)
     .         /0.00,  0.01,5000.,   0.0,   0.000,       !  0 NO     VEGETATION
     .          0.07,  0.01,  50.,   0.5e9, 0.961,       !  1 CROPS      LOW
     .          0.21,  0.03,  50.,   0.5e9, 0.961,       !  2 CROPS      MEDIUM
     .          0.70,  0.10,  50.,   0.5e9, 0.961,       !  3 CROPS      HIGH
     .          0.07,  0.01,  50.,   0.5e9, 0.943,       !  4 GRASS      LOW
     .          0.21,  0.03,  50.,   0.5e9, 0.964,       !  5 GRASS      MEDIUM
     .          0.70,  0.10,  50.,   0.5e9, 0.972,       !  6 GRASS      HIGH
     .          1.40,  0.20,  10.,   1.0e9, 0.968,       !  7 BROADLEAF  LOW
     .          5.60,  0.80,  10.,   1.0e9, 0.962,       !  8 BROADLEAF  MEDIUM
     .         14.00,  2.00,  10.,   1.0e9, 0.962,       !  9 BROADLEAF  HIGH
     .          1.40,  0.20,  10.,   1.0e9, 0.971,       ! 10 NEEDLELEAF LOW
     .          5.60,  0.80,  10.,   1.0e9, 0.976,       ! 11 NEEDLELEAF MEDIUM
     .         14.00,  2.00,  10.,   1.0e9, 0.976/       ! 12 NEEDLELEAF HIGH


      data      pscdSV / 250.  /                         ! Crit.Leaf Water Pot.
      data      StxdSV /5000.  /                         ! MAX Stomatal Resist.
      data      LAIdSV /   4.  /                         ! MAX LAI


C +--Soil
C +  ----

      data          rcwdSV /4.180e+6/                    ! Water: Density 
C +                                                      !      * Spec.Heat
C +--Soil Vertical Discretization
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      data         (dz_dSV(iso),iso=-4,0)
     .                     /0.72,0.20,0.060,0.019,0.001/ ! Layer's Thickness

C +--Soil Hydraulic Parameters (USDA Classification)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      data         (etadSV(iso),
     .                        psidSV(iso),
     .                                  Ks_dSV(iso),
     .                                            bCHdSV(iso),
     .                                                   iso=0,nsot)
     .             / 1.000,    1.000,   0.0e00,     1.00, !  0 WATER
     .               0.395,    0.121, 176.0e-6,     4.05, !  1 SAND
     .               0.410,    0.090, 156.3e-6,     4.38, !  2 LOAMY      SAND
     .               0.435,    0.218,  34.1e-6,     4.90, !  3 SANDY      LOAM
     .               0.485,    0.786,   7.2e-6,     5.30, !  4 SILT       LOAM
     .               0.451,    0.478,   7.0e-6,     5.39, !  5            LOAM
     .               0.420,    0.299,   6.3e-6,     7.12, !  6 SANDY CLAY LOAM
     .               0.477,    0.356,   1.7e-6,     7.75, !  7 SILTY CLAY LOAM
     .               0.476,    0.630,   2.5e-6,     8.52, !  8       CLAY LOAM
     .               0.426,    0.153,   2.2e-6,    10.40, !  9 SANDY CLAY
     .               0.492,    0.490,   1.0e-6,    10.40, ! 10 SILTY CLAY
     .               0.482,    0.405,   1.3e-6,    11.40, ! 11       CLAY
     .               0.001,    0.001,   0.0e00,     0.02/ ! 12       ICE 
C +!!!Revoir les donnees pour la glace


C +--Water Bodies
C +  ------------

      data          vK_dSV /1000.    /   ! Diffusivity in Water          [m2/s]
      data          TSIdSV /   0.50  /   ! Sea-Ice Fraction: SST Scale      [K]

      end


      subroutine SISVAT_ini

C +------------------------------------------------------------------------+
C | MAR          SISVAT_ini                            Sun 31-10-2010  MAR |
C |   SubRoutine SISVAT_ini generates non time dependant SISVAT parameters |
C +------------------------------------------------------------------------+
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   dt__SV   : Time  Step                                   [s] |
C |   ^^^^^    dz_dSV   : Layer Thickness                              [m] |
C |                                                                        |
C |   OUTPUT:  RF__SV   : Root Fraction in Layer isl                   [-] |
C |   ^^^^^^   rocsSV   : Soil Contrib. to (ro c)_s exclud.Water  [J/kg/K] |
C |            etamSV   : Soil Minimum Humidity                    [m3/m3] |
C |                      (based on a prescribed Soil Relative Humidity)    |
C |            s1__SV   : Factor of eta**( b+2) in Hydraul.Diffusiv.       |
C |            s2__SV   : Factor of eta**( b+2) in Hydraul.Conduct.        |
C |            aKdtSV   : KHyd: Piecewise Linear Profile:  a * dt    [m]   |
C |            bKdtSV   : KHyd: Piecewise Linear Profile:  b * dt    [m/s] |
C |            dzsnSV(0): Soil first Layer Thickness                   [m] |
C |            dzmiSV   : Distance between two contiguous levels       [m] |
C |            dz78SV   : 7/8 (Layer Thickness)                        [m] |
C |            dz34SV   : 3/4 (Layer Thickness)                        [m] |
C |            dz_8SV   : 1/8 (Layer Thickness)                        [m] |
C |            dzAvSV   : 1/8  dz_(i-1) + 3/4 dz_(i) + 1/8 dz_(i+1)    [m] |
C |            dtz_SV   : dt/dz                                      [s/m] |
C |            OcndSV   : Swab Ocean / Soil Ratio                      [-] |
C |            Implic   : Implicit Parameter  (0.5:  Crank-Nicholson)      |
C |            Explic   : Explicit Parameter = 1.0 - Implic                |
C |                                                                        |
C | # OPTIONS: #ER: Richards Equation is not smoothed                      |
C | # ^^^^^^^  #kd: De Ridder   Discretization                             |
C | #          #SH: Hapex-Sahel Values                                     |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"


C +--INPUT / OUTPUT
C +  --------------

      include  "MARxSV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/)

C +--Internal Variables
C +  ==================

      integer   ivt   ,ist   ,ivg   ,ikl   ,isl   ,isn   ,ikh
      integer   misl_2,nisl_2
      real      zDepth
      real      d__eta,eta__1,eta__2,Khyd_1,Khyd_2
      real      RHsMin                          ! Min.Soil Relative Humidity
      real      PsiMax                          ! Max.Soil Water    Potential
      real      a_Khyd,b_Khyd                   ! Piecewis.Water Conductivity
c #WR real      Khyd_x,Khyd_y


C +--DATA
C +  ====

      data      RHsMin/0.001/                   ! Min.Soil Relative Humidity


C +--Non Time Dependant SISVAT parameters
C +  ====================================

C +--Soil Discretization
C +  -------------------

C +--Numerical Scheme Parameters
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Implic = 0.75                           ! 0.5  <==> Crank-Nicholson
        Explic = 1.00 - Implic                  !

C +--Soil/Snow Layers Indices
C +  ^^^^^^^^^^^^^^^^^^^^^^^^
      DO  isl=-nsol,0
        islpSV(isl) =           isl+1
        islpSV(isl) = min(      islpSV(isl),0)
        islmSV(isl) =           isl-1
        islmSV(isl) = max(-nsol,islmSV(isl))
      END DO

      DO  isn=1,nsno
        isnpSV(isn) =           isn+1
        isnpSV(isn) = min(      isnpSV(isn),nsno)
      END DO

C +--Soil      Layers Thicknesses
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #kd IF (nsol.gt.4)                                              THEN
c #kd   DO isl=-5,-nsol,-1
c #kd     dz_dSV(isl)=   1.
c #kd   END DO
c #kd END IF

      IF (nsol.ne.4)                                              THEN
        DO isl= 0,-nsol,-1
          misl_2 =     -mod(isl,2)
          nisl_2 =         -isl/2
          dz_dSV(isl)=(((1-misl_2) * 0.001
     .                  +  misl_2  * 0.003) * 10**(nisl_2)) * 4.
C +...    dz_dSV(0)  =         Hapex-Sahel Calibration:       4 mm

        END DO
          dz_dSV(0)  =               0.001
          dz_dSV(-1) = dz_dSV(-1)  - dz_dSV(0)          + 0.004
      END IF

        zz_dSV      = 0.
      DO  isl=-nsol,0
        dzmiSV(isl) = 0.500*(dz_dSV(isl)        +dz_dSV(islmSV(isl)))
        dziiSV(isl) = 0.500* dz_dSV(isl)        /dzmiSV(isl)
        dzi_SV(isl) = 0.500* dz_dSV(islmSV(isl))/dzmiSV(isl)
        dtz_SV(isl) =        dt__SV             /dz_dSV(isl)
        dz78SV(isl) = 0.875* dz_dSV(isl)
        dz34SV(isl) = 0.750* dz_dSV(isl)
        dz_8SV(isl) = 0.125* dz_dSV(isl)
        dzAvSV(isl) = 0.125* dz_dSV(islmSV(isl))
     .              + 0.750* dz_dSV(isl)
     .              + 0.125* dz_dSV(islpSV(isl))
c #ER   dz78SV(isl) =        dz_dSV(isl)
c #ER   dz34SV(isl) =        dz_dSV(isl)
c #ER   dz_8SV(isl) = 0.
c #ER   dzAvSV(isl) =        dz_dSV(isl)
        zz_dSV      = zz_dSV+dz_dSV(isl)
      END DO
      DO ikl=1,klonv
        dzsnSV(ikl,0) =      dz_dSV(0)
      END DO

C +--Conversion to a 50 m Swab Ocean Discretization
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        OcndSV = 0.
      DO isl=-nsol,0
        OcndSV = OcndSV +dz_dSV(isl)
      END DO
        OcndSV = 50.    /OcndSV 


C +--Secondary Vegetation Parameters
C +  -------------------------------

C +--Minimum Stomatal Resistance (Hapex Sahel Data)
C +  (Taylor et al. 1997, J.Hydrol 188-189, p.1047)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #SH DO ivg=1,3                       !
c #SH   StodSV(ivg) = 210.             ! Millet
c #SH END DO                           !
c #SH   StodSV(  4) = 120.             ! Sparse Tiger Bush
c #SH DO ivg=5,6                       !
c #SH   StodSV(ivg) =  80.             ! Dense  Tiger Bush
c #SH END DO                           !
c #SH   StodSV(  7) =  80.             ! Low    Trees (Fallow)
c #SH   StodSV( 10) =  80.             !

C +--Minimum Stomatal Resistance (Tropical Forest) 
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #SH   StodSV(  8) =  60.             ! Medium Trees
c #SH   StodSV( 11) =  60.             !
c #SH   StodSV(  9) =  40.             ! High   Trees
c #SH   StodSV( 12) =  40.             !

C +--Root Fraction
C +  ^^^^^^^^^^^^^
C +  * GENERAL REFERENCE
C +    Jackson et al., 1996: A global analysis of root distributions for
C +    terrestrial biomes. In Oecologia, 108, 389-411.

C +  * ROOT PROFILE
C +    The cumulative root fraction Y is given by
C +        Y = 1 - beta**d   with d    the depth (in cm),
C +                               beta a coefficient (vegetation dependent).

C +  * BETA VALUES (for 11 world biomes)
C +  1  boreal forest                0.943
C +  2  crops                        0.961
C +  3  desert                       0.975
C +  4  sclerophyllous shrubs        0.964
C +  5  temperate coniferous forest  0.976
C +  6  temperate deciduous forest   0.966
C +  7  temperate grassland          0.943
C +  8  tropical deciduous forest    0.961
C +  9  tropical evergreen forest    0.962
C +  10 tropical grassland savanna   0.972
C +  11 tundra                       0.914

C +  * ADVISED BETA VALUES FOR MAR
C +    (see 'block data SISVAT_dat', variable rbtdSV)
C +
C +    SVAT veg. type         default      West Africa
C +    0  barren soil         0.000        0.000
C +    1  crops low           0.961 (2)    0.961 (2)
C +    2  crops medium        0.961 (2)    0.961 (2)
C +    3  crops high          0.961 (2)    0.961 (2)
C +    4  grass low           0.943 (7)    0.943 (7)
C +    5  grass medium        0.943 (7)    0.964 (4)
C +    6  grass high          0.943 (7)    0.972 (10)
C +    7  broadleaf low       0.966 (6)    0.968 (4,10)
C +    8  broadleaf medium    0.966 (6)    0.962 (8,9)
C +    9  broadleaf high      0.966 (6)    0.962 (8,9)
C +    10 needleleaf low      0.976 (5)    0.971 (5,6)
C +    11 needleleaf medium   0.976 (5)    0.976 (5)
C +    12 needleleaf high     0.976 (5)    0.976 (5)

C +    Numbers between brackets refer to Jackson's biomes. For more details
C +    about some choices, see the correspondance between the IGBP and SVAT
C +    vegetation classes (i.e. in NESTOR).

C +  * WARNING
C +    Most of the roots are located in the first 2 m of soil. The root
C +    fraction per layer depends on the definition of the soil layer
C +    thickness. It will get wrong if a thick layer is defined around 2 m
C +    deep.

      write(*,'(/a)') 'ROOT PROFILES (Jackson, 1996) :'

      DO ivt = 0, nvgt
        zDepth = 0.
        DO isl = 0, -nsol, -1
          IF (ivt .ne. 0) THEN
            RF__SV(ivt,isl) =  rbtdSV(ivt)**zDepth *
     .                         (1. - rbtdSV(ivt)**(dz_dSV(isl)*100) )
            zDepth = zDepth + dz_dSV(isl)*100  !in cm
          ELSE
            RF__SV(ivt,isl) = 0.
          END IF
        END DO
        write(*,'(a,i2,a,i3,a,99f10.5:)')
     .       '  RF__SV(', ivt, ',', -nsol, ':0) =', RF__SV(ivt,:)
      END DO
      write(6,6600)
 6600 format(
     .  '  NOTE: If root fraction is not close to 0  around 2 m deep,',
     ./,'        Then you should redefine the soil layer thicknesses.',
     ./,'        See the code for more details.')


C +--Secondary Soil       Parameters
C +  -------------------------------

      DO  ist=0,nsot
         rocsSV(ist)=(1.0-etadSV(ist))*1.2E+6  ! Soil Contrib. to (ro c)_s 
         s1__SV(ist)=     bCHdSV(ist)          ! Factor of (eta)**(b+2)
     .  *psidSV(ist)     *Ks_dSV(ist)          !    in DR97, Eqn.(3.36)
     . /(etadSV(ist)**(   bCHdSV(ist)+3.))     !
         s2__SV(ist)=     Ks_dSV(ist)          ! Factor of (eta)**(2b+3)
     . /(etadSV(ist)**(2.*bCHdSV(ist)+3.))     !    in DR97, Eqn.(3.35)

C +--Soil Minimum Humidity (from a prescribed minimum relative Humidity)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         Psimax = -(log(RHsMin))/7.2E-5        ! DR97, Eqn 3.15 Inversion
         etamSV(ist) =  etadSV(ist)
     .         *(PsiMax/psidSV(ist))**(-min(10.,1./bCHdSV(ist)))
      END DO
         etamSV(12)  =  0.

C +--Piecewise Hydraulic Conductivity Profiles
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      DO   ist=0,nsot

c #WR     write(6,6000)
 6000     format(' Type |    etaSat | No |    eta__1 |    eta__2 |',
     .           '    Khyd_1 |    Khyd_x |    Khyd_2 |    Khyd_y |'
     .         /,' -----+-----------+----+-----------+-----------+',
     .           '-----------+-----------+-----------+-----------+')

          d__eta          =  etadSV(ist)/nkhy
          eta__1          =  0.
          eta__2          =  d__eta
        DO ikh=0,nkhy
          Khyd_1          =  s2__SV(ist)             ! DR97, Eqn.(3.35)
     .  *(eta__1      **(2. *bCHdSV(ist)+3.))        !
          Khyd_2          =  s2__SV(ist)             !
     .  *(eta__2      **(2. *bCHdSV(ist)+3.))        !

          a_Khyd          = (Khyd_2-Khyd_1)/d__eta   !
          b_Khyd          =  Khyd_1-a_Khyd *eta__1   !
c #WR     Khyd_x          =  a_Khyd*eta__1 +b_Khyd   !
c #WR     Khyd_y          =  a_Khyd*eta__2 +b_Khyd   !
          aKdtSV(ist,ikh) =  a_Khyd       * dt__SV   !
          bKdtSV(ist,ikh) =  b_Khyd       * dt__SV   !

c #WR     write(6,6001) ist,etadSV(ist),ikh,eta__1,
c #WR.          eta__2,Khyd_1,Khyd_x,Khyd_2,Khyd_y
 6001     format(i5,' |',e10.2,' |',i3,' |',
     .                 6(e10.2,' |'))

          eta__1          = eta__1  + d__eta
          eta__2          = eta__2  + d__eta
        END DO
      END DO

      return
      end


      subroutine SISVAT

C +------------------------------------------------------------------------+
C | MAR          SISVAT                               Mon 23-Jan-2012  MAR |
C |   SubRoutine SISVAT contains the fortran 77 code of the                |
C |              Soil/Ice Snow Vegetation Atmosphere Transfer Scheme       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   daHost   : Date Host Model                                  |
C |   ^^^^^                                                                |
C |                                                                        |
C |   INPUT:   LSmask   : 1:          Land       MASK                      |
C |   ^^^^^               0:          Sea        MASK                      |
C |            ivgtSV   = 0,...,12:   Vegetation Type                      |
C |            isotSV   = 0,...,12:   Soil       Type                      |
C |                       0:          Water,          Liquid (Sea, Lake)   |
C |                      12:          Water, Solid           (Ice)         |
C |                                                                        |
C |   INPUT:   coszSV   : Cosine of the Sun Zenithal Distance          [-] |
C |   ^^^^^    sol_SV   : Surface Downward  Solar      Radiation    [W/m2] |
C |            IRd_SV   : Surface Downward  Longwave   Radiation    [W/m2] |
C |            drr_SV   : Rain  Intensity                        [kg/m2/s] |
C |            dsn_SV   : Snow  Intensity                      [mm w.e./s] |
C |            dsnbSV   : Snow  Intensity,  Drift Fraction             [-] |
C |            dbs_SV   : Drift Amount                           [mm w.e.] |
C |            za__SV   : Surface Boundary Layer (SBL) Height          [m] |
C |            VV__SV   :(SBL Top)   Wind Velocity                   [m/s] |
C |            VV10SV   : 10-m       Wind Velocity                   [m/s] |
C |            TaT_SV   : SBL Top    Temperature                       [K] |
C |            rhT_SV   : SBL Top    Air  Density                  [kg/m3] |
C |            QaT_SV   : SBL Top    Specific  Humidity            [kg/kg] |
C |            qsnoSV   : SBL Mean   Snow      Content             [kg/kg] |
C |            LAI0SV   : Leaf Area  Index                             [-] |
C |            glf0SV   : Green Leaf Fraction                          [-] |
C |            alb0SV   : Soil Basic Albedo                            [-] |
C |            slopSV   : Surface    Slope                             [-] |
C |            dt__SV   : Time  Step                                   [s] |
C |                                                                        |
C |   INPUT /  isnoSV   = total Nb of Ice/Snow Layers                      |
C |   OUTPUT:  ispiSV   = 0,...,nsno: Uppermost Superimposed Ice Layer     |
C |   ^^^^^^   iiceSV   = total Nb of Ice      Layers                      |
C |            istoSV   = 0,...,5 :   Snow     History (see istdSV data)   |
C |                                                                        |
C |   INPUT /  alb_SV   : Surface-Canopy Albedo                        [-] |
C |   OUTPUT:  emi_SV   : Surface-Canopy Emissivity                    [-] |
C |   ^^^^^^   IRs_SV   : Soil           IR Flux  (negative)        [W/m2] |
C |            LMO_SV   : Monin-Obukhov               Scale            [m] |
C |            us__SV   : Friction          Velocity                 [m/s] |
C |            uts_SV   : Temperature       Turbulent Scale          [m/s] |
C |            uqs_SV   : Specific Humidity Velocity                 [m/s] |
C |            uss_SV   : Blowing Snow      Turbulent Scale          [m/s] |
C |            usthSV   : Blowing Snow      Erosion   Threshold      [m/s] |
C |            Z0m_SV   : Momentum     Roughness Length                [m] |
C |            Z0mmSV   : Momentum     Roughness Length (time mean)    [m] |
C |            Z0mnSV   : Momentum     Roughness Length (instantaneous)[m] |
C |            Z0SaSV   : Sastrugi     Roughness Length                [m] |
C |            Z0e_SV   : Erosion Snow Roughness Length                [m] |
C |            Z0emSV   : Erosion Snow Roughness Length (time mean)    [m] |
C |            Z0enSV   : Erosion Snow Roughness Length (instantaneous)[m] |
C |            Z0roSV   : Subgrid Topo Roughness Length                [m] |
C |            Z0h_SV   : Heat         Roughness Length                [m] |
C |            snCaSV   : Canopy   Snow     Thickness            [mm w.e.] |
C |            rrCaSV   : Canopy   Water    Content                [kg/m2] |
C |            psivSV   : Leaf     Water    Potential                  [m] |
C |            TvegSV   : Canopy   Temperature                         [K] |
C |            TsisSV   : Soil/Ice Temperatures (layers -nsol,-nsol+1,..,0)|
C |                     & Snow     Temperatures (layers  1,2,...,nsno) [K] |
C |            ro__SV   : Soil/Snow Volumic Mass                   [kg/m3] |
C |            eta_SV   : Soil/Snow Water   Content                [m3/m3] |
C |            G1snSV   : snow dendricity/sphericity                       |
C |            G2snSV   : snow sphericity/grain size                       |
C |            dzsnSV   : Snow Layer        Thickness                  [m] |
C |            agsnSV   : Snow       Age                             [day] |
C |            BufsSV   : Snow Buffer Layer              [kg/m2] .OR. [mm] |
C |            BrosSV   : Snow Buffer Layer Density      [kg/m3]           |
C |            BG1sSV   : Snow Buffer Layer Dendricity / Sphericity    [-] |
C |            BG2sSV   : Snow Buffer Layer Sphericity / Size [-] [0.1 mm] |
C |            rusnSV   : Surficial   Water              [kg/m2] .OR. [mm] |
C |                                                                        |
C |   OUTPUT:  no__SV   : OUTPUT file Unit Number                      [-] |
C |   ^^^^^^   i___SV   : OUTPUT point   i Coordinate                  [-] |
C |            j___SV   : OUTPUT point   j Coordinate                  [-] |
C |            n___SV   : OUTPUT point   n Coordinate                  [-] |
C |            lwriSV   : OUTPUT point vec Index                       [-] |
C |                                                                        |
C |   OUTPUT:  IRu_SV   : Upward     IR Flux (+, upw., effective)      [K] |
C |   ^^^^^^   hSalSV   : Saltating Layer Height                       [m] |
C |            qSalSV   : Saltating Snow  Concentration            [kg/kg] |
C |            RnofSV   : RunOFF Intensity                       [kg/m2/s] |
C |                                                                        |
C |   Internal Variables:                                                  |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |            NLaysv   = New            Snow Layer Switch             [-] |
C |            albisv   : Snow/Ice/Water/Soil Integrated Albedo        [-] |
C |            SoCasv   : Absorbed Solar Radiation by Canopy (Normaliz)[-] |
C |            SoSosv   : Absorbed Solar Radiation by Surfac.(Normaliz)[-] |
C |            tau_sv   : Fraction of Radiation transmitted by Canopy  [-] |
C |            TBr_sv   : Brightness Temperature                       [K] |
C |            IRupsv   : Upward     IR Flux (-, upw.)              [W/m2] |
C |            IRv_sv   : Vegetation IR Flux                        [W/m2] |
C |            rrMxsv   : Canopy Maximum Intercepted Rain          [kg/m2] |
C |            Sigmsv   : Canopy Ventilation Factor                    [-] |
C |            ram_sv   : Aerodynamic Resistance for Momentum        [s/m] |
C |            rah_sv   : Aerodynamic Resistance for Heat            [s/m] |
C |            HSv_sv   : Vegetation Sensible Heat Flux             [W/m2] |
C |            HLv_sv   : Vegetation Latent   Heat Flux             [W/m2] |
C |            Rootsv   : Root Water Pump                        [kg/m2/s] |
C |            Evp_sv   : Evaporation                              [kg/m2] |
C |            EvT_sv   : Evapotranspiration                       [kg/m2] |
C |            HSs_sv   : Surface    Sensible Heat Flux + => absorb.[W/m2] |
C |            HLs_sv   : Surface    Latent   Heat Flux + => absorb.[W/m2] |
C |            Lx_H2O   : Latent Heat of Vaporization/Sublimation   [J/kg] |
C |            Tsrfsv   : Surface    Temperature                       [K] |
C |            LAI_sv   : Leaf Area  Index (snow included)             [-] |
C |            LAIesv   : Leaf Area  Index (effective / transpiration) [-] |
C |            glf_sv   : Green Leaf Fraction of NOT fallen Leaves     [-] |
C |            sEX_sv   : Verticaly Integrated Extinction Coefficient  [-] |
C |            LSdzsv   : Vertical   Discretization Factor             [-] |
C |                     =    1. Soil                                       |
C |                     = 1000. Ocean                                      |
C |            z_snsv   : Snow Pack  Thickness                         [m] |
C |            zzsnsv   : Snow Pack  Thickness                         [m] |
C |            albssv   : Soil       Albedo                            [-] |
C |            Evg_sv   : Soil+Vegetation Emissivity                   [-] |
C |            Eso_sv   : Soil+Snow       Emissivity                   [-] |
C |            psi_sv   : Soil       Water    Potential                [m] |
C |            Khydsv   : Soil   Hydraulic    Conductivity           [m/s] |
C |                                                                        |
C |            ETVg_d   : VegetationEnergy Power         Forcing    [W/m2] |
C |            ETSo_0   : Snow/Soil Energy Power, before Forcing    [W/m2] |
C |            ETSo_1   : Snow/Soil Energy Power, after  Forcing    [W/m2] |
C |            ETSo_d   : Snow/Soil Energy Power         Forcing    [W/m2] |
C |            EqSn_0   : Snow      Energy, before Phase Change     [J/m2] |
C |            EqSn_1   : Snow      Energy, after  Phase Change     [J/m2] |
C |            EqSn_d   : Snow      Energy,       net    Forcing    [J/m2] |
C |            Enrsvd   : SVAT      Energy Power         Forcing    [W/m2] |
C |            Enrbal   : SVAT      Energy Balance                  [W/m2] |
C |            Wats_0   : Soil Water,  before Forcing                 [mm] |
C |            Wats_1   : Soil Water,  after  Forcing                 [mm] |
C |            Wats_d   : Soil Water          Forcing                 [mm] |
C |            SIWm_0   : Snow        initial Mass               [mm w.e.] |
C |            SIWm_1   : Snow        final   Mass               [mm w.e.] |
C |            SIWa_i   : Snow Atmos. initial Forcing            [mm w.e.] |
C |            SIWa_f   : Snow Atmos. final   Forcing(noConsumed)[mm w.e.] |
C |            SIWe_i   : SnowErosion initial Forcing            [mm w.e.] |
C |            SIWe_f   : SnowErosion final   Forcing(noConsumed)[mm w.e.] |
C |            SIsubl   : Snow sublimed/deposed  Mass            [mm w.e.] |
C |            SImelt   : Snow Melted            Mass            [mm w.e.] |
C |            SIrnof   : Surficial Water + Run OFF Change       [mm w.e.] |
C |            SIvAcr   : Sea-Ice    vertical Acretion           [mm w.e.] |
C |            Watsvd   : SVAT Water          Forcing                 [mm] |
C |            Watbal   : SVAT Water  Balance                       [W/m2] |
C |                                                                        |
C |            dsn_Ca,snCa_n :     Snow Contribution to the Canopy[m w.e.] |
C |            drr_Ca,rrCa_n,drip: Rain Contribution to the Canopy [kg/m2] |
C |            vk2      : Square of Von Karman Constant                [-] |
C |            sqrCm0   : Factor of   Neutral Drag Coeffic.Momentum  [s/m] |
C |            sqrCh0   : Factor of   Neutral Drag Coeffic.Heat      [s/m] |
C |            EmiVeg   : Vegetation    Emissivity                     [-] |
C |            EmiSol   : Soil          Emissivity                     [-] |
C |            EmiSno   : Snow          Emissivity                     [-] |
C |            EmiWat   : Water         Emissivity                     [-] |
C |            Z0mSea   :          Sea  Roughness Length               [m] |
C |            Z0mLnd   :          Land Roughness Length               [m] |
C |            sqrrZ0   : u*t/u*                                           |
C |            f_eff    : Marticorena & B. 1995 JGR (20)                   |
C |            A_Fact   : Fundamental * Roughness                          |
C |            Z0mBSn   :         BSnow Roughness Length               [m] |
C |            Z0mBS0   : Mimimum BSnow Roughness Length (blown* )     [m] |
C |            Z0m_Sn   :          Snow Roughness Length (surface)     [m] |
C |            Z0m_S0   : Mimimum  Snow Roughness Length               [m] |
C |            Z0m_S1   : Maximum  Snow Roughness Length               [m] |
C |            Z0_GIM   : Minimum GIMEX Roughness Length               [m] |
C |            Z0_ICE   : Sea Ice ISW   Roughness Length               [m] |
C |                                                                        |
C | # TUNING PARAMETERS :                                                  |
C | # OPTIONS: #BS: Wind Dependant Roughness Length of Snow                |
C | # ^^^^^^^  #ZS: Wind Dependant Roughness Length of Sea                 |
C | #          #FL: Dead Leaves are assumed to been fallen                 |
C | #          #RS: Z0h = Z0m / 100 over the ocean                         |
C | #          #US: u*   computed from aerodynamic resistance              |
C | #          #WV: OUTPUT                                                 |
C | #          #WR: OUTPUT    for Verification                             |
C | #          #SR: Variable      Tracing                                  |
C | #          #CP: Col de Porte  Turbulence        Parameterization       |
C | #          #GL: Greenland                       Parameterization       |
C |                                                                        |
C |                                                                        |
C |   TUNING PARAMETER:                                                    |
C |   ^^^^^^^^^^^^^^^^                                                     |
C |            z0soil   : Soil Surface averaged Bumps Height (see _qSo)[m] |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # SISVAT_iii_jjj_n     | #E0: OUTPUT on ASCII  File (SISVAT Variables) |
C | #                      |      Energy Budg. Verif.: Soil+(Sea-Ice)+Snow |
C | #                      |(#E0  MUST BE PREPROCESSED BEFORE #e1 & #e2 !) |
C | # SISVAT_iii_jjj_n     | #m0: OUTPUT/Verification: H2O    Conservation |
C |                        |                                               |
C | # stdout               | #s0: OUTPUT of Snow Buffer Layer              |
C |                        |      unit  6, SubRoutine  SISVAT     **ONLY** |
C | # stdout               | #sb: OUTPUT of Snow Erosion                   |
C |                        |      unit  6, SubRoutine  SISVAT_BSn **ONLY** |
C | # stdout               | #sz: OUTPUT of Roughness Length & Drag Coeff. |
C |                        |      unit  6, SubRoutine  SISVAT     **ONLY** |
C | # stdout               | #wz: OUTPUT of Roughness Length (Blown Snow)  |
C |                        |      unit  6, SubRoutines SISVAT, PHY_SISVAT  |
C |                                                                        |
C |   SUGGESTIONS of MODIFICATIONS: see lines beginning with "C +!!!"      |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                         |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARCTR.inc"
      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARlSV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"
      include  "MARxSV.inc"
c #CP include  "MARdCP.inc"


C +--Internal Variables
C +  ==================

C +--Non Local
C +  ---------

      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

      real      TBr_sv(klonv)                 ! Brightness Temperature
      real      IRdwsv(klonv)                 ! DOWNward   IR Flux
      real      IRupsv(klonv)                 ! UPward     IR Flux
      real      d_Bufs,Bufs_N                 ! Buffer Snow Layer Increment
      real      Buf_ro,Bros_N                 ! Buffer Snow Layer Density
      real      BufPro                        ! Buffer Snow Layer Density
      real      Buf_G1,BG1__N                 ! Buffer Snow Layer Dendr/Sphe[-]
      real      Buf_G2,BG2__N                 ! Buffer Snow Layer Spher/Size[-]
      real      Bdzssv(klonv)                 ! Buffer Snow Layer Thickness
      real      z_snsv(klonv)                 ! Snow-Ice, current Thickness

C +--Energy         Budget
C +  ~~~~~~~~~~~~~~~~~~~~~
! #e1 real      ETVg_d(klonv)                 ! VegetationPower, Forcing
! #e1 real      ETSo_0(klonv)                 ! Soil/Snow Power, before Forcing
! #e1 real      ETSo_1(klonv)                 ! Soil/Snow Power, after  Forcing
! #e1 real      ETSo_d(klonv)                 ! Soil/Snow Power, Forcing
! #e1 real      EqSn_0(klonv)                 ! Snow Energy, befor Phase Change
! #e1 real      EqSn_1(klonv)                 ! Snow Energy, after Phase Change
! #e1 real      EqSn_d(klonv)                 ! Energy in Excess

C +--Water   (Mass) Budget
C +  ~~~~~~~~~~~~~~~~~~~~~
! #m0 real      Wats_0(klonv)                 ! Soil Water,  before Forcing
! #m0 real      Wats_1(klonv)                 ! Soil Water,  after  Forcing
! #m0 real      Wats_d(klonv)                 ! Soil Water,         Forcing

C +--Snow/Ice(Mass) Budget
C +  ~~~~~~~~~~~~~~~~~~~~~
! #m1 real      SIsubl(klonv)                 ! Snow Sublimed/Deposed Mass
! #m1 real      SImelt(klonv)                 ! Snow Melted           Mass
! #m1 real      SIrnof(klonv)                 ! Local Surficial Water + Run OFF

C +--Sea-Ice (Mass) Budget
C +  ~~~~~~~~~~~~~~~~~~~~~
! #m2 real      SIvAcr(klonv)                 ! Sea-Ice      Vertical Acretion


C +--Local
C +  -----

c #MT logical      Garrat                     ! SBL     Scheme    Switch
      character* 1 SepLab                     ! OUTPUT ASCII File Labels
      character* 6 FilLab                     !
      character*16 FilNam                     !
      common/SISVAT_loc_abc/SepLab,FilLab     !

      integer               noUNIT            ! OUTPUT File  Unit Number
      integer               nwUNIT            ! OUTPUT File  Unit Number (New)
      common/SISVAT_loc_num/nwUNIT            !

      integer   iwr
      integer   ikl   ,isn   ,isl   ,ist      !
      integer   ist__s,ist__w                 ! Soil/Water Body Identifier
      integer   growth                        ! Seasonal               Mask
      integer   LISmsk                        ! Land+Ice / Open    Sea Mask
      integer   LSnMsk                        ! Snow-Ice / No Snow-Ice Mask
      integer   IceMsk,IcIndx(klonv)          !      Ice / No      Ice Mask
      integer   SnoMsk                        ! Snow     / No Snow     Mask

      real      drr_Ca,rrCa_n,drip            ! Rain Contribution to the Canopy
      real      dsn_Ca,snCa_n,FallOK(klonv)   ! Snow Contribution to the Canopy
      real      roSMin,roSn_1,roSn_2,roSn_3   ! Fallen Snow Density (PAHAUT)
c #SD real      roSMax                        ! Max. Fallen Snow Density
      real      Dendr1,Dendr2,Dendr3          ! Fallen Snow Dendric.(GIRAUD)
      real      Spher1,Spher2,Spher3,Spher4   ! Fallen Snow Spheric.(GIRAUD)
      real      Polair                        ! Polar  Snow Switch
      real      PorSno,Por_BS,Salt_f,PorRef   !
c #sw real      PorVol,rWater                 !
c #sw real      rusNEW,rdzNEW,etaNEW          !
      real      ro_new                        !
      real      TaPole                        ! Maximum     Polar Temperature
      real      T__Min                        ! Minimum realistic Temperature

      real      EmiVeg                        ! Emissivity of Vegetation 
      real      EmiSol                        ! Emissivity of       Soil
      real      EmiSno                        ! Emissivity of            Snow
      real      EmiWat                        ! Emissivity of a Water Area
      real      vk2                           ! Square of Von Karman Constant
      real      u2star                        !(u*)**2
c #WR real      u_star                        ! Friction Velocity (aer.resist.)
      real      fallen                        ! Fallen   Leaves         Switch
      real      Z0mSea,Z0hSea                 !          Sea  Roughness Length
      real      Z0mLnd                        !          Land Roughness Length
c #ZN real      sqrrZ0                        ! u*t/u*
      real      f_eff                         ! Marticorena & B. 1995 JGR (20)
      real      A_Fact                        ! Fundamental * Roughness
      real      Z0m_nu                        ! Smooth R Snow Roughness Length
      real      Z0mBSn                        !         BSnow Roughness Length
      real      Z0mBS0                        ! Mimimum BSnow Roughness Length
      real      Z0m_S0                        ! Mimimum  Snow Roughness Length
      real      Z0m_S1                        ! Maximum  Snow Roughness Length
c #SZ real      Z0Sa_N                        ! Regime   Snow Roughness Length
c #SZ real      Z0SaSi                        ! 1.IF Rgm Snow Roughness Length 
c #GL real      Z0_GIM                        ! Mimimum GIMEX Roughness Length
      real      Z0_ICE                        ! Sea-Ice ISW   Roughness Length
      real      Z0m_Sn,Z0m_90                 ! Snow  Surface Roughness Length
      real      SnoWat                        ! Snow Layer    Switch
c #RN real      rstar,alors                   !
c #RN real      rstar0,rstar1,rstar2          !
      real      SameOK                        ! 1. => Same Type of Grains
      real      G1same                        ! Averaged G1,  same Grains
      real      G2same                        ! Averaged G2,  same Grains
      real      typ__1                        ! 1. => Lay1 Type: Dendritic
      real      zroNEW                        ! dz X ro, if fresh Snow
      real      G1_NEW                        ! G1,      if fresh Snow
      real      G2_NEW                        ! G2,      if fresh Snow
      real      zroOLD                        ! dz X ro, if old   Snow
      real      G1_OLD                        ! G1,      if old   Snow
      real      G2_OLD                        ! G2,      if old   Snow
      real      SizNEW                        ! Size,    if fresh Snow
      real      SphNEW                        ! Spheric.,if fresh Snow
      real      SizOLD                        ! Size,    if old   Snow
      real      SphOLD                        ! Spheric.,if old   Snow
      real      Siz_av                        ! Averaged    Grain Size
      real      Sph_av                        ! Averaged    Grain Spher.
      real      Den_av                        ! Averaged    Grain Dendr.
      real      DendOK                        ! 1. => Average is  Dendr.
      real      G1diff                        ! Averaged G1, diff. Grains
      real      G2diff                        ! Averaged G2, diff. Grains
      real      G1                            ! Averaged G1
      real      G2                            ! Averaged G2
c #SD real      tt_c,vv_c                     ! Critical param.
c #SD real      tt_tmp,vv_tmp,vv_virt         ! Temporary variables

C +--Energy       Budget
C +  ~~~~~~~~~~~~~~~~~~~
! #e1 integer             noEBal              ! Energy Imbalances Counter
! #e1 common/SISVAT__EBal/noEBal              !
! #e1 real        Enrsvd(klonv)               ! Soil+Vegetat  Power  Forcing
! #e1 real        EnsBal                      ! Soil+Snow   , Power  Balance
! #e1 real        EnvBal                      !      Vegetat, Power  Balance

C +--Water (Mass) Budget
C +  ~~~~~~~~~~~~~~~~~~~
! #m0 integer             noWBal              ! Water  Imbalances Counter
! #m0 common/SISVAT__WBal/noWBal              !
! #m0 real        Watsv0(klonv)               ! Soil+Vegetat, before Forcing
! #m0 real        Watsvd(klonv)               ! Soil+Vegetat  Water  Forcing
! #m0 real        Watbal                      ! Soil+Vegetat, Water  Balance

C +--Snow  (Mass) Budget
C +  ~~~~~~~~~~~~~~~~~~~
! #m1 integer             noSBal              ! Water  Imbalances Counter
! #m1 common/SISVAT__SBal/noSBal              !
! #m1 real        SIWm_0(klonv),SIWm_1(klonv) ! Snow Initial/Final        Mass
! #m1 real        SIWa_i(klonv),SIWa_f(klonv) ! Snow Initial/Final ATM Forcing
! #m1 real        SIWe_i(klonv),SIWe_f(klonv) ! Snow Initial/Final BLS Forcing
! #m1 real        SnoBal                      ! Snow Pack     Mass   Balance


C +--Internal DATA
C +  =============

c #MT data      Garrat /.true. /              ! SBL     Scheme    Switch
      data      T__Min / 200.00/              ! Minimum realistic Temperature
c #AC data      TaPole / 283.15/              ! Maximum Polar     Temp. 
      data      TaPole / 268.15/              ! Maximum Polar     Temperature
c #EU data      roSMin / 100.  /              ! Minimum Snow   Density
      data      roSMin / 150.  /              ! Minimum Snow   Density
cXF
c #SD data      roSMax / 450.  /              ! Max Fresh Snow Density
c #SD data      tt_c   / -2.0  /              ! Critical Temp. (degC)
C +...DATA      tt_c=-2.  => rho->quickly to rho(vv_c) when T->-inf
c #SD data      vv_c   / 14.3  /              ! Critical Wind speed (m/s)
C +...DATA     vv_c=14.3 => rho->300 when T->-inf
      data      roSn_1 / 109.  /              ! Fall.Sno.Density, Indep. Param.
      data      roSn_2 /   6.  /              ! Fall.Sno.Density, Temper.Param.
      data      roSn_3 /  26.  /              ! Fall.Sno.Density, Wind   Param.
      data      Dendr1 /  17.12/              ! Fall.Sno.Dendric.,Wind 1/Param.
      data      Dendr2 / 128.  /              ! Fall.Sno.Dendric.,Wind 2/Param.
      data      Dendr3 / -20.  /              ! Fall.Sno.Dendric.,Indep. Param.
      data      Spher1 /   7.87/              ! Fall.Sno.Spheric.,Wind 1/Param.
      data      Spher2 /  38.  /              ! Fall.Sno.Spheric.,Wind 2/Param.
      data      Spher3 /  50.  /              ! Fall.Sno.Spheric.,Wind 3/Param.
      data      Spher4 /  90.  /              ! Fall.Sno.Spheric.,Indep. Param.
      data      EmiSol /   0.94/              ! Emissivity of Soil
      data      EmiVeg /   0.98/              ! Emissivity of Vegetation
      data      EmiWat /   0.99/              ! Emissivity of a Water Area
      data      EmiSno /   0.99/              ! Emissivity of Snow
C +...DATA      Emissivities                  ! Pielke, 1984, pp. 383,409

      data      fallen /   0.    /            ! Fallen  Leaves         Switch
      data      Z0mBS0 /   0.5e-6/            ! MINimum Snow Roughness Length 
                                              ! for Momentum if Blowing Snow
                                              ! Gall?e et al. 2001 BLM 99 (19)
      data      Z0m_S0/    0.00005/           ! MINimum Snow Roughness Length
c #MG data      Z0m_S0/    0.00200/           ! MINimum Snow Roughness Length
                                              ! MegaDunes    included
      data      Z0m_S1/    0.030  /           ! MAXimum Snow Roughness Length
                                              !        (Sastrugis)
c #GL data      Z0_GIM/    0.0013/            ! Ice Min Z0 = 0.0013 m (Broeke)
C +                                           ! Old Ice Z0 = 0.0500 m (Bruce)
c +                                           !              0.0500 m (Smeets)
C +                                           !              0.1200 m (Broeke)
      data      Z0_ICE/    0.0010/            ! Sea-Ice Z0 = 0.0010 m (Andreas)
c +                                           !    (Ice Station Weddel -- ISW)
      vk2    =  vonkar  *  vonkar             ! Square of Von Karman Constant
c #FL fallen =             1.                 ! Fallen  Leaves         Switch


C +..BEGIN.main.
C +--SISVAT Forcing VERIFICATION
C +  ===========================

      IF (.not.iniOUT)                                              THEN
               iniOUT = .true.
        IF (IRs_SV(1).gt.-epsi)
     .  write(6,600) 
 600    format(/,'### SISVAT ERROR, Soil IR Upward  not defined ###',
     .         /,'###               Initialize and Store IRs_SV ###')


! OUTPUT
! ======

                    FilLab              ='SISVAT'
                    SepLab              ='_'
                    nwUNIT              = 51
      END IF

c #E0 DO ikl=1,klonv
c #E0   IF   (lwriSV(ikl).ne.0.AND.no__SV(lwriSV(ikl)).eq.0)        THEN 
c #E0                nwUNIT              = nwUNIT+1
c #E0                no__SV(lwriSV(ikl)) = nwUNIT
c #E0      write(FilNam,'(a6,a1,2(i3.3,a1),i1)')
c #E0.           FilLab,SepLab,i___SV(lwriSV(ikl)),
c #E0.                  SepLab,j___SV(lwriSV(ikl)),
c #E0.                  SepLab,n___SV(lwriSV(ikl))
c #E0      open(unit=nwUNIT,status='unknown',file=FilNam)
c #E0      rewind    nwUNIT
c #E0   END IF
c #E0 END DO

c #E0 DO ikl=1,klonv
c #E0   IF (lwriSV(ikl).ne.0)                                       THEN 
c #E0           noUNIT=no__SV(lwriSV(ikl)) 
c #E0     write(noUNIT,5000) daHost,i___SV(lwriSV(ikl)),
c #E0.                              j___SV(lwriSV(ikl)),
c #E0.                              n___SV(lwriSV(ikl)),
c #E0.                                     Z0m_SV(ikl) ,
c #E0.                                     albisv(ikl)
 5000     format(
     .       /,              a18,'|           Grid Point ',2i4,
     .                                           ' (',i2,')',
     .         '    | Z0m =',f12.6,' | Albedo = ',f6.3,' |',
     .       /,' -------+',7('---------+'),2('--------+'))
c #E0   END IF
c #E0 END DO


C +--"Soil" Humidity of Water Bodies
C +  ===============================

      DO ikl=1,klonv
          ist    =      isotSV(ikl)                       ! Soil Type
          ist__s =  min(ist, 1)                           ! 1 => Soil
          ist__w =  1 - ist__s                            ! 1 => Water Body
        DO isl=-nsol,0
          eta_SV(ikl,isl) = eta_SV(ikl,isl) * ist__s      ! Soil 
     .                    + etadSV(ist)     * ist__w      ! Water Body
        END DO


C +--Vertical Discretization Factor
C +  ==============================

          LSdzsv(ikl)     =                   ist__s      ! Soil
     .                    + OcndSV          * ist__w      ! Water Body
      END DO


C +--Vegetation Temperature Limits
C +  =============================

          DO ikl=1,klonv
            TvegSV(ikl) = max(TvegSV(ikl),T__Min)         ! T__Min = 200.K


C +--LAI Assignation and Fallen Leaves Correction (#FL)
C +  ==================================================

            LAI0SV(ikl) =     LAI0SV(ikl)*min(1,ivgtSV(ikl)) ! NO LAI if 
C +                                                          ! no vegetation
            glf_sv(ikl) =     glf0SV(ikl)
c #FL       glf_sv(ikl) =     1.
            LAI_sv(ikl) =     LAI0SV(ikl)
c #FL.               *        glf0SV(ikl) 
          END DO


C +--LAI in Presence of Snow
C +  =======================

C +       ASSUMPTION: LAI decreases   when Snow Thickness increases, 
C +       ^^^^^^^^^^      becoming  0 when Snow Thickn. = Displac.Height
          DO ikl=1,klonv
            LAI_sv(ikl) =     LAI_sv(ikl)
     .               * (1.0 - zzsnsv(       ikl, isnoSV(ikl))
     .                      /(DH_dSV(ivgtSV(ikl))+epsi)      )
            LAI_sv(ikl) = max(LAI_sv(ikl),zero)
            LAI_sv(ikl) = min(LAI_sv(ikl),argmax)
          END DO


C +--Interception of Rain by the Canopy
C +  ==================================

! Vegetation Forcing
! ------------------

! #m0     DO ikl=1,klonv
! #m0       Watsv0(ikl) =      rrCaSV(ikl)           ! Canopy Water Cont.
! #m0       Watsvd(ikl) =      drr_SV(ikl)           ! Precipitation
! #m0     END DO


C +--New Canopy Water Content
C +  ------------------------

          DO ikl=1,klonv
            rrMxsv(ikl) = 0.2*max( epsi,LAI_sv(ikl)) ! Precip. Max. Intercept.
            Sigmsv(ikl) = 1.0-exp(-demi*LAI_sv(ikl)) ! Canopy Ventilation Coe.
C +                                                  ! (DR97, eqn 3.6)
            drr_Ca      = drr_SV(ikl)  *Sigmsv(ikl)  ! Intercepted Rain
     .                                 *dt__SV       !
            rrCa_n      = rrCaSV(ikl)  +drr_Ca       ! New Canopy Water Contnt
                                                     ! (DR97, eqn 3.28)
            drip        = rrCa_n       -rrMxsv(ikl)  ! Water  Drip
            drip        =      max(zero,drip)        !
            rrCa_n      = rrCa_n       -drip         !
            drr_SV(ikl) = drr_SV(ikl) +(rrCaSV(ikl)  ! Update Rain  Contribut.
     .                                 -rrCa_n     ) !
     .                                 /dt__SV       !
            rrCaSV(ikl) = rrCa_n                     ! Upd.Canopy Water Contnt


C +--Interception of Snow by the Canopy
C +  ==================================

            dsn_Ca      = dsn_SV(ikl)  *Sigmsv(ikl)  ! Intercepted Snow
     .                                 *dt__SV       !
            snCa_n      = snCaSV(ikl)  +dsn_Ca       ! New Canopy Snow Thickn.
            drip        = snCa_n       -rrMxsv(ikl)  !
            drip        =      max(zero,drip)        !
            snCa_n      = snCa_n       -drip         !
            dsn_SV(ikl) = dsn_SV(ikl) +(snCaSV(ikl)  ! Update Snow  Contribut.
     .                                 -snCa_n     ) ! 
     .                                 /dt__SV       !
            snCaSV(ikl) = snCa_n                     ! Upd.Canopy Snow Thickn.
          END DO 


C +--Snow Fall from the Canopy
C +  =========================

C +       ASSUMPTION: snow fall from the canopy, 
C +       ^^^^^^^^^^  when the temperature of the vegetation is positive
C +             (.OR. when snow over the canopy is saturated  with water)

          DO ikl=1,klonv
            FallOK(ikl) =  max(zero,sign(unun,TvegSV(ikl)-TfSnow+epsi))
     .                  *  max(zero,sign(unun,snCaSV(ikl)       -epsi))
            dsn_SV(ikl) =      dsn_SV(ikl)   +snCaSV(ikl)*FallOK(ikl) 
     .                                       /dt__SV
            snCaSV(ikl) =      snCaSV(ikl) * (1.         -FallOK(ikl))


C +--Blowing Particles Threshold Friction velocity
C +  =============================================

c #AE       usthSV(ikl) =                     1.0e+2
          END DO


C +--Contribution of Snow to the Surface Snow Pack
C +  =============================================

      IF (SnoMod)                                                 THEN


! Snow Initial Mass (below the Canopy) and Forcing
! ------------------------------------------------

! #m1   DO ikl=1,klonv
! #m1     SIWa_i(ikl) =(drr_SV(ikl) + dsn_SV(ikl))   *dt__SV         ![mm w.e.]
! #m1     SIWe_i(ikl) = dbs_SV(ikl)                                  !
! #m1     SIWm_0(ikl) = BufsSV(ikl) + HFraSV(ikl)    *ro_Ice         !
! #m1   DO isn=1,nsno                                                !
! #m1     SIWm_0(ikl) = SIWm_0(ikl) + dzsnSV(ikl,isn)*ro__SV(ikl,isn)!
! #m1   END DO                                                       !
! #m1   END DO                                                       !


C +--Blowing Snow
C +  ------------

C +                       **********
c #SN   IF (BloMod)  call SISVAT_BSn
C +                       **********

C +                       **********
! #ve                call SISVAT_wEq('_BSn  ',1)
C +                       **********


C +--Sea Ice
C +  -------

C +          **********
c #SI   call SISVAT_SIc
! #m2.                 (SIvAcr)
C +          **********

C +          **********
! #ve   call SISVAT_wEq('_SIc  ',0)
C +          **********


C +--Buffer Layer
C +  ------------

          DO ikl=1,klonv
            BufsSV(ikl) =      BufsSV(ikl)              !     [mm w.e.]
            d_Bufs      =  max(dsn_SV(ikl) *dt__SV,0.)  ! i.e., [kg/m2]
            dsn_SV(ikl) =      0.                       !
            Bufs_N      =      BufsSV(ikl) +d_Bufs      !

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Buffer G1, G2 variables
! #s0       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
! #s0.          nn__SV(ikl).EQ.nwr_SV)
! #s0.      write(6,6601)      BufsSV(ikl) ,d_Bufs,Bufs_N
 6601       format(/,'Buffer *: ',3e15.6)
 
C +--Snow Density
C +  ^^^^^^^^^^^^
            Polair      =      zero
c #NP       Polair      =  max(zero,                    !
c #NP.                         sign(unun,TaPole         !
c #NP.                                  -TaT_SV(ikl)))  !
c #SD       Polair      =  max(zero,                    !
c #SD.                         sign(unun,TaPole         !
c #SD.                                  -TaT_SV(ikl)))  !
            Buf_ro      =  max( rosMin,                 ! Fallen Snow Density
     .      roSn_1+roSn_2*     (TaT_SV(ikl)-TfSnow)     ! [kg/m3]
     .            +roSn_3*sqrt( VV10SV(ikl)))           ! Pahaut    (CEN)
c #NP       BufPro      =  max( rosMin,                 ! Fallen Snow Density
c #NP.         104. *sqrt( max( VV10SV(ikl)-6.0,0.0)))  ! Kotlyakov (1961)

C + ...     Fallen Snow Density, Adapted for Antarctica
c #SD       tt_tmp = TaT_SV(ikl)-TfSnow
c #SD       vv_tmp = VV10SV(ikl)
C + ...     [ A compromise between
C + ...       Kotlyakov (1961) and Lenaerts (2012, JGR, Part1) ]
c #SD       if (tt_tmp.ge.-10) then
c #SD         BufPro   =  max( rosMin,
c #SD.           104. *sqrt( max( vv_tmp-6.0,0.0))) ! Kotlyakov (1961)
c #SD       else
c #SD         vv_virt  = (tt_c*vv_tmp+vv_c*(tt_tmp+10))/(tt_c+tt_tmp+10)
c #SD         BufPro   =  max( rosMin,
c #SD.                    104. *sqrt( max( vv_virt-6.0,0.0)))
c #SD         BufPro   =  min( rosMax, BufPro )
c #SD       endif

            Bros_N      = (1. - Polair) *   Buf_ro      ! Temperate Snow
     .                        + Polair  *   BufPro      ! Polar     Snow
 
!    Instantaneous Density of deposited blown Snow (de Montmollin, 1978)
!    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS       PorSno =      1.0d00     -  blsno
c #BS.                               /  ro_Ice
c #BS       Salt_f =      usthSV(ikl)/  max(epsi,   us__SV(ikl))
c #BS       Salt_f =  min(Salt_f     ,  unun)
c #BS       PorRef =      PorSno     /  max(epsi,1.-PorSno)
c #BS.               +log(Salt_f)
c #BS       Por_BS =      PorRef     /          (1.+PorRef)
c #BS       ro_new =      ro_Ice     *          (1.-Por_BS)
c #BS       ro_new =  max(ro_new     ,  blsno)
c #BS       Bros_N      = Bros_N     * (1.0-dsnbSV(ikl))
c #BS.                  + ro_new     *      dsnbSV(ikl)
 
!    Instantaneous Density IF deposited blown Snow (Melted* from Canopy)
!    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            Bros_N      = Bros_N     * (1.0-FallOK(ikl))!
     .                  + 300.       *      FallOK(ikl) !

!    Time averaged Density of deposited blown Snow
!    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            BrosSV(ikl) =(Bros_N     *      d_Bufs      !
     .                   +BrosSV(ikl)*      BufsSV(ikl))!
     .                   /         max(epsi,Bufs_N)     !

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Buffer G1, G2 variables
! #s0       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
! #s0.          nn__SV(ikl).EQ.nwr_SV)
! #s0.      write(6,6602) Buf_ro,Bros_N,BrosSV(ikl),dsnbSV(ikl)
 6602       format('rho    *: ',3e15.6,'    dsnbSV: ',e15.6)
 
C +-- S.Falling Snow Properties (computed as in SISVAT_zAg)
C +     ^^^^^^^^^^^^^^^^^^^^^^^
            Buf_G1      =  max(-G1_dSV,                 ! Temperate Snow
     .               min(Dendr1*VV__SV(ikl)-Dendr2,     !     Dendricity
     .                   Dendr3                   ))    !
            Buf_G2      =  min( Spher4,                 ! Temperate Snow
     .               max(Spher1*VV__SV(ikl)+Spher2,     !     Sphericity
     .                   Spher3                   ))    !
            Buf_G1      = (1. - Polair) *   Buf_G1      ! Temperate Snow
     .                        + Polair  *   G1_dSV      ! Polar     Snow
            Buf_G2      = (1. - Polair) *   Buf_G2      ! Temperate Snow
     .                        + Polair  *   ADSdSV      ! Polar     Snow
                G1      =                   Buf_G1      ! NO  Blown Snow
                G2      =                   Buf_G2      ! NO  Blown Snow

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Buffer G1, G2 variables
! #s0       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
! #s0.          nn__SV(ikl).EQ.nwr_SV)
! #s0.      write(6,6603)       BG1sSV(ikl),BG2sSV(ikl)  
 6603       format('G1,G2  *: ',3e15.6)
 
!     S.1. Meme  Type  de Neige  / same Grain Type
!          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #BS       SameOK  =  max(zero,
c #BS.                     sign(unun,    Buf_G1             *G1_dSV
c #BS.                                 - eps_21                    ))
c #BS       G1same  = ((1.0-dsnbSV(ikl))*Buf_G1+dsnbSV(ikl) *G1_dSV)
c #BS       G2same  = ((1.0-dsnbSV(ikl))*Buf_G2+dsnbSV(ikl) *ADSdSV)
!           Blowing Snow Properties:                         G1_dSV, ADSdSV
 
!     S.2. Types differents / differents Types
!          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #BS       typ__1  =  max(zero,sign(unun,epsi-Buf_G1))   ! =1.=> Dendritic
c #BS       zroNEW  =     typ__1  *(1.0-dsnbSV(ikl))      ! fract.Dendr.Lay.
c #BS.              + (1.-typ__1) *     dsnbSV(ikl)       !
c #BS       G1_NEW  =     typ__1  *Buf_G1                 ! G1 of Dendr.Lay.
c #BS.              + (1.-typ__1) *G1_dSV                 !
c #BS       G2_NEW  =     typ__1  *Buf_G2                 ! G2 of Dendr.Lay.
c #BS.              + (1.-typ__1) *ADSdSV                 !
c #BS       zroOLD  = (1.-typ__1) *(1.0-dsnbSV(ikl))      ! fract.Spher.Lay.
c #BS.              +     typ__1  *     dsnbSV(ikl)       !
c #BS       G1_OLD  = (1.-typ__1) *Buf_G1                 ! G1 of Spher.Lay.
c #BS.              +     typ__1  *G1_dSV                 !
c #BS       G2_OLD  = (1.-typ__1) *Buf_G2                 ! G2 of Spher.Lay.
c #BS.              +     typ__1  *ADSdSV                 !
c #BS       SizNEW  =    -G1_NEW  *DDcdSV/G1_dSV          ! Size  Dendr.Lay.
c #BS.               +(1.+G1_NEW         /G1_dSV)         !
c #BS.                  *(G2_NEW  *DScdSV/G1_dSV          !
c #BS.               +(1.-G2_NEW         /G1_dSV)*DFcdSV) !
c #BS       SphNEW  =     G2_NEW         /G1_dSV          ! Spher.Dendr.Lay.
c #BS       SizOLD  =     G2_OLD                          ! Size  Spher.Lay.
c #BS       SphOLD  =     G1_OLD         /G1_dSV          ! Spher.Spher.Lay.
c #BS       Siz_av =     (zroNEW*SizNEW+zroOLD*SizOLD)    ! Averaged Size
c #BS       Sph_av = min( zroNEW*SphNEW+zroOLD*SphOLD     !
c #BS.                   ,  unun)                         ! Averaged Sphericity
c #BS       Den_av = min((Siz_av -(    Sph_av *DScdSV     !
c #BS.                            +(1.-Sph_av)*DFcdSV))   !
c #BS.                 / (DDcdSV -(    Sph_av *DScdSV     !
c #BS.                            +(1.-Sph_av)*DFcdSV))   !
c #BS.                   ,  unun)                         !
c #BS       DendOK  = max(zero,                           !
c #BS.                    sign(unun,     Sph_av *DScdSV   ! Small   Grains
c #BS.                              +(1.-Sph_av)*DFcdSV   ! Faceted Grains
c #BS.                              -    Siz_av        )) !
C +...      REMARQUE: le  type moyen (dendritique ou non) depend
C +         ^^^^^^^^  de la  comparaison avec le diametre optique
C +                   d'une neige recente de   dendricite nulle
C +...      REMARK:   the mean type  (dendritic   or not) depends
C +         ^^^^^^    on the comparaison with the optical diameter
C +                   of a recent snow    having zero dendricity
 
c #BS       G1diff  =(   -DendOK *Den_av
c #BS.               +(1.-DendOK)*Sph_av) *G1_dSV
c #BS       G2diff  =     DendOK *Sph_av  *G1_dSV
c #BS.               +(1.-DendOK)*Siz_av
c #BS       G1      =     SameOK *G1same
c #BS.               +(1.-SameOK)*G1diff
c #BS       G2      =     SameOK *G2same
c #BS.               +(1.-SameOK)*G2diff
 
            BG1__N      =((1. - FallOK(ikl))*   G1      !
     .                        + FallOK(ikl) *   99.)    ! Melted *  from Canopy
     .                  *       d_Bufs/max(epsi,d_Bufs) !
            BG2__N      =((1. - FallOK(ikl))*   G2      !
     .                        + FallOK(ikl) *   30.)    ! Melted *  from Canopy
     .                  *       d_Bufs/max(epsi,d_Bufs) !

C +-- S.Buffer  Snow Properties (computed as in SISVAT_zAg)
C +     ^^^^^^^^^^^^^^^^^^^^^^^
            Buf_G1      =       BG1__N                  ! Falling   Snow
            Buf_G2      =       BG2__N                  ! Falling   Snow

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Buffer G1, G2 variables
! #s0       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
! #s0.          nn__SV(ikl).EQ.nwr_SV)
! #s0.      write(6,6604)      Buf_G1      ,Buf_G2         ,FallOK(ikl)
! #s0.                                                     ,TvegSV(ikl)
 6604       format('G1,G2 F*: ',3e15.6,'    T__Veg: ',e15.6)
 
!     S.1. Meme  Type  de Neige  / same Grain Type
!          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            SameOK  =  max(zero,
     .                     sign(unun,    Buf_G1 *BG1sSV(ikl)
     .                                 - eps_21                    ))
            G1same  = (d_Bufs*Buf_G1+BufsSV(ikl)*BG1sSV(ikl))
     .                     /max(epsi,Bufs_N)
            G2same  = (d_Bufs*Buf_G2+BufsSV(ikl)*BG2sSV(ikl))
     .                     /max(epsi,Bufs_N)
 
!     S.2. Types differents / differents Types
!          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            typ__1  =  max(zero,sign(unun,epsi-Buf_G1))   ! =1.=> Dendritic
            zroNEW  =(    typ__1  *d_Bufs                 ! fract.Dendr.Lay.
     .              + (1.-typ__1) *BufsSV(ikl))           !
     .                   /max(epsi,Bufs_N)                !
            G1_NEW  =     typ__1  *Buf_G1                 ! G1 of Dendr.Lay.
     .              + (1.-typ__1) *BG1sSV(ikl)            !
            G2_NEW  =     typ__1  *Buf_G2                 ! G2 of Dendr.Lay.
     .              + (1.-typ__1) *BG2sSV(ikl)            !
            zroOLD  =((1.-typ__1) *d_Bufs                 ! fract.Spher.Lay.
     .              +     typ__1  *BufsSV(ikl))           !
     .                   /max(epsi,Bufs_N)                !
            G1_OLD  = (1.-typ__1) *Buf_G1                 ! G1 of Spher.Lay.
     .              +     typ__1  *BG1sSV(ikl)            !
            G2_OLD  = (1.-typ__1) *Buf_G2                 ! G2 of Spher.Lay.
     .              +     typ__1  *BG2sSV(ikl)            !
            SizNEW  =    -G1_NEW  *DDcdSV/G1_dSV          ! Size  Dendr.Lay.
     .               +(1.+G1_NEW         /G1_dSV)         !
     .                  *(G2_NEW  *DScdSV/G1_dSV          !
     .               +(1.-G2_NEW         /G1_dSV)*DFcdSV) !
            SphNEW  =     G2_NEW         /G1_dSV          ! Spher.Dendr.Lay.
            SizOLD  =     G2_OLD                          ! Size  Spher.Lay.
            SphOLD  =     G1_OLD         /G1_dSV          ! Spher.Spher.Lay.
            Siz_av  =   ( zroNEW  *SizNEW+zroOLD*SizOLD)  ! Averaged Size
            Sph_av = min( zroNEW  *SphNEW+zroOLD*SphOLD   !
     .                  ,   unun                       )  ! Averaged Sphericity
            Den_av = min((Siz_av  - (    Sph_av *DScdSV   !
     .                              +(1.-Sph_av)*DFcdSV)) !
     .                 / (DDcdSV  - (    Sph_av *DScdSV   !
     .                              +(1.-Sph_av)*DFcdSV)) !
     .                  ,   unun                         )!
            DendOK  = max(zero,                           !
     .                    sign(unun,     Sph_av *DScdSV   ! Small   Grains
     .                              +(1.-Sph_av)*DFcdSV   ! Faceted Grains
     .                              -    Siz_av        )) !
C +...      REMARQUE: le  type moyen (dendritique ou non) depend
C +         ^^^^^^^^  de la  comparaison avec le diametre optique
C +                   d'une neige recente de   dendricite nulle
C +...      REMARK:   the mean type  (dendritic   or not) depends
C +         ^^^^^^    on the comparaison with the optical diameter
C +                   of a recent snow    having zero dendricity
 
            G1diff  =(   -DendOK *Den_av
     .               +(1.-DendOK)*Sph_av) *G1_dSV
            G2diff  =     DendOK *Sph_av  *G1_dSV
     .               +(1.-DendOK)*Siz_av
            G1      =     SameOK *G1same
     .               +(1.-SameOK)*G1diff
            G2      =     SameOK *G2same
     .               +(1.-SameOK)*G2diff
 
            BG1sSV(ikl) =                       G1      !
     .                  *       Bufs_N/max(epsi,Bufs_N) !
            BG2sSV(ikl) =                       G2      !
     .                  *       Bufs_N/max(epsi,Bufs_N) !

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Buffer G1, G2 variables
! #s0       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
! #s0.          nn__SV(ikl).EQ.nwr_SV)
! #s0.      write(6,6605) Buf_G1     ,typ__1
! #s0.                   ,DendOK     ,Den_av     ,Sph_av     ,Siz_av
! #s0.                   ,G1same     ,G1diff     ,G1
 6605       format('B1,Typ  : ',2e15.6,11x,'OK,Den,Sph,Siz: ',4e15.6
     .          ,/,'          ',30x   ,11x,'sam,dif,G1    : ',3e15.6)

C +--Update of Buffer Layer Content & Decision about creating a new snow layer
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            BufsSV(ikl) =       Bufs_N                  !     [mm w.e.]
            NLaysv(ikl) = min(unun,                     !
     .                    max(zero,                     ! Allows to create 
     .                        sign(unun,BufsSV(ikl)     ! a new snow Layer
     .                                 -SMndSV     ))   ! if Buffer > SMndSV
     .                   *max(zero,                     ! Except if * Erosion
     .                        sign(unun,0.50            ! dominates
     .                                 -dsnbSV(ikl)))   !
     .                   +max(zero,                     ! Allows to create
     .                        sign(unun,BufsSV(ikl)     ! a new snow Layer
     .                                 -SMndSV*3.00)))  ! is Buffer > SMndSV*3

            Bdzssv(ikl) = 1.e-3*BufsSV(ikl)*ro_Wat      ! [mm w.e.] -> [m w.e.]
     .                            /max(epsi,BrosSV(ikl))!& [m w.e.] -> [m]
 
! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Buffer G1, G2 variables
! #s0       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
! #s0.          nn__SV(ikl).EQ.nwr_SV)
! #s0.      write(6,6606) BG1sSV(ikl),BG2sSV(ikl)
! #s0.                   ,NLaysv(ikl),BdzsSV(ikl)  
 6606       format('G1,G2 N*: ',2e15.6,i15,e27.6)

          END DO


C +--Snow Pack Discretization
C +  ========================

cXF
c #XF if (klonv.eq.1) then
c #XF  if(isnoSV(1).ge.1.or.NLaysv(1).ge.1) then
C +          **********
c #XF   call SISVAT_zSn
C +          **********
c #XF  endif
c #XF else
C +          **********
        call SISVAT_zSn
C +          **********
c #XF endif

C +          **********
! #ve   call SISVAT_wEq('_zSn  ',0)
C +          **********

c #EF   IF          (isnoSV(1) .GT. 0)
c #EF.  write(6,6004)isnoSV(1),    dsn_SV(1) *dt__SV + BufsSV(1),
c #EF.              (dzsnSV(1,isn)*ro__SV(1,isn),isn=1,isnoSV(1))
 6004   format(i3,'  dsn+Buf=',f6.2,6x,'z dz *ro =',10f6.2,
     .                                       (/,35x,10f6.2))


C +--Add a new Snow Layer
C +  ====================

          DO ikl=1,klonv
c #EC       IF (NLaysv(ikl).gt.0)  
c #EC.      write(6,6005) isnoSV(ikl),1.e3*Bdzssv(ikl),Brossv(ikl),
c #EC.                                     BG1ssv(ikl),BG2ssv(ikl)
 6005       format(i3,' dz     = ',f6.3,3x,' ro     = ',f6.1,3x,
     .                ' G1     = ',f6.3,3x,' G2     = ',f6.1)
C +
            isnoSV(ikl)     = isnoSV(ikl)         +NLaysv(ikl)
            isn             = isnoSV(ikl)
            dzsnSV(ikl,isn) = dzsnSV(ikl,isn) * (1-NLaysv(ikl))
     .                      + Bdzssv(ikl)     *    NLaysv(ikl) 
            TsisSV(ikl,isn) = TsisSV(ikl,isn) * (1-NLaysv(ikl))
     .                  + min(TaT_SV(ikl),TfSnow) *NLaysv(ikl) 
            ro__SV(ikl,isn) = ro__SV(ikl,isn) * (1-NLaysv(ikl))
     .                      + Brossv(ikl)     *    NLaysv(ikl) 
            eta_SV(ikl,isn) = eta_SV(ikl,isn) * (1-NLaysv(ikl))   ! + 0. 
            agsnSV(ikl,isn) = agsnSV(ikl,isn) * (1-NLaysv(ikl))   ! + 0. 
            G1snSV(ikl,isn) = G1snSV(ikl,isn) * (1-NLaysv(ikl))
     .                      + BG1ssv(ikl)     *    NLaysv(ikl)
            G2snSV(ikl,isn) = G2snSV(ikl,isn) * (1-NLaysv(ikl))
     .                      + BG2ssv(ikl)     *    NLaysv(ikl)
            istoSV(ikl,isn) = istoSV(ikl,isn) * (1-NLaysv(ikl))
     .   + max(zero,sign(unun,TaT_SV(ikl)
     .                       -TfSnow-eps_21)) *    istdSV(2)
     .                                        *    NLaysv(ikl)
            BufsSV(ikl)     = BufsSV(ikl)     * (1-NLaysv(ikl))
            NLaysv(ikl)     = 0
          END DO


C +--Snow Pack Thickness
C +  -------------------

          DO ikl=1,klonv
            z_snsv(ikl)     = 0.0
          END DO
        DO   isn=1,nsno
          DO ikl=1,klonv
            z_snsv(ikl)     = z_snsv(ikl) + dzsnSV(ikl,isn)
            zzsnsv(ikl,isn) = z_snsv(ikl)
          END DO
        END DO


C +--Diffusion of Surficial Water in the Snow Pack
C +  ---------------------------------------------

c #sw     DO isn=1,nsno
c #sw     DO ikl=1,klonv
c #sw       PorVol      = 1.     - ro__SV(ikl,isn) /  ro_Ice          !
c #sw       PorVol      =      max(PorVol            ,zero  )         !
c #sw       rWater      = ws0dSV * PorVol     *ro_Wat*dzsnSV(ikl,isn)
c #sw.                  * max(zero,
c #sw.                   sign(unun,rusnSV(ikl)/ro_Wat-zzsnsv(ikl,isn)
c #sw.                                               +dzsnSV(ikl,isn)))
c #sw       rusNEW      =      max(rusnSV(ikl)-rWater,zero  )
c #sw       rWater      =          rusnSV(ikl)-rusNEW
c #sw       rdzNEW          =      rWater
c #sw.                           + ro__SV(ikl,isn) * dzsnSV(ikl,isn)
c #sw       etaNEW          =      rWater / max(epsi,rdzNEW)
c #sw       rusnSV(ikl) =          rusNEW
c #sw       ro__SV(ikl,isn) =      rdzNEW / max(epsi,dzsnSV(ikl,isn))
c #sw       eta_SV(ikl,isn) =      eta_SV(ikl,isn)  +etaNEW
c #sw     ENDDO
c #sw     ENDDO

      END IF

c #EF   IF          (isnoSV(1) .GT. 0)
c #EF.  write(6,6006)isnoSV(1),    dsn_SV(1) *dt__SV + BufsSV(1),
c #EF.              (dzsnSV(1,isn)*ro__SV(1,isn),isn=1,isnoSV(1))
 6006   format(i3,'  dsn+Buf=',f6.2,6x,'* dz *ro =',10f6.2,
     .                                       (/,35x,10f6.2))


C +--Blowing Dust
C +  ============

c #BD   IF (BloMod)                                               THEN

C +       ***************
c #BD     call SISVAT_BDu
C +       ***************

c #BD   END IF



C +--Soil      Albedo: Soil Humidity Correction
C +  ==========================================

C +...    REFERENCE: McCumber and Pielke (1981), Pielke (1984)
C +       ^^^^^^^^^
          DO ikl=1,klonv
            albssv(ikl) = 
     .      alb0SV(ikl) *(1.0-min(demi,eta_SV(       ikl,0)
     .                                /etadSV(isotSV(ikl))))
C +...      REMARK: Albedo of Water Surfaces (isotSV=0): 
C +         ^^^^^^  alb0SV := 2  X  effective value, while 
C +                 eta_SV :=          etadSV
          END DO


C +--Snow Pack Optical Properties
C +  ============================

      IF (SnoMod)                                                 THEN

C +          ******
        call SnOptP
C +          ******

      ELSE
        DO ikl=1,klonv
          sEX_sv(ikl,1) = 1.0
          sEX_sv(ikl,0) = 0.0
          albisv(ikl)   = albssv(ikl)
        END DO
      END IF

C +          **********
! #ve   call SISVAT_wEq('SnOptP',0)
C +          **********


C +--Solar Radiation Absorption and Effective Leaf Area Index
C +  ========================================================

C +          ******
        call VgOptP
C +          ******


C +--Surface-Canopy Emissivity
C +  =========================

        DO ikl=1,klonv
            LSnMsk     =    min( iun,isnoSV(ikl))
            tau_sv(ikl)=    exp(    -LAI_sv(ikl))          ! Veg Transmit.Frac.
            Evg_sv(ikl)=  EmiVeg*(1-LSnMsk)+EmiSno*LSnMsk  ! Veg+Sno Emissivity
            Eso_sv(ikl)=  EmiSol*(1-LSnMsk)+EmiSno*LSnMsk  ! Sol+Sno Emissivity
            emi_SV(ikl)=
     .   (((EmiSol*     tau_sv(ikl) 
     .     +EmiVeg*(1.0-tau_sv(ikl))) *LSmask(ikl))
     .    + EmiWat                 *(1-LSmask(ikl)))*(1-LSnMsk)
     .   +  EmiSno                                     *LSnMsk
        END DO


C +--Soil/Vegetation Forcing/ Upward IR (INPUT, from previous time step)
C +  ===================================================================

        DO ikl=1,klonv
! #e1     Enrsvd(ikl) =    - IRs_SV(ikl)
          IRupsv(ikl) =      IRs_SV(ikl) *     tau_sv(ikl) ! Upward   IR
        END DO


C +--Turbulence
C +  ==========

C +--Latent Heat of Vaporization/Sublimation
C +  ---------------------------------------

        DO ikl=1,klonv
          SnoWat      =                     min(isnoSV(ikl),0)
          Lx_H2O(ikl) =
     .    (1.-SnoWat) * Lv_H2O 
     .  +     SnoWat  *(Ls_H2O * (1.-eta_SV(ikl,isnoSV(ikl)))
     .                 +Lv_H2O *     eta_SV(ikl,isnoSV(ikl)) )
        END DO


C +--Roughness Length for Momentum
C +  -----------------------------

C +--Land+Sea-Ice / Ice-free Sea Mask
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=1,klonv
          IcIndx(ikl) = 0
        ENDDO
        DO isn=1,nsno
        DO ikl=1,klonv
          IcIndx(ikl) = max(IcIndx(ikl),
     .                      isn*max(0,
     .                              sign(1,
     .                                   int(ro__SV(ikl,isn)-900.))))
        ENDDO
        ENDDO

        DO ikl=1,klonv
          LISmsk    =     min(iiceSV(ikl),1     )
          LISmsk    =     max(LSmask(ikl),LISmsk)
          IceMsk    =     max(0,sign(1   ,IcIndx(ikl)-1)  )
          SnoMsk    = max(min(isnoSV(ikl)-iiceSV(ikl),1),0)

C +--Sea  Roughness Length
C +  ^^^^^^^^^^^^^^^^^^^^^
          Z0mSea =       0.0002
          Z0hSea =       0.000049

c #zs     Z0mSea =       0.0185*us__SV(ikl)*us__SV(ikl) ! Doyle MWR 130
c #zs.                         *grvinv                  ! p.3088 2e col 

c #ZS     Z0mSea =       0.016 *us__SV(ikl)*us__SV(ikl) ! Wang  MWR 129
c #ZS.                         *grvinv                  ! p.1377 (21)   
c #ZS.           +       0.11  *akmol                   !
c #ZS.                         /  max(epsi ,us__SV(ikl))!

c #zs     Z0mSea =       0.0185*us__SV(ikl)*us__SV(ikl) ! Wang  MWR 129
c #zs.                         *grvinv                  ! p.1377 (21)   
c #zs.           +       0.135 *akmol                   !   (adapted)
c #zs.                         /  max(epsi ,us__SV(ikl))!

c #ZS     Z0hSea =   max(0.000049,                      ! Wang  MWR 129
c #ZS.                   0.20  *akmol                   ! p.1377 (22)   
c #ZS.                         /  max(epsi ,us__SV(ikl)))

c #ZS     Z0mSea =   max(Z0mSea,epsi)                   ! 

C +--Land Roughness Length, Snow Contribution excluded
C +  ^^^^^^^^^^^^^^^^^^^^^^ Ice  Contribution included
C +                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
C +--If vegetation Seasonal Cycle described by  LAI     :
          growth      =min(max(0,7-ivgtSV(ikl)),1)
          Z0mLnd      =     Z0mdSV(ivgtSV(ikl))*LAI_sv(ikl)*growth
     .                                         /LAIdSV
     .                +     Z0mdSV(ivgtSV(ikl))*         (1-growth)

C +--If vegetation Seasonal Cycle described by  GLF only:
c #sa     Z0mLnd      =     
c #sa.             fallen * Z0mLnd     
c #sa.        +(1.-fallen)* Z0mdSV(ivgtSV(ikl))*glf_sv(ikl)*growth
c #sa.                 +    Z0mdSV(ivgtSV(ikl))*         (1-growth)

C +--Land Roughness Length, Influence of the Masking by Snow
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          Z0mLnd      =max( Z0mLnd   ,
     .                      Z0mdSV(0)*(iun-IceMsk)
     .                     +Z0_ICE   *     IceMsk )
          Z0mLnd      =     Z0mLnd             
     .                    -(zzsnsv(ikl,    isnoSV(ikl))
     .                     -zzsnsv(ikl,max(IcIndx(ikl),0)))/7. 
          Z0mLnd      =max( Z0mLnd    ,    5.e-5  )  ! Min set := Z0 on *
C +...    Roughness  disappears under Snow 
C +       Assumption Height/Roughness Length =  7 is used

C +--Z0 Smooth Regime over Snow (Andreas 1995, CRREL Report 95-16, p. 8)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          Z0m_nu =       5.e-5 ! z0s~(10-d)*exp(-vonkar/sqrt(1.1e-03))  

C +--Z0 Saltat.Regime over Snow (Gallee  et al., 2001, BLM 99 (19) p.11)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          u2star =       us__SV(ikl) *us__SV(ikl)
          Z0mBSn =       u2star      *0.536e-3   -  61.8e-6
          Z0mBSn =   max(Z0mBS0      ,Z0mBSn)

C +--Z0 Smooth + Saltat. Regime
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          Z0enSV(ikl) =  Z0m_nu
     .                +  Z0mBSn

C +--Rough   Snow Surface Roughness Length (Typical Value)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #tz     Z0m_Sn =    0.250e-3 ! Andreas 1995, CRREL Report 95-16, fig.1&p.2
                               ! z0r~(10-d)*exp(-vonkar/sqrt(1.5e-03))-5.e-5
          Z0m_Sn =    2.000e-3 ! Calibration    of MAR  
c #TZ     Z0m_Sn =    1.000e-3 ! Exemple Tuning in RACMO
c #TZ     Z0m_Sn =    0.500e-3 ! Exemple Tuning in MAR  

C +--Rough   Snow Surface Roughness Length (Variable Sastrugi Height)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          A_Fact      =  1.0000        ! Andreas et al., 2004, p.4
                                       ! ams.confex.com/ams/pdfpapers/68601.pdf

!                                                               ! 0050=.003/.6
c #SZ     Z0Sa_N =                   (us__SV(ikl) -0.2)*0.0001  ! 0040=TUNING
cXF en travaux pour BS
c #SZ.           * max(zero,sign(unun,TfSnow-eps9 
c #SZ.                               -TsisSV(ikl , isnoSV(ikl))))
!!#SZ     Z0SaSi = max(zero,sign(unun,Z0Sa_N                  ))! 1 if erosion
c #SZ     Z0SaSi = max(zero,sign(unun,zero  -eps9 -uss_SV(ikl)))!
c #SZ     Z0Sa_N = max(zero,          Z0Sa_N)
c #SZ     Z0SaSV(ikl) =
c #SZ.             max(Z0SaSV(ikl)   ,Z0SaSV(ikl) 
c #SZ.               + Z0SaSi*(Z0Sa_N-Z0SaSV(ikl))*exp(-dt__SV/43200.))
c #SZ.               -            min(dz0_SV(ikl) ,     Z0SaSV(ikl))

c #SZ     A_Fact      =               Z0SaSV(ikl) *  5.0/0.15   ! A=5 if h~10cm
C +...    CAUTION: The influence of the sastrugi direction is not yet included

c #SZ     Z0m_Sn =                    Z0SaSV(ikl)               !
c #SZ.                              - Z0m_nu                    !

C +--Z0 Saltat.Regime over Snow (Shao & Lin, 1999, BLM 91 (46)  p.222)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
c #ZN     sqrrZ0 =       usthSV(ikl)/max( us__SV(ikl),0.001)
c #ZN     sqrrZ0 =                   min( sqrrZ0     ,0.999)
c #ZN     Z0mBSn =       0.55 *0.55 *exp(-sqrrZ0     *sqrrZ0)
c #ZN.                  *us__SV(ikl)*     us__SV(ikl)*grvinv*0.5

C +--Z0 Smooth + Saltat. Regime (Shao & Lin, 1999, BLM 91 (46)  p.222)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
c #ZN     Z0enSV(ikl) = (Z0m_nu     **    sqrrZ0 )
c #ZN.                * (Z0mBSn     **(1.-sqrrZ0))
c #ZN     Z0enSV(ikl) =  max(Z0enSV(ikl), Z0m_nu)

C +--Z0 Smooth Regime over Snow (Andreas etAl., 2004
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^  ams.confex.com/ams/pdfpapers/68601.pdf)
c #ZA     Z0m_nu = 0.135*akmol  / max(us__SV(ikl) , epsi)

C +--Z0 Saltat.Regime over Snow (Andreas etAl., 2004
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^  ams.confex.com/ams/pdfpapers/68601.pdf)
c #ZA     Z0mBSn = 0.035*u2star      *grvinv

C +--Z0 Smooth + Saltat. Regime (Andreas etAl., 2004
!    (      used by Erosion)     ams.confex.com/ams/pdfpapers/68601.pdf)
!    ^^^^^^^^^^^^^^^^^^^^^^^^^^
c #ZA     Z0enSV(ikl) =  Z0m_nu
c #ZA.                +  Z0mBSn

C +--Z0 Rough  Regime over Snow (Andreas etAl., 2004
C +  (.NOT. used by Erosion)     ams.confex.com/ams/pdfpapers/68601.pdf)
!    ^^^^^^^^^^^^^^^^^^^^^^^^^^
!!#ZA     u2star =      (us__SV(ikl) -0.1800)     / 0.1
!!#ZA     Z0m_Sn =A_Fact*Z0mBSn *exp(-u2star*u2star)
c #ZA     Z0m_90 =(10.-0.025*VVs_SV(ikl)/5.)
c #ZA.            *exp(-0.4/sqrt(.00275+.00001*max(0.,VVs_SV(ikl)-5.)))
c #ZA     Z0m_Sn =           DDs_SV(ikl)* Z0m_90 / 45.
c #ZA.         - DDs_SV(ikl)*DDs_SV(ikl)* Z0m_90 /(90.*90.)

C +--Z0  (Erosion)    over Snow (instantaneous or time average)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          Z0e_SV(ikl) =  Z0enSV(ikl)
c #ZM     Z0e_SV(ikl) =  Z0emSV(ikl)

C +--Momentum  Roughness Length
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^                              ! Contribution of
          Z0mnSV(ikl) =  Z0mLnd                              ! Vegetation Form
     .                + (Z0m_Sn                              ! Sastrugi   Form
     .                +  Z0enSV(ikl))   *SnoMsk              ! Snow    Erosion

C +--Mom. Roughness Length, Discrimination among Ice/Land  and Ice-Free Ocean
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          Z0mnSV(ikl) =  Z0mnSV(ikl)    *LISmsk              ! Ice and  Land
     .                  +Z0mSea      *(1-LISmsk)             ! Ice-Free Ocean
c #OR.                  +Z0roSV(ikl)                         ! Subgrid  Topogr.

C +--GIS  Roughness Length
C +  ^^^^^^^^^^^^^^^^^^^^^
c #GL     Z0mnSV(ikl) = 
c #GL.      (1-LSmask(ikl)) *     Z0mnSV(ikl)
c #GL.    +    LSmask(ikl)  * max(Z0mnSV(ikl),max(Z0_GIM,
c #GL.                                            Z0_GIM+
c #GL.      (0.0032-Z0_GIM)*(ro__SV(ikl,isnoSV(ikl))-600.)   !
c #GL.                     /(920.00                 -600.))) !

C +--Mom. Roughness Length, Instantaneous OR Box Moving Average in Time
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          Z0m_SV(ikl) =  Z0mnSV(ikl)                         ! Z0mnSV  instant.
c #ZM     Z0m_SV(ikl) =  Z0mmSV(ikl)                         ! Z0mnSV  Average

C +--Corrected Threshold Friction Velocity before Erosion    ! Marticorena and
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ! Bergametti 1995
c #BS     Z0e_SV(ikl) =   min(Z0m_SV(ikl),Z0e_SV(ikl))       !
c #MB     f_eff=    log(0.35*(0.1        /Z0e_SV(ikl))**0.8) ! JGR 100
c #MB     f_eff=1.-(log(      Z0m_SV(ikl)/Z0e_SV(ikl)      ))! (20) p. 16420
c #MB.            /(max(      f_eff      ,epsi             ))! p.16426 2nd ?
c #MB     f_eff=    max(      f_eff      ,epsi              )! CONTROL
c #MB     f_eff=1.0   -(1.0 - f_eff)     /3.00               ! TUNING
cXF attention en travaux
c #MB     f_eff=    min(      f_eff      ,1.00              )!
c #MB     usthSV(ikl) =       usthSV(ikl)/f_eff              !


C +--Roughness Length for Scalars
C +  ----------------------------

          Z0hnSV(ikl) =     Z0mnSV(ikl)/  7.4
c #SH     Z0hnSV(ikl) =     Z0mnSV(ikl)/100.0
C +                         Z0h = Z0m  /100.0   over the Sahel
C +                                            (Taylor & Clark, QJRMS 127,p864)

c #RN     rstar       =     Z0mnSV(ikl) * us__SV(ikl) / akmol
c #RN     rstar       = max(epsi,min(rstar,thous))
c #RN     alors       =          log(rstar)   
c #RN     rstar0      = 1.250e0 * max(zero,sign(unun,0.135e0 - rstar))
c #RN.                +(1.      - max(zero,sign(unun,0.135e0 - rstar)))
c #RN.                *(0.149e0 * max(zero,sign(unun,2.500e0 - rstar)) 
c #RN.                + 0.317e0 
c #RN.                *(1.      - max(zero,sign(unun,2.500e0 - rstar))))      
c #RN     rstar1      = 0.      * max(zero,sign(unun,0.135e0 - rstar))
c #RN.                +(1.      - max(zero,sign(unun,0.135e0 - rstar)))
c #RN.                *(-0.55e0 * max(zero,sign(unun,2.500e0 - rstar)) 
c #RN.                - 0.565
c #RN.                *(1.      - max(zero,sign(unun,2.500e0 - rstar))))
c #RN     rstar2      = 0.      * max(zero,sign(unun,0.135e0 - rstar))
c #RN.                +(1.      - max(zero,sign(unun,0.135e0 - rstar)))
c #RN.                *(0.      * max(zero,sign(unun,2.500e0 - rstar)) 
c #RN.                - 0.183
c #RN.                *(unun    - max(zero,sign(unun,2.500e0 - rstar))))
c #RN     Z0hnSV(ikl) = max(zero
c #RN.                , sign(unun,zzsnsv(ikl,isnoSV(ikl))-epsi)) 
c #RN.                * exp(rstar0+rstar1*alors+rstar2*alors*alors)
c #RN.                * 0.001e0 + Z0hnSV(ikl) * ( 1. - max(zero   
c #RN.                , sign(unun,zzsnsv(ikl,isnoSV(ikl))-epsi)))

          Z0hnSV(ikl) =     Z0hSea             *(1-LISmsk) ! Ice-free Ocean
     .                +     Z0hnSV(ikl)        *   LISmsk  ! Ice and  Land

          Z0h_SV(ikl) =     Z0hnSV(ikl)
c #ZM     Z0h_SV(ikl) =     Z0hmSV(ikl)


C +--Contributions of the Roughness Lenghths to the neutral Drag Coefficient
C +  -----------------------------------------------------------------------

c #MT     Z0m_SV(ikl) = max(2.0e-6     ,Z0m_SV(ikl)) ! Min Z0_m (Garrat Scheme)
          Z0m_SV(ikl) = min(Z0m_SV(ikl),za__SV(ikl)*0.3333)
          sqrCm0(ikl) = log(za__SV(ikl)/Z0m_SV(ikl))
          sqrCh0(ikl) = log(za__SV(ikl)/Z0h_SV(ikl))

! #wz     IF (ikl.EQ.1) write(6,6661) dsn_SV(ikl),us__SV(ikl),Z0SaSi
! #wz.                        ,Z0Sa_N,Z0SaSV(ikl),Z0m_Sn,Z0m_SV(ikl)
 6661     format(7f9.6)

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           of Roughness Length and Drag Coefficients
! #sz     IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
! #sz.        nn__SV(ikl).EQ.nwr_SV)
! #sz.    write(6,6600)  za__SV(ikl) , Z0m_SV(ikl)
! #sz.                  ,sqrCm0(ikl) , za__SV(ikl)/Z0m_SV(ikl)
! #sz.                  ,Z0SaSV(ikl) , Z0h_SV(ikl)
! #sz.                  ,sqrCh0(ikl) , za__SV(ikl)/Z0h_SV(ikl)
 6600     format(/,' ** SISVAT     *0  '
     .            ,'  za__SV  = ',e12.4,'  Z0m_SV  = ',e12.4
     .            ,'  sqrCm0  = ',e12.4,'  Za/Z0m  = ',e12.4
     .          ,/,'                   '
     .            ,'  Z0SaSV  = ',e12.4,'  Z0h_SV  = ',e12.4
     .            ,'  sqrCh0  = ',e12.4,'  Za/Z0h  = ',e12.4)


C +--Vertical Stability Correction
C +  -----------------------------

C +--Surface/Canopy Temperature
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          Tsrfsv(ikl) = Sigmsv(ikl) * TvegSV(ikl)
     .          + (1. - Sigmsv(ikl))* TsisSV(ikl,isnoSV(ikl))
        END DO

C +--Aerodynamic Resistance
C +  ^^^^^^^^^^^^^^^^^^^^^^
c #CP   IF            (SnoMod.AND.ColPrt)                           THEN

C +              **********
c #CP       call ColPrt_SBL
C +              **********

c #CP   ELSE
c #MT    IF           (Garrat)                                      THEN

C +              **********
c #MT       call SISVAT_SBL
C +              **********

c #MT    ELSE

C +              **********
            call SISVATeSBL
C +              **********

c #MT    END IF
c #CP   END IF


C +--Friction Velocity
C +  -----------------

c #US   DO ikl=1,klonv
c #WR     u_star      = sqrt(VV__SV(ikl)/ram_sv(ikl))
c #WR     write(6,*)  u_star,us__SV(ikl)
c #US     us__SV(ikl) = sqrt(VV__SV(ikl)/ram_sv(ikl))
c #US   END DO


! Canopy Energy Balance
! =====================

C +          **********
        call SISVAT_TVg
! #e1.                 (ETVg_d)
C +          **********


C +--Surface/Canopy Temperature
C +  ==========================

        DO ikl=1,klonv
          Tsrfsv(ikl) = Sigmsv(ikl) * TvegSV(ikl)
     .          + (1. - Sigmsv(ikl))* TsisSV(ikl,isnoSV(ikl))
        END DO


! Soil   Energy Balance
! =====================

C +          **********
        call SISVAT_TSo
! #e1.                 (ETSo_0,ETSo_1,ETSo_d)
C +          **********

C +          **********
! #ve   call SISVAT_wEq('_TSo  ',0)
C +          **********


C +--Canopy Water  Balance
C +  =====================

C +--Soil Water     Potential
C +  ------------------------

      DO   isl=-nsol,0
        DO ikl=1,klonv
          ist             =     isotSV(ikl)        ! Soil Type
          psi_sv(ikl,isl) =     psidSV(ist)        ! DR97, Eqn.(3.34)
     .  *(etadSV(ist) /max(epsi,eta_SV(ikl,isl)))  !
     .  **bCHdSV(ist)                              !


C +--Soil Hydraulic Conductivity
C +  ---------------------------

          Khydsv(ikl,isl) =    s2__SV(ist)         ! DR97, Eqn.(3.35)
     .  *(eta_SV(ikl,isl)**(2.*bCHdSV(ist)+3.))    !  
        END DO
      END DO

C +          **********
        call SISVAT_qVg
C +          **********


! Vegetation Forcing
! ------------------

! #m0   DO ikl=1,klonv
! #m0     Watsvd(ikl) =     (Watsvd(ikl)           ! Canopy Precip. IN
! #m0.                      -drr_SV(ikl)           ! Canopy Precip. OUT
! #m0.                      -Evp_sv(ikl))* dt__SV  ! Canopy Water Evap.
! #m0   END DO


C +--Melting / Refreezing in the Snow Pack
C +  =====================================

      IF (SnoMod)                                                 THEN

C +          **********
        call SISVAT_qSn
     .                 (
! #e1.                  EqSn_0,EqSn_1,EqSn_d
! #m1.                 ,SIsubl,SImelt,SIrnof
     .                 )
C +          **********

C +          **********
! #ve   call SISVAT_wEq('_qSn  ',0)
C +          **********

c #EF   IF          (isnoSV(1) .GT. 0)
c #EF.  write(6,6007)isnoSV(1),    dsn_SV(1) *dt__SV + BufsSV(1),
c #EF.              (dzsnSV(1,isn)*ro__SV(1,isn),isn=1,isnoSV(1))
 6007   format(i3,'  dsn+Buf=',f6.2,6x,'q dz *ro =',10f6.2,
     .                                       (/,35x,10f6.2))


C +--Snow Pack Thickness
C +  -------------------

          DO ikl=1,klonv
            z_snsv(ikl)     = 0.0
          END DO
        DO   isn=1,nsno
          DO ikl=1,klonv
            z_snsv(ikl)     = z_snsv(ikl) + dzsnSV(ikl,isn)
            zzsnsv(ikl,isn) = z_snsv(ikl)
          END DO
        END DO


C +--Energy in Excess is added to the first Soil Layer
C +  -------------------------------------------------

        DO ikl=1,klonv
            z_snsv(ikl)   = max(zero,
     .                          sign(unun,epsi-z_snsv(ikl)))
            TsisSV(ikl,0) = TsisSV(ikl,0)    + EExcsv(ikl) 
     .                                       /(rocsSV(isotSV(ikl))
     .                                        +rcwdSV*eta_SV(ikl,0))
            EExcsv(ikl)   = 0.
        END DO


! Snow Final   Mass (below the Canopy) and Forcing
! ------------------------------------------------

! #m1   DO ikl=1,klonv
! #m1     SIWa_f(ikl) =(drr_SV(ikl) + dsn_SV(ikl))   *dt__SV         ![mm w.e.]
! #m1     SIWe_f(ikl) = dbs_SV(ikl)                                  !
! #m1     SIWm_1(ikl) = BufsSV(ikl) + HFraSV(ikl)    *ro_Ice         !
! #m1   DO isn=1,nsno                                                !
! #m1     SIWm_1(ikl) = SIWm_1(ikl) + dzsnSV(ikl,isn)*ro__SV(ikl,isn)!
! #m1   END DO                                                       !
! #m1   END DO                                                       !

      END IF


! Soil   Water  Balance
! =====================

C +          **********
        call SISVAT_qSo
! #m0.                 (Wats_0,Wats_1,Wats_d
C +          **********


C +--Surface/Canopy Fluxes
C +  =====================

        DO ikl=1,klonv
          IRdwsv(ikl)=tau_sv(ikl) *IRd_SV(ikl)*Eso_sv(ikl) ! Downward IR
     .          +(1.0-tau_sv(ikl))*IRd_SV(ikl)*Evg_sv(ikl) ! 
          IRupsv(ikl) =      IRupsv(ikl)                   ! Upward   IR
     .                + 0.5 *IRv_sv(ikl) * (1.-tau_sv(ikl))!
          IRu_SV(ikl) =     -IRupsv(ikl)                   ! Upward   IR
     .                      +IRd_SV(ikl)                   ! (effective)
     .                      -IRdwsv(ikl)                   ! (positive)
          TBr_sv(ikl) =sqrt(sqrt(IRu_SV(ikl)/stefan))      ! Brightness
!                                                          ! Temperature
          uts_SV(ikl) =     (HSv_sv(ikl) +HSs_sv(ikl))     ! u*T*
     .                     /(rhT_SV(ikl) *Cp)              !
          uqs_SV(ikl) =     (HLv_sv(ikl) +HLs_sv(ikl))     ! u*q*
     .                     /(rhT_SV(ikl) *Lv_H2O)          !

C +--Surface/Canopy Temperature
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          Tsrfsv(ikl) = Sigmsv(ikl) * TvegSV(ikl)
     .          + (1. - Sigmsv(ikl))* TsisSV(ikl,isnoSV(ikl))
        END DO


C +--Snow Pack Properties (sphericity, dendricity, size)
C +  ===================================================

      IF (SnoMod)                                                 THEN
cXF
c #XF if (klonv.eq.1) then
c #XF  if(isnoSV(1).ge.1) then
C +          **********
c #XF   call SISVAT_GSn
C +          **********
c #XF  endif
c #XF else
C +          **********
        call SISVAT_GSn
C +          **********
c #XF endif

C +          **********
! #ve   call SISVAT_wEq('_GSn  ',0)
C +          **********


C +--Surficial Water Freezing, including that of a Water Surface (isotSV=0)
C +  ======================================================================


      END IF


C +--OUTPUT
C +  ======

c #E0   DO ikl=1,klonv
c #E0   IF (lwriSV(ikl).ne.0)                                     THEN
c #E0           noUNIT =  no__SV(lwriSV(ikl))
c #E0     write(noUNIT,5001)
c #E0.       (SoSosv(ikl)+SoCasv(ikl))*sol_SV(ikl),
c #E0.        IRdwsv(ikl),IRu_SV(ikl),
c #E0.        HSv_sv(ikl)+HSs_sv(ikl),
c #E0.        HLv_sv(ikl)+HLs_sv(ikl), TaT_SV(ikl),
c #E0.        dsn_SV(ikl)*3.6e3,       drr_SV(ikl)*3.6e3,
c #E0.        SoSosv(ikl)             *sol_SV(ikl),
c #E0.                    IRv_sv(ikl) *0.5,
c #E0.        HSv_sv(ikl),HLv_sv(ikl), TvegSV(ikl),
c #E0.                    SoCasv(ikl) *sol_SV(ikl),
c #E0.        HSs_sv(ikl),HLs_sv(ikl), TsisSV(ikl,isnoSV(ikl)) 
 5001     format(
     .         '        |Net Solar| IR Down | IR Up   | HS/Dwn=+|',
     .          ' HL/Dwn=+| Temper. |         |  Snow  |  Rain  |',
     .       /,'        | [W/m2]  | [W/m2]  | [W/m2]  | [W/m2]  |',
     .          ' [W/m2]  | [K]     |         | [mm/h] | [mm/h] |',
     .       /,' -------+',7('---------+'),2('--------+'),
     .       /,' SISVAT |',f8.1,' |',f8.1,' |',f8.1,' |',f8.1,' |',
     .                     f8.1,' |A',f7.2,' |', 8x ,' |',2(f7.2,' |'),
     .       /,' Canopy |',f8.1,' |', 8x ,' |',f8.1,' |',f8.1,' |',
     .                     f8.1,' |',f8.2,' |', 8x ,' |',2( 7x ,' |')
     .       /,' Soil   |',f8.1,' |', 8x ,' |', 8x ,' |',f8.1,' |',
     .                     f8.1,' |',f8.2,' |', 8x ,' |',2( 7x ,' |'))


C +--Energy Budget
C +  -------------

! #e1     Enrsvd(ikl) = Enrsvd(ikl)                            ! Up Surf. IR
! #e1.                + IRs_SV(ikl)                            ! Offset
! #e1.        + (      (SoSosv(ikl)                            ! Net   Solar
! #e1.                 +SoCasv(ikl)) *sol_SV(ikl)              !            
! #e1.          +                     IRdwsv(ikl)              ! Downward IR
! #e1.          +                     IRupsv(ikl)              ! Upward   IR
! #e1.          +                     HSv_sv(ikl)+HSs_sv(ikl)  ! Sensible
! #e1.          +                     HLv_sv(ikl)+HLs_sv(ikl)) ! Latent

! #e1     write(noUNIT,5002)           Enrsvd(ikl),
! #e1.                   ETSo_0(ikl),  ETSo_d(ikl),
! #e1.                   ETSo_0(ikl)+  ETSo_d(ikl), ETSo_1(ikl),
! #e1.                   EqSn_0(ikl)                            /dt__SV,
! #e1.                   EqSn_d(ikl)                            /dt__SV,
! #e1.                  (EqSn_1(ikl)-  EqSn_0(ikl)- EqSn_d(ikl))/dt__SV,
! #e1.                   EqSn_1(ikl)                            /dt__SV
 5002     format(
     .           ' -----------------+-------------------+', !
     .            '-----------------+-+-----------------+', !
     .          '-------------------+',                     !
     .         /,' SOIL/SNOW/VEGET. |                   |', !
     .            ' Power,  Forcing |                   |', ! Enrsvd
     .          '                   |',                     ! 
c #WR.         /,' -----------------+-------------------+', !
c #WR.            '-----------------+-------------------+', !
c #WR.          '-------------------+',                     !
     .         /,'                  |',   11x ,'        |', !
     .                f9.2,' [W/m2] |',   11x ,'        |', ! Enrsvd
     .                11x ,'        |',                     !
     .         /,' -----------------+-------------------+', !
     .            '-----------------+-------------------+', !
     .          '-------------------+',                     ! 
     .         /,' SOIL/SNOW  (TSo) | Energy/dt, Time 0 |', !        ETSo_0
     .            ' Power,  Forcing |   Sum Tim.0+Forc. |', ! ETSo_d/ETSo_0+d
     .          ' Energy/dt, Time 1 |',                     ! ETSo_1
c #WR.         /,' -----------------+-------------------+', !
c #WR.            '-----------------+-------------------+', !
c #WR.          '-------------------+',                     !
     .         /,'                  |',  f11.2,' [W/m2] |', !        ETSo_0
     .                f9.2,' [W/m2] |',  f11.2,' [W/m2] |', ! ETSo_d/ETSo_0+d
     .               f11.2,' [W/m2] |',                     ! ETSo_1
     .         /,' -----------------+-------------------+', !
     .            '-----------------+-------------------+', !
     .          '-------------------+',                     !
     .         /,'      SNOW  (qSn) | Energy/dt, Time 0 |', ! EqSn_0/dt
     .            ' Power,  Excess  |   D(Tim.1-0-Forc.)|', ! EqSn_d/dt, 1-0-d
     .          ' Energy/dt, Time 1 |',                     ! EqSn_1/dt
c #WR.         /,' -----------------+-------------------+', !
c #WR.            '-----------------+-------------------+', !
c #WR.          '-------------------+',                     !
     .         /,'                  |',  f12.2, '[W/m2] |', ! EqSn_0/dt
     .                f9.2,' [W/m2] |',  f11.2,' [W/m2] |', ! EqSn_d/dt, 1-0-d
     .               f12.2, '[W/m2] | ',                    ! EqSn_1/dt
     .         /,' -----------------+-------------------+', !
     .            '-----------------+-------------------+', !
     .          '-------------------+')                     !

! #e1             EnsBal = ETSo_1(ikl)-(ETSo_0(ikl)+Enrsvd(ikl))
! #e1             EnvBal = Enrsvd(ikl)- ETVg_d(ikl)
! #e1     IF (abs(EnsBal).gt.5.e-1)
! #e2.    .OR.lwriSV(ikl).eq.    2)
! #e1.                                                              THEN
! #e1       write(6,6001) daHost,i___SV(lwriSV(ikl)),
! #e1.                           j___SV(lwriSV(ikl)),
! #e1.                           n___SV(lwriSV(ikl)),
! #e1.                           ETSo_1(ikl),ETSo_0(ikl),ETSo_d(ikl),
! #e1.                           ETSo_1(ikl)-ETSo_0(ikl)-ETSo_d(ikl),
! #e1.                           Enrsvd(ikl),ETVg_d(ikl),ETSo_d(ikl),
! #e1.                           Enrsvd(ikl)-ETVg_d(ikl)-ETSo_d(ikl)
 6001       format(a18,3i4,' (EB1'           ,f15.6,
     .                ')  - [(EB0           ',f15.6,')',
     .               /,55x,'+(ATM->Snow/Soil',f15.6,')] ',
     .                     '= EBAL'          ,f15.6,' [W/m2]',
     .               /,55x,' (ATM->SISVAT'   ,f18.6,
     .               /,55x,'- Veg. ImBal.',   f18.6,')  ',
     .               /,55x,'- ATM->SnoSol',   f18.6,')  ',
     .                     '= ????'          ,f15.6,' [W/m2]')
! #e1           noEBal = noEBal + 1
! #e2           noEBal = noEBal - 1
! #e1       IF (noEBal.GE.       10) stop 'TOO MUCH ENERGY IMBALANCES'
! #e1     END IF


C +--Snow   Budget [mm w.e.]
C +  -----------------------

! #m1     write(noUNIT,5010) 
! #m1.             SIWm_0(ikl),  SIWa_i(ikl)-SIWa_f(ikl)
! #m1.            ,SIWm_0(ikl)+  SIWa_i(ikl)-SIWa_f(ikl)
! #m1.                          +SIWe_i(ikl)-SIWe_f(ikl)
! #m1.                          +SIsubl(ikl)
! #m1.                          -SImelt(ikl)
! #m1.                          -SIrnof(ikl)
! #m2.                          +SIvAcr(ikl)    
! #m1.            ,SIWm_1(ikl),  SIWe_i(ikl)-SIWe_f(ikl)
! #m1.            ,              SIsubl(ikl)
! #m1.            ,             -SImelt(ikl)
! #m1.            ,             -SIrnof(ikl)
! #m2.            ,              SIvAcr(ikl)
 5010     format(' SNOW             |   Snow,   Time 0  |',
     .            ' Snow,   Forcing |           Sum     |',
     .          '   Snow,   Time 1  |',
c #WR.         /,' -----------------+-------------------+',
c #WR.            '-----------------+-------------------+',
c #WR.          '-------------------+',
     .         /,'                  |',    f13.3,' [mm] |',
     .           ' A',  f9.3,' [mm] |',    f13.3,' [mm] |',
     .                 f13.3,' [mm] |',
     .         /,'                  |',     13x ,'      |',
     .           ' E',  f9.3,' [mm] |',     13x ,'      |',
     .                  13x ,'      |',
     .         /,'                  |',     13x ,'      |',
     .           ' S',  f9.3,' [mm] |',     13x ,'      |',
     .                  13x ,'      |',
     .         /,'                  |',     13x ,'      |',
     .           '(M',  f9.3,' [mm])|  (included in A)  |',
     .                  13x ,'      |',
     .         /,'                  |',     13x ,'      |',
     .           ' R',  f9.3,' [mm] |',     13x ,'      |',
     .                  13x ,'      |',
! #m2.         /,'                  |',     13x ,'      |',
! #m2.           ' O',  f9.3,' [mm] |',     13x ,'      |',
! #m2.                  13x ,'      |',
     .         /,' -----------------+-------------------+',
     .            '-----------------+-------------------+',
     .          '-------------------+')
! #m1             SnoBal = SIWm_1(ikl)-(SIWm_0(ikl)
! #m1.                                 +SIWa_i(ikl)-SIWa_f(ikl)
! #m1.                                 +SIWe_i(ikl)-SIWe_f(ikl))
! #m1.                                 -SIsubl(ikl)
! #m1.                                 +SIrnof(ikl)
! #m2.                                 -SIvAcr(ikl) 
! #m1     IF (abs(SnoBal).gt.epsi)                                  THEN
! #m1       write(6,6010) daHost,i___SV(lwriSV(ikl)),
! #m1.                           j___SV(lwriSV(ikl)),
! #m1.                           n___SV(lwriSV(ikl)),
! #m1.                           SIWm_1(ikl),SIWm_0(ikl),
! #m1.                           SIWa_i(ikl),SIWa_f(ikl),
! #m1.                           SIWe_i(ikl),SIWe_f(ikl),
! #m1.                           SIsubl(ikl),SImelt(ikl),
! #m2.                           SIrnof(ikl),SIvAcr(ikl),
! #m1.                           SnoBal
 6010       format(a18,3i4,' (MB1'        ,f12.6,
     .                 ') - [(MB0        ',f12.6,        15x,')',
     .               /,51x,'+(ATM Forcing',f12.6,' - ',f12.6,')',
     .               /,51x,'+(BLS Forcing',f12.6,' - ',f12.6,')',
     .               /,51x,'-(Depo/Sublim',f12.6,        15x,')',
     .               /,51x,' !Melting    ',f12.6,'  included in A!',
     .               /,51x,'+(Run  OFF   ',f12.6,        15x,')',
! #m2.               /,51x,'-(Sea-Ice Acr',f12.6,        15x,')',
     .               /,29x,'= *BAL'       ,f12.6,      ' [mm w.e.]')
! #m1           noSBal = noSBal + 1
! #m1       IF (noSBal.GE.       10) stop 'TOO MUCH SNOW MASS IMBALANCE'
! #m1     END IF


C +--Water  Budget
C +  -------------

! #m0     Watsv0(ikl) =  Watsv0(ikl)                    ! Canopy Water Cont.
! #m0.                 + Wats_0(ikl)                    ! Soil   Water Cont.
! #m0     Watsvd(ikl) =  Watsvd(ikl)                    ! Canopy Forcing
! #m0.                 + Wats_d(ikl)                    ! Soil   Forcing

! #m0     write(noUNIT,5003) 
! #m0.                   Wats_0(ikl),  Wats_d(ikl),
! #m0.                   Wats_0(ikl)+  Wats_d(ikl),    Wats_1(ikl),
! #m0.                   Watsv0(ikl),  Watsvd(ikl), 
! #m0.                   Watsv0(ikl)+  Watsvd(ikl),    Wats_1(ikl)
! #m0.                                                +rrCaSV(ikl)
 5003     format(' SOIL/SNOW  (qSo) |   Water,  Time 0  |',
     .            ' Water,  Forcing |           Sum     |',
     .          '   Water,  Time 1  |',
c #WR.         /,' -----------------+-------------------+',
c #WR.            '-----------------+-------------------+',
c #WR.          '-------------------+',
     .         /,'                  |',    f13.3,' [mm] |',
     .                 f11.3,' [mm] |',    f13.3,' [mm] |',
     .                 f13.3,' [mm] |',
     .         /,' -----------------+-------------------+',
     .            '-----------------+-------------------+',
     .          '-------------------+',
     .         /,' SOIL/SNOW/VEGET. |   Water,  Time 0  |',
     .            ' Water,  Forcing |           Sum     |',
     .          '   Water,  Time 1  |',
c #WR.         /,' -----------------+-------------------+',
c #WR.            '-----------------+-------------------+
c #WR.          '-------------------+',
     .         /,'                  |',    f13.3,' [mm] |',
     .                 f11.3,' [mm] |',    f13.3,' [mm] |',
     .                 f13.3,' [mm] |',
     .         /,' -----------------+-------------------+',
     .            '-----------------+-------------------+',
     .          '-------------------+')

! #m0             WatBal = Wats_1(ikl)+rrCaSV(ikl)
! #m0.                   -(Watsv0(ikl)+Watsvd(ikl))
! #m0     IF (abs(WatBal).gt.epsi)                                  THEN
! #m0       write(6,6002) daHost,i___SV(lwriSV(ikl)),
! #m0.                           j___SV(lwriSV(ikl)),
! #m0.                           n___SV(lwriSV(ikl)),
! #m0.                           Wats_1(ikl),rrCaSV(ikl),
! #m0.                           Watsv0(ikl),Watsvd(ikl),WatBal,
! #m0.                           Wats_1(ikl),
! #m0.                           Wats_0(ikl),Wats_d(ikl),
! #m0.               Wats_1(ikl)-Wats_0(ikl)-Wats_d(ikl)
 6002       format(30x,' NEW Soil Water',3x,' Canopy   Water',3x,
     .                 ' OLD SVAT Water',4x,' FRC SVAT Water',
     .           /,a18,3i4,f15.6,' + ' ,f15.6,' - ' ,f15.6,
     .                           ' -  ',f15.6,'    ', 15x ,'    ',
     .      /,31x,'= ',f12.6,' [mm] (Water Balance)',
     .           /,30x,' NEW Soil Water',3x,'               ',3x,
     .                 ' OLD Soil Water',4x,' FRC Soil Water',
     .           /,30x,f15.6,'   ' , 15x ,' - ' ,f15.6,
     .                       ' -  ',f15.6,'    ', 15x ,'    ',
     .      /,31x,'= ',f12.6,' [mm] (3 terms SUM)')
! #m0           noWBal = noWBal + 1
! #m0       IF (noWBal.GE.       10) stop 'TOO MUCH WATER  IMBALANCES'
! #m0     END IF


C +--Water/Temperature Profiles
C +  --------------------------

c #E0       write(noUNIT,5004)
 5004       format(' -----+--------+--+-----+--------+----+---+',
     .  '--------+----+---+--------+------+-+--------+--------+',
     .           /,'    n |     z  |     dz |     ro |    eta |',
     .  '     T  |     G1 |     G2 | Extinc |        | HISTORY|',
     .           /,'      |    [m] |    [m] | [kg/m3]| [m3/m3]|',
     .  '    [K] |    [-] |    [-] |    [-] |        |   [-]  |',
     .           /,' -----+--------+--------+--------+--------+',
     .  '--------+--------+--------+--------+--------+--------+')
c #E0       write(noUNIT,5005) rusnSV(ikl),albisv(ikl)
 5005       format('      |        |        |        |W',f6.3,' |',
     .  '        |        |        |A',f6.3,' |        |        |')
c #E0       write(noUNIT,5015)
c #E0.                    (isn,zzsnsv(ikl,isn),dzsnSV(ikl,isn),
c #E0.                         ro__SV(ikl,isn),eta_SV(ikl,isn),
c #E0.                         TsisSV(ikl,isn),
c #E0.                         G1snSV(ikl,isn),G2snSV(ikl,isn),
c #E0.                         sEX_sv(ikl,isn),istoSV(ikl,isn),
c #E0.                     isn=isnoSV(ikl),1,-1)
 5015       format((i5,' |',2(f7.3,' |'),               f7.1,' |',
     .           f7.3,' |' ,  f7.2,' |', 2(f7.1,' |'),  f7.3,' |',
     .            7x ,' |' ,  i5,'   |'                          ))
c #E0       write(noUNIT,5006)
 5006       format(' -----+--------+--------+--------+--------+',
     .  '--------+--------+--------+--------+--------+--------+')
c #E0       write(noUNIT,5007) TBr_sv(ikl),
c #E0.                         TvegSV(ikl),rrCaSV(ikl)*1.e3,
c #E0.                         EvT_sv(ikl)*86.4e3
 5007       format(' Brgh |',4(8x,'|'),  f7.2,' | [micm] |',4(8x,'|'),
     .           /,' VEGE |',4(8x,'|'),2(f7.2,' |'),        2(8x,'|'),
     .                                   f7.3,' |',           8x,'|' )
c #E0       write(noUNIT,5014)
 5014       format(' -----+--------+--------+--------+--------+',
     .  '--------+--------+--------+--------+--------+--------+',
     .           /,'    n |        |     dz |        |    eta |',
     .  '     T  |        |        |        | Root W.| W.Flow |',
     .           /,'      |        |    [m] |        | [m3/m3]|',
     .  '    [K] |        |        |        | [mm/d] | [mm/h] |',
     .           /,' -----+--------+--------+--------+--------+',
     .  '--------+--------+--------+--------+--------+--------+')

c #E0       write(noUNIT,5008)
c #E0.                    (isl,    LSdzsv(ikl)*dz_dSV(    isl),
c #E0.                                         eta_SV(ikl,isl),
c #E0.                                         TsisSV(ikl,isl),
c #E0.                                  86.4e3*Rootsv(ikl,isl),
c #E0.                                   3.6e3*Khydsv(ikl,isl),
c #E0.                     isl=0,-nsol,-1)
 5008       format((i5,' |',   7x ,' |' ,  f7.3,' |' ,   7x ,' |',
     .           f7.3,' |' ,  f7.2,' |', 2( 7x ,' |'),   7x ,' |',
     .                                     f7.3,' |' ,  f7.2,' |'))
c #E0       write(noUNIT,5006)
c #E0       write(noUNIT,5009) RnofSV(ikl)* 3.6e3
 5009       format('      |',9(8x,'|'),f7.3,' |')
c #E0       write(noUNIT,5006)
c #E0   END IF
c #E0   END DO

C +..END  .main.
      return
      end


      subroutine SISVAT_BSn

C +------------------------------------------------------------------------+
C | MAR          SISVAT_BSn                           Wed  2-Sep-2011  MAR |
C |   SubRoutine SISVAT_BSn treats Snow Erosion and Deposition             |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # stdout               | #sb: OUTPUT of Snow Erosion                   |
C |                        |      unit  6, SubRoutine  SISVAT_BSn **ONLY** |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--General Variables
C +  =================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MAR_SV.inc'
      include 'MARdSV.inc'

      include 'MARxSV.inc'
      include 'MARySV.inc'

!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--Local Variables
C +  ===============

      logical           BlowIn
      common/llocal_BSn/BlowIn

      real              FacSBS,FacUBS        !
      real              Por_BS               ! Snow       Porosity
      real              SheaBS               !
      real              rCd10n               ! GM97:   assumed neutral stabil.
      common/rlocal_BSn/FacSBS,FacUBS,       !
     .                  Por_BS,SheaBS,rCd10n !

      integer  ikl   ,isn   ,isnMAX,is2      !
      integer  Mobilm,Mobiln                 !
      integer  Mobile(klonv)                 !

      real     DendOK                        ! Dendricity Switch
      real     SaltOK                        ! Saltation  Switch
      real     MeltOK                        ! Saltation  Switch (Melting Snow)
      real     SnowOK                        ! Pack Top   Switch
      real     SaltM1,SaltM2,SaltMo,SaltMx   ! Saltation  Parameters
      real     ShearX                        ! Arg. Max Shear Stress
      real     SaltSU,Salt_U                 !
      real     ArgFac,Fac_Mo                 !
      real     FacRBS,FacTBS                 !
      real     ArguSi                        !
      real     SaltSI(klonv,nsno)            ! Snow Drift Index
      real     hdrift                        ! Inverse erodibl.Snow Lay.Thickn.
      real     h_mmWE                        ! Eroded Snow Layer Min Thickness
      real     tfv_vk                        ! * Fall Veloc. / Von Karman Cst
      real     sdrift(klonv,nsno)            !
      real     xdrift(klonv)                 !
      real     zdrift(klonv)                 !
      real     tdepos(klonv)                 !
      real     zdepos(klonv,nsno)            !
      real     dbsaux(klonv)                 ! Drift Amount   (Dummy Variable)
      real     dzweqo,dzweqn,bsno_x          ! 
      real                   hsno_x          !
      real     PorSno,Salt_f,PorRef,ro_new   !
      real     MIN_Mo                        ! Minimum Mobility Fresh Fallen *
      real     AgBlow                        ! Snow Mobility    Time  Scale
      real     snofOK                        ! Threshd Snow Fall

      integer  isagr1(klonv)                 ! 1st     Layer History
      integer  isagr2(klonv)                 ! 2nd     Layer History

      real     WEagre(klonv)                 ! Snow Water Equivalent Thickness
      real     Agrege(klonv)                 ! 1. when Agregation constrained
      real     dzagr1(klonv)                 ! 1st     Layer Thickness
      real     dzagr2(klonv)                 ! 2nd     Layer Thickness
      real     T_agr1(klonv)                 ! 1st     Layer Temperature
      real     T_agr2(klonv)                 ! 2nd     Layer Temperature
      real     roagr1(klonv)                 ! 1st     Layer Density
      real     roagr2(klonv)                 ! 2nd     Layer Density
      real     etagr1(klonv)                 ! 1st     Layer Water Content
      real     etagr2(klonv)                 ! 2nd     Layer Water Content
      real     G1agr1(klonv)                 ! 1st     Layer Dendricity/Spher.
      real     G1agr2(klonv)                 ! 2nd     Layer Dendricity/Spher.
      real     G2agr1(klonv)                 ! 1st     Layer Sphericity/Size
      real     G2agr2(klonv)                 ! 2nd     Layer Sphericity/Size
      real     agagr1(klonv)                 ! 1st     Layer Age
      real     agagr2(klonv)                 ! 2nd     Layer Age

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Snow Erosion  Variables
! #sb real     Sno0WE,Sno1WE                 ! Snow Mass before/after Erosion
! #sb real     SnodWE                        ! Snow Mass              Erosion


C +--DATA
C +  ====

      data     AgBlow  / 1.00     /          ! 1 Day (F.Domine, pers.communic.)
      data     SaltMx  /-5.83e-2  /          !
      data     FacRBS  / 2.868    /          !
      data     FacTBS  / 0.085    /          !
      data     hdrift  / 1.00e+1  /          ! Inverse erodibl.Snow Lay.Thickn.
      data     h_mmWE  / 0.01e00  /          ! Eroded Snow Layer Min Thickness
      data     tfv_vk  / 5.10e-1  /          ! tfv (Terminal Fall Veloc. =.216) 
C +...                                       ! /vk (Von Karman Constant  =.4  )
C +                                          ! (Wamser & Lykosov,   1995 
C +                                          !  Contr.Atm.Phys. 68, p.90)

C +--Initialization
C +  ==============

      IF (.NOT.BlowIn)                                             THEN
               BlowIn = .true.
               FacSBS =  1.             / FacRBS
               FacUBS =  1.             / FacTBS
               Por_BS =  1.             - blsno /      ro_Ice
               SheaBS =                   Por_BS/(unun-Por_BS)
C +...         SheaBS =  Arg(sqrt(shear = max shear stress in snow)):
C +            shear  =  3.420d00 * exp(-(Por_BS      +Por_BS)
C +  .                                  /(unun        -Por_BS))
C +            SheaBS :  see de Montmollin         (1978),
C +                      These Univ. Sci. Medic. Grenoble, Fig. 1 p. 124

             DO ikl=1,klonv             ! Parameterization of u*th
               rCd10n      =  1./  26.5 ! was developed from observations made
             END DO                     ! during assumed neutral conditions
                                         
               write(6,5000)  1./  rCd10n
 5000          format(/,' Blowing Snow Model  Initialization     ',
     .                /,' Vt / u*t =',f8.2,' (Neutral Assumption)',
     .                /,'           ', 8x ,' (Budd assumes  26.5)',/)
      END IF


C +--Snow Age (Influence on Snow Erosion Threshold)
C +  ==============================================

c #BS DO isn=1,nsno
c #BS DO ikl=1,klonv
c #BS   agsnSV(ikl,isn) = agsnSV(ikl,isn) + dt__SV/86400.
c #BS END DO
c #BS END DO
c #BS DO ikl=1,klonv
c #BS   isn    = max(1 ,        isnoSV(ikl))
c #BS   snofOK = max(0.,sign(1.,dsn_SV(ikl)-epsi))      !  Threshold=1.e-6
c #BS   agsnSV(ikl,isn) =   (1.-snofOK) *agsnSV(ikl,isn)! ~0.1 mm w.e./day
c #BS END DO
      IF (.NOT.BloMod)                                     GO TO 1000
c #AG STOP '?!&~@|@[#@#] --- INCONSISTANT SNOW AGE --- EMERGENCY STOP'
 1000 CONTINUE


C +--EROSION
C +  =======

      DO isn = 1, nsno
      DO ikl = 1,klonv

C +--Below the high Snow Density Threshold  (ro__SV < blsno)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        DendOK   =  max(zero,sign(unun,epsi-G1snSV(ikl,isn)  ))  !
        SaltOK   =  min(1   , max(istdSV(2)-istoSV(ikl,isn),0))  !
        MeltOK   =     (unun                                     !
     .             -max(zero,sign(unun,TfSnow-epsi               !
     .                                     -TsisSV(ikl,isn)  ))) ! Melting Snow
     .           *  min(unun,DendOK                              !
     .                  +(1.-DendOK)                             !
     .                      *sign(unun,     G2snSV(ikl,isn)-1.0))! 1.0 for 1mm
        SnowOK   =  min(1   , max(isnoSV(ikl)      +1 -isn ,0))  ! Snow Switch

        G1snSV(ikl,isn) =      SnowOK *    G1snSV(ikl,isn)
     .                  + (1.- SnowOK)*min(G1snSV(ikl,isn),G1_dSV)
        G2snSV(ikl,isn) =      SnowOK *    G2snSV(ikl,isn)
     .                  + (1.- SnowOK)*min(G2snSV(ikl,isn),G1_dSV)

        SaltOK   =  min(unun , SaltOK +    MeltOK)       * SnowOK
        SaltM1   = -0.750e-2 * G1snSV(ikl,isn) 
     .             -0.500e-2 * G2snSV(ikl,isn)+ 0.500e00
C +...  SaltM1   :  Guyomarc'h & Merindol, 1997, Ann. Glac.
C +       CAUTION:  Guyomarc'h & Merindol Dendricity Sign is +
C +       ^^^^^^^^                    MAR Dendricity Sign is -
        SaltM2   = -0.833d-2 * G1snSV(ikl,isn) 
     .             -0.583d-2 * G2snSV(ikl,isn)+ 0.833d00
        SaltMo   = (DendOK   * SaltM1 + (1.-DendOK) *     SaltM2       )

C +--Increased Mobility of Deposed (blown) Snow (Mann et al., 2000, JGR 105,
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Fig.2 p.24496 & text below)
        MIN_Mo   =  0.
c #MA   MIN_Mo   =  0.6 * exp(-agsnSV(ikl,isn)                  /AgBlow)
        SaltMo   =                                    max(SaltMo,MIN_Mo)

        SaltMo   =  SaltOK   * SaltMo + (1.-SaltOK) * min(SaltMo,SaltMx)
c #TUNE SaltMo   =  SaltOK   * SaltMo - (1.-SaltOK) *     0.9500
        SaltMo   =         max(SaltMo ,  epsi-unun)

        SaltSU   =     (1.00d0+SaltMo)     *FacSBS

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Snow Erosion  Variables
! #sb   Salt_U   =        -log(SaltSU)     *FacUBS
! #sb   IF (ii__SV(ikl).EQ.iwr_SV.AND.jj__SV(ikl).EQ.jwr_SV        .AND.
! #sb.      nn__SV(ikl).EQ.nwr_SV.AND.isn        .EQ.isnoSV(ikl))
! #sb.    write(6,6010) itexpe
! #sb.                 ,isnoSV(ikl),G1snSV(ikl,isn)/G1_dSV
! #sb.                             ,G2snSV(ikl,isn)/G1_dSV
! #sb.                             ,ro__SV(ikl,isn),agsnSV(ikl,isn)
! #sb.                             ,SaltM1, SaltM2, SaltMo, Salt_U
! #sb.                             ,us__SV(ikl)   / rCd10n
 6010     format(/,'SISVAT_BSn',i6
     .           ,6x,i3,2x,'G1         =',f6.3,'   G2         =',f7.3
     .           ,      '   ro [kg/m3] =',f9.3,'   Age* [Day] =',f9.3
     .           ,   /,27x,'SaltM1     =',f6.3,'   SaltM2     =',f7.3
     .           ,      '   Mobility I.=',f9.3,'   Vt   [m/s] =',f9.3
     .           ,   /,27x,'            ', 6x ,'               ', 7x
     .           ,      '               ', 9x ,'   Vn10 [m/s] =',f9.3)

C +--Above the high Snow Density Threshold  (ro__SV > blsno)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Por_BS      =  1.000       - ro__SV(ikl,isn)     /ro_Ice
        ShearX      =                Por_BS/max(epsi,unun-Por_BS) 
C +...  ShearX ==> Arg(sqrt(shear)) with shear = max shear stress in snow:
C +     shear       =  3.420d00 * exp(-(Por_BS      +Por_BS)
C +  .                                /max(epsi,unun-Por_BS))
C +                    see de Montmollin         (1978),
C +                    These Univ. Sci. Medic. Grenoble, Fig. 1 p. 124

C +--Influence of Density on Shear Stress if ro__SV > blsno
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ArgFac      =  max(zero  ,SheaBS-ShearX)     !
!       Fac_Mo      =  exp(       ArgFac       )     ! ** NOT ** tuned
        Fac_Mo   =     exp(       ArgFac       )     ! = 1 if ro__SV < blsno
                                                     ! < 1 if ro__SV > blsno
C +--Snow Drift Index
C +  ~~~~~~~~~~~~~~~~
        SaltSU      =  max(epsi  ,    SaltSU)
        SaltSU      =  exp(Fac_Mo*log(SaltSU))
        ArguSi      =     -FacTBS              *us__SV(ikl)/rCd10n
        SaltSI(ikl,isn) = (SaltSU-exp(ArguSi)) *FacRBS
C +...  SaltSI          :  Generalization of the Snow Drift Index of                       
C +                        Guyomarc'h & Merindol (1997, Ann.Glaciol.)

C +--Threshold Friction Velocity
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        SnowOK   =  1 -min(1,iabs(isn-isnoSV(ikl)))
        Salt_U   =               -log(SaltSU)  *FacUBS
C +...  Salt_U   :  Guyomarc'h & Merindol, 1997, Ann. Glac.

        usthSV(ikl) =     SnowOK *   (Salt_U   *rCd10n)
     .              + (1.-SnowOK)*    usthSV(ikl)

c #BA   usthSV(ikl) =     SnowOK *   (Salt_U   /26.5)
c #BA.              + (1.-SnowOK)*    usthSV(ikl)
C +...  Us(U10)     :  Budd et al.            1966, Ant.Res.Ser.9
C +               (see Pomeroy & Gray 1995 NHRI Sci.Rep.7(30)p.62)

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Snow Erosion  Variables
! #sb   IF (ii__SV(ikl).EQ.iwr_SV.AND.jj__SV(ikl).EQ.jwr_SV        .AND.
! #sb.      nn__SV(ikl).EQ.nwr_SV.AND.isn        .EQ.isnoSV(ikl))
! #sb.    write(6,6011)     Fac_Mo,Por_BS,SaltSI(ikl,isn),usthSV(ikl)
 6011     format(      27x,'Fac_Mo     =',f6.3,'   Por_BS     =',f7.3
     .           ,      '   Drift    I.=',f9.3,'   ut*_0[m/s] =',f9.3)
      END DO
      END DO


C +--Deepest Mobile Snow Layer
C +  -------------------------

      DO ikl = 1,klonv
        Mobile(ikl) = nsno+1
      END DO
      DO isn =   nsno ,1,-1
      DO ikl = 1,klonv
        isnMAX      =       max(   1,          isnoSV(ikl)             )
        isnMAX      =       min( isn,          isnMAX                  )
        Mobiln      = isn * max(zero,sign(unun,SaltSI(ikl     ,isnMAX)))
        Mobilm      =   1 - min(1   ,          Mobile(ikl) -1 -Mobiln)
C +...  Mobilm      =   1   ONLY IF   Mobiln = Mobile(ikl) -1 (0 otherwise)

        Mobile(ikl) =                 Mobilm * Mobiln 
     .              +              (1-Mobilm)* Mobile(ikl)
      END DO
      END DO


C +--Weighting the Amount of Snow to erode
C +  -------------------------------------

      DO ikl = 1,klonv
        zdrift(ikl) = 0.0 
        xdrift(ikl) = 0.0
        dbsaux(ikl) = dbs_SV(ikl)
      END DO

      DO isn = 1, nsno
      DO ikl = 1,klonv
        zdrift(ikl)     =  zdrift(ikl)
     .            + 0.50 * dzsnSV(ikl,isn) * (3.25  -SaltSI(ikl,isn))
        sdrift(ikl,isn) =  SaltSI(ikl,isn)
     .          *exp(  max(argmin, -zdrift(ikl)     *hdrift     ))
     .          *min(1,max(0     ,  isn +1          -Mobile(ikl)))
     .          *min(1,max(0     ,  isnoSV(ikl)     -isn +1     ))
C +...           Last 2 Lines force sdrift = 0 outside mobile Snow Layers
     .          *      max(zero, sign(unun,         -dbs_SV(ikl)))
C +...           Erosion is allowed only if available Blowing Snow
        xdrift(ikl)     =           sdrift(ikl,isn) +xdrift(ikl)
        zdrift(ikl)     =  zdrift(ikl)
     .            + 0.50 * dzsnSV(ikl,isn) * (3.25  -SaltSI(ikl,isn))
      END DO
      END DO

C +--Normalization
C +  ~~~~~~~~~~~~~
      DO isn = 1, nsno
      DO ikl = 1,klonv
        sdrift(ikl,isn) =  sdrift(ikl,isn) /max(epsi,xdrift(ikl))
      END DO
      END DO


C +--Weighting the Amount of Snow to depose
C +  --------------------------------------

      DO ikl = 1,klonv
        zdrift(ikl) = 0.0 
        tdepos(ikl) = 0.0
      END DO

      DO isn = 1, nsno
      DO ikl = 1,klonv
        zdepos(ikl,isn) =      exp(-zdrift(ikl)   )
     .          *min(1,max(0     ,  isn +1          -Mobile(ikl)))
     .          *min(1,max(0     ,  isnoSV(ikl    ) -isn +1     ))
C +...           Last 2 Lines force zdepos = 0 outside mobile Snow Layers
        tdepos(ikl) = tdepos(ikl) + zdepos(ikl,isn)
        zdrift(ikl) = zdrift(ikl) + dzsnSV(ikl,isn) *ro__SV(ikl,isn)
     .                                              /ro_Wat
      END DO
      END DO

C +--Normalization
C +  ~~~~~~~~~~~~~
      DO isn = 1, nsno
      DO ikl = 1,klonv
        zdepos(ikl,isn) = zdepos(ikl,isn) / max(epsi,tdepos(ikl))
      END DO
      END DO

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Snow Erosion  Variables
! #sb DO ikl = 1,klonv
! #sb   IF (ii__SV(ikl).EQ.iwr_SV.AND.jj__SV(ikl).EQ.jwr_SV        .AND.
! #sb.      nn__SV(ikl).EQ.nwr_SV                          )        THEN
! #sb     Sno0WE =   0.
! #sb   DO isn=1,nsno
! #sb     Sno0WE =   Sno0WE 
! #sb.           +   dzsnSV(ikl,isn) *ro__SV(ikl,isn)
! #sb   END DO
! #sb     write(6,6005)   Sno0WE                    ,dbs_SV(ikl)
 6005     format(
     .      18x,'MB0',6x,'Sno1WE [mm]=',f9.3,19x,'0  dbs_SV [mm]=',f9.6)
! #sb     SnodWE =   dbs_SV(ikl)
! #sb   END IF
! #sb END DO


C +--Weighted  Erosion (Erosion amount is distributed       ! dbs_SV decreases
C +  -----------------  over the upper Snow Pack)           ! dzsnSV decreases

      DO isn = 1, nsno
      DO ikl = 1,klonv
        SnowOK      = min(1,max(isnoSV(ikl)+1-isn ,0))      ! Snow Switch
        dzweqo      = dzsnSV(ikl,isn) *ro__SV(ikl,isn)      ! [kg/m2, mm w.e.]
        bsno_x      = dbsaux(ikl)     *sdrift(ikl,isn)
        dzweqn      = dzweqo          +bsno_x
        dzweqn  = max(dzweqn,          h_mmWE *SnowOK)
        dbs_SV(ikl) = dbs_SV(ikl)    +(dzweqo -dzweqn)
        dzsnSV(ikl,isn) =              dzweqn
     .                       /max(epsi,ro__SV(ikl,isn))
      END DO
      END DO

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Snow Erosion  Variables
! #sb DO ikl = 1,klonv
! #sb   IF (ii__SV(ikl).EQ. 1 .AND.  jj__SV(ikl) .EQ. 1)            THEN
! #sb     SnodWE =   SnodWE         -dbs_SV(ikl)
! #sb     Sno1WE =   0.
! #sb   DO isn=1,nsno
! #sb     Sno1WE =   Sno1WE 
! #sb.           +   dzsnSV(ikl,isn)*ro__SV(ikl,isn)
! #sb   END DO
! #sb     write(6,6006)Sno1WE      , dbs_SV(ikl)
 6006     format(
     .      18x,'MB1',6x,'Sno1WE [mm]=',f9.3,19x,'1  dbs_SV [mm]=',f9.6)
! #sb     write(6,6007)Sno1WE    ,SnodWE   ,Sno0WE,
! #sb.                (Sno1WE    -SnodWE   -Sno0WE)     
 6007     format(
     .      18x,'MB ',5x,'(After  [mm]=',f6.0, ')-(Erosion[mm]=', f7.3,
     .                                         ')-(Before [mm]=', f9.3,
     .                                         ')= Budget [mm]=', f9.6)
! #sb   END IF
! #sb END DO


C +--ACCUMULATION of BLOWN SNOW                             ! dsn_SV decreases
C +  --------------------------                             ! dzsnSV increases

        DO ikl = 1,klonv
          tdepos(ikl) = dsn_SV(ikl) * dsnbSV(ikl) * dt__SV
          WEagre(ikl) = 0.

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Snow Erosion  Variables
! #sb     IF (ii__SV(ikl).EQ.iwr_SV.AND.jj__SV(ikl).EQ.jwr_SV      .AND.
! #sb.        nn__SV(ikl).EQ.nwr_SV.AND.0          .LT.isnoSV(ikl))
! #sb.        write(6,6003) tdepos(ikl)  ,Mobile(ikl)
 6003         format(/,41x,'tdepos [-] =',f6.3,40x,'Mobil',i3
     .              ,/,27x,'Salt.Index    sdrift'
     .              ,      '    zdepos  ro__snow  ro_bsnow  roN_snow'
     .              ,                '  dz__snow  dz_bsnow  dzN_snow'
     .              ,                '  d___snow'
     .              ,/,27x,'             [kg/m3]   [kg/m3]   [kg/m3]'
     .              ,                '       [m]       [m]       [m]'
     .              ,                '   [kg/m2]')
        END DO

      DO isn =     nsno,1,-1
        DO ikl = 1,klonv
          WEagre(ikl) = WEagre(ikl) + ro__SV(ikl,isn)*dzsnSV(ikl,isn)
          isagr1(ikl) = istoSV(ikl,isn)
          isagr2(ikl) = 0.

C +--Density of deposited blown Snow
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ro_new =                    blsno

C +--Density of deposited blown Snow (de Montmollin, 1978)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #EM     PorSno =      1.0d00     -  ro__SV(ikl,isn)
c #EM.                             /  ro_Ice
c #EM     Salt_f =      usthSV(ikl)/  max(epsi,   us__SV(ikl))
c #EM     Salt_f =  min(Salt_f     ,  unun)
c #EM     PorRef =      PorSno     /  max(epsi,1.-PorSno)
c #EM.             +log(Salt_f)
c #EM     Por_BS =      PorRef     / (1.0d00 + PorRef)
c #EM     ro_new =      ro_Ice     * (1.0d00 - Por_BS)
c #EM     ro_new =  max(ro_new     ,  blsno )

          roagr1(ikl) = ro__SV(ikl,isn)
          roagr2(ikl) = ro_new
          hsno_x      = tdepos(ikl)*  zdepos(ikl,isn)

          dzagr1(ikl) = dzsnSV(ikl,isn)
          dzagr2(ikl) = hsno_x     /  ro_new
C +...    Conversion    [kg/m2, i.e., mm w.e.] -----> [mSnow]

          dsn_SV(ikl) = dsn_SV(ikl)-  hsno_x / dt__SV

C +--Other Snow Properties
C +  ~~~~~~~~~~~~~~~~~~~~~
          T_agr1(ikl) =    TsisSV(ikl,isn)
          T_agr2(ikl) =min(TfSnow,TaT_SV(ikl))
          etagr1(ikl) =    eta_SV(ikl,isn)
          etagr2(ikl) =    0.0
          G1agr1(ikl) =    G1snSV(ikl,isn)
          G1agr2(ikl) =    G1_dSV
          G2agr1(ikl) =    G2snSV(ikl,isn)
          G2agr2(ikl) =    ADSdSV
c #BY     G2agr2(ikl) =    0.87d0
C +...    Budd et al. 1966, 2~m Average /Table 5 p. 97

          agagr1(ikl) =    agsnSV(ikl,isn)
          agagr2(ikl) =    0.
          Agrege(ikl) =    1.
        END DO

C +--Agregation
C +  ~~~~~~~~~~
C +     ***************
        call SISVAT_zAg
     .                 (isagr1,isagr2,WEagre
     .                 ,dzagr1,dzagr2,T_agr1,T_agr2
     .                 ,roagr1,roagr2,etagr1,etagr2
     .                 ,G1agr1,G1agr2,G2agr1,G2agr2
     .                 ,agagr1,agagr2,Agrege
     .                 )
C +     ***************

        DO ikl = 1,klonv

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! OUTPUT           for Snow Erosion  Variables
! #sb     IF (ii__SV(ikl).EQ.iwr_SV.AND.jj__SV(ikl).EQ.jwr_SV      .AND.
! #sb.        nn__SV(ikl).EQ.nwr_SV.AND.isn        .LE.isnoSV(ikl))
! #sb.        write(6,6004)   isn          ,SaltSI(ikl,isn)
! #sb.                     ,sdrift(ikl,isn),zdepos(ikl,isn)
! #sb.                     ,ro__SV(ikl,isn),roagr2(ikl),roagr1(ikl)
! #sb.                     ,dzsnSV(ikl,isn),dzagr2(ikl),dzagr1(ikl)
! #sb.                     ,dsn_SV(ikl)
 6004         format((27x,i3,f7.2,2f10.6,3f10.3,4f10.6))

          istoSV(ikl,isn) = isagr1(ikl)
          dzsnSV(ikl,isn) = dzagr1(ikl)
          TsisSV(ikl,isn) = T_agr1(ikl)
          ro__SV(ikl,isn) = roagr1(ikl)
          eta_SV(ikl,isn) = etagr1(ikl)
          G1snSV(ikl,isn) = G1agr1(ikl)
          G2snSV(ikl,isn) = G2agr1(ikl)
          agsnSV(ikl,isn) = agagr1(ikl)

        END DO

      END DO

c #EF   IF          (isnoSV(1) .GT. 0)
c #EF.  write(6,6008)isnoSV(1),    dsn_SV(1) *dt__SV + BufsSV(1),
c #EF.              (dzsnSV(1,isn)*ro__SV(1,isn),isn=1,isnoSV(1))
 6008   format(i3,'  dsn+Buf=',f6.2,6x,'A dz *ro =',10f6.2,
     .                                       (/,35x,10f6.2))

        DO ikl = 1,klonv
          hdrift      =  tdepos(ikl)/dt__SV
          esnbSV(ikl) = (dsnbSV(ikl)-unun)*hdrift/max(dsn_SV(ikl),epsi)
     .                  +dsnbSV(ikl)
          dsnbSV(ikl) =          min(unun,   max(zero,esnbSV(ikl) )   )
!         dsnbSV is now the Blown Snow fraction of precipitating snow
!                will be used for characterizing the Buffer Layer
!               (see update of  Bros_N, G1same, G2same, zroOLD, zroNEW)
        END DO

      return
      END


      subroutine SISVAT_BDu

C +------------------------------------------------------------------------+
C | MAR          SISVAT_BDu                                27-11-2002  MAR |
C |   SubRoutine SISVAT_BDu treats Dust Erosion                            |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   OUTPUT:  usthSV   : Blowing Snow Erosion   Threshold           [m/s] |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   REFER. : F?can, F., B. Marticorena and G. Bergametti, 1999   (Fal99) |
C |   ^^^^^^^^ Ann. Geophysicae 17, 149--157                               |
C |            u* threshold: adapted from Fig. 4 p. 153                    |
C |            Clay Content:         from Tab. 2 p. 155                    |
C |                                                                        |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MAR_SV.inc'
      include 'MARdSV.inc'
      include 'MARxSV.inc'

!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/)

C +
C +
C +--Local   Variables
C +  =================
C +
      integer              ikl   ,  isot
      real                 ustdmn(0:nsot)
      real                 claypc(0:nsot)
      real                 f__ust(0:nvgt)
      real                 etaust(0:nsot)
      common /SISVAT_BDu_r/etaust
      logical              logust
      common /SISVAT_BDu_L/logust
      real                 eta_Du,usthDu
C +
C +
C +--DATA
C +  ====
C +
      data         (ustdmn(isot),
     .                        claypc(isot),
     .                                                   isot=0,nsot)
     .             /10.000,  0.0000, !  0 WATER           !
     .               0.300,  0.0000, !  1 SAND            !
     .               0.300,  0.0920, !  2 LOAMY      SAND ! Fal99, Table 2
     .               0.300,  0.1420, !  3 SANDY      LOAM ! Fal99, Table 2
     .               0.300,  0.1630, !  4 SILT       LOAM ! Guess (Interpol.)
     .               0.300,  0.1840, !  5            LOAM ! Fal99, Table 2
     .               0.300,  0.2280, !  6 SANDY CLAY LOAM ! Guess (Interpol.)
     .               0.300,  0.2720, !  7 SILTY CLAY LOAM ! Guess (Interpol.)
     .               0.300,  0.3160, !  8       CLAY LOAM ! Fal99, Table 2
     .               0.300,  0.3750, !  9 SANDY CLAY      ! Guess (Interpol.)
     .               0.300,  0.4340, ! 10 SILTY CLAY      ! Guess (Interpol.)
     .               0.300,  0.4920, ! 11       CLAY      ! Fal99, Table 2
     .              10.000,  0.0000/ ! 12       ICE       !
      data          (f__ust(isot),                       isot=0,nvgt)
     .              /1.00,           !  0 NO     VEGETATION
     .               1.20,           !  1 CROPS      LOW
     .               5.00,           !  2 CROPS      MEDIUM
     .              10.00,           !  3 CROPS      HIGH
     .               1.20,           !  4 GRASS      LOW
     .               5.00,           !  5 GRASS      MEDIUM
     .              10.00,           !  6 GRASS      HIGH
     .               5.00,           !  7 BROADLEAF  LOW
     .              10.00,           !  8 BROADLEAF  MEDIUM
     .              12.00,           !  9 BROADLEAF  HIGH
     .              10.00,           ! 10 NEEDLELEAF LOW
     .              12.00,           ! 11 NEEDLELEAF MEDIUM
     .              50.00          / ! 12 NEEDLELEAF HIGH
C +
      IF (.NOT.logust)                                              THEN
        DO isot=1,nsot
               etaust(isot) = 0.0014 * claypc(isot) * claypc(isot) ! Fal99
     .                      + 0.17   * claypc(isot)                ! Eqn.(14)
        END DO                                                     !  p. 154
               logust = .true.
      END IF
C +
C +
C +--Soil Erodibility
C +  ----------------
C +
      DO ikl = 1,klonv
        eta_Du      =  max(     eta_SV(ikl,0),etaust(isotSV(ikl))) ! Fal99
        eta_Du      =  max(epsi,eta_SV(ikl,0)-eta_Du             ) ! Eqn.(15)
        usthDu      = sqrt(unun+1.21*exp(0.68*   log(eta_Du)    )) ! p.  155
     .              *                         ustdmn(isotSV(ikl))  !
     .              *                         f__ust(ivgtSV(ikl))  !
        usthSV(ikl) = 
     .                 usthSV(ikl)*(1-max(0,1-isnoSV(ikl))) +
     .                 usthDu     *   max(0,1-isnoSV(ikl))
      END DO
C +
      return
      END


      subroutine SISVAT_SIc
! #m2.                     (SIvAcr)

C +------------------------------------------------------------------------+
C | MAR          SISVAT_SIc                                26-09-2006  MAR |
C |   SubRoutine SISVAT_SIc treats Sea-Ice and Ocean Latent Heat Exchanges |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:   TaT_SV   : SBL Top    Temperature                       [K] |
C |   ^^^^^    isnoSV   : total Nb of Ice/Snow Layers                  [-] |
C |            LSmask   : Land-Sea   Mask                              [-] |
C |            dsn_SV   : Snow  Intensity                      [mm w.e./s] |
C |                                                                        |
C |   INPUT /  TsisSV   : Snow/Ice/Soil-Water Temperature              [K] |
C |   OUTPUT:  eta_SV   : Soil/Snow Water   Content                [m3/m3] |
C |   ^^^^^^   dzsnSV   : Snow Layer        Thickness                  [m] |
C |                                                                        |
C |   OUTPUT:  HFraSV   : Frazil            Thickness                  [m] |
C |   ^^^^^^                                                               |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--General Variables
C +  =================

      include 'MARphy.inc'

      include 'MAR_SV.inc'
      include 'MARdSV.inc'


C +--INPUT/OUTPUT
C +  ------------

      include  "MARxSV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/)

! #m2 real      SIvAcr(klonv)                 ! Sea-Ice      Vertical Acretion


C +--Local Variables
C +  ===============

      integer             ikl   ,isn
      real                OCN_OK
      real                SIceOK
      real                SIcFrz
      real                Twat_n
      real                Crodzw,Lro__I
      common/SISVAT_SIc_R/Crodzw,Lro__I
      logical             SIcINI
      common/SISVAT_SIc_L/SIcINI

      real                SalIce              ! Sea-Ice   Salinity
      real                SalWat              ! Sea-Water Salinity


C +--DATA
C +  ====

      data                SalIce /10./        ! Sea-Ice   Salinity
      data                SalWat /35./        ! Sea-Water Salinity
C +...                    Typical Salinities in Terra Nova Bay
C +                       (Bromwich and Kurtz,   1984, JGR, p.3568;
C +                        Cavalieri and Martin, 1985,      p. 248)


C +--Initialisation
C +  ==============

      IF (.NOT.SIcINI)                                              THEN
               SIcINI =  .true.
               Crodzw =  C__Wat*ro_Wat *          dz_dSV(0)   ! [J/m2/K]
               Lro__I =  Lf_H2O*ro_Ice *(1.-1.e-3*SalIce      ! [J/m3]
     .                 -(SalIce/SalWat)*(1.-1.e-3*SalWat) )   !
! #e1          Lro__I =  Lf_H2O*ro_Ice
      END IF


C +--Snow Fall cools Sea Water
C +  =========================

      DO ikl=1,klonv
        OCN_OK        =  (1   -LSmask(ikl)   )                ! Free Ocean
     .             *max(0,1   -isnoSV(ikl)   )                !
c #IA   TsisSV(ikl,0) =        TsisSV(ikl,0)                  ! [K]
c #IA. -OCN_OK*(Cn_dSV*(TfSnow-TaT_SV(ikl)   )                ! [J/kg]
c #IA.         +Lf_H2O*(1.    -eta_SV(ikl,0)))                ! [J/kg]
c #IA.        * dsn_SV(ikl)   *dt__SV          / Crodzw       ! [kg/m2]


C +--Sea-Ice Formation
C +  =================

c #IA   Twat_n      =      max(TsisSV(ikl,0  )  ,tfrwat)      ! [K]
c #IA   SIcFrz      =  (Twat_n-TsisSV(ikl,0  ) )*Crodzw/Lro__I! [m]
c #IA.                              * 0.75
C +***  Hibler (1984), Ocean Heat Flux: 25% of cooling (ANTARCTIC Ocean)
C +    (Hansen and Takahashi Eds) 
C +     Geophys. Monogr. 29, M. Ewing Vol. 5, AGU, p. 241


C +--Frazil  Formation
C +  -----------------

c #IA   HFraSV(ikl) =          SIcFrz           *OCN_OK


C +--Growth of the Sea-Ice First Ice Floe
C +  ------------------------------------

c #IA   SIceOK        =  (1   -LSmask(ikl)     )              ! Ice Cover.Ocean
c #IA.             *min(  1   ,isnoSV(ikl)     )              !
c #IA   dzsnSV(ikl,1) =        dzsnSV(ikl,1)                  ! Vertical Acret.
c #IA.                +        SIcFrz           *SIceOK       !


C +--Diagnostic of the Surface Mass Balance
C +  --------------------------------------

! #m2   SIvAcr(ikl) = ro_Ice*SIcFrz     *(OCN_OK+SIceOK)
! #m2.              - dt__SV*dsn_SV(ikl)* OCN_OK


C +--Water Fluxes Update
C +  -------------------

        RnofSV(ikl) =          RnofSV(ikl)
     .              +          dsn_SV(ikl) *     OCN_OK
        dsn_SV(ikl) =          dsn_SV(ikl) * (1.-OCN_OK)

      END DO

      return
      end


      subroutine SISVAT_zSn

C +------------------------------------------------------------------------+
C | MAR          SISVAT_zSn                            Thu  3-02-2011  MAR |
C |   SubRoutine SISVAT_zSn manages the Snow Pack vertical Discretization  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT /  NLaysv   = New             Snow Layer  Switch               |
C |   OUTPUT:  isnoSV   = total Nb of Ice/Snow Layers                      |
C |   ^^^^^^   ispiSV   = 0,...,nsno: Uppermost Superimposed Ice Layer     |
C |            iiceSV   = total Nb of Ice      Layers                      |
C |            istoSV   = 0,...,5 :   Snow     History (see istdSV data)   |
C |                                                                        |
C |   INPUT /  TsisSV   : Soil/Ice Temperatures (layers -nsol,-nsol+1,..,0)|
C |   OUTPUT:           & Snow     Temperatures (layers  1,2,...,nsno) [K] |
C |   ^^^^^^   ro__SV   : Soil/Snow Volumic Mass                   [kg/m3] |
C |            eta_SV   : Soil/Snow Water   Content                [m3/m3] |
C |            dzsnSV   : Snow Layer        Thickness                  [m] |
C |            G1snSV   : Dendricity (<0) or Sphericity (>0) of Snow Layer |
C |            G2snSV   : Sphericity (>0) or Size            of Snow Layer |
C |            agsnSV   : Snow       Age                             [day] |
C |                                                                        |
C |   METHOD:  1) Agregate the thinest Snow Layer                          |
C |   ^^^^^^      if a new Snow Layer has been precipitated   (NLaysv = 1) |
C |            2) Divide   a too thick Snow Layer except                   |
C |               if the maximum Number of Layer is reached                |
C |               in this case forces                          NLay_s = 1  |
C |            3) Agregate the thinest Snow Layer                          |
C |               in order to divide a too thick Snow Layer                |
C |               at next Time Step when                       NLay_s = 1  |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # SISVAT_zSn.vz        | #vz: OUTPUT/Verification: Snow Layers Agrega. |
C |                        |      unit 41, SubRoutine  SISVAT_zSn **ONLY** |
C | # SISVAT_GSn.vp        | #vp: OUTPUT/Verification: Snow   Properties   |
C |                        |      unit 47, SubRoutines SISVAT_zSn, _GSn    |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"

      include  "MARxSV.inc"


C +--Internal Variables
C +  ==================

      integer   ikl   ,isn   ,i               !

      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)


      integer   NLay_s(klonv)                 ! Split Snow Layer         Switch
      integer   isagr1(klonv)                 ! 1st     Layer History
      integer   isagr2(klonv)                 ! 2nd     Layer History
      integer   LstLay                        ! 0 ====> isnoSV = 1
      integer   isno_n                        ! Snow Normal.Profile
      integer   iice_n                        ! Ice  Normal.Profile
      integer   iiceOK                        ! Ice         Switch
      integer   icemix                        ! 0 ====> Agregated Snow+Ice=Snow
C +                                           ! 1                          Ice
      integer   isn1  (klonv)                 ! 1st layer to stagger
      real      staggr                        !              stagger  Switch

      real      WEagre(klonv)                 ! Snow Water Equivalent Thickness
      real      dzthin(klonv)                 ! Thickness of the thinest layer
      real      OKthin                        ! Swich ON  a  new thinest layer
      real      dz_dif                        ! difference from ideal discret.
      real      thickL                        ! Thick Layer          Indicator
      real      OK_ICE                        ! Swich ON   uppermost Ice Layer

      real      Agrege(klonv)                 ! 1. when Agregation constrained
      real      dzepsi                        ! Min Single Snw Layer Thickness
      real      dzxmin                        ! Min Acceptable Layer Thickness
      real      dz_min                        ! Min            Layer Thickness
      real      dz_max                        ! Max            Layer Thickness
      real      dzagr1(klonv)                 ! 1st     Layer Thickness
      real      dzagr2(klonv)                 ! 2nd     Layer Thickness
      real      T_agr1(klonv)                 ! 1st     Layer Temperature
      real      T_agr2(klonv)                 ! 2nd     Layer Temperature
      real      roagr1(klonv)                 ! 1st     Layer Density
      real      roagr2(klonv)                 ! 2nd     Layer Density
      real      etagr1(klonv)                 ! 1st     Layer Water Content
      real      etagr2(klonv)                 ! 2nd     Layer Water Content
      real      G1agr1(klonv)                 ! 1st     Layer Dendricity/Spher.
      real      G1agr2(klonv)                 ! 2nd     Layer Dendricity/Spher.
      real      G2agr1(klonv)                 ! 1st     Layer Sphericity/Size
      real      G2agr2(klonv)                 ! 2nd     Layer Sphericity/Size
      real      agagr1(klonv)                 ! 1st     Layer Age
      real      agagr2(klonv)                 ! 2nd     Layer Age

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx integer             iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1
! #wx common/SISVAT_EV/   iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
! #vz logical         as_opn                  ! IO   Switch
! #vz common/SI_zSn_L/as_opn                  !
! #vz real      dz_ref(            nsno)      ! Snow Reference Discretization
! #vz real      dzwdif(            nsno)      !

C +--Snow Properties Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #vp logical         VP_opn                  ! IO   Switch
! #vp common/SI_GSn_L/VP_opn                  !


C +--DATA
C +  ====

      data      icemix /   0    /             ! 0 ====> Agregated Snow+Ice=Snow
      data      dzepsi /   0.0015/            ! Min single Layer Thickness 
      data      dzxmin /   0.0020/            ! Min accept.Layer Thickness 
      data      dz_min /   0.0050/            ! Min Local  Layer Thickness 
      data      dz_max /   0.0300/            ! Min Gener. Layer Thickness 
C +   CAUTION:  dz_max > dz_min*2 is required ! Otherwise re-agregation is
C +                                           ! activated  after splitting


C +--Layers Agregation: IO
C +  =====================

! #vz IF (.NOT.as_opn)                                              THEN
! #vz          as_opn=.true.
! #vz     open(unit=41,status='unknown',file='SISVAT_zSn.vz')
! #vz     rewind    41
! #vz END IF


C +--Snow Properties:   IO
C +  =====================

! #vp IF (.NOT.VP_opn)                                              THEN
! #vp          VP_opn=.true.
! #vp     open(unit=47,status='unknown',file='SISVAT_GSn.vp')
! #vp     rewind    47
! #vp END IF


C +--Constrains Agregation         of too thin  Layers
C +  =================================================

C +--Search the thinest  non-zero Layer
C +  ----------------------------------

        DO ikl=1,klonv
          dzthin(ikl) = 0.                              ! Arbitrary unrealistic
        END DO                                          !       Layer Thickness 
cXF
      DO ikl=1,klonv
      DO   isn=1,isnoSV(ikl)
          isno_n    =             isnoSV(ikl)-isn+1     ! Snow Normal.Profile
          iice_n    =             iiceSV(ikl)-isn       ! Ice  Normal.Profile
          iiceOK    = min(1,max(0,iice_n         +1))   ! Ice         Switch
! #vz     dz_ref(isn) =                                 !
! #vz.          dz_min *((1-iiceOK)*isno_n*isno_n       ! Theoretical Profile
! #vz.                 +    iiceOK *    2**iice_n)      !
! #vz.               /max(1,isnoSV(ikl))                !
          dz_dif      = max(zero,                       ! Actual      Profile
     .          dz_min                                  !
     .                 *((1-iiceOK)*isno_n*isno_n       ! Theoretical Profile
     .                 +    iiceOK *2.   **iice_n)      !
     .        - dzsnSV(ikl, isn)                    )   ! Actual      Profile
! #vz     dzwdif(isn) =     dz_dif                      !
          OKthin      = max(zero,                       !
     .                      sign(unun,                  !
     .                           dz_dif-dzthin(ikl)))   ! 1.=> New thinest Lay.
     .                * max(0,                          ! 1 => .le. isnoSV
     .                  min(1,                          ! 1 => isn is in the
     .                      isnoSV(ikl)-isn +1 ))       !          Snow Pack
     .                * min(unun,                                !
!
!                       1st additional Condition to accept OKthin
     .                  max(zero,                                ! combination
     .                      sign(unun,G1snSV(ikl,      isn  )    ! G1 with same
     .                               *G1snSV(ikl,max(1,isn-1)))) !  sign => OK
!
!                       2nd additional Condition to accept OKthin
     .                + max(zero,                                ! G1>0
     .                      sign(unun,G1snSV(ikl,      isn   ))) !  =>OK
!
!                       3rd additional Condition to accept OKthin
     .                + max(zero,                                ! dz too small
     .                      sign(unun,dzxmin                     !  =>OK
     .                               -dzsnSV(ikl,      isn   ))))!

          i_thin(ikl) =    (1. - OKthin)  * i_thin(ikl) ! Update   thinest Lay.
     .                         + OKthin   * isn         !                Index
          dzthin(ikl) =    (1. - OKthin)  * dzthin(ikl) !
     .                         + OKthin   * dz_dif      !
        END DO
      END DO

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
! #vz     write(41,4150) daHost   ,n___SV(  lwriSV(1))
! #vz.                  ,i_thin(1),dzsnSV(1,i_thin(1))
 4150     format(/,'-',a18,i5,' ',70('-'),
     .           /,' Thinest ',i3,':',f9.3)

      DO ikl=1,klonv
      DO   isn=1,isnoSV(ikl)
          OKthin =      max(zero,                       !
     .                      sign(unun,                  !
     .                           dz_min                 !
     .                          -dzsnSV(ikl,isn)))      !
     .                * max(zero,                       ! ON if dz > 0
     .                      sign(unun,                  !
     .                           dzsnSV(ikl,isn)-epsi)) !
     .           *min(1,max(0,                          ! Multiple Snow    Lay.
     .                      min (1,                     ! Switch = 1
     .                           isnoSV(ikl)            !   if isno > iice + 1
     .                          -iiceSV(ikl)-1))        !
C +                                                     !
     .             +int(max(zero,                       !
     .                      sign(unun,                  !
     .                           dzepsi                 ! Minimum accepted for
     .                          -dzsnSV(ikl,isn))))     ! 1 Snow Layer over Ice
     .             *int(max(zero,                       ! ON if dz > 0
     .                      sign(unun,                  !
     .                           dzsnSV(ikl,isn)-epsi)))!
     .                 *(1 -min (abs(isnoSV(ikl)        ! Switch = 1
     .                              -iiceSV(ikl)-1),1)) !   if isno = iice + 1
C +                                                     !
     .                 +max(0,                          ! Ice
     .                      min (1,                     ! Switch
     .                           iiceSV(ikl)+1-isn)))   !
     .             *min(unun,                                    !
     .                  max(zero,                                ! combination
     .                      sign(unun,G1snSV(ikl,      isn  )    ! G1>0 + G1<0
     .                               *G1snSV(ikl,max(1,isn-1)))) ! NO
     .                + max(zero,                                !
     .                      sign(unun,G1snSV(ikl,      isn   ))) !
     .                + max(zero,                                !
     .                      sign(unun,dzxmin                     !
     .                               -dzsnSV(ikl,      isn   ))))!
          i_thin(ikl) =    (1. - OKthin)  * i_thin(ikl) ! Update   thinest Lay.
     .                         + OKthin   * isn         !                Index
        END DO
      END DO

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
! #vz     write(41,4151) i_thin(1),dzsnSV(1,i_thin(1))
! #vz.                  ,isnoSV(1),dzsnSV(1,isnoSV(1))
 4151     format(' Thinest ',i3,':',f9.3,'   Max   =',i3,f12.3)

C +--Snow Properties Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #vp   write(47,470)(G1snSV(1,isn),isn=1,isnoSV(1))
 470    format('Before _zCr1: G1 = ',10f8.1,(/,19x,10f8.1))
! #vp   write(47,472)(G2snSV(1,isn),isn=1,isnoSV(1))
 472    format('              G2 = ',10f8.1,(/,19x,10f8.1))


C +--Index of the contiguous Layer to agregate
C +  -----------------------------------------

C +   ***************
      call SISVAT_zCr
C +   ***************


C +--Assign the 2 Layers to agregate
C +  -------------------------------

        DO ikl=1,klonv
          isn         =    i_thin(ikl)
          isagr1(ikl) =    istoSV(ikl,isn)
          isagr2(ikl) =    istoSV(ikl,isn+LIndsv(ikl))
          dzagr1(ikl) =    dzsnSV(ikl,isn)
          dzagr2(ikl) =    dzsnSV(ikl,isn+LIndsv(ikl))
          T_agr1(ikl) =    TsisSV(ikl,isn)
          T_agr2(ikl) =    TsisSV(ikl,isn+LIndsv(ikl))
          roagr1(ikl) =    ro__SV(ikl,isn)
          roagr2(ikl) =    ro__SV(ikl,isn+LIndsv(ikl))
          etagr1(ikl) =    eta_SV(ikl,isn)
          etagr2(ikl) =    eta_SV(ikl,isn+LIndsv(ikl))
          G1agr1(ikl) =    G1snSV(ikl,isn)
          G1agr2(ikl) =    G1snSV(ikl,isn+LIndsv(ikl))
          G2agr1(ikl) =    G2snSV(ikl,isn)
          G2agr2(ikl) =    G2snSV(ikl,isn+LIndsv(ikl))
          agagr1(ikl) =    agsnSV(ikl,isn)
          agagr2(ikl) =    agsnSV(ikl,isn+LIndsv(ikl))
          LstLay      = min(1,max(  0,isnoSV(ikl) -1))  ! 0  if single Layer
          isnoSV(ikl) =               isnoSV(ikl)       ! decrement   isnoSV
     .     -(1-LstLay)* max(zero,                       ! if downmost  Layer
     .                      sign(unun,eps_21            ! <  1.e-21 m
     .                               -dzsnSV(ikl,1)))   !
          isnoSV(ikl) = max(   0,     isnoSV(ikl)   )   !
          Agrege(ikl) = max(zero,                       !
     .                      sign(unun,dz_min            ! No Agregation 
     .                               -dzagr1(ikl)  ))   ! if too thick Layer
     .                               *LstLay            ! if  a single Layer
     .                * min( max(0   ,isnoSV(ikl)+1     ! if Agregation
     .                               -i_thin(ikl)       !    with    a Layer
     .                               -LIndsv(ikl)  ),1) !    above the Pack

          WEagre(ikl) = 0.
        END DO


        DO ikl=1,klonv
        DO   isn=1,isnoSV(ikl)
          WEagre(ikl) = WEagre(ikl) + ro__SV(ikl,isn)*dzsnSV(ikl,isn)
     .                                *min(1,max(0,i_thin(ikl)+1-isn))
        ENDDO
        ENDDO

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
! #vz write(41,410)
 410  format(/,' Agregation of too THIN Layers')
! #vz write(41,411) (100.*dz_ref(  isn),isn=1,nsno)
! #vz write(41,412) (100.*dzwdif(  isn),isn=1,nsno)
! #vz write(41,413) (100.*dzsnSV(1,isn),isn=1,nsno)
! #vz write(41,414) (              isn ,isn=1,nsno)
 411  format(' dz_ref [cm]:',10f8.2   ,/,('             ',10f8.2) )
 412  format(' dz_dif [cm]:',10f8.2   ,/,('             ',10f8.2) )
 413  format(' dzsnSV [cm]:',10f8.2   ,/,('             ',10f8.2) )
 414  format('             ',10(i5,3x),/,('             ',10(i5,3x)))
! #vz write(41,4111)      isnoSV(1    )
! #vz write(41,4112)      i_thin(1    )
! #vz write(41,4113)      LIndsv(1    )
! #vz write(41,4114)      Agrege(1    )
! #vz write(41,4115) 1.e2*dzagr1(1    )
! #vz write(41,4116) 1.e2*dzagr2(1    )
 4111 format(' isnoSV     :',  i8  )
 4112 format(' i_thin     :',  i8  )
 4113 format(' LIndsv     :',  i8  )
 4114 format(' Agrege     :',  f8.2)
 4115 format(' dzagr1     :',  f8.2)
 4116 format(' dzagr2     :',  f8.2)

C +--Snow Properties Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #vp   write(47,471)(G1snSV(1,isn),isn=1,isnoSV(1))
 471    format('Before _zAg1: G1 = ',10f8.1,(/,19x,10f8.1))
! #vp   write(47,472)(G2snSV(1,isn),isn=1,isnoSV(1))


C +--Agregates
C +  ---------

C +     ***************
        call SISVAT_zAg
     .                 (isagr1,isagr2,WEagre
     .                 ,dzagr1,dzagr2,T_agr1,T_agr2
     .                 ,roagr1,roagr2,etagr1,etagr2
     .                 ,G1agr1,G1agr2,G2agr1,G2agr2
     .                 ,agagr1,agagr2,Agrege
     .                 )
C +     ***************


C +--Rearranges the Layers
C +  ---------------------

C +--New (agregated) Snow layer
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=1,klonv
          isn     =             i_thin(ikl)
          isn     = min(isn,isn+LIndsv(ikl))
          isnoSV(ikl) =         isnoSV(ikl) -Agrege(ikl)
          iiceSV(ikl) =         iiceSV(ikl) 
     .            -max(0,sign(1,iiceSV(ikl) -isn +icemix))
     .                                      *Agrege(ikl)
     .            *max(0,sign(1,iiceSV(ikl) -1          ))
          istoSV(ikl,isn) = (1.-Agrege(ikl))*istoSV(ikl,isn)
     .                      +   Agrege(ikl) *isagr1(ikl)
          dzsnSV(ikl,isn) = (1.-Agrege(ikl))*dzsnSV(ikl,isn)
     .                      +   Agrege(ikl) *dzagr1(ikl)
          TsisSV(ikl,isn) = (1.-Agrege(ikl))*TsisSV(ikl,isn)
     .                      +   Agrege(ikl) *T_agr1(ikl)
          ro__SV(ikl,isn) = (1.-Agrege(ikl))*ro__SV(ikl,isn)
     .                      +   Agrege(ikl) *roagr1(ikl)
          eta_SV(ikl,isn) = (1.-Agrege(ikl))*eta_SV(ikl,isn)
     .                      +   Agrege(ikl) *etagr1(ikl)
          G1snSV(ikl,isn) = (1.-Agrege(ikl))*G1snSV(ikl,isn)
     .                      +   Agrege(ikl) *G1agr1(ikl)
          G2snSV(ikl,isn) = (1.-Agrege(ikl))*G2snSV(ikl,isn)
     .                      +   Agrege(ikl) *G2agr1(ikl)
          agsnSV(ikl,isn) = (1.-Agrege(ikl))*agsnSV(ikl,isn)
     .                      +   Agrege(ikl) *agagr1(ikl)
        END DO

C +--Above
C +  ^^^^^
        DO ikl=1,klonv
          isn1(ikl)=max(i_thin(ikl),i_thin(ikl)+LIndsv(ikl))
        END DO
        DO i=  1,nsno-1
        DO ikl=1,klonv
            staggr        =  min(1,max(0,i +1 -isn1(ikl)   ))
            istoSV(ikl,i) = (1.-staggr     )*istoSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*istoSV(ikl,i  )
     .                      +   Agrege(ikl) *istoSV(ikl,i+1))
            dzsnSV(ikl,i) = (1.-staggr     )*dzsnSV(ikl,i  ) 
     .            + staggr*((1.-Agrege(ikl))*dzsnSV(ikl,i  )
     .                      +   Agrege(ikl) *dzsnSV(ikl,i+1))
            TsisSV(ikl,i) = (1.-staggr     )*TsisSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*TsisSV(ikl,i  )
     .                      +   Agrege(ikl) *TsisSV(ikl,i+1))
            ro__SV(ikl,i) = (1.-staggr     )*ro__SV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*ro__SV(ikl,i  )
     .                      +   Agrege(ikl) *ro__SV(ikl,i+1))
            eta_SV(ikl,i) = (1.-staggr     )*eta_SV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*eta_SV(ikl,i  )
     .                      +   Agrege(ikl) *eta_SV(ikl,i+1))
            G1snSV(ikl,i) = (1.-staggr     )*G1snSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*G1snSV(ikl,i  )
     .                      +   Agrege(ikl) *G1snSV(ikl,i+1))
            G2snSV(ikl,i) = (1.-staggr     )*G2snSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*G2snSV(ikl,i  )
     .                      +   Agrege(ikl) *G2snSV(ikl,i+1))
            agsnSV(ikl,i) = (1.-staggr     )*agsnSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*agsnSV(ikl,i  )
     .                      +   Agrege(ikl) *agsnSV(ikl,i+1))
        END DO
        END DO

        DO ikl=1,klonv
          isn             = min(isnoSV(ikl) +1,nsno)
          istoSV(ikl,isn) = (1.-Agrege(ikl))*istoSV(ikl,isn)
          dzsnSV(ikl,isn) = (1.-Agrege(ikl))*dzsnSV(ikl,isn)
          TsisSV(ikl,isn) = (1.-Agrege(ikl))*TsisSV(ikl,isn)
          ro__SV(ikl,isn) = (1.-Agrege(ikl))*ro__SV(ikl,isn)
          eta_SV(ikl,isn) = (1.-Agrege(ikl))*eta_SV(ikl,isn)
          G1snSV(ikl,isn) = (1.-Agrege(ikl))*G1snSV(ikl,isn)
          G2snSV(ikl,isn) = (1.-Agrege(ikl))*G2snSV(ikl,isn)
          agsnSV(ikl,isn) = (1.-Agrege(ikl))*agsnSV(ikl,isn)
        END DO

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx   IF (ikl .EQ. kSV_v1 .AND. lSV_v1 .EQ. 3)                    THEN
! #wx     write(6,5991) i_thin(ikl)
 5991     format(/,'First Agregation / Layer',i3,
     .           /,'  i',11x,'T',9x,'rho',10x,'dz',11x,'H')
! #wx     write(6,5995) (isn,TsisSV(ikl,isn),ro__SV(ikl,isn)
! #wx.                      ,dzsnSV(ikl,isn),istoSV(ikl,isn),
! #wx.                   isn=isnoSV(ikl),1,-1)
 5995     format(i3,3f12.3,i12)
! #wx   END IF


C +--Constrains Splitting          of too thick Layers
C +  =================================================


C +--Search the thickest non-zero Layer
C +  ----------------------------------

        DO ikl=1,klonv
          dzthin(ikl) =   0.                            ! Arbitrary unrealistic
        END DO 
      DO ikl=1,klonv
        DO   isn=1,isnoSV(ikl)
          isno_n    =             isnoSV(ikl)-isn+1     ! Snow Normal.Profile
          iice_n    =             iiceSV(ikl)-isn       ! Ice  Normal.Profile
          iiceOK    = min(1,max(0,iice_n         +1))   ! Ice         Switch
          dz_dif    =(      dzsnSV(ikl,isn)             ! Actual      Profile
     .        - dz_max *((1-iiceOK)*isno_n*isno_n       ! Theoretical Profile
     .                 +    iiceOK *2.   **iice_n)  )   !
     .                 /max(dzsnSV(ikl,isn),epsi)       !
          OKthin      = max(zero,                       !
     .                      sign(unun,                  !
     .                           dz_dif-dzthin(ikl)))   ! 1.=>New thickest Lay.
     .                * max(0,                          ! 1 =>.le. isnoSV
     .                  min(1,                          !
     .                      isnoSV(ikl)-isn +1 ))       !
          i_thin(ikl) =    (1. - OKthin)  * i_thin(ikl) !  Update thickest Lay.
     .                         + OKthin   * isn         !                Index
          dzthin(ikl) =    (1. - OKthin)  * dzthin(ikl) !
     .                         + OKthin   * dz_dif      !
        END DO
      END DO

      DO   ikl=1,klonv
          ThickL      = max(zero,                       ! 1. => a too   thick
     .                      sign(unun,dzthin(ikl)       !         Layer exists
     .                               -epsi       ))     !
     .        * max(0,1-max(0   ,     isnoSV(ikl)       ! No spliting allowed
     .                               -nsno+3     ))     ! if isno > nsno - 3
          Agrege(ikl) =               ThickL            ! 1. => effective split
     .        * max(0,1-max(0   ,     NLaysv(ikl)       !
     .                               +isnoSV(ikl)       !
     .                               -nsno+1     ))     ! 
          NLay_s(ikl) =               ThickL            ! Agregation
     .        * max(0,1-max(0   ,     NLaysv(ikl)       ! to allow  Splitting 
     .                               +isnoSV(ikl)       !   at next Time Step
     .                               -nsno       ))     !
     .                               -Agrege(ikl)       ! 
          NLay_s(ikl) = max(0   ,     NLay_s(ikl))      ! Agregation effective
      END DO

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
! #vz     write(41,4152) i_thin(1),dzthin(1),ThickL
 4152     format(/,' Thickest',i3,':',f9.3,'   Split =',f4.0)


C +--Rearranges the Layers
C +  ---------------------

      DO isn=nsno,2,-1
      DO ikl=1,klonv
        IF (Agrege(ikl).gt.0..AND.i_thin(ikl).lt.isnoSV(ikl))       THEN
          staggr          =  min(1,max(0,isn-i_thin(ikl)    -1))
     .                    *  min(1,max(0,    isnoSV(ikl)-isn+2))
          istoSV(ikl,isn) =        staggr  * istoSV(ikl ,isn-1)
     .                    + (1. -  staggr) * istoSV(ikl ,isn  )
          dzsnSV(ikl,isn) =        staggr  * dzsnSV(ikl ,isn-1)
     .                    + (1. -  staggr) * dzsnSV(ikl ,isn  )
          TsisSV(ikl,isn) =        staggr  * TsisSV(ikl ,isn-1)
     .                    + (1. -  staggr) * TsisSV(ikl ,isn  )
          ro__SV(ikl,isn) =        staggr  * ro__SV(ikl ,isn-1)
     .                    + (1. -  staggr) * ro__SV(ikl ,isn  )
          eta_SV(ikl,isn) =        staggr  * eta_SV(ikl ,isn-1)
     .                    + (1. -  staggr) * eta_SV(ikl ,isn  )
          G1snSV(ikl,isn) =        staggr  * G1snSV(ikl ,isn-1)
     .                    + (1. -  staggr) * G1snSV(ikl ,isn  )
          G2snSV(ikl,isn) =        staggr  * G2snSV(ikl ,isn-1)
     .                    + (1. -  staggr) * G2snSV(ikl ,isn  )
          agsnSV(ikl,isn) =        staggr  * agsnSV(ikl ,isn-1)
     .                    + (1. -  staggr) * agsnSV(ikl ,isn  )
        END IF
      END DO
      END DO

      DO  ikl=1,klonv
          isn             =     i_thin(ikl)
          dzsnSV(ikl,isn) = 0.5*Agrege(ikl) *dzsnSV(ikl,isn)
     .                    + (1.-Agrege(ikl))*dzsnSV(ikl,isn)

          isn             = min(i_thin(ikl) +1,nsno)
          istoSV(ikl,isn) =     Agrege(ikl) *istoSV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*istoSV(ikl,isn)
          dzsnSV(ikl,isn) =     Agrege(ikl) *dzsnSV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*dzsnSV(ikl,isn)
          TsisSV(ikl,isn) =     Agrege(ikl) *TsisSV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*TsisSV(ikl,isn)
          ro__SV(ikl,isn) =     Agrege(ikl) *ro__SV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*ro__SV(ikl,isn)
          eta_SV(ikl,isn) =     Agrege(ikl) *eta_SV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*eta_SV(ikl,isn)
          G1snSV(ikl,isn) =     Agrege(ikl) *G1snSV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*G1snSV(ikl,isn)
          G2snSV(ikl,isn) =     Agrege(ikl) *G2snSV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*G2snSV(ikl,isn)
          agsnSV(ikl,isn) =     Agrege(ikl) *agsnSV(ikl,isn-1)
     .                    + (1.-Agrege(ikl))*agsnSV(ikl,isn)
          isnoSV(ikl)     =     Agrege(ikl) +isnoSV(ikl)
          iiceSV(ikl)     =                  iiceSV(ikl)
     .                    +     Agrege(ikl) *max(0,sign(1,iiceSV(ikl) 
     .                                                   -isn +icemix))
     .                                      *max(0,sign(1,iiceSV(ikl) 
     .                                                   -1          ))
      END DO


C +--Constrains Agregation in case of too much  Layers
C +  =================================================

C +--Search the thinest   non-zero Layer
C +  -----------------------------------

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
c #La     write( 6,*)   ' '
c #La     write( 6,*)   'Agregation 2'
c #La     write( 6,6000) NLaysv(1)
 6000     format(i3,6x,
     .          'dzsnSV      dz_min      dz_dif      ',
     .          'OKthin      dzthin   i_thin')

        DO ikl=1,klonv
          dzthin(ikl) =   0.                            ! Arbitrary unrealistic
        END DO                                          !       Layer Thickness 
      DO ikl=1,klonv
        DO isn=1,isnoSV(ikl)
          isno_n    =             isnoSV(ikl)-isn+1     ! Snow Normal.Profile
          iice_n    =             iiceSV(ikl)-isn       ! Ice  Normal.Profile
          iiceOK    = min(1,max(0,iice_n         +1))   ! Ice         Switch
! #vz     dz_ref(isn) =                                 !
! #vz.          dz_min *((1-iiceOK)*isno_n*isno_n       ! Theoretical Profile
! #vz.                 +    iiceOK *    2**iice_n)      !
! #vz.               /max(1,isnoSV(ikl))                !
          dz_dif      =     dz_min                      ! Actual      Profile
     .                    - dzsnSV(ikl    ,isn)         !
     .        /max(epsi,((1-iiceOK)*isno_n*isno_n       ! Theoretical Profile
     .                 +    iiceOK *2.   **iice_n))     !
! #vz     dzwdif(isn) =     dz_dif                      !
          OKthin      = max(zero,                       !
     .                      sign(unun,                  !
     .                           dz_dif  - dzthin(ikl)))! 1.=> New thinest Lay.
     .                * max(0,                          ! 1 => .le. isnoSV
     .                  min(1,                          !
     .                      isnoSV(ikl)-isn +1 ))       !
          i_thin(ikl) =    (1. - OKthin) * i_thin(ikl)  ! Update   thinest Lay.
     .                         + OKthin  * isn          !                Index
          dzthin(ikl) =    (1. - OKthin) * dzthin(ikl)  !
     .                         + OKthin  * dz_dif       !

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
c #La   IF(isn.LE.isnoSV(1).AND.ikl.EQ.1)
c #La.    write( 6,6001) isn,dzsnSV(ikl,isn),dz_min*isno_n*isno_n,dz_dif
c #La.               ,OKthin,dzthin(ikl),    i_thin(ikl)
 6001     format(i3,5f12.6,i9)

        END DO
      END DO

c #La     write( 6,*)   ' '

! #vz     write(41,4153) i_thin(1),dzsnSV(1,i_thin(1))
 4153     format(/,' Thinest ',i3,':',f9.3)

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
! #vz     write(41,4151) i_thin(1),dzsnSV(1,i_thin(1))
! #vz.                  ,isnoSV(1),dzsnSV(1,isnoSV(1))

C +--Snow Properties Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #vp   write(47,473)(G1snSV(1,isn),isn=1,isnoSV(1))
 473    format('Before _zCr2: G1 = ',10f8.1,(/,19x,10f8.1))
! #vp   write(47,472)(G2snSV(1,isn),isn=1,isnoSV(1))


C +--Index of the contiguous Layer to agregate
C +  -----------------------------------------

C +   ***************
      call SISVAT_zCr
C +   ***************


C +--Assign the 2 Layers to agregate
C +  -------------------------------

        DO ikl=1,klonv
          isn         =    i_thin(ikl)
          isagr1(ikl) =    istoSV(ikl,isn)
          isagr2(ikl) =    istoSV(ikl,isn+LIndsv(ikl))
          dzagr1(ikl) =    dzsnSV(ikl,isn)
          dzagr2(ikl) =    dzsnSV(ikl,isn+LIndsv(ikl))
          T_agr1(ikl) =    TsisSV(ikl,isn)
          T_agr2(ikl) =    TsisSV(ikl,isn+LIndsv(ikl))
          roagr1(ikl) =    ro__SV(ikl,isn)
          roagr2(ikl) =    ro__SV(ikl,isn+LIndsv(ikl))
          etagr1(ikl) =    eta_SV(ikl,isn)
          etagr2(ikl) =    eta_SV(ikl,isn+LIndsv(ikl))
          G1agr1(ikl) =    G1snSV(ikl,isn)
          G1agr2(ikl) =    G1snSV(ikl,isn+LIndsv(ikl))
          G2agr1(ikl) =    G2snSV(ikl,isn)
          G2agr2(ikl) =    G2snSV(ikl,isn+LIndsv(ikl))
          agagr1(ikl) =    agsnSV(ikl,isn)
          agagr2(ikl) =    agsnSV(ikl,isn+LIndsv(ikl))
          LstLay      = min(1,max(  0,    isnoSV(ikl)-1   ))
          Agrege(ikl) = min(1,
     .                  max(0,
     .                      NLaysv(ikl)   +isnoSV(ikl)-nsno
     .                     +NLay_s(ikl)                    )
     .                                    *LstLay           )
          isnoSV(ikl) =                    isnoSV(ikl)
     .     -(1-LstLay)*max(zero,
     .                     sign(unun,      eps_21
     .                                    -dzsnSV(ikl,1)   ))
          isnoSV(ikl) =max(   0,           isnoSV(ikl)      )

          WEagre(ikl) = 0.
        END DO

        DO isn=1,nsno
        DO ikl=1,klonv
          WEagre(ikl) = WEagre(ikl) + ro__SV(ikl,isn)*dzsnSV(ikl,isn)
     .                                *min(1,max(0,i_thin(ikl)+1-isn))
        ENDDO
        ENDDO

C +--Layers Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~
! #vz write(41,4120)
 4120 format(' Agregation of too MUCH Layers')
! #vz write(41,411) (100.*dz_ref(  isn),isn=1,nsno)
! #vz write(41,412) (100.*dzwdif(  isn),isn=1,nsno)
! #vz write(41,413) (100.*dzsnSV(1,isn),isn=1,nsno)
! #vz write(41,414) (              isn ,isn=1,nsno)
! #vz write(41,4111)      isnoSV(1    )
! #vz write(41,4112)      i_thin(1    )
! #vz write(41,4113)      LIndsv(1    )
! #vz write(41,4114)      Agrege(1    )

C +--Snow Properties Agregation: IO
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #vp   write(47,474)(G1snSV(1,isn),isn=1,isnoSV(1))
 474    format('Before _zAg2: G1 = ',10f8.1,(/,19x,10f8.1))
! #vp   write(47,472)(G2snSV(1,isn),isn=1,isnoSV(1))


C +--Agregates
C +  ---------

C +     ***************
        call SISVAT_zAg
     .                 (isagr1,isagr2,WEagre
     .                 ,dzagr1,dzagr2,T_agr1,T_agr2
     .                 ,roagr1,roagr2,etagr1,etagr2
     .                 ,G1agr1,G1agr2,G2agr1,G2agr2
     .                 ,agagr1,agagr2,Agrege
     .                 )
C +     ***************


C +--Rearranges the Layers
C +  ---------------------

C +--New (agregated) Snow layer
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=1,klonv
          isn     =             i_thin(ikl)
          isn     = min(isn,isn+LIndsv(ikl))
          isnoSV(ikl) =         isnoSV(ikl) -Agrege(ikl)
          iiceSV(ikl) =         iiceSV(ikl) 
     .            -max(0,sign(1,iiceSV(ikl) -isn +icemix))
     .                                      *Agrege(ikl)
     .            *max(0,sign(1,iiceSV(ikl) -1          ))
          istoSV(ikl,isn) = (1.-Agrege(ikl))*istoSV(ikl,isn)
     .                      +   Agrege(ikl) *isagr1(ikl)
          dzsnSV(ikl,isn) = (1.-Agrege(ikl))*dzsnSV(ikl,isn)
     .                      +   Agrege(ikl) *dzagr1(ikl)
          TsisSV(ikl,isn) = (1.-Agrege(ikl))*TsisSV(ikl,isn)
     .                      +   Agrege(ikl) *T_agr1(ikl)
          ro__SV(ikl,isn) = (1.-Agrege(ikl))*ro__SV(ikl,isn)
     .                      +   Agrege(ikl) *roagr1(ikl)
          eta_SV(ikl,isn) = (1.-Agrege(ikl))*eta_SV(ikl,isn)
     .                      +   Agrege(ikl) *etagr1(ikl)
          G1snSV(ikl,isn) = (1.-Agrege(ikl))*G1snSV(ikl,isn)
     .                      +   Agrege(ikl) *G1agr1(ikl)
          G2snSV(ikl,isn) = (1.-Agrege(ikl))*G2snSV(ikl,isn)
     .                      +   Agrege(ikl) *G2agr1(ikl)
          agsnSV(ikl,isn) = (1.-Agrege(ikl))*agsnSV(ikl,isn)
     .                      +   Agrege(ikl) *agagr1(ikl)
        END DO

C +--Above
C +  ^^^^^
        DO ikl=1,klonv
          isn1(ikl)=max(i_thin(ikl),i_thin(ikl)+LIndsv(ikl))
        END DO
        DO i=  1,nsno-1
        DO ikl=1,klonv
            staggr        =  min(1,max(0,i +1 -isn1(ikl)   ))
            istoSV(ikl,i) = (1.-staggr     )*istoSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*istoSV(ikl,i  )
     .                      +   Agrege(ikl) *istoSV(ikl,i+1))
            dzsnSV(ikl,i) = (1.-staggr     )*dzsnSV(ikl,i  ) 
     .            + staggr*((1.-Agrege(ikl))*dzsnSV(ikl,i  )
     .                      +   Agrege(ikl) *dzsnSV(ikl,i+1))
            TsisSV(ikl,i) = (1.-staggr     )*TsisSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*TsisSV(ikl,i  )
     .                      +   Agrege(ikl) *TsisSV(ikl,i+1))
            ro__SV(ikl,i) = (1.-staggr     )*ro__SV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*ro__SV(ikl,i  )
     .                      +   Agrege(ikl) *ro__SV(ikl,i+1))
            eta_SV(ikl,i) = (1.-staggr     )*eta_SV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*eta_SV(ikl,i  )
     .                      +   Agrege(ikl) *eta_SV(ikl,i+1))
            G1snSV(ikl,i) = (1.-staggr     )*G1snSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*G1snSV(ikl,i  )
     .                      +   Agrege(ikl) *G1snSV(ikl,i+1))
            G2snSV(ikl,i) = (1.-staggr     )*G2snSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*G2snSV(ikl,i  )
     .                      +   Agrege(ikl) *G2snSV(ikl,i+1))
            agsnSV(ikl,i) = (1.-staggr     )*agsnSV(ikl,i  )
     .            + staggr*((1.-Agrege(ikl))*agsnSV(ikl,i  )
     .                      +   Agrege(ikl) *agsnSV(ikl,i+1))
        END DO
        END DO

        DO ikl=1,klonv
          isn             = min(isnoSV(ikl) +1,nsno)
          istoSV(ikl,isn) = (1.-Agrege(ikl))*istoSV(ikl,isn)
          dzsnSV(ikl,isn) = (1.-Agrege(ikl))*dzsnSV(ikl,isn)
          TsisSV(ikl,isn) = (1.-Agrege(ikl))*TsisSV(ikl,isn)
          ro__SV(ikl,isn) = (1.-Agrege(ikl))*ro__SV(ikl,isn)
          eta_SV(ikl,isn) = (1.-Agrege(ikl))*eta_SV(ikl,isn)
          G1snSV(ikl,isn) = (1.-Agrege(ikl))*G1snSV(ikl,isn)
          G2snSV(ikl,isn) = (1.-Agrege(ikl))*G2snSV(ikl,isn)
          agsnSV(ikl,isn) = (1.-Agrege(ikl))*agsnSV(ikl,isn)
        END DO

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx   IF  (kSV_v1.GT.0 .AND. lSV_v1.EQ.3)                         THEN
! #wx     write(6,5992) i_thin(kSV_v1)
 5992     format(/,'Secnd Agregation / Layer',i3,
     .           /,'  i',11x,'T',9x,'rho',10x,'dz',11x,'H')
! #wx     write(6,5995) (isn,TsisSV(kSV_v1,isn),ro__SV(kSV_v1,isn)
! #wx.                      ,dzsnSV(kSV_v1,isn),istoSV(kSV_v1,isn),
! #wx.                   isn=isnoSV(kSV_v1),1,-1)
! #wx   ENDIF

! #vp   write(47,475)(G1snSV(1,isn),isn=1,isnoSV(1))
 475    format('At End _zSn : G1 = ',10f8.1,(/,19x,10f8.1))
! #vp   write(47,472)(G2snSV(1,isn),isn=1,isnoSV(1))


C +--Search new Ice/Snow Interface
C +  =============================

c #II   DO ikl=1,klonv
c #II     iiceSV(ikl) =  0
c #II   END DO

c #II   DO ikl=1,klonv
c #II   DO   isn=1,isnoSV(ikl)
c #II     OK_ICE      = max(zero,sign(unun,ro__SV(ikl,isn)-ro_ice+20.))
c #II.                * max(zero,sign(unun,dzsnSV(ikl,isn)-epsi))
c #II     iiceSV(ikl) = (1.-OK_ICE)       *iiceSV(ikl)
c #II.                +     OK_ICE        *isn
c #II   END DO
c #II   END DO

      return 
      end


      subroutine SISVAT_zCr
C +
C +------------------------------------------------------------------------+
C | MAR          SISVAT_zCr                                12-12-2002  MAR |
C |   SubRoutine SISVAT_zCr determines criteria for Layers Agregation      |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT /  isnoSV   = total Nb of Ice/Snow Layers                      |
C |   OUTPUT:  iiceSV   = total Nb of Ice      Layers                      |
C |   ^^^^^^   ispiSV   = 0,...,nsno: Uppermost Superimposed Ice Layer     |
C |            istoSV   = 0,...,5 :   Snow     History (see istdSV data)   |
C |                                                                        |
C |   INPUT /  ro__SV   : Soil/Snow Volumic Mass                   [kg/m3] |
C |   OUTPUT:           & Snow     Temperatures (layers  1,2,...,nsno) [K] |
C |   ^^^^^^   G1snSV   : Dendricity (<0) or Sphericity (>0) of Snow Layer |
C |            G2snSV   : Sphericity (>0) or Size            of Snow Layer |
C |            agsnSV   : Snow       Age                             [day] |
C |                                                                        |
C |   OUTPUT:  LIndsv   : Relative Index of a contiguous Layer to agregate |
C |   ^^^^^^                                                               |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"
C +
      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)
C +
C +
C +--Internal Variables
C +  ==================
C +
      integer   ikl   ,isn   ,is0   ,is1
      integer   isno_1                        ! Switch:  ! Snow Layer over Ice
      real      Dtyp_0,Dtyp_1                 ! Snow Grains Difference Measure
      real      DenSph                        ! 1. when contiguous spheric
C +                                           !     and dendritic  Grains
      real      DendOK                        ! 1. when dendritic  Grains
      real      dTypMx                        ! Grain Type Differ.
      real      dTypSp                        ! Sphericity Weight
      real      dTypRo                        ! Density    Weight
      real      dTypDi                        ! Grain Diam.Weight
      real      dTypHi                        ! History    Weight


C +--DATA
C +  ====

      data      dTypMx / 200.0  /             ! Grain Type Weight 
      data      dTypSp /   0.5  /             ! Sphericity Weight
      data      dTypRo /   0.5  /             ! Density    Weight
      data      dTypDi /  10.0  /             ! Grain Diam.Weight
      data      dTypHi / 100.0  /             ! History    Weight


C +--Agregation Criteria
C +  ===================
C +
      DO  ikl=1,klonv
          i_thin(ikl) = min(i_thin(ikl),isnoSV(ikl))
          isn         = max(1          ,i_thin(ikl))
C +
C +
C +--Comparison with the downward Layer
C +  ----------------------------------
C +
          is0    = max(1,        i_thin(ikl)-1 )        ! Downward Layer Index
          DenSph = max(zero,                            ! isn/is1
     .                 sign(unun,                       ! Dendricity/Sphericity
     .                      epsi-G1snSV(ikl,isn)        !            Switch
     .                          *G1snSV(ikl,is0)))      !
          DendOK = max(zero,                            ! Dendricity Switch
     .                 sign(unun,                       !
     .                      epsi-G1snSV(ikl,isn)))      !
C +
          Dtyp_0 =
     .         DenSph *      dTypMx
     .    +(1.-DenSph)
     .    *    DendOK *((abs(G1snSV(ikl,isn)            ! Dendricity
     .                      -G1snSV(ikl,is0))           !     Contribution
     .                  +abs(G2snSV(ikl,isn)            ! Sphericity
     .                      -G2snSV(ikl,is0))) *dTypSp  !     Contribution
     .                  +abs(ro__SV(ikl,isn)            ! Density
     .                      -ro__SV(ikl,is0))  *dTypRo) !     Contribution
     .    +(1.-DenSph)                                  !
     .    *(1.-DendOK)*((abs(G1snSV(ikl,isn)            ! Sphericity
     .                      -G1snSV(ikl,is0))           !     Contribution
     .                  +abs(G2snSV(ikl,isn)            ! Size
     .                      -G2snSV(ikl,is0))) *dTypDi  !     Contribution
     .                  +abs(ro__SV(ikl,isn)            ! Density
     .                      -ro__SV(ikl,is0))  *dTypRo) !     Contribution
          Dtyp_0 =                                      !
     .                   min(dTypMx,                    !
     .                       Dtyp_0                     !
     .                  +abs(istoSV(ikl,isn)            ! History
     .                      -istoSV(ikl,is0))  *dTypHi) !     Contribution
     .        +             (1 -abs(isn-is0))  * 1.e+6  !"Same Layer"Score
     .        +  max(0,1-abs(iiceSV(ikl)                !"Ice /Snow
     .                                 -is0))  * 1.e+6  ! Interface" Score
C +
C +
C +--Comparison with the   upward Layer
C +  ----------------------------------
C +
          is1    = min(          i_thin(ikl)+1,         ! Upward   Layer Index
     .                 max(1,    isnoSV(ikl)  ))        !
          DenSph = max(zero,                            ! isn/is1
     .                 sign(unun,                       ! Dendricity/Sphericity
     .                      epsi-G1snSV(ikl,isn)        !            Switch
     .                          *G1snSV(ikl,is1)))      !
          DendOK = max(zero,                            ! Dendricity Switch
     .                 sign(unun,                       !
     .                      epsi-G1snSV(ikl,isn)))      !
C +
          Dtyp_1 = 
     .         DenSph *      dTypMx
     .    +(1.-DenSph)
     .    *    DendOK *((abs(G1snSV(ikl,isn)            ! Dendricity
     .                      -G1snSV(ikl,is1))           !     Contribution
     .                  +abs(G2snSV(ikl,isn)            ! Sphericity
     .                      -G2snSV(ikl,is1))) *dTypSp  !     Contribution
     .                  +abs(ro__SV(ikl,isn)            ! Density
     .                      -ro__SV(ikl,is1))  *dTypRo) !     Contribution
     .    +(1.-DenSph)                                  !
     .    *(1.-DendOK)*((abs(G1snSV(ikl,isn)            ! Sphericity
     .                      -G1snSV(ikl,is1))           !     Contribution
     .                  +abs(G2snSV(ikl,isn)            ! Size
     .                      -G2snSV(ikl,is1))) *dTypDi  !     Contribution
     .                  +abs(ro__SV(ikl,isn)            ! Density
     .                      -ro__SV(ikl,is1))  *dTypRo) !     Contribution
          Dtyp_1 =                                      !
     .                   min(dTypMx,                    !
     .                       Dtyp_1                     !
     .                  +abs(istoSV(ikl,isn)            ! History
     .                      -istoSV(ikl,is1))  *dTypHi) !     Contribution
     .        +             (1 -abs(isn-is1))  * 1.e+6  !"Same Layer"Score
     .        +  max(0,1-abs(iiceSV(ikl)                !"Ice /Snow
     .                                 -isn))  * 1.e+6  ! Interface" Score
C +
C +
C +--Index of the Layer to agregate
C +  ==============================
C +
          LIndsv(ikl) = sign(unun,Dtyp_0    
     .                           -Dtyp_1)
          isno_1      = (1 -min (abs(isnoSV(ikl)        ! Switch = 1
     .                              -iiceSV(ikl)-1),1)) !   if isno = iice +1
     .                * (1 -min (abs(isnoSV(ikl)        ! Switch = 1
     .                              -i_thin(ikl)  ),1)) !   if isno = i_ithin
          LIndsv(ikl) = (1 -isno_1) *LIndsv(ikl)        ! Contiguous Layer is
     .                     -isno_1                      ! downward for top L.
          i_thin(ikl) =  max(1,   i_thin(ikl)   )
      END DO
C +
      return 
      end


      subroutine SISVAT_zAg
     .                     (isagra,isagrb,WEagra
     .                     ,dzagra,dzagrb,T_agra,T_agrb
     .                     ,roagra,roagrb,etagra,etagrb
     .                     ,G1agra,G1agrb,G2agra,G2agrb
     .                     ,agagra,agagrb,Agreg1
     .                     )

C +------------------------------------------------------------------------+
C | MAR SURFACE                                       Sat 30-Apr-2004  MAR |
C |   SubRoutine SISVAT_zAg aggregates two contiguous snow layers          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   isagrb   : 2nd     Layer History                            |
C |   ^^^^^                                                                |
C |                                                                        |
C |   INPUT:   dzagrb   : 2nd     Layer Thickness                          |
C |   ^^^^^    T_agrb   : 2nd     Layer Temperature                        |
C |            roagrb   : 2nd     Layer Density                            |
C |            etagrb   : 2nd     Layer Water Content                      |
C |            G1agrb   : 2nd     Layer Dendricity/Spher.                  |
C |            G2agrb   : 2nd     Layer Sphericity/Size                    |
C |            agagrb   : 2nd     Age                                      |
C |            Agreg1   : 1. when Agregation constrained                   |
C |                                                                        |
C |   INPUT /  isagra   : 1st     Layer History                            |
C |   OUTPUT:                                                              |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   INPUT /  dzagra   : 1st     Layer Thickness                          |
C |   OUTPUT:  T_agra   : 1st     Layer Temperature                        |
C |   ^^^^^^   roagra   : 1st     Layer Density                            |
C |            etagra   : 1st     Layer Water Content                      |
C |            G1agra   : 1st     Layer Dendricity/Spher.                  |
C |            G2agra   : 1st     Layer Sphericity/Size                    |
C |            agagra   : 1st     Age                                      |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"
      include  "MARxSV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/)

C +--INPUT
C +  -----

      integer   isagrb(klonv)                 ! 2nd Layer History
      real      dzagrb(klonv)                 ! 2nd Layer Thickness
      real      T_agrb(klonv)                 ! 2nd Layer Temperature
      real      roagrb(klonv)                 ! 2nd Layer Density
      real      etagrb(klonv)                 ! 2nd Layer Water Content
      real      G1agrb(klonv)                 ! 2nd Layer Dendricity/Spher.
      real      G2agrb(klonv)                 ! 2nd Layer Sphericity/Size
      real      agagrb(klonv)                 ! 2nd Layer Age


C +--INPUT/OUTPUT
C +  ------------

      integer   isagra(klonv)                 ! 1st Layer History
      real      WEagra(klonv)                 ! 1st Layer Height    [mm w.e.]
      real      Agreg1(klonv)                 ! 1. ===>   Agregates 
      real      dzagra(klonv)                 ! 1st Layer Thickness
      real      T_agra(klonv)                 ! 1st Layer Temperature
      real      roagra(klonv)                 ! 1st Layer Density
      real      etagra(klonv)                 ! 1st Layer Water Content
      real      G1agra(klonv)                 ! 1st Layer Dendricity/Spher.
      real      G2agra(klonv)                 ! 1st Layer Sphericity/Size
      real      agagra(klonv)                 ! 1st Layer Age


C +--Internal Variables
C +  ==================

      integer   ikl
      integer   nh                            ! Averaged    Snow History
      integer   nh__OK                        ! 1=>Conserve Snow History
      real      rh                            !
      real      dz                            ! Thickness
      real      dzro_1                        ! Thickness X Density, Lay.1
      real      dzro_2                        ! Thickness X Density, Lay.2
      real      dzro                          ! Thickness X Density, Aver.
      real      ro                            ! Averaged    Density
      real      wn                            ! Averaged    Water Content
      real      tn                            ! Averaged    Temperature
      real      ag                            ! Averaged    Snow Age
      real      SameOK                        ! 1. => Same Type of Grains
      real      G1same                        ! Averaged G1,  same Grains
      real      G2same                        ! Averaged G2,  same Grains
      real      typ__1                        ! 1. => Lay1 Type: Dendritic
      real      zroNEW                        ! dz X ro, if fresh Snow
      real      G1_NEW                        ! G1,      if fresh Snow
      real      G2_NEW                        ! G2,      if fresh Snow
      real      zroOLD                        ! dz X ro, if old   Snow
      real      G1_OLD                        ! G1,      if old   Snow
      real      G2_OLD                        ! G2,      if old   Snow
      real      SizNEW                        ! Size,    if fresh Snow
      real      SphNEW                        ! Spheric.,if fresh Snow
      real      SizOLD                        ! Size,    if old   Snow
      real      SphOLD                        ! Spheric.,if old   Snow
      real      Siz_av                        ! Averaged    Grain Size
      real      Sph_av                        ! Averaged    Grain Spher.
      real      Den_av                        ! Averaged    Grain Dendr.
      real      DendOK                        ! 1. => Average is  Dendr.
      real      G1diff                        ! Averaged G1, diff. Grains
      real      G2diff                        ! Averaged G2, diff. Grains
      real      G1                            ! Averaged G1
      real      G2                            ! Averaged G2

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx integer                iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1
! #wx common  /SISVAT_EV/    iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1


C +--Mean   Properties
C +  =================

C +-- 1 Densite, Contenu en Eau, Temperature / 
C +     Density, Water Content,  Temperature
C +     ------------------------------------

      DO ikl = 1,klonv
          dz      =  dzagra(ikl) + dzagrb(ikl)
          dzro_1  =  roagra(ikl) * dzagra(ikl)
          dzro_2  =  roagrb(ikl) * dzagrb(ikl)
          dzro    =  dzro_1      + dzro_2
          ro      =  dzro                                     
     .     /max(epsi,dz)
          wn      = (dzro_1*etagra(ikl) + dzro_2*etagrb(ikl)) 
     .     /max(epsi,dzro)
          tn      = (dzro_1*T_agra(ikl) + dzro_2*T_agrb(ikl)) 
     .     /max(epsi,dzro)
          ag      = (dzro_1*agagra(ikl) + dzro_2*agagrb(ikl)) 
     .     /max(epsi,dzro)

          rh      =  max(zero,sign(unun,zWEcSV(ikl)
     .                                         -0.5*WEagra(ikl)))
          nh__OK  =  rh
          nh      =                 max(isagra(ikl),isagrb(ikl))
c #HB.            *  nh__OK
c #HB.          + (1-nh__OK)*       min(isagra(ikl),isagrb(ikl))

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx   IF (ikl .EQ. kSV_v1 .AND. lSV_v1 .EQ. 3)                    THEN
! #wx     write(6,5995) zWEcSV(ikl),WEagra(ikl)
! #wx.                 ,isagra(ikl),isagrb(ikl)
! #wx.                 ,nh__OK     ,nh
 5995     format(' WE2,WEa =',2f9.1,'  nha,b =',2i2,'  nh__OK,nh =',2i2)
! #wx   END IF


C +-- 2 Nouveaux Types de Grains /  new Grain Types
C +     -------------------------------------------

C +-- 2.1. Meme  Type  de Neige  / same Grain Type
C +        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          SameOK  =  max(zero,
     .                   sign(unun, G1agra(ikl) *G1agrb(ikl)  - eps_21))
          G1same  = (dzro_1*G1agra(ikl) + dzro_2*G1agrb(ikl)) 
     .     /max(epsi,dzro)
          G2same  = (dzro_1*G2agra(ikl) + dzro_2*G2agrb(ikl)) 
     .     /max(epsi,dzro)

C +-- 2.2. Types differents / differents Types
C +        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          typ__1  =  max(zero,sign(unun,epsi-G1agra(ikl))) ! =1.=> Dendritic
          zroNEW  =     typ__1  *dzro_1                    ! ro of Dendr.Lay.
     .            + (1.-typ__1) *dzro_2                    !
          G1_NEW  =     typ__1  *G1agra(ikl)               ! G1 of Dendr.Lay.
     .            + (1.-typ__1) *G1agrb(ikl)               !
          G2_NEW  =     typ__1  *G2agra(ikl)               ! G2 of Dendr.Lay.
     .            + (1.-typ__1) *G2agrb(ikl)               !
          zroOLD  = (1.-typ__1) *dzro_1                    ! ro of Spher.Lay.
     .            +     typ__1  *dzro_2                    !
          G1_OLD  = (1.-typ__1) *G1agra(ikl)               ! G1 of Spher.Lay.
     .            +     typ__1  *G1agrb(ikl)               !
          G2_OLD  = (1.-typ__1) *G2agra(ikl)               ! G2 of Spher.Lay.
     .            +     typ__1  *G2agrb(ikl)               !
          SizNEW  =    -G1_NEW  *DDcdSV/G1_dSV             ! Size  Dendr.Lay.
     .             +(1.+G1_NEW         /G1_dSV)            !
     .                *(G2_NEW  *DScdSV/G1_dSV             !
     .             +(1.-G2_NEW         /G1_dSV)*DFcdSV)    !
          SphNEW  =     G2_NEW         /G1_dSV             ! Spher.Dendr.Lay.
          SizOLD  =     G2_OLD                             ! Size  Spher.Lay.
          SphOLD  =     G1_OLD         /G1_dSV             ! Spher.Spher.Lay.
          Siz_av  = (zroNEW*SizNEW+zroOLD*SizOLD)      ! Averaged Size
     .     /max(epsi,dzro)                             !
          Sph_av  = (zroNEW*SphNEW+zroOLD*SphOLD)      ! Averaged Sphericity
     .     /max(epsi,dzro)                             !
          Den_av  = (Siz_av -(    Sph_av *DScdSV       !
     .                       +(1.-Sph_av)*DFcdSV))     !
     .            / (DDcdSV -(    Sph_av *DScdSV       !
     .                       +(1.-Sph_av)*DFcdSV))     !
          DendOK  = max(zero,                          !
     .                  sign(unun,     Sph_av *DScdSV  ! Small   Grains Contr.
     .                            +(1.-Sph_av)*DFcdSV  ! Faceted Grains Contr.
     .                            -    Siz_av        ))!
C +...    REMARQUE: le  type moyen (dendritique ou non) depend  
C +       ^^^^^^^^  de la  comparaison avec le diametre optique 
C +                 d'une neige recente de   dendricite nulle
C +...    REMARK:   the mean type  (dendritic   or not) depends 
C +       ^^^^^^    on the comparaison with the optical diameter 
C +                 of a recent snow    having zero dendricity

          G1diff  =(   -DendOK *Den_av       
     .             +(1.-DendOK)*Sph_av) *G1_dSV
          G2diff  =     DendOK *Sph_av  *G1_dSV
     .             +(1.-DendOK)*Siz_av
          G1      =     SameOK *G1same
     .             +(1.-SameOK)*G1diff
          G2      =     SameOK *G2same
     .             +(1.-SameOK)*G2diff


C +--Assignation to new Properties
C +  =============================

          isagra(ikl)   = Agreg1(ikl) *nh +(1.-Agreg1(ikl)) *isagra(ikl)
          dzagra(ikl)   = Agreg1(ikl) *dz +(1.-Agreg1(ikl)) *dzagra(ikl)
          T_agra(ikl)   = Agreg1(ikl) *tn +(1.-Agreg1(ikl)) *T_agra(ikl)
          roagra(ikl)   = Agreg1(ikl) *ro +(1.-Agreg1(ikl)) *roagra(ikl)
          etagra(ikl)   = Agreg1(ikl) *wn +(1.-Agreg1(ikl)) *etagra(ikl)
          G1agra(ikl)   = Agreg1(ikl) *G1 +(1.-Agreg1(ikl)) *G1agra(ikl)
          G2agra(ikl)   = Agreg1(ikl) *G2 +(1.-Agreg1(ikl)) *G2agra(ikl)
          agagra(ikl)   = Agreg1(ikl) *ag +(1.-Agreg1(ikl)) *agagra(ikl)

      END DO

      return
      end


      subroutine SnOptP

C +------------------------------------------------------------------------+
C | MAR/SISVAT   SnOptP                                     8-06-2010  MAR |
C |   SubRoutine SnOptP computes the Snow Pack optical Properties          |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     Grid Boxes       |
C |                     X       Number of Mosaic Cell per Grid Box         |
C |                                                                        |
C |   INPUT:   isnoSV   = total Nb of Ice/Snow Layers                      |
C |   ^^^^^    ispiSV   = 0,...,nsno: Uppermost Superimposed Ice Layer     |
C |                                                                        |
C |            ivgtSV   = 0,...,12:   Vegetation Type                      |
C |                       0:          Water, Solid or Liquid               |
C |                                                                        |
C |   INPUT:   G1snSV   : Dendricity (<0) or Sphericity (>0) of Snow Layer |
C |   ^^^^^    G2snSV   : Sphericity (>0) or Size            of Snow Layer |
C |            agsnSV   : Snow       Age                             [day] |
C |            ro__SV   : Snow/Soil  Volumic Mass                  [kg/m3] |
C |            eta_SV   : Water      Content                       [m3/m3] |
C |            rusnSV   : Surficial  Water   Thickness   [kg/m2] .OR. [mm] |
C |            SWS_SV   : Surficial  Water   Status                        |
C |            dzsnSV   : Snow       Layer   Thickness                 [m] |
C |                                                                        |
C |            albssv   : Soil       Albedo                            [-] |
C |            zzsnsv   : Snow       Pack    Thickness                 [m] |
C |                                                                        |
C |   OUTPUT:  albisv   : Snow/Ice/Water/Soil Integrated Albedo        [-] |
C |   ^^^^^^   sEX_sv   : Verticaly Integrated Extinction Coefficient      |
C |                                                                        |
C |   Internal Variables:                                                  |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |            SnOpSV   : Snow Grain optical Size                      [m] |
C |            EX1_sv   : Integrated Snow Extinction (0.3--0.8micr.m)      |
C |            EX2_sv   : Integrated Snow Extinction (0.8--1.5micr.m)      |
C |            EX3_sv   : Integrated Snow Extinction (1.5--2.8micr.m)      |
C |                                                                        |
C |   METHODE:    Calcul de la taille optique des grains ? partir de       |
C |   ^^^^^^^    -leur type decrit par les deux variables descriptives     |
C |                    continues sur la plage -99/+99 passees en appel.    |
C |              -la taille optique (1/10mm) des etoiles,                  |
C |                                          des grains fins et            |
C |                                          des jeunes faces planes       |
C |                                                                        |
C |   METHOD:     Computation of the optical diameter of the grains        |
C |   ^^^^^^      described with the CROCUS formalism G1snSV / G2snSV      |
C |                                                                        |
C |   REFERENCE: Brun et al.      1989, J. Glaciol 35 pp. 333--342         |
C |   ^^^^^^^^^  Brun et al.      1992, J. Glaciol 38 pp.  13-- 22         |
C |              Eric Martin Sept.1996                                     |
C |                                                                        |
C | # OPTIONS: #AG: Generalisation of Col de Porte Ageing Parameterization |
C | # ^^^^^^^  #CZ: Albedo Correction (Zenith Angle)                       |
C | #          #AW: Output of Soil-Ice-Snow Albedo                         |
C |                                                                        |
C |   CAUTION: Vegetation is not taken into account in albedo computations |
C |   ^^^^^^^  Suggestion: 1) Reduce the displacement height  and/or LAI   |
C |            (when snow)    for radiative transfert through vegetation   |
C |                        2) Adapt leaf optical parameters                |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # SnOptP____.va        | #va: OUTPUT/Verification: Albedo Parameteriz. |
C |                        |      unit 46, SubRoutine  SnOptP     **ONLY** |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
c #AG include  "MARdim.inc"
c #AG include  "MAR_GE.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
c #cp include  "MARdCP.inc"
C +
      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--Internal Variables
C +  ==================

      real      coalb1(klonv)                      ! weighted Coalbedo, Vis.
      real      coalb2(klonv)                      ! weighted Coalbedo, nIR 1
      real      coalb3(klonv)                      ! weighted Coalbedo, nIR 2
      real      coalbm                             ! weighted Coalbedo, mean
      real      sExt_1(klonv)                      ! Extinction Coeff., Vis.
      real      sExt_2(klonv)                      ! Extinction Coeff., nIR 1
      real      sExt_3(klonv)                      ! Extinction Coeff., nIR 2
      real      SnOpSV(klonv,      nsno)           ! Snow Grain optical Size
c #AG real      agesno

      integer   isn   ,ikl   ,isn1  ,jjtime
      real      sbeta1,sbeta2,sbeta3,sbeta4,sbeta5
      real      AgeMax,AlbMin,HSnoSV,HIceSV,doptmx,SignG1,Sph_OK
      real      dalbed,dalbeS,dalbeW
c #CZ real      bsegal,czemax,csegal
      real      RoFrez,DiffRo,SignRo,SnowOK,OpSqrt
      real      albSn1,albIc1,a_SnI1,a_SII1
      real      albSn2,albIc2,a_SnI2,a_SII2
      real      albSn3,albIc3,a_SnI3,a_SII3
      real      albSno,albIce,albSnI,albSII,albWIc,albmax
      real      doptic,Snow_H,SIce_H,SnownH,SIcenH
      real      exarg1,exarg2,exarg3,sign_0,sExt_0
      real      albedo_old
      real      ro_ave,dz_ave

C +--OUTPUT of SISVAT Trace Statistics (see assignation in PHY_SISVAT)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SR integer             iSRwri,jSRwri,nSRwri,kSRwri,lSRwri
c #SR common/SISVAT_trace/iSRwri,jSRwri,nSRwri,kSRwri,lSRwri

C +--Albedo: IO
C +  ~~~~~~~~~~
! #va logical         aw_opn                       ! IO       Switch
! #va common/SnOptP_L/aw_opn                       !


C +--Local   DATA
C +  ============

C +--For the computation of the solar irradiance extinction in snow
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      data      sbeta1/0.0192/,sbeta2/0.4000/,sbeta3/0.1098/
      data      sbeta4/1.0000/
      data      sbeta5/2.00e1/

C +--Snow Age Maximum (Taiga, e.g. Col de Porte)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      data      AgeMax  /60.0/
C +...          AgeMax:  Snow Age Maximum                              [day]

      data      AlbMin  /0.94/
C +...          AlbMin:  Albedo   Minimum / visible (0.3--0.8 micrometers)

      data      HSnoSV  /0.01/
C +...          HSnoSV:  Snow     Thickness through witch 
C +                      Albedo is interpolated to Ice  Albedo
      data      HIceSV  /0.10/
C +...          HIceSV:  Snow/Ice Thickness through witch 
C +                      Albedo is interpolated to Soil Albedo
      data      doptmx  /2.3e-3/
C +...          doptmx:  Maximum  optical Diameter    (pi * R**2)        [m]
C +
c #CZ data      czeMAX  /0.173648178/  ! 80.deg (Segal et al., 1991 JAS)  
c #CZ data      bsegal  /4.00       /  !
      data      albmax  /0.99       /  ! Albedo max


C +--Snow Grain optical Size
C +  =======================

      DO   isn=1,nsno
        DO ikl=1,klonv

          G2snSV(ikl,isn) =  max(epsi,G2snSV(ikl,isn))
C +...    Avoid non physical Values

          SignG1          = sign(unun,G1snSV(ikl,isn))
          Sph_OK          =  max(zero,SignG1)

          SnOpSV(ikl,isn) =   1.e-4 *
C +...    SI:           (from 1/10 mm to m)


C +--Contribution of Non Dendritic Snow
C +  ----------------------------------

     .    (    Sph_OK *(      G2snSV(ikl,isn)*G1snSV(ikl,isn)/G1_dSV
     .              +max(demi*G2snSV(ikl,isn),DFcdSV)
     .                 *(unun-G1snSV(ikl,isn)                /G1_dSV))


C +--Contribution of     Dendritic Snow
C +  ----------------------------------

     .    +(1.-Sph_OK)*(     -G1snSV(ikl,isn)*DDcdSV         /G1_dSV
     .                 +(unun+G1snSV(ikl,isn)                /G1_dSV)
     .                  *    (G2snSV(ikl,isn)*DScdSV         /G1_dSV
     .                 +(unun-G2snSV(ikl,isn)                /G1_dSV)
     .                                       *DFcdSV                 )))
          SnOpSV(ikl,isn) =  max(zero,SnOpSV(ikl,isn))
        END DO
      END DO


C +--Snow/Ice Albedo
C +  ===============

C +--Snow Age (Influence on Albedo)
C +  ------------------------------

c #AG jjtime = jhurGE*3600+minuGE*60+jsecGE
c #AG IF (iabs(mod(jjtime,86400)).lt.dt__SV)                        THEN
c #AG   DO isn=1,nsno
c #AG   DO ikl=1,klonv
c #AG     agsnSV(ikl,isn) = agsnSV(ikl,isn) + 1.
c #AG.           + max(zero,DH_dSV(ivgtSV(ikl))-DH_dSV(4)) ! High Vegetation
C +                                                        ! Impurities
C +...                      CAUTION: crude parameterization
C +                         ^^^^^^^       
c #AG   END DO
c #AG   END DO
c #AG END IF


C +--Uppermost effective Snow Layer
C +  ------------------------------

        DO ikl=1,klonv

           isn   =  max(iun,isnoSV(ikl))

          SignRo = sign(unun, rocdSV - ro__SV(ikl,isn))
          SnowOK =  max(zero,SignRo) ! Ice Density Threshold

          OpSqrt = sqrt(SnOpSV(ikl,isn))

          albSn1 =  0.96-1.580*OpSqrt
          albSn1 =  max(albSn1,AlbMin)

          albSn1 =  max(albSn1,zero)
          albSn1 =  min(albSn1,unun)

          albSn2 =  0.95-15.40*OpSqrt
          albSn2 =  max(albSn2,zero)
          albSn2 =  min(albSn2,unun)

          doptic =  min(SnOpSV(ikl,isn),doptmx)
          albSn3 =  346.3*doptic -32.31*OpSqrt +0.88
          albSn3 =  max(albSn3,zero)
          albSn3 =  min(albSn3,unun)

          albSno =  So1dSV*albSn1
     .           +  So2dSV*albSn2
     .           +  So3dSV*albSn3

          SnowOK =  SnowOK*max(zero,sign(unun,albSno-aI3dSV))
                 !  Minimum snow albedo is aI3dSV

          albSn1 =  SnowOK*albSn1+(1.0-SnowOK)*max(albSno,aI3dSV)
          albSn2 =  SnowOK*albSn2+(1.0-SnowOK)*max(albSno,aI3dSV)
          albSn3 =  SnowOK*albSn3+(1.0-SnowOK)*max(albSno,aI3dSV)


C +--Snow/Ice Pack Thickness
C +  -----------------------
 
          isn    =    max(min(isnoSV(ikl) ,ispiSV(ikl)),0)
          Snow_H =  zzsnsv(ikl,isnoSV(ikl))-zzsnsv(ikl,isn)
          SIce_H =  zzsnsv(ikl,isnoSV(ikl))
          SnownH =  Snow_H  /  HSnoSV
          SnownH =  min(unun,  SnownH)
          SIcenH =  SIce_H  / (HIceSV
     .           +  max(zero,Z0mdSV(ivgtSV(ikl))
     .           -           Z0mdSV(4)         ))
          SIcenH =  min(unun,  SIcenH)
 
C +       The value of SnownH is set to 1 in case of ice lenses above 
C +       1m of dry snow (ro<700kg/m3) for using CROCUS albedo

          ro_ave =  0. 
          dz_ave =  0.
          SnowOK =  1.
       do isn    =  isnoSV(ikl),1,-1
          ro_ave =  ro_ave + ro__SV(ikl,isn) * dzsnSV(ikl,isn) * SnowOK
          dz_ave =  dz_ave +                   dzsnSV(ikl,isn) * SnowOK
          SnowOK =  max(zero,sign(unun,1.-dz_ave))
       enddo

          ro_ave =  ro_ave / max(dz_ave,epsi)
          SnowOK =  max(zero,sign(unun,700.-ro_ave))

          SnownH =  SnowOK + SnownH * (1. - SnowOK)   


C +--Integrated Snow/Ice Albedo: Case of Water on Bare Ice
C +  -----------------------------------------------------

          isn    =  max(min(isnoSV(ikl) ,ispiSV(ikl)),0)

          albWIc =  aI1dSV-(aI1dSV-aI2dSV)
     .           *  exp(-(rusnSV(ikl)                      !
     .           *  (1. -SWS_SV(ikl)                       ! 0 <=> freezing
     .           *  (1  -min(1,iabs(isn-isnoSV(ikl)))))    ! 1 <=> isn=isnoSV
     .           /   ru_dSV)**0.25)                        !
          albWIc = max(aI1dSV,min(aI2dSV,albWIc+slopSV(ikl)*1.5))

          SignRo = sign(unun,ro_Ice-2.-ro__SV(ikl,isn))    ! RoSN<920kg/m3
          SnowOK =  max(zero,SignRo)

          albWIc = (1. - SnowOK) * albWIc + SnowOK   
     .           * (aI2dSV + (aI3dSV -aI2dSV) 
     .           * (ro__SV(ikl,isn)-ro_Ice)/(rocdSV-ro_Ice))
  
c +  rocdSV < ro < ro_ice | aI2dSV< al >aI3dSV (fct of density)
c +           ro > ro_ice | aI1dSV< al >aI2dSV (fct of superficial water content)


C +--Integrated Snow/Ice      Albedo
C +  -------------------------------
 
          a_SII1      =     albWIc      +(albSn1-albWIc)     *SnownH
          a_SII1      = min(a_SII1       ,albSn1)
 
          a_SII2      =     albWIc      +(albSn2-albWIc)     *SnownH
          a_SII2      = min(a_SII2       ,albSn2)
 
          a_SII3      =     albWIc      +(albSn3-albWIc)     *SnownH
          a_SII3      = min(a_SII3       ,albSn3)

c #AG     agesno =      min(agsnSV(ikl,isn)          ,AgeMax)
c #AG     a_SII1      =     a_SII1      -0.175*agesno/AgeMax
C +...                                   Impurities: Col de Porte Parameter.


!    Zenith Angle Correction (Segal et al.,         1991, JAS 48, p.1025)
!    ----------------------- (Wiscombe & Warren, dec1980, JAS   , p.2723)
!                            (Warren,               1982,  RG   , p.  81)
!                            --------------------------------------------


          dalbed = 0.0
c #CZ     csegal = max(czemax                   ,coszSV(ikl))
c #cz     dalbeS =   ((bsegal+unun)/(unun+2.0*bsegal*csegal)
c #cz.                -       unun                          )*0.32
c #cz.              /  bsegal
c #cz     dalbeS = max(dalbeS,zero)
c #cz     dalbed =     dalbeS      *       min(1,isnoSV(ikl))

c #CZ     dalbeW =(0.64 - csegal  )*0.0625  ! Warren 1982, RevGeo, fig.12b
                                            ! 0.0625 = 5% * 1/0.8,   p.81
                                            ! 0.64   = cos(50)
c #CZ     dalbed =     dalbeW      *       min(1,isnoSV(ikl))

C +--Col de Porte Integrated Snow/Ice Albedo
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #cp     IF (ColPrt.AND.TotSol.gt.0.)                              THEN
c #cp       albSII =  (((Dr_1SN*a_SII1+Dr_2SN*a_SII2+Dr_3SN*a_SII3)
c #cp.                  +dalbed                                    )
c #cp.                  *DirSol
c #cp.                 +(Df_1SN*a_SII1+Df_2SN*a_SII2+Df_3SN*a_SII3)
c #cp.                  *DifSol*(1.   -cld_SV(ikl))
c #cp.                 +(Dfc1SN*a_SII1+Dfc2SN*a_SII2+Dfc3SN*a_SII3)
c #cp.                  *DifSol*       cld_SV(ikl)                  )
c #cp.                 / TotSol

C +--Elsewhere    Integrated Snow/Ice Albedo
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #cp     ELSE
            albSII =     So1dSV*a_SII1
     .                 + So2dSV*a_SII2
     .                 + So3dSV*a_SII3
c #cp     END IF


C +--Integrated Snow/Ice/Soil Albedo
C +  -------------------------------

            alb1sv(ikl) =     albssv(ikl) +(a_SII1-albssv(ikl))*SIcenH
            alb1sv(ikl) = min(alb1sv(ikl)  ,a_SII1)

            alb2sv(ikl) =     albssv(ikl) +(a_SII2-albssv(ikl))*SIcenH
            alb2sv(ikl) = min(alb2sv(ikl)  ,a_SII2)

            alb3sv(ikl) =     albssv(ikl) +(a_SII3-albssv(ikl))*SIcenH
            alb3sv(ikl) = min(alb3sv(ikl)  ,a_SII3)

            albisv(ikl) =     albssv(ikl) +(albSII-albssv(ikl))*SIcenH
            albisv(ikl) = min(albisv(ikl)  ,albSII)


C +--Integrated Snow/Ice/Soil Albedo: Clouds Correction! Greuell & all., 1994
C +  --------------------------------------------------! Glob.&t Planet.Change
                                                       ! (9):91-114
c #cp     IF (.NOT.ColPrt)                                          THEN
            alb1sv(ikl) = alb1sv(ikl) + 0.05 *(cld_SV(ikl)-0.5)*SIcenH
c #CZ.                  + dalbed      *    (1.-cld_SV(ikl))
            alb2sv(ikl) = alb2sv(ikl) + 0.05 *(cld_SV(ikl)-0.5)*SIcenH
c #CZ.                  + dalbed      *    (1.-cld_SV(ikl))
            alb3sv(ikl) = alb3sv(ikl) + 0.05 *(cld_SV(ikl)-0.5)*SIcenH
c #CZ.                  + dalbed      *    (1.-cld_SV(ikl))
            albisv(ikl) = albisv(ikl) + 0.05 *(cld_SV(ikl)-0.5)*SIcenH
c #CZ.                  + dalbed      *    (1.-cld_SV(ikl))
c #cp     END IF

C +--Integrated Snow/Ice/Soil Albedo: Minimum snow albedo = aI1dSV
C +  -------------------------------------------------------------

            albedo_old  = albisv(ikl)
            albisv(ikl) = max(albisv(ikl),aI1dSV   * SIcenH 
     .                  + albssv(ikl) *(1.0        - SIcenH))
            alb1sv(ikl) = alb1sv(ikl) - 1.0/3.0             ! 33 %
     .                  * (albedo_old-albisv(ikl)) / So1dSV
            alb2sv(ikl) = alb2sv(ikl) - 1.0/3.0             ! 33 %
     .                  * (albedo_old-albisv(ikl)) / So2dSV  
            alb3sv(ikl) = alb3sv(ikl) - 1.0/3.0             ! 33 %
     .                  * (albedo_old-albisv(ikl)) / So3dSV


C +--Integrated Snow/Ice/Soil Albedo: Maximum albedo = 95%
C +  -----------------------------------------------------

            albedo_old  = albisv(ikl)
            albisv(ikl) = min(albisv(ikl),0.95)
            alb1sv(ikl) = alb1sv(ikl) - 1.0/3.0             ! 33 %
     .                  * (albedo_old-albisv(ikl)) / So1dSV
            alb2sv(ikl) = alb2sv(ikl) - 1.0/3.0             ! 33 %
     .                  * (albedo_old-albisv(ikl)) / So2dSV  
            alb3sv(ikl) = alb3sv(ikl) - 1.0/3.0             ! 33 %
     .                  * (albedo_old-albisv(ikl)) / So3dSV

            alb1sv(ikl) = min(max(zero,alb1sv(ikl)),albmax)  
            alb2sv(ikl) = min(max(zero,alb2sv(ikl)),albmax)
            alb3sv(ikl) = min(max(zero,alb3sv(ikl)),albmax)

        END DO


C +--Extinction Coefficient: Exponential Factor
C +  ==========================================

        DO ikl=1,klonv
          sExt_1(ikl)        = 1.
          sExt_2(ikl)        = 1.
          sExt_3(ikl)        = 1.
          sEX_sv(ikl,nsno+1) = 1.

          coalb1(ikl) = (1.          -alb1sv(ikl))*So1dSV
          coalb2(ikl) = (1.          -alb2sv(ikl))*So2dSV
          coalb3(ikl) = (1.          -alb3sv(ikl))*So3dSV
          coalbm      =  coalb1(ikl) +coalb2(ikl) +coalb3(ikl)
          coalb1(ikl) =  coalb1(ikl)              /coalbm
          coalb2(ikl) =  coalb2(ikl)              /coalbm
          coalb3(ikl) =  coalb3(ikl)              /coalbm
        END DO

      DO   isn=nsno,1,-1
        DO ikl=1,klonv

          SignRo = sign(unun, rocdSV - ro__SV(ikl,isn))
          SnowOK =  max(zero,SignRo) ! Ice Density Threshold

          RoFrez =  1.e-3      * ro__SV(ikl,isn) * (1.0-eta_SV(ikl,isn))

          OpSqrt = sqrt(max(epsi,SnOpSV(ikl,isn)))
          exarg1 =      SnowOK  *1.e2 *max(sbeta1*RoFrez/OpSqrt,sbeta2)
     .            +(1.0-SnowOK)           *sbeta5
          exarg2 =      SnowOK  *1.e2 *max(sbeta3*RoFrez/OpSqrt,sbeta4)
     .            +(1.0-SnowOK)           *sbeta5
          exarg3 =      SnowOK  *1.e2     *sbeta5
     .            +(1.0-SnowOK)           *sbeta5

C +--Col de Porte Snow Extinction Coefficient
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #cp     IF (ColPrt.AND.TotSol.gt.0.)                              THEN
c #cp       exarg1 = exarg1*(Dr_1SN*DirSol
c #cp.                      +Df_1SN*DifSol*(1.-cld_SV(ikl))
c #cp.                      +Dfc1SN*DifSol*    cld_SV(ikl) )
c #cp.                     /(Dr_1SN*TotSol)
c #cp       exarg2 = exarg2*(Dr_2SN*DirSol
c #cp.                      +Df_2SN*DifSol*(1.-cld_SV(ikl))
c #cp.                      +Dfc2SN*DifSol*    cld_SV(ikl) )
c #cp.                     /(Dr_2SN*TotSol)
c #cp       exarg3 = exarg3*(Dr_3SN*DirSol
c #cp.                      +Df_3SN*DifSol*(1.-cld_SV(ikl))
c #cp.                      +Dfc3SN*DifSol*    cld_SV(ikl) )
c #cp.                     /(Dr_3SN*TotSol)
c #cp     END IF


C +--Integrated Extinction of Solar Irradiance (Normalized Value)
C +  ============================================================

          sExt_1(ikl) = sExt_1(ikl)
     .                          * exp(min(0.0,-exarg1 *dzsnSV(ikl,isn)))
          sign_0      =              sign(unun,eps9   -sExt_1(ikl))
          sExt_0      =               max(zero,sign_0)*sExt_1(ikl)
          sExt_1(ikl) = sExt_1(ikl)                   -sExt_0

          sExt_2(ikl) = sExt_2(ikl)
     .                          * exp(min(0.0,-exarg2 *dzsnSV(ikl,isn)))
          sign_0      =              sign(unun,eps9   -sExt_2(ikl))
          sExt_0      =               max(zero,sign_0)*sExt_2(ikl)
          sExt_2(ikl) = sExt_2(ikl)                   -sExt_0

          sExt_3(ikl) = sExt_3(ikl)
     .                          * exp(min(0.0,-exarg3 *dzsnSV(ikl,isn)))
          sign_0      =              sign(unun,eps9   -sExt_3(ikl))
          sExt_0      =               max(zero,sign_0)*sExt_3(ikl)
          sExt_3(ikl) = sExt_3(ikl)                   -sExt_0

          sEX_sv(ikl,isn) = coalb1(ikl) * sExt_1(ikl)
     .                    + coalb2(ikl) * sExt_2(ikl)
     .                    + coalb3(ikl) * sExt_3(ikl)
        END DO
      END DO

      DO   isn=0,-nsol,-1
        DO ikl=1,klonv
          sEX_sv(ikl,isn) = 0.0
        END DO
      END DO


C +--Albedo: IO
C +  ==========

! #va IF (.NOT.aw_opn)                                              THEN
! #va          aw_opn = .true.
! #va          open(unit=46,status='unknown',file='SnOptP____.va')
! #va          rewind(   46)
! #va END IF

! #va     ikl=1
! #va     write(46,460)daHost
 460      format('---------------------------------+----+',
     .          '-------+-------+-------+-------+-------+-------+',
     .                                  '-------+-------+-------+',
     .         /,'Snow/Ice Pack ',a18,' |    |',
     .          ' z [m] |0.3/0.8|0.8/1.5|1.5/2.8| Full  |Opt[mm]|',
     .                                  ' G1    | G2    | ro    |',
     .         /,'---------------------------------+----+',
     .          '-------+-------+-------+-------+-------+-------+',
     .                                  '-------+-------+-------+')
!         ______________________________________________________________
! #va     write(46,461)            SIce_H,
! #va.                             alb1sv(ikl),alb2sv(ikl),alb3sv(ikl),
! #va.                             albisv(ikl)
 461      format('Integrated Snow/Ice/Soil  Albedo |',
     .            3x,' |',  f6.3,' |' ,4(f6.3,' |'), 6x ,' |',
     .                                            3( 6x ,' |'))
!         ______________________________________________________________
! #va     write(46,462)ispiSV(ikl),a_SII1,a_SII2,a_SII3,albSII
 462      format('Integrated Snow/Ice       Albedo |',
     .            i3,' |',   6x ,' |' ,4(f6.3,' |'), 6x ,' |',
     .                                            3( 6x ,' |'))
!         ______________________________________________________________
! #va     write(46,463)            rusnSV(ikl),         albWIc,
! #va.                             SWS_SV(ikl)
 463      format('Integrated Water/Bare Ice Albedo |',
     .            3x,' |',  f6.3,'w|' ,3( 6x, ' |'),  
     .                                   f6.3,' |' ,f6.3,' |',
     .                                            3( 6x ,' |'))
!         ______________________________________________________________
! #va     write(46,464)     LiceOK,a_SnI1,a_SnI2,a_SnI3,albSnI
 464      format('Integrated Snow/Ice Lense Albedo |',
     .           f4.0,'|',    6x,' |' ,4(f6.3,' |'), 6x ,' |',
     .                                            3( 6x ,' |'))
!         ______________________________________________________________
! #va     write(46,465)isn1       ,zzsnsv(ikl,isn1),
! #va.                             albIc1,albIc2,albIc3,albIce,
! #va.                        1.e3*SnOpSV(ikl,max(iun,isnoSV(ikl)-iun)),
! #va.                             G1snSV(ikl,max(iun,isnoSV(ikl)-iun)),
! #va.                             G2snSV(ikl,max(iun,isnoSV(ikl)-iun)),
! #va.                             ro__SV(ikl,max(iun,isnoSV(ikl)-iun))
! #va.                      *(1. - eta_SV(ikl,max(iun,isnoSV(ikl)-iun)))
 465      format('Surficial       Ice Lense        |',
     .            i3,' |', (f6.3,'i|'),4(f6.3,' |'),f6.3,' |',
     .                                            3(f6.1,' |'))
!         ______________________________________________________________
! #va     write(46,466)isnoSV(ikl),zzsnsv(ikl,isnoSV(ikl)),
! #va.                             albSn1,albSn2,albSn3,albSno,
! #va.                        1.e3*SnOpSV(ikl,isnoSV(ikl)),
! #va.                             G1snSV(ikl,isnoSV(ikl)),
! #va.                             G2snSV(ikl,isnoSV(ikl)),
! #va.                             ro__SV(ikl,isnoSV(ikl))
! #va.                      *(1. - eta_SV(ikl,isnoSV(ikl)))
 466      format('Uppermost  Effective Snow Layer  |',
     .            i3,' |', (f6.3,'*|'),4(f6.3,' |'),f6.3,' |',
     .                                            3(f6.1,' |'))

      return
      end


      subroutine VgOptP

C +------------------------------------------------------------------------+
C | MAR/SISVAT   VgOptP                                     8-04-2009  MAR |
C |   SubRoutine VgOptP computes the Canopy    optical Properties          |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     Grid Boxes       |
C |                     X       Number of Mosaic Cell per Grid Box         |
C |                                                                        |
C |   INPUT:   ivgtSV   = 0,...,12:   Vegetation Type                      |
C |   ^^^^^               0:          Water, Solid or Liquid               |
C |                                                                        |
C |   INPUT:   coszSV   : Cosine of the Sun Zenithal Distance          [-] |
C |   ^^^^^    sol_SV   : Surface Downward  Solar   Radiation       [W/m2] |
C |            snCaSV   : Canopy     Snow      Thickness         [mm w.e.] |
C |                                                                        |
C |            LAI_sv   : Leaf Area  Index      (snow included)        [-] |
C |            glf_sv   : Green Leaf Fraction of NOT fallen Leaves     [-] |
C |            albisv   : Snow/Ice/Water/Soil Integrated Albedo        [-] |
C |                                                                        |
C |   OUTPUT:  alb_SV   : Surface-Canopy Albedo                        [-] |
C |   ^^^^^^   SoCasv   : Absorbed Solar Radiation by Canopy (Normaliz)[-] |
C |            SoSosv   : Absorbed Solar Radiation by Surfac (Normaliz)[-] |
C |            LAIesv   : Effective Leaf Area  Index for Transpiration [-] |
C |                                                                        |
C |   Internal Variables: Normalized Values:                               |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |            u0_Vis   : Upward   Visible Radiation at Top Canopy     [-] |
C |            absg_V   : Absorbed Visible Radiation by the Ground     [-] |
C |            absv_V   : Absorbed Visible Radiation by the Canopy     [-] |
C |            u0_nIR   : Upward   Near IR Radiation at Top Canopy     [-] |
C |            absgnI   : Absorbed Near IR Radiation by the Ground     [-] |
C |            absv_V   : Absorbed Near IR Radiation by the Canopy     [-] |
C |                                                                        |
C |   REFERENCE:   De Ridder, 1997, unpublished thesis, chapter 2 (DR97,2) |
C |   ^^^^^^^^^                                                            |
C |                                                                        |
C |   ASSUMPTIONS: Leaf Inclination Index chi_l (eqn2.49 DR97) set to zero |
C |   ^^^^^^^^^^^                         for all vegetation types         |
C |                Radiation Fluxes are normalized                         |
C |                      with respect to incoming solar radiation (=I0+D0) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"

      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--Internal Variables
C +  ==================


      integer   ikl   ,kri

      real      exdRad,k_drad,k___sv(klonv)
      real      e_prad,e1pRad
      real      zv_fac,zv1fac,deadLF
      real      T_Rad0,A_Rad0,A0__sv(klonv)
      real                    r0_Rad,t0_Rad,nu_Rad
      real      Tr_Rad,Re_Rad,r__Rad,t__Rad,t1_Rad
      real      arggam, gamma,gamasv(klonv),gammaL
      real      denSig,Sig__c,Sigcsv(klonv)
      real      DDifH1,DDifC1,C1__sv(klonv)
      real      DDifH2,DDifC2,C2__sv(klonv)
      real      denS_s,denS_a,den_c1,DDif_L
      real      u0_Vis,absg_V,absv_V
      real      u0_nIR,absgnI,absvnI
      real      argexg,argexk,criLAI(klonv)
      real      residu,d_DDif,dDDifs,dDDifa


C +--Internal DATA
C +  =============

      integer            nvgt
      parameter         (nvgt=12)
      real      reVisL(0:nvgt)      ! Reflectivity  / Visible / Live Leaves
      real      renIRL(0:nvgt)      ! Reflectivity  / Near IR / Live Leaves
      real      trVisL(0:nvgt)      ! Transmitivity / Visible / Live Leaves
      real      trnIRL(0:nvgt)      ! Transmitivity / Near IR / Live Leaves
      real      reVisD(0:nvgt)      ! Reflectivity  / Visible / Dead Leaves
      real      renIRD(0:nvgt)      ! Reflectivity  / Near IR / Dead Leaves
      real      trVisD(0:nvgt)      ! Transmitivity / Visible / Dead Leaves
      real      trnIRD(0:nvgt)      ! Transmitivity / Near IR / Dead Leaves

      real      reVisS              ! Reflectivity  / Visible / Canopy Snow
      real      renIRS              ! Reflectivity  / Near IR / Canopy Snow
      real      trVisS              ! Transmitivity / Visible / Canopy Snow
      real      trnIRS              ! Transmitivity / Near IR / Canopy Snow

      real      snCaMx              ! Canopy Snow Thickness for having Snow
                                    ! Snow Reflectivity and Transmitivity
      real      CriStR              ! Critical Radiation Stomatal Resistance

      integer            ivg

      DATA (reVisL(ivg),renIRL(ivg),trVisL(ivg),trnIRL(ivg),
     .      reVisD(ivg),renIRD(ivg),trVisD(ivg),trnIRD(ivg),ivg=0,nvgt)

C +   reVisL renIRL trVisL trnIRL reVisD renIRD trVisD trnIRD  SVAT     CLASSES
C +   ------ ------ ------ ------ ------ ------ ------ ------+ ----------------
     ./0.11,  0.58,  0.07,  0.25,  0.36,  0.58,  0.22,  0.38,!  0 NO VEGETATION
     . 0.11,  0.58,  0.07,  0.25,  0.36,  0.58,  0.22,  0.38,!  1 CROPS LOW
     . 0.11,  0.58,  0.07,  0.25,  0.36,  0.58,  0.22,  0.38,!  2 CROPS MEDIUM
     . 0.11,  0.58,  0.07,  0.25,  0.36,  0.58,  0.22,  0.38,!  3 CROPS HIGH
     . 0.11,  0.58,  0.07,  0.25,  0.36,  0.58,  0.22,  0.38,!  4 GRASS LOW
     . 0.11,  0.58,  0.07,  0.25,  0.36,  0.58,  0.22,  0.38,!  5 GRASS MEDIUM
     . 0.11,  0.58,  0.07,  0.25,  0.36,  0.58,  0.22,  0.38,!  6 GRASS HIGH
     . 0.10,  0.45,  0.05,  0.25,  0.16,  0.39,  0.01,  0.01,!  7 BROADL LOW
     . 0.10,  0.45,  0.05,  0.25,  0.16,  0.39,  0.01,  0.01,!  8 BROADL MEDIUM
     . 0.10,  0.45,  0.05,  0.25,  0.16,  0.39,  0.01,  0.01,!  9 BROADL HIGH
     . 0.07,  0.35,  0.05,  0.10,  0.10,  0.39,  0.01,  0.01,! 10 NEEDLE LOW
     . 0.07,  0.35,  0.05,  0.10,  0.10,  0.39,  0.01,  0.01,! 11 NEEDLE MEDIUM
     . 0.07,  0.35,  0.05,  0.10,  0.10,  0.39,  0.01,  0.01/! 12 NEEDLE HIGH

      DATA 
     .reVisS,renIRS,trVisS,trnIRS
C +   ------ ------ ------ ------+
     ./0.85,  0.85,  0.00,  0.00/!
C +   REMARK: Possible Refinement by taking actual Surface Snow Reflectivities
C +   ^^^^^^

      DATA      snCaMx /0.5/

      DATA      CriStR /25./


C +--General Parameters, Solar Radiation Absorption
C +  ==============================================

      DO ikl=1,klonv

c #sv   IF (ifraSV(ikl).GT.0)                                     THEN

            k_dRad = 0.5 /max(coszSV(ikl),epsi) ! absorbed irradiance fraction
            e_pRad = 2.5   *  coszSV(ikl)       ! exponential argument,   
C +                                             ! V/nIR radiation partitioning,
C +                                             ! DR97, 2, eqn (2.53) & (2.54)
            exdRad =    exp(-k_dRad*LAI_sv(ikl))! exponential, Irradi. Absorpt.
            e1pRad = 1.-exp(-e_pRad)            ! exponential, V/nIR Rad. Part.

            ivg    =                ivgtSV(ikl) ! Vegetation Type
            zv_fac =    min( snCaSV(ikl)/snCaMx ! Contribution of Snow to Leaf
     .                      ,  unun)            ! Reflectivity and Transmissiv.
            zv1fac = 1.     -       zv_fac      !
            deadLF = 1.     -       glf_sv(ikl) ! Dead Leaf Fraction


C +--Visible Part of the Solar Radiation Spectrum (V,   0.4--0.7mi.m)
C +  ================================================================

            A_Rad0 =      0.25 + 0.697 * e1pRad ! Absorbed    Vis. Radiation
            T_Rad0 = 1. - A_Rad0                ! Transmitted Vis  Radiation

C +--Reflectivity, Transmissivity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Re_Rad = glf_sv(ikl) *ReVisL(ivg) 
     .             + deadLF      *ReVisD(ivg)
            Tr_Rad = glf_sv(ikl) *TrVisL(ivg) 
     .             + deadLF      *TrVisD(ivg)

C +--Adaptation to Snow
C +  ^^^^^^^^^^^^^^^^^^
            Re_Rad = zv1fac      *Re_Rad      + zv_fac *reVisS
            Tr_Rad = zv1fac      *Tr_Rad      + zv_fac *trVisS

C +--Scattering /DR97, 2, eqn (2.26) and (2.27)        ! Diffuse  Radiation:
C +  ^^^^^^^^^^                                        ! ^^^^^^^^^^^^^^^^^^
            r__Rad = (2. *Re_Rad +     Tr_Rad) / 3.    ! Upw.  Scatter.Fract.
            t__Rad = (    Re_Rad + 2. *Tr_Rad) / 3.    ! Downw.Scatter.Fract.

            t1_Rad =  1. -t__Rad                       !
            arggam =      t1_Rad*t1_Rad-r__Rad*r__Rad  !
            arggam =  max(arggam,zero)                 !
            gamma  = sqrt(arggam)                      ! eqn (2.39)
            gammaL =  min( gamma*LAI_sv(ikl),40.0)     !
            DDifH1 =  exp( gammaL           )          ! Downw.Diffus.Solut.1
            DDifH2 =  exp(-gammaL           )          ! Downw.Diffus.Solut.2
C +         REMARK:  These 2 contributions are zero in case of 0 Reflectivity
C +         ^^^^^^

C +--Scattering /DR97, 2, eqn (2.19) and (2.20)        ! Direct   Radiation:
C +  ^^^^^^^^^^                                        ! ^^^^^^^^^^^^^^^^^^
            r0_Rad = 0.5 *((Re_Rad+Tr_Rad) *k_dRad     ! Upw.  Scatter.Fract.
     .                    +(Re_Rad-Tr_Rad) /    3.)    ! 
            t0_Rad = 0.5 *((Re_Rad+Tr_Rad) *k_dRad     ! Downw.Scatter.Fract.
     .                    -(Re_Rad-Tr_Rad) /    3.)    !

            nu_Rad = t1_Rad-r__Rad*albisv(ikl)         ! nu coeff., eqn 2.43
            den_c1 =  gamma*(DDifH1+DDifH2)            ! eqn (2.43) Denomin. 
     .              +nu_Rad*(DDifH1-DDifH2)            !(Constant for DDifH1)

            denSig =  gamma*gamma - k_dRad*k_dRad      ! eqn (2.40) Denomin.
            denS_s = sign(unun,denSig)                 !
            denS_a =  abs(     denSig)                 !
            denSig =  max(epsi,denS_a) * denS_s        !
            Sig__c = (r__Rad* r0_Rad                   ! sigma_c, eqn (2.40)
     .               +t0_Rad*(k_dRad+t1_Rad)) / denSig ! 

            DDifC1 = ((gamma-nu_Rad)*(T_Rad0-Sig__c*A_Rad0)*DDifH2
     .             +((k_dRad-nu_Rad)* Sig__c
     .               +t0_Rad+r__Rad * albisv(ikl)) *A_Rad0 *exdRad)
     .           /max(den_c1,epsi)
            DDifC2 =  T_Rad0        - DDifC1-Sig__c*A_Rad0

C +--Visible Diffuse Fluxes
C +  ^^^^^^^^^^^^^^^^^^^^^^
            DDif_L =  DDifC1*DDifH1 + DDifC2*DDifH2    ! DOWNward,
     .             +  Sig__c*A_Rad0 *exdRad            ! Canopy Basis
            u0_Vis = ((gamma+t1_Rad)*DDifC1            ! UPward
     .               -(gamma-t1_Rad)*DDifC2            ! Canopy Top
     .             -((k_dRad-t1_Rad)*Sig__c            !
     .               +t0_Rad               )*A_Rad0)   !
     .          / max(r__Rad,epsi)                     !
            u0_Vis = min(0.99,max(epsi,u0_Vis))        ! ERROR 
            absg_V = (1.-albisv(ikl))*(A_Rad0*exdRad   ! Ground Absorption
     .                                +DDif_L       )  !
            absv_V = (1.-u0_Vis     )- absg_V          ! Veget. Absorption

C +--Parameters for Computing Effective LAI for Transpiration
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            gamasv(ikl) = gamma
            C1__sv(ikl) = DDifC1
            C2__sv(ikl) = DDifC2
            Sigcsv(ikl) = Sig__c
            k___sv(ikl) = k_dRad
            A0__sv(ikl) = A_Rad0


C +--Near-IR Part of the Solar Radiation Spectrum (nIR, 0.7--2.8mi.m)
C +  ================================================================

            A_Rad0 =      0.80 + 0.185 * e1pRad ! Absorbed    nIR. Radiation
            T_Rad0 = 1. - A_Rad0                ! Transmitted nIR  Radiation

C +--Reflectivity, Transmissivity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Re_Rad = glf_sv(ikl) *RenIRL(ivg) 
     .             + deadLF      *RenIRD(ivg)
            Tr_Rad = glf_sv(ikl) *TrnIRL(ivg) 
     .             + deadLF      *TrnIRD(ivg)

C +--Adaptation to Snow
C +  ^^^^^^^^^^^^^^^^^^
            Re_Rad = zv1fac      *Re_Rad      + zv_fac *renIRS
            Tr_Rad = zv1fac      *Tr_Rad      + zv_fac *trnIRS

C +--Scattering /DR97, 2, eqn (2.26) and (2.27)        ! Diffuse  Radiation:
C +  ^^^^^^^^^^                                        ! ^^^^^^^^^^^^^^^^^^
            r__Rad = (2. *Re_Rad +     Tr_Rad) / 3.    ! Upw.  Scatter.Fract.
            t__Rad = (    Re_Rad + 2. *Tr_Rad) / 3.    ! Downw.Scatter.Fract.

            t1_Rad =  1. -t__Rad                       !
            arggam =      t1_Rad*t1_Rad-r__Rad*r__Rad  !
            arggam =  max(arggam,zero)                 !
            gamma  = sqrt(arggam)                      ! eqn (2.39)
            DDifH1 =  exp( gamma*LAI_sv(ikl))          ! Downw.Diffus.Solut.1
            DDifH2 =  exp(-gamma*LAI_sv(ikl))          ! Downw.Diffus.Solut.2
C +         REMARK:  These 2 contributions are zero in case of 0 Reflectivity
C +         ^^^^^^

C +--Scattering /DR97, 2, eqn (2.19) and (2.20)        ! Direct   Radiation:
C +  ^^^^^^^^^^                                        ! ^^^^^^^^^^^^^^^^^^
            r0_Rad = 0.5 *((Re_Rad+Tr_Rad) *k_dRad     ! Upw.  Scatter.Fract.
     .                    +(Re_Rad-Tr_Rad) /    3.)    ! 
            t0_Rad = 0.5 *((Re_Rad+Tr_Rad) *k_dRad     ! Downw.Scatter.Fract.
     .                    -(Re_Rad-Tr_Rad) /    3.)    !

            nu_Rad = t1_Rad-r__Rad*albisv(ikl)         ! nu coeff., eqn 2.43
            den_c1 =  gamma*(DDifH1+DDifH2)            ! eqn (2.43) Denomin. 
     .              +nu_Rad*(DDifH1-DDifH2)            !(Constant for DDifH1)

            denSig =  gamma*gamma - k_dRad*k_dRad      ! eqn (2.40) Denomin.
            denS_s = sign(unun,denSig)                 !
            denS_a =  abs(     denSig)                 !
            denSig =  max(epsi,denS_a) * denS_s        !
            Sig__c = (r__Rad* r0_Rad                   ! sigma_c, eqn (2.40)
     .               +t0_Rad*(k_dRad+t1_Rad)) / denSig ! 

            DDifC1 = ((gamma-nu_Rad)*(T_Rad0-Sig__c*A_Rad0)*DDifH2
     .             +((k_dRad-nu_Rad)* Sig__c
     .               +t0_Rad+r__Rad * albisv(ikl)) *A_Rad0 *exdRad)
     .           /max(den_c1,epsi)
            DDifC2 =  T_Rad0        - DDifC1-Sig__c*A_Rad0

C +--Near IR Diffuse Fluxes
C +  ^^^^^^^^^^^^^^^^^^^^^^
            DDif_L =  DDifC1*DDifH1 + DDifC2*DDifH2    ! DOWNward,
     .             +  Sig__c*A_Rad0 *exdRad            ! Canopy Basis
            u0_nIR = ((gamma+t1_Rad)*DDifC1            ! UPward
     .               -(gamma-t1_Rad)*DDifC2            ! Canopy Top
     .             -((k_dRad-t1_Rad)*Sig__c            !
     .               +t0_Rad               )*A_Rad0)   !
     .          / max(r__Rad,epsi)                     !
            u0_nIR = min(0.99,max(epsi,u0_nIR))        ! ERROR
            absgnI = (1.-albisv(ikl))*(A_Rad0*exdRad   ! Ground Absorption
     .                                +DDif_L       )  !
            absvnI = (1.-u0_nIR     )- absgnI          ! Veget. Absorption


C +--Surface-Canopy Albedo and Normalized Solar Radiation Absorption
C +  ===============================================================

            alb_SV(ikl) = (u0_Vis+u0_nIR)*0.5d0
            SoCasv(ikl) = (absv_V+absvnI)*0.5d0
            SoSosv(ikl) = (absg_V+absgnI)*0.5d0

c #sv   END IF

      END DO


C +--Effective LAI for Transpiration
C +  ===============================

        DO ikl=1,klonv
              criLAI(ikl) = 2.                  ! LAI for which D0_Vis > 20W/m2
C +                                             ! DR97, 2, eqn (2.57)
        END DO

      DO   kri=1,10
        DO ikl=1,klonv

c #sv     IF (ifraSV(ikl).GT.0)                                   THEN
              argexg      =  min(criLAI(ikl)*gamasv(ikl),     argmax)
              argexk      =  min(criLAI(ikl)*k___sv(ikl),     argmax)
              residu      =      C1__sv(ikl)            *exp( argexg)
     .                          +C2__sv(ikl)            *exp(-argexg)
     .                          +A0__sv(ikl)*gamasv(ikl)*exp(-argexk)
     .                          -CriStR /max(sol_SV(ikl),       epsi)

              d_DDif      =      C1__sv(ikl)*gamasv(ikl)*exp( argexg)
     .                          -C2__sv(ikl)*gamasv(ikl)*exp(-argexg)
     .                          -A0__sv(ikl)*k___sv(ikl)*exp(-argexk)
              dDDifs      = sign(unun,d_DDif)
              dDDifa      =  abs(     d_DDif)
              d_DDif      =  max(epsi,dDDifa) * dDDifs

              criLAI(ikl) =      criLAI(ikl)-residu/d_DDif
              criLAI(ikl) =  max(criLAI(ikl),zero       )
              criLAI(ikl) =  min(criLAI(ikl),LAI_sv(ikl))
c #sv     END IF

        END DO
      END DO

        DO ikl=1,klonv
              LAIesv(ikl) = criLAI(ikl) +(exp(-k___sv(ikl)*criLAI(ikl))
     .                                   -exp(-k___sv(ikl)*LAI_sv(ikl)))
     .                                  /      k___sv(ikl)
        END DO

      return
      end


      subroutine ColPrt_SBL

C +------------------------------------------------------------------------+
C | MAR          ColPrt_SBL                                27-04-2002  MAR |
C |   SubRoutine ColPrt_SBL generates Surface Boundary Layers Properties   |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns                          |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   za__SV   : Surface Boundary Layer (SBL) Height          [m] |
C |   ^^^^^    VV__SV   :(SBL Top)   Wind Velocity                   [m/s] |
C |            TaT_SV   : SBL Top    Temperature                       [K] |
C |            rhT_SV   : SBL Top  Air  Density                    [kg/m3] |
C |            uqs_SV   : Specific  Humidity  Turbulent Flux         [m/s] |
C |            Tsrfsv   : Surface    Temperature                       [K] |
C |                                                                        |
C |   INPUT /  LMO_SV   : Monin-Obukhov       Scale                    [m] |
C |   OUTPUT:  us__SV   : Friction  Velocity                         [m/s] |
C |   ^^^^^^   uts_SV   : Temperature         Turbulent Flux       [K.m/s] |
C |                                                                        |
C |   OUTPUT:  ram_sv   : Aerodynamic Resistance for Momentum        [s/m] |
C |   ^^^^^^   rah_sv   : Aerodynamic Resistance for Heat            [s/m] |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"

      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--Internal Variables
C +  ==================

      integer   ikl    ,ist    ,ist__s ,ist__w
      real      d_TaTs ,CD_m
      real      uustar ,thstar ,qqstar ,ssstar
      real      thstarv,thstars,thstara
      real      zeta   ,zeta_S ,zeta_A
      real      fCdCdP ,Cd_min ,cCdUns
      real      RapCm0


C +--Internal DATA
C +  =============

      data      fCdCdP/ 3.09/   ! Drag Coefficient Factor, Col de Porte
      data      Cd_min/ 1.05/   ! Drag Coefficient Minimum Col de Porte
      data      cCdUns/-5.00/   ! Drag Coefficient Correction for Unstability


C +--Aerodynamic Resistances
C +  =======================

      DO ikl=1,klonv

C +--Surface Type
C +  ~~~~~~~~~~~~
        ist    =      isotSV(ikl)                    ! Soil Type
        ist__s =  min(ist, 1)                        ! 1 => Soil
        ist__w =  1 - ist__s                         ! 1 => Water Body

C +--Drag and Aerodynamic Resistance
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        d_TaTs =      TaT_SV(ikl)-Tsrfsv(ikl)
        RapCm0 =  log(za__SV(ikl)/Z0mdSV(4          ))
     .         /  log(za__SV(ikl)/Z0mdSV(ivgtSV(ikl)))
        RapCm0 =      RapCm0     *RapCm0             ! Neutral Drag Coefficient
                                                     ! Vegetation   Correction
        CD_m   =  max(Cd_min*RapCm0,                 ! Actual  Drag Coefficient
     .                fCdCdP*RapCm0*VV__SV(ikl)  )   !         for  Momentum
     .          *(1.+max(min(d_TaTs,zero),cCdUns)    ! Unstability  Correction
     .                                   /cCdUns )
     .          * 1.5
        ram_sv(ikl) = rhT_SV(ikl)  *Cp   /CD_m
        rah_sv(ikl) = ram_sv(ikl)


C +--Turbulent Scales
C +  ================

C +--Friction Velocity                   u*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uustar      =      VV__SV(ikl) / ram_sv(ikl)
        us__SV(ikl) = sqrt(uustar)

C +--Real    Temperature Turbulent Scale theta*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uts_SV(ikl) =    - d_TaTs      / rah_sv(ikl)
        thstar      =      uts_SV(ikl) / us__SV(ikl)

C +--Specific Humidity   Turbulent Scale qq*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        qqstar      =      uqs_SV(ikl) / us__SV(ikl) 

C +--Virtual Temperature Turbulent Scale thetav*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        thstarv     = thstar      + TaT_SV(ikl) *(0.608*qqstar)
        thstars     =     sign(unun,thstarv)
        thstara     =      abs(     thstarv)
        thstarv     =      max(epsi,thstara)    *thstars

C +--Monin Obukhov Scale Height
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~
        LMO_SV(ikl) = TaT_SV(ikl) * uustar 
     .              /(vonkar      * gravit     * thstarv)
        zeta        = za__SV(ikl) / LMO_SV(ikl)
        zeta_S      =          sign(unun  ,zeta)
        zeta_A      =           abs(       zeta)
        zeta        = zeta_S  * max(epsi  ,zeta_A)
        LMO_SV(ikl) = za__SV(ikl) / zeta

      END DO

      return
      end


      subroutine SISVATeSBL

!--------------------------------------------------------------------------+
!   MAR          SISVATeSBL                           Tue 12-Apr-2011  MAR |
!     SubRoutine SISVATeSBL generates Surface Boundary Layers Properties   |
!--------------------------------------------------------------------------+
!                                                                          |
!     PARAMETERS:  klonv: Total Number of columns                          |
!     ^^^^^^^^^^        = Total Number of continental     grid boxes       |
!                       X       Number of Mosaic Cell per grid box         |
!                                                                          |
!     INPUT:   za__SV   : Surface Boundary Layer (SBL) Height          [m] |
!     ^^^^^    VV__SV   :(SBL Top)   Wind Velocity                   [m/s] |
!              TaT_SV   : SBL Top    Temperature                       [K] |
!              ExnrSV   : Exner      Potential                         [-] |
!              qsnoSV   : SBL Mean   Snow      Content             [kg/kg] |
!              uqs_SV   : Specific   Humidity  Turbulent Flux        [m/s] |
!              usthSV   : Blowing Snow Erosion   Threshold           [m/s] |
!              Z0m_SV   : Momentum     Roughness Length                [m] |
!              Z0h_SV   : Heat         Roughness Length                [m] |
!              Tsrfsv   : Surface    Temperature                       [K] |
!              sqrCm0   : Contribution of Z0m to Neutral Drag Coefficient  |
!              sqrCh0   : Contribution of Z0h to Neutral Drag Coefficient  |
!                                                                          |
!     INPUT /  LMO_SV   : Monin-Obukhov       Scale                    [m] |
!     OUTPUT:  us__SV   : Friction  Velocity                         [m/s] |
!     ^^^^^^   uts_SV   : Temperature         Turbulent Flux       [K.m/s] |
!              uss_SV   : Blowing Snow        Turbulent Flux         [m/s] |
!                                                                          |
!     OUTPUT:  hSalSV   : Saltating Layer Height                       [m] |
!     ^^^^^^   qSalSV   : Saltating Snow  Concentration            [kg/kg] |
!              ram_sv   : Aerodynamic Resistance for Momentum        [s/m] |
!              rah_sv   : Aerodynamic Resistance for Heat            [s/m] |
!                                                                          |
!   # OPTIONS: #BS: Blowing Snow turbulent Fluxes are computed             |
!   # ^^^^^^^  #ss: Additional Output                                      |
!                                                                          |
!--------------------------------------------------------------------------+


      IMPLICIT NONE


!  Global Variables
!  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"

      include  "MARxSV.inc"
      include  "MARySV.inc"


! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx integer                iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1
! #wx common  /SISVAT_EV/    iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1

!  V,  dT(a-s)    Time Moving Averages
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      integer                       ntaver,nt !
      parameter                    (ntaver= 4)! ntaver defined in MAR_SL.inc
c #AW real             V__mem(klonv,ntaver)   !                   only
c #AW real             VVmmem(klonv)          !
c #AW common/SVeSBLmem/V__mem,VVmmem          !
c #AH real             T__mem(klonv,ntaver)   !
c #AH real             dTmmem(klonv)          !
c #AH common/STeSBLmem/T__mem,dTmmem          !

!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/,
!$OMP. /SVeSBLmem/,/STeSBLmem/)

!  u*, u*T*, u*s* Time Moving Averages
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM real             u__mem(klonv,ntaver)
c #AT real             uT_mem(klonv,ntaver)
c #AS real             us_mem(klonv,ntaver)
c #AM common/S_eSBLmem/u__mem
c #AT.                ,uT_mem
c #AS.                ,us_mem


!  Internal Variables
!  ==================

      integer   ikl   ,icount
c #AE integer   nit   ,iit
      real      VVaSBL(klonv),VVa_OK          ! effective SBL wind speed
      real      dTa_Ts(klonv)                 ! effective SBL Temperature diff.
      real      Theta0                        ! Potential Reference Temperature
      real      LMOmom(klonv)                 ! Monin-Obukhov Scale Momentum
      real      LMOsgn                        ! Monin-Obukhov Scale Sign
      real      LMOabs                        ! Monin-Obukhov Scale Abs.Value
      real      uustar,thstar,qqstar,ssstar,thstarv,thstars,thstara
      real      zetam ,zetah ,zeta_S,zeta_A,zeta0m ,zeta0h
      real      psim_s,xpsimi,psim_i,psim_z
      real      psis_s,psis_z,psis_0
      real      psih_s,xpsihi,psih_i,psih_z
      real      psim_0,psih_0
      real      CDm(klonv)                    ! Drag Coefficient, Momentum
      real      CDs(klonv),rCDs(klonv)        ! Drag Coefficient, Blown **
      real      CDh(klonv)                    ! Drag Coefficient, Scalar
      real      dustar,u0star,uTstar,usstar
      real      sss__F,sss__N,usuth0
c #AE real      dusuth,signus
c #AE real      sss__K,sss__G
c #AE real      us_127,us_227,us_327,us_427,us_527
      real      zetMAX
      real      coef_m,coef_h,stab_s
c #AE real      SblPom
      real      Richar(klonv)                 ! Richardson Number
c #wr real      W_pLMO                        ! Pseudo Obukhov Length  (WRITE)
c #wr real      W_psim                        ! Pseudo psim(z)         (WRITE)
c #w1 real      W_NUs1                        ! Contrib to U* numerat.1(WRITE)
c #w1 real      W_NUs2                        ! Contrib to U* numerat.2(WRITE)
c #w1 real      W_NUs3                        ! Contrib to U* numerat.3(WRITE)
c #w1 real      W_DUs1                        ! Contrib to U* denomin.1(WRITE)
c #w1 real      W_DUs2                        ! Contrib to U* denomin.2(WRITE)
      real      fac_Ri,vuzvun,Kz_vun


!  Internal DATA
!  =============

      data      Theta0/288.0/   ! Potential Reference Temperature
c #ZX data      zetMAX/ 1.e6/   ! Strong Stability Limit
c #zx data      zetMAX/ 1.e0/   ! Strong Stability Limit
C +                             !(Mahalov et al. 2004, GRL  31 2004GL021055)
      data      zetMAX/ 4.28/   ! Strong Stability Limit
C +                             !(King    et al. 1996, JGR 101(7) p.19121)
      data      coef_m/20.  /   ! Stabil.Funct.for Moment.: unstab.coef.
      data      coef_h/15.  /   ! Stabil.Funct.for Heat:    unstab.coef.
c #AE data      SblPom/ 1.27/   ! Lower Boundary Height Parameter 
C +                             ! for Suspension
C +                             ! Pommeroy, Gray and Landine 1993, 
C +                             ! J. Hydrology, 144(8) p.169
c #AE data      nit   / 5   /   ! us(is0,uth) recursivity: Nb Iterations 


!  Effective SBL variables
!  =======================

      DO ikl=1,klonv
        VVaSBL(ikl)   = VV__SV(ikl)
c #AW   VVaSBL(ikl)   = VVmmem(ikl)
        dTa_Ts(ikl)   = TaT_SV(ikl)-Tsrfsv(ikl)
c #AH   dTa_Ts(ikl)   = dTmmem(ikl)
      ENDDO


!  Convergence Criterion
!  =====================

      icount = 0

 1    CONTINUE
      icount = icount + 1
      dustar = 0.

        DO ikl=1,klonv

          u0star      = us__SV(ikl)

!  u*, u*T*, u*s* Time Moving Averages
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM     u0star      = 0.0
c #AT     uTstar      = 0.0
c #AS     usstar      = 0.0
c #AM     DO nt=1,ntaver
c #AM     u0star      = u0star + u__mem(ikl,nt)
c #AT     uTstar      = uTstar + uT_mem(ikl,nt)
c #AS     usstar      = usstar + us_mem(ikl,nt)
c #AM     ENDDO
c #AM     u0star      = u0star / ntaver
c #AM     us__SV(ikl) = u0star
c #AT     uts_SV(ikl) = uTstar / ntaver
c #AS     uss_SV(ikl) = usstar / ntaver


!  Turbulent Scales from previous Time Step
!  ----------------------------------------

          u0star      =      max(epsi,u0star)      ! Friction Velocity     u*
          uustar      = u0star      * u0star       ! Friction Velocity^2  uu*
          thstar      = uts_SV(ikl) / u0star       ! Temperature       theta*
          qqstar      = uqs_SV(ikl) / u0star       ! Specific Humidity    qq*
          ssstar      = uss_SV(ikl) / u0star       ! Blown    Snow        ss*


!  Monin-Obukhov Stability Parameter for Momentum
!  ----------------------------------------------

!  Pseudo Virtual Temperature Turbulent Scale thetav*
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          thstarv     = thstar      + Theta0      *(0.608*qqstar)
     .                             /(1.+0.608*QaT_SV(ikl)-qsnoSV(ikl))
          thstars     =     sign(unun,thstarv)
          thstara     =      abs(     thstarv)
          thstarv     =      max(epsi,thstara)*thstars

!  Pseudo Obukhov Length Scale        (Gall?e et al., 2001 BLM 99, (A2) p.17)
!  Full   Obukhov Length Scale        (when Blowing * is ##NOT## switched ON)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          LMO_SV(ikl) = Theta0      * max(epsi,uustar)
     .                /(vonkar      * gravit  *thstarv)
c #wr     W_pLMO      = LMO_SV(ikl)

          zetah       = za__SV(ikl) / LMO_SV(ikl)
          zetam       =           min(zetMAX,zetah)! Strong Stability Limit
                                                   !(Mahalov et al. 2004
                                                   ! GRL 31 2004GL021055)
          LMOmom(ikl) = za__SV(ikl) /(max(epsi,abs(zetam))
     .                              *sign(unun,    zetam ))
          zeta0m      = Z0m_SV(ikl) / LMOmom(ikl)
          zeta0h      = Z0h_SV(ikl) / LMO_SV(ikl)

!  Momentum Pseudo Stability Function (Gall?e et al. 2001, BLM 99, (11) p. 7)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          stab_s      =  max(zero,sign(unun,zetam))

          psim_s      =  -A_Turb *zetam
          xpsimi      = sqrt(sqrt(unun-coef_m*min(zero,zetam)))
          psim_i      =   2. *log(demi*(unun+xpsimi)) 
     .                       +log(demi*(unun+xpsimi*xpsimi))
     .                   -2.*atan(xpsimi)   +demi*pi
          psim_z      =    stab_s*psim_s+(1.-stab_s)*psim_i
c #wr     W_psim      =           psim_z

          psim_s      =  -A_Turb *zeta0m
          xpsimi      = sqrt(sqrt(unun-coef_m*min(zero,zeta0m)))
          psim_i      =   2. *log(demi*(unun+xpsimi)) 
     .                       +log(demi*(unun+xpsimi*xpsimi))
     .                   -2.*atan(xpsimi)   +demi*pi
          psim_0      =    stab_s*psim_s+(1.-stab_s)*psim_i

!  Virtual Temperature Turbulent Scale thetav*    (ss* impact included   )
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ needed for new ss*)
c #AE     thstarv     = thstar      + Theta0      *(0.608*qqstar
c #AE.                                                   -ssstar
c #AE.                                             )
c #AE.                             /(1.+0.608*QaT_SV(ikl)-qsnoSV(ikl))
c #AE     thstars     =     sign(unun,thstarv)
c #AE     thstara     =      abs(     thstarv)
c #AE     thstarv     =      max(epsi,thstara)    *thstars

!  Full   Obukhov Length Scale        (Gall?e et al. 2001, BLM 99, (A1) p.16)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE     LMO_SV(ikl) = Theta0      * us__SV(ikl)* us__SV(ikl)
c #AE.                /(vonkar      * gravit     * thstarv)
C +
c #AE     zetah       = za__SV(ikl) / LMO_SV(ikl)
c #AE     zetam       =           min(zetMAX,zetah)! Strong Stability Limit
                                                   !(Mahalov et al. 2004
                                                   ! GRL 31 2004GL021055)
c #AE     LMOmom(ikl) = za__SV(ikl) /(max(epsi,abs(zetam))
c #AE.                              *sign(unun,    zetam ))
c #AE     zeta0m      = Z0m_SV(ikl) / LMOmom(ikl)

!  Snow Erosion    Stability Function (Gall?e et al. 2001, BLM 99, (11) p. 7)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE     stab_s      =  max(zero,sign(unun,zetam))

c #AE     psis_s      =  -AsTurb *zetam
c #AE     xpsimi      = sqrt(sqrt(unun-coef_m*min(zero,zetam)))
c #AE     psim_i      =   2. *log(demi*(unun+xpsimi)) 
c #AE.                       +log(demi*(unun+xpsimi*xpsimi))
c #AE.                   -2.*atan(xpsimi)   +demi*pi
c #AE     psis_z      =    stab_s*psis_s+(1.-stab_s)*psim_i

c #AE     psis_s      =  -AsTurb *zeta0m
c #AE     xpsimi      = sqrt(sqrt(unun-coef_m*min(zero,zeta0m)))
c #AE     psim_i      =   2. *log(demi*(unun+xpsimi)) 
c #AE.                       +log(demi*(unun+xpsimi*xpsimi))
c #AE.                   -2.*atan(xpsimi)   +demi*pi
c #AE     psis_0      =    stab_s*psis_s+(1.-stab_s)*psim_i

!  Square Roots of the Drag Coefficient for Snow Erosion Turbulent Flux
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE     rCDmSV(ikl) = vonkar/(sqrCm0(ikl)-psim_z+psim_0)

c #ss     IF (ii__SV(ikl).EQ.iwr_SV.AND.jj__SV(ikl).EQ.jwr_SV      .AND.
c #ss.        nn__SV(ikl).EQ.nwr_SV                          )
c #ss.    write(6,6600)  Z0m_SV(ikl) , psim_z
c #ss.                  ,LMO_SV(ikl) , uustar
c #ss.                  ,sqrCm0(ikl) , psim_0
c #ss.                  ,LMOmom(ikl) , thstarv
 6600     format(/,' ** SISVATeSBL *0  '
     .            ,'  Z0m_SV  = ',e12.4,'  psim_z  = ',e12.4
     .            ,'  LMO_SV  = ',e12.4,'  uustar  = ',e12.4
     .          ,/,'                   '
     .            ,'  sqrCm0  = ',e12.4,'  psim_0  = ',e12.4
     .            ,'  LMOmom  = ',e12.4,'  thstarv = ',e12.4)


!  Momentum            Turbulent Scale  u*
!  ---------------------------------------

!  Momentum            Turbulent Scale  u*          in case of NO Blow. Snow
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          VVa_OK      =  max(0.000001,       VVaSBL(ikl))
          sss__N      =  vonkar      *       VVa_OK
          sss__F      = (sqrCm0(ikl) - psim_z + psim_0)
          usuth0      =  sss__N /sss__F                ! u* if NO Blow. Snow

!  Momentum            Turbulent Scale  u*          in case of    Blow. Snow
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE     sss__G      =  0.27417     * gravit

!  ______________               _____
!  Newton-Raphson (! Iteration, BEGIN)
!  ~~~~~~~~~~~~~~               ~~~~~
c #AE     DO iit=1,nit
c #AE     sss__K      =  gravit      * r_Turb * A_Turb *za__SV(ikl)
c #AE.                                     *rCDmSV(ikl)*rCDmSV(ikl)
c #AE.                           /(1.+0.608*QaT_SV(ikl)-qsnoSV(ikl))
c #AE     us_127      =  exp(    SblPom *log(us__SV(ikl)))
c #AE     us_227      =  us_127         *    us__SV(ikl)
c #AE     us_327      =  us_227         *    us__SV(ikl)
c #AE     us_427      =  us_327         *    us__SV(ikl)
c #AE     us_527      =  us_427         *    us__SV(ikl)

c #AE     us__SV(ikl) =  us__SV(ikl)
c #AE.    - (  us_527     *sss__F     /sss__N
c #AE.      -  us_427
c #AE.      -  us_227     *qsnoSV(ikl)*sss__K
c #AE.      + (us__SV(ikl)*us__SV(ikl)-usthSV(ikl)*usthSV(ikl))/sss__G)
c #AE.     /(  us_427*5.27*sss__F     /sss__N
c #AE.      -  us_327*4.27
c #AE.      -  us_127*2.27*qsnoSV(ikl)*sss__K
c #AE.      +  us__SV(ikl)*2.0                                 /sss__G)

c #AE     us__SV(ikl)= min(us__SV(ikl),usuth0)
c #AE     us__SV(ikl)= max(us__SV(ikl),epsi  )
c #AE     rCDmSV(ikl)=     us__SV(ikl)/VVa_OK
! #AE     sss__F     =     vonkar     /rCDmSV(ikl)
c #AE     ENDDO
!  ______________               ___  
!  Newton-Raphson (! Iteration, END  )
!  ~~~~~~~~~~~~~~               ~~~  

c #AE     us_127      =  exp(    SblPom *log(us__SV(ikl)))
c #AE     us_227      =  us_127         *    us__SV(ikl)

!  Momentum            Turbulent Scale  u*: 0-Limit in case of no Blow. Snow
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AE     dusuth      =  us__SV(ikl) - usthSV(ikl)       ! u* - uth*
c #AE     signus      =  max(sign(unun,dusuth),zero)     ! 1 <=> u* - uth* > 0
          us__SV(ikl) =                                  !
c #AE.                   us__SV(ikl)  *signus  +         ! u* (_BS)
     .                   usuth0                          ! u* (nBS)
c #AE.                            *(1.-signus)           !


!  Blowing Snow        Turbulent Scale ss*
!  ---------------------------------------

c #AE     hSalSV(ikl) = 8.436e-2  *exp(SblPom  *log(us__SV(ikl)))
c #AE     qSalSV(ikl) = (us__SV(ikl) * us__SV(ikl)
c #AE.                  -usthSV(ikl) * usthSV(ikl))*signus
c #AE.                / (sss__G      * us_227     )

c #ae     qSalSV(ikl) = (us__SV(ikl) * us__SV(ikl)
c #ae.                  -usthSV(ikl) * usthSV(ikl))
c #ae.                  *signus      * us__SV(ikl) *3.25
c #ae.                 /(hSalSV(ikl) * gravit           )

c #AE     ssstar      =  rCDmSV(ikl) *(qsnoSV(ikl) -qSalSV(ikl))
c #AE.                 * r_Turb

c #AE     uss_SV(ikl) =  min(zero    , us__SV(ikl) *ssstar)
c #BS     uss_SV(ikl) =  max(-0.002  , uss_SV(ikl)        )

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #ss     IF (ii__SV(ikl).EQ.iwr_SV.AND.jj__SV(ikl).EQ.jwr_SV      .AND.
c #ss.        nn__SV(ikl).EQ.nwr_SV                          )
c #ss.    write(6,6610)  usuth0      , us__SV(ikl)
c #ss.                  ,qsnoSV(ikl) , uss_SV(ikl)
c #ss.                  ,usthSV(ikl) , LMO_SV(ikl)
c #ss.                  ,qSalSV(ikl) , VVa_OK
 6610     format(/,' ** SISVATeSBL *1  '
     .            ,'  u*(nBS) = ',e12.4,'  u*(_BS) = ',e12.4
     .            ,'  Qs      = ',e12.4,'  u*Qs*   = ',e12.4
     .          ,/,'                   '
     .            ,'  u*(_th) = ',e12.4,'  LMO     = ',e12.4
     .            ,'  QSalt   = ',e12.4,'  VVa     = ',e12.4)

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx IF       (ikl .EQ. kSV_v1   .AND.   lSV_v1 .GT. 0
! #wx.                            .AND.   lSV_v1 .LE. 2)
! #wx.    write(6,6000)  daHost     ,     icount     ,
! #wx.                   us__SV(ikl),1.e3*hSalSV(ikl),
! #wx.              1.e3*Z0m_SV(ikl),
! #wx.              1.e3*qsnoSV(ikl),1.e3*qSalSV(ikl)
! #wx.                  ,usthSV(ikl),     us__SV(ikl)-usthSV(ikl),
! #wx.              1.e3*ssstar     ,1.e3*us__SV(ikl)*ssstar
 6000     format(a18,i3,6x,'u*   [m/s] =',f6.3,'   hSalt[mm]='  ,e9.3,
     .                  '   Z0m   [mm] =',f9.3,'   q   [g/kg] =',f9.3,
     .               /,91x,                    '   qSa [g/kg] =',f9.3,
     .               /,27x, 'ut*[m/s]='  ,e9.3,'   u*-ut*   ='  ,e9.3,
     .                  '   s*  [g/kg] =',f9.3,'   us* [mm/s] =',f9.3)


!  Virtual Temperature Turbulent Scale thetav*    (ss* impact included)
!  --------------------------------------------------------------------

c #AE     thstarv     = thstar      + Theta0      *(0.608*qqstar
c #AE.                                                   -ssstar
c #AE.                                             )
c #AE.                             /(1.+0.608*QaT_SV(ikl)-qsnoSV(ikl))
c #AE     thstars     =     sign(unun,thstarv)
c #AE     thstara     =      abs(     thstarv)
c #AE     thstarv     =      max(epsi,thstara)    *thstars


!  Full   Obukhov Length Scale (Gall?e et al., 2001, BLM 99, (A1) p.16)
!  --------------------------------------------------------------------

c #AE     LMO_SV(ikl) = Theta0      * us__SV(ikl)* us__SV(ikl) 
c #AE.                /(vonkar      * gravit     * thstarv)

c #AE     zetah       = za__SV(ikl) / LMO_SV(ikl)
c #AE     zetam       =           min(zetMAX,zetah)! Strong Stability Limit
                                                   !(Mahalov et al. 2004
                                                   ! GRL 31 2004GL021055)
c #AE     LMOmom(ikl) = za__SV(ikl) /(max(epsi,abs(zetam))
c #AE.                              *sign(unun,    zetam ))
c #AE     zeta0m      = Z0m_SV(ikl) / LMOmom(ikl)
c #AE     zeta0h      = Z0h_SV(ikl) / LMO_SV(ikl)

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx IF       (ikl .EQ. kSV_v1   .AND.   lSV_v1 .GT. 0
! #wx.                            .AND.   lSV_v1 .LE. 2)
! #wx.    write(6,6001)  LMO_SV(ikl)    ,    zetah
 6001     format(18x,9x,'LMO  [m]=',f9.1,'   zetah[-] =',f9.3)


!  Turbulent Scales
!  ----------------

!  Momentum Stability Function (Gall?e et al., 2001, BLM 99, (11) p. 7)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          stab_s      =  max(zero,sign(unun,zetam))

          psim_s      =  -A_Turb *zetam
          xpsimi      = sqrt(sqrt(unun-coef_m*min(zero,zetam)))
          psim_i      =   2. *log(demi*(unun+xpsimi)) 
     .                       +log(demi*(unun+xpsimi*xpsimi))
     .                   -2.*atan(xpsimi)   +demi*pi
          psim_z      =    stab_s*psim_s+(1.-stab_s)*psim_i

          psim_s      =  -A_Turb *zeta0m
          xpsimi      = sqrt(sqrt(unun-coef_m*min(zero,zeta0m)))
          psim_i      =   2. *log(demi*(unun+xpsimi)) 
     .                       +log(demi*(unun+xpsimi*xpsimi))
     .                   -2.*atan(xpsimi)   +demi*pi
          psim_0      =    stab_s*psim_s+(1.-stab_s)*psim_i

!  Heat     Stability Function (Gall?e et al., 2001, BLM 99, (11) p. 7)
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          stab_s      =  max(zero,sign(unun,zetah))

          psih_s      =  -AhTurb *zetah
          xpsihi      = sqrt(sqrt(unun-coef_h*min(zero,zetah)))
          psih_i      =   2. *log(demi*(unun+xpsihi)) 
          psih_z      =    stab_s*psih_s+(1.-stab_s)*psih_i

          psih_s      =  -AhTurb *zeta0h
          xpsihi      = sqrt(sqrt(unun-coef_h*min(zero,zeta0h)))
          psih_i      =   2. *log(demi*(unun+xpsihi)) 
          psih_0      =    stab_s*psih_s+(1.-stab_s)*psih_i

!  Square Roots of the Drag Coefficients
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          rCDhSV(ikl) = vonkar*(ExnrSV(ikl)/pcap)
     .                        /(sqrCh0(ikl)-psih_z+psih_0)
          rCDmSV(ikl) = vonkar/(sqrCm0(ikl)-psim_z+psim_0)

!  Drag Coefficients
!  ~~~~~~~~~~~~~~~~~
          CDh(ikl)    = rCDmSV(ikl) * rCDhSV(ikl)
          CDm(ikl)    = rCDmSV(ikl) * rCDmSV(ikl)

!  Real    Temperature Turbulent Scale theta*
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          thstar      = rCDhSV(ikl) * dTa_Ts(ikl)
     .                              *(pcap       /ExnrSV(ikl))
          uts_SV(ikl) = us__SV(ikl) * thstar


!  Convergence Criterion
!  =====================

          dustar      = max(dustar,abs(us__SV(ikl)-u0star))

!  u*, u*T*, u*s* Time Moving Averages
!  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #AM     DO nt=   1,ntaver-1
c #AM     u__mem(ikl,nt    ) = u__mem(ikl,nt+1)
c #AT     uT_mem(ikl,nt    ) = uT_mem(ikl,nt+1)
c #AS     us_mem(ikl,nt    ) = us_mem(ikl,nt+1)
c #AM     ENDDO
c #AM     u__mem(ikl,ntaver) = us__SV(ikl)
c #AT     uT_mem(ikl,ntaver) = uts_SV(ikl)
c #AS     us_mem(ikl,ntaver) = uss_SV(ikl)

!  OUTPUT for Verification (general)
!  ~~~~~~~~~~~~~~~~~~~~~~~
c #wr    IF (icount     .EQ.1  )                                    THEN
c #wr     write(6,6004)
 6004     format(122('-'))
c #wr    IF (mod(VVaSBL(ikl),4.).LT.0.1)                            THEN
c #wr     write(6,6003)
 6003     format('   V  Ta-Ts  Z0      It'
     .   ,' du*     u*    sss__F   CD       Qss       Qs*     '
     .   ,' PseudOL Full-OL zetam   zetah   psim_z  psih_z')
c #wr     write(6,6004)
c #wr    END IF
c #wr    END IF
c #wr     write(6,6002) VVaSBL(ikl),dTa_Ts(ikl),Z0m_SV(ikl),icount
c #wr.                 ,dustar     ,us__SV(ikl),sss__F
c #wr.                 ,   CDm(ikl),qSalSV(ikl),ssstar
c #wr.                 ,W_pLMO     ,LMO_SV(ikl)
c #wr.                 ,zetam      ,zetah      ,W_psim     ,psih_z
 6002     format(2f6.1,f8.4,i3,f9.6,f6.3,f9.3,3f9.6,2f8.2,2f8.4,2f8.2)

!  OUTPUT for Verification (u*_AE)
!  ~~~~~~~~~~~~~~~~~~~~~~~
c #w1    IF (icount     .EQ.1  )                                    THEN
c #w1     write(6,6014)
 6014     format(100('-'))
c #w1    IF (mod(VVaSBL(ikl),4.).LT.0.1)                            THEN
c #w1     write(6,6013)
 6013     format('   V  Ta-Ts  Z0      It'
     .   ,' du*     u*    sss__F   W_NUs1   W_NUs2   W_NUs3      '
     .   ,' W_DUs1     W_DUs2 ')
c #w1     write(6,6014)
c #w1    END IF
c #w1    END IF
c #w1     write(6,6012) VVaSBL(ikl),dTa_Ts(ikl),Z0m_SV(ikl),icount
c #w1.                 ,dustar     ,us__SV(ikl),sss__F
c #w1.                 ,W_NUs1     ,W_NUs2     ,W_NUs3     
c #w1.                 ,W_DUs1     ,W_DUs2     
 6012     format(2f6.1,f8.4,i3,f9.6,f6.3,f9.3,3f9.3,2f12.3)

        END DO

c #IX IF (                     icount.lt. 3)                     GO TO 1
!     IF (dustar.gt.0.0001.AND.icount.lt. 6)                     GO TO 1


c #AM   DO ikl=1,klonv
c #AM     u0star      =      0.0
c #AT     uTstar      =      0.0
c #AS     usstar      =      0.0
c #AM     DO nt=1,ntaver
c #AM     u0star      = u0star + u__mem(ikl,nt)
c #AT     uTstar      = uTstar + uT_mem(ikl,nt)
c #AS     usstar      = usstar + us_mem(ikl,nt)
c #AM     ENDDO
c #AM     us__SV(ikl) = u0star / ntaver
c #AT     uts_SV(ikl) = uTstar / ntaver
c #AS     uss_SV(ikl) = usstar / ntaver
c #AM   END DO


!  Aerodynamic Resistances
!  -----------------------

        DO ikl=1,klonv
          ram_sv(ikl) = 1./(CDm(ikl)*max(VVaSBL(ikl),epsi))
          rah_sv(ikl) = 1./(CDh(ikl)*max(VVaSBL(ikl),epsi))
        END DO


      return
      end


      subroutine SISVAT_SBL
 
C +------------------------------------------------------------------------+
C | MAR          SISVAT_SBL                            Tue 04-01-2011  MAR |
C |   SubRoutine SISVAT_SBL generates Surface Boundary Layers Properties   |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns                          |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   za__SV   : Surface Boundary Layer (SBL) Height          [m] |
C |   ^^^^^    VV__SV   :(SBL Top)   Wind Velocity                   [m/s] |
C |            TaT_SV   : SBL Top    Temperature                       [K] |
C |            ExnrSV   : Exner      Potential                         [-] |
C |            uqs_SV   : Specific   Humidity  Turbulent Flux        [m/s] |
C |            Z0m_SV   : Momentum   Roughness Length                  [m] |
C |            Z0h_SV   : Heat       Roughness Length                  [m] |
C |            Tsrfsv   : Surface    Temperature                       [K] |
C |            sqrCm0   : Contribution of Z0m to Neutral Drag Coefficient  |
C |            sqrCh0   : Contribution of Z0h to Neutral Drag Coefficient  |
C |                                                                        |
C |   INPUT /  LMO_SV   : Monin-Obukhov       Scale                    [m] |
C |   OUTPUT:  us__SV   : Friction  Velocity                         [m/s] |
C |   ^^^^^^   uts_SV   : Temperature         Turbulent Flux       [K.m/s] |
C |                                                                        |
C |   OUTPUT:  Fh__sv   : Stability Function                           [-] |
C |   ^^^^^^   dFh_sv   : Stability Function (Derivative)              [-] |
C |            ram_sv   : Aerodynamic Resistance for Momentum        [s/m] |
C |            rah_sv   : Aerodynamic Resistance for Heat            [s/m] |
C |                                                                        |
C |   WARNING: SISVAT_SBL blows up for too small z0m values & large z_SBL  |
C |   ^^^^^^^                      (z0m = 1.8e-6 m for z_SBL = 20 m)       |
C |                                                                        |
C +------------------------------------------------------------------------+
 
 
      IMPLICIT NONE
 
 
C +--Global Variables
C +  ================
 
      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
 
      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)
 
C +--Internal Variables
C +  ==================
 
      integer   ikl    ,ist    ,ist__s ,ist__w
      real      CD_m_0 ,CD_h_0 ,ram0   ,rah0  ,rahMIN
      real      d_TaTs ,RiB__D ,RiBulk
      real      bmstab ,Am1_FU ,Am2_FU ,Fm_Uns
      real      bhstab ,Ah1_FU ,Ah2_FU ,Fh_Uns,dFh_Un
      real      Aux_FS ,FStabl ,dFSdRi ,Stabil,Fm_loc
      real      uustar ,thstar ,qqstar ,ssstar
      real      thstarv,thstars,thstara
      real      zeta   ,zeta_S ,zeta_A
      real      zetMAX
 
 
C +--Internal DATA
C +  =============
 
      data      zetMAX/ 4.28/   ! Strong Stability Limit
C +                             !(King et al. 1996, JGR 101(7) p.19121)
 
C +--Aerodynamic Resistances
C +  =======================
 
      DO ikl=1,klonv
 
C +--Surface Type
C +  ~~~~~~~~~~~~
        ist    =      isotSV(ikl)                    ! Soil Type
        ist__s =  min(ist, 1)                        ! 1 => Soil
        ist__w =  1 - ist__s                         ! 1 => Water Body
 
C +--Neutral Parameters
C +  ~~~~~~~~~~~~~~~~~~
        CD_m_0 =  0.16/    (sqrCm0(ikl)*sqrCm0(ikl)) ! Neutral Drag Coeff.Mom.
        CD_h_0 =  0.16/    (sqrCm0(ikl)*sqrCh0(ikl)) ! Neutral Drag Coeff.Heat
        ram0   =  1.0 /    (CD_m_0     *VV__SV(ikl)) ! Neutral Aero Resis.Mom.
        rah0   =  1.0 /    (CD_h_0     *VV__SV(ikl)) ! Neutral Aero Resis.Heat
 
C +--Bulk Richardson Number
C +  ~~~~~~~~~~~~~~~~~~~~~~
        RiB__D =          VV__SV(ikl) *VV__SV(ikl)
     .                   *TaT_SV(ikl)
        d_TaTs =         (TaT_SV(ikl)- Tsrfsv(ikl))
     .                   *pcap       / ExnrSV(ikl)
        RiBulk =  gravit *za__SV(ikl)* d_TaTs
     .          / RiB__D
 
C +--OUTPUT
c #gs       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
c #gs.          nn__SV(ikl).GE.nwr_SV)
c #gs.      write(6,6600) Tsrfsv(ikl),TaT_SV(ikl),VV__SV(ikl)
c #gs.                  , d_TaTs     ,RiBulk
 6600       format(/,'Tem(s,a), Wind  , d_TaTs, RiBulk = ',5e15.6)
 
C +--Unstable Case
C +  ~~~~~~~~~~~~~
        bmstab =  ist__s * (13.7 -0.34 /sqrt(CD_m_0))! Momentum
     .          + ist__w *   4.9                     !
        bmstab =  10.    *  bmstab   * CD_m_0        !
     .              *sqrt(za__SV(ikl)/ Z0m_SV(ikl))  !
        Am1_FU =  bmstab *    sqrt(abs(RiBulk))      !
        Am2_FU =  Am1_FU +1.0 +10.*abs(RiBulk)       !
        Fm_Uns = (Am1_FU +1.0)/        Am2_FU        !
 
C +--OUTPUT
c #gs       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
c #gs.          nn__SV(ikl).GE.nwr_SV)
c #gs.      write(6,6601) CD_m_0     ,Z0m_SV(ikl),bmstab     
c #gs.                  , ist__s     ,ist__w
 6601       format(/,'CD_m_0  , Z0m_SV, bmstab, ist/sw = ',3e15.6,2i15)
 
        bhstab =  ist__s * ( 6.3 -0.18 /sqrt(CD_h_0))! Heat
     .          + ist__w *   2.6                     !
        bhstab =  10.    *  bhstab   * CD_h_0        !
     .              *sqrt(za__SV(ikl)/ Z0h_SV(ikl))  !
        Ah1_FU =  bhstab *    sqrt(abs(RiBulk))      !
        Ah2_FU =  Ah1_FU +1.0 +10.*abs(RiBulk)       !
        Fh_Uns = (Ah1_FU +1.0)/        Ah2_FU        !
        dFh_Un =((Ah1_FU +2.0)/(Ah2_FU*Ah2_FU)) * 5. !
 
C +--Stable   Case
C +  ~~~~~~~~~~~~~
        Aux_FS =          1.0 + 5.*    RiBulk
        FStabl =                Aux_FS*Aux_FS
        dFSdRi =                Aux_FS          *10.
 
C +--Effective Stability Functions and Derivatives
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Stabil      =          sign(unun,d_TaTs)
        Fm_loc      =  FStabl * max(zero,Stabil)
     .               - Fm_Uns * min(zero,Stabil)
        Fh__sv(ikl) =  FStabl * max(zero,Stabil)
     .               - Fh_Uns * min(zero,Stabil)
        dFh_sv(ikl) =  dFSdRi * max(zero,Stabil)
     .               - dFh_Un * min(zero,Stabil)
 
C +--OUTPUT
c #gs       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
c #gs.          nn__SV(ikl).GE.nwr_SV)
c #gs.      write(6,6602) FStabl     ,Stabil     
c #gs.                   ,Fm_Uns     ,Fm_loc     
 6602       format(/,'FStabl  , Stabil, Fm_Uns, Fm_loc = ',4e15.6)
 
C +--Aerodynamic Resistances
C +  ~~~~~~~~~~~~~~~~~~~~~~~
        ram_sv(ikl) =  ram0   *          Fm_loc
        rah_sv(ikl) =  rah0   *          Fh__sv(ikl)
        rahMIN   = max(rah_sv(ikl),  abs(d_TaTs)*60./za__SV(ikl))
                                               ! 60 for 30dgC within 1/2 hour
        dFh_sv(ikl) =  rah0   *          dFh_sv(ikl)
     .              *  rahMIN /          rah_sv(ikl)
        rah_sv(ikl) =  rahMIN
 
 
C +--Square Root Contributions to the Drag Coefficients
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        rCDmSV(ikl) =  sqrt(ram_sv(ikl) *VV__SV(ikl))
        rCDmSV(ikl) =  1.     / max(epsi,rCDmSV(ikl))
        rCDhSV(ikl) =       rah_sv(ikl) *VV__SV(ikl)
     .                                  *rCDmSV(ikl)
        rCDhSV(ikl) = (1.     / max(epsi,rCDhSV(ikl)))
     .              * (     ExnrSV(ikl) /pcap        )
 
C +--OUTPUT
c #gs       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
c #gs.          nn__SV(ikl).GE.nwr_SV)
c #gs.      write(6,6603) ram_sv(ikl),rah_sv(ikl)
c #gs.                   ,rCDmSV(ikl),rCDhSV(ikl)
 6603       format(/,'AeR(m,h), rCD(m,h)               = ',4e15.6)
 
 
C +--Turbulent Scales
C +  ================
 
C +--Friction Velocity                   u*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uustar      =      VV__SV(ikl) / ram_sv(ikl)
        us__SV(ikl) = sqrt(uustar)
 
C +--Real    Temperature Turbulent Scale theta*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        uts_SV(ikl) =      d_TaTs      / rah_sv(ikl)
        thstar      =      uts_SV(ikl) / us__SV(ikl)
 
C +--Specific Humidity   Turbulent Scale qq*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        qqstar      =      uqs_SV(ikl) / us__SV(ikl)
 
C +--Virtual Temperature Turbulent Scale thetav*
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        thstarv     = thstar      + TaT_SV(ikl) *(0.608*qqstar
     .                                             )
        thstars     =     sign(unun,thstarv)
        thstara     =      abs(     thstarv)
        thstarv     =      max(epsi,thstara)    *thstars
 
C +--Monin Obukhov Scale Height
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~
        LMO_SV(ikl) = TaT_SV(ikl) * uustar
     .              /(vonkar      * gravit     * thstarv)
        zeta        = za__SV(ikl) / LMO_SV(ikl)
        zeta        =           min(zetMAX,zeta)  ! Strong Stability Limit
C +                                               ! King et al.   1996
C +                                               ! JGR 101(7) p.19121
        zeta_S      =          sign(unun  ,zeta)
        zeta_A      =           abs(       zeta)
        zeta        = zeta_S  * max(epsi  ,zeta_A)
        LMO_SV(ikl) = za__SV(ikl) / zeta
 
C +--OUTPUT
c #gs       IF (ii__SV(ikl).EQ.iwr_SV .AND. jj__SV(ikl).EQ. jwr_SV .AND.
c #gs.          nn__SV(ikl).GE.nwr_SV)
c #gs.      write(6,6604) us__SV(ikl),uts_SV(ikl)
c #gs.                   ,LMO_SV(ikl),zeta        
 6604       format(/,'***(m,h), LMO   , zeta           = ',4e15.6)
 
      END DO
 
      return
      end


      subroutine SISVAT_TVg
! #e1.                     (ETVg_d)

C +------------------------------------------------------------------------+
C | MAR          SISVAT_TVg                                13-09-2003  MAR |
C |   SubRoutine SISVAT_TVg computes the Canopy Energy Balance             |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   ivgtSV   = 0,...,12:   Vegetation Type                      |
C |   ^^^^^               0:          Water, Solid or Liquid               |
C |            isnoSV   = total Nb of Ice/Snow Layers                      |
C |                                                                        |
C |   INPUT:   sol_SV   : Downward Solar Radiation                  [W/m2] |
C |   ^^^^^    IRd_SV   : Surface  Downward Longwave Radiation      [W/m2] |
C |            TaT_SV   : SBL Top  Temperature                         [K] |
C |            rhT_SV   : SBL Top  Air  Density                    [kg/m3] |
C |            QaT_SV   : SBL Top  Specific  Humidity              [kg/kg] |
C |            psivSV   : Leaf     Water     Potential                 [m] |
C |            IRs_SV   : Soil     IR Flux  (previous time step)    [W/m2] |
C |            dt__SV   : Time     Step                                [s] |
C |                                                                        |
C |            SoCasv   : Absorbed Solar Radiation by Canopy (Normaliz)[-] |
C |            tau_sv   : Fraction of Radiation transmitted by Canopy  [-] |
C |            Evg_sv   : Soil+Vegetation Emissivity                   [-] |
C |            Eso_sv   : Soil+Snow       Emissivity                   [-] |
C |            rah_sv   : Aerodynamic Resistance for Heat            [s/m] |
C |            Sigmsv   : Canopy Ventilation Factor                    [-] |
C |            LAI_sv   : Leaf Area  Index                             [-] |
C |            LAIesv   : Leaf Area  Index (effective / transpiration) [-] |
C |            glf_sv   : Green Leaf Fraction of NOT fallen Leaves     [-] |
C |            rrMxsv   : Canopy Maximum Intercepted Rain          [kg/m2] |
C |                                                                        |
C |   INPUT /  TvegSV   : Canopy   Temperature                         [K] |
C |   OUTPUT:  rrCaSV   : Canopy     Water     Content             [kg/m2] |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   OUTPUT:  IRv_sv   : Vegetation IR Flux                        [W/m2] |
C |   ^^^^^^   HSv_sv   : Sensible Heat Flux                        [W/m2] |
C |            HLv_sv   : Latent   Heat Flux                        [W/m2] |
C |            Evp_sv   : Evaporation                              [kg/m2] |
C |            EvT_sv   : Evapotranspiration                       [kg/m2] |
C |            ETVg_d   : Vegetation  Energy Power Forcing          [W/m2] |
C |                                                                        |
C |   Internal Variables:                                                  |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |                                                                        |
C |   METHOD: The Newton-Raphson Scheme is preferable                      |
C |   ^^^^^^  when computing over a long time step the heat content        |
C |           of a medium having a very small or zero heat capacity.       |
C |           This is to handle strong non linearities arising             |
C |           in conjunction with rapid temperature variations.            |
C |                                                                        |
C | # OPTIONS: #NN: Newton-Raphson Increment not added in last Iteration   |
C | # ^^^^^^^                                                              |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"

      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--OUTPUT
C +  ------

! #e1 real      ETVg_d(klonv)                 ! VegetationPower, Forcing

C +--OUTPUT for Stand Alone NetCDF File
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #NC real          SOsoKL(klonv)             ! Absorbed Solar Radiation
c #NC real          IRsoKL(klonv)             ! Absorbed IR    Radiation
c #NC real          HSsoKL(klonv)             ! Absorbed Sensible Heat Flux
c #NC real          HLsoKL(klonv)             ! Absorbed Latent   Heat Flux
c #NC real          HLs_KL(klonv)             ! Evaporation
c #NC real          HLv_KL(klonv)             ! Transpiration
c #NC common/DumpNC/SOsoKL,IRsoKL
c #NC.             ,HSsoKL,HLsoKL
c #NC.             ,HLs_KL,HLv_KL


C +--Internal Variables
C +  ==================

      integer   ikl                           ! Grid Point Index
      integer   nitmax,nit                    ! Iterations Counter
      real      d_Tveg                        ! Canopy Temperat. Increment
      real      dTvMAX                        ! Canopy Temperat. Increment MAX
      real      dHvdTv                        ! Derivativ.of Canopy Energ.Budg.
      real      Hv_Tv0                        ! Imbalance of Canopy Energ.Budg.
      real      Hv_MAX                        ! MAX Imbal.of Canopy Energ.Budg.
      real      Hv_MIN                        ! MIN Imbal.of Canopy Energ.Budg.
      real      Hswich                        ! Newton-Raphson         Switch
      real      Tveg_0(klonv)                 ! Canopy Temperature, Previous t
      real      tau_Ca                        ! Canopy IR Radiation Absorption
      real      IR_net                        ! InfraRed  NET(t)
      real      dIRdTv(klonv)                 ! InfraRed  NET(t), Derivative(t)
      real      dHSdTv(klonv)                 ! Sensible Heat FL. Derivative(t)
      real      dHLdTv(klonv)                 ! Latent   Heat FL. Derivative(t)
c #HC real      dHCdTv(klonv)                 !          Heat     Storage
      real      EvFrac                        ! Condensat./Transpirat. Switch
      real      SnoMsk                        ! Canopy Snow            Switch
      real      den_qs,arg_qs,qsatvg          ! Canopy Saturat. Spec. Humidity
      real      dqs_dT                        ! d(qsatvg)/dTv
      real      FacEvp,FacEvT,Fac_Ev          ! Evapo(transpi)ration Factor
      real      dEvpdT(klonv),dEvTdT(klonv)   ! Evapo(transpi)ration Derivative
      real      F_Stom                        ! Funct.  (Leaf Water Potential)
      real      R0Stom                        ! Minimum Stomatal Resistance
      real      R_Stom                        !         Stomatal Resistance
      real      LAI_OK                        ! 1. ==>  Leaves   exist
      real      rrCaOK,snCaOK,dEvpOK          ! Positive Definiteness Correct.


C +--Internal DATA
C +  =============

      data      nitmax /   5   /              ! Maximum  Iterations    Number
      data      dTvMAX /   5.  /              ! Canopy Temperat. Increment MAX
      data      Hv_MIN /   0.1 /              ! MIN Imbal. of Surf.Energy Budg.
      data      SnoMsk /   0.0 /              ! Canopy Snow Switch    (Default)


C +--Newton-Raphson Scheme
C +  =====================

      nit    = 0
  101 CONTINUE
      nit    = nit + 1
      HV_MAX = 0.


C +--Temperature of the Previous Time Step
C +  -------------------------------------

        DO ikl=1,klonv
          Tveg_0(ikl) = TvegSV(ikl)


C +--IR    Radiation Absorption
C +  --------------------------

          tau_Ca = 1.  - tau_sv(ikl)                        ! Canopy Absorption
          IRv_sv(ikl) = -2.0   *Evg_sv(ikl)  *stefan        !
     .                         *TvegSV(ikl)  *TvegSV(ikl)   ! Downward IR (OUT)
     .                         *TvegSV(ikl)  *TvegSV(ikl)   ! + Upward IR (OUT)
          dIRdTv(ikl) =
     .     -Evg_sv(ikl)*                                    !
     .                8.*stefan*TvegSV(ikl)  *TvegSV(ikl)   ! Downward IR (OUT)
     .                         *TvegSV(ikl)                 ! + Upward IR (OUT)
          IR_net =       tau_Ca                             !
     .    *(Evg_sv(ikl)* IRd_SV(ikl)                        ! Downward IR (IN)
     .     -             IRs_SV(ikl)                        !   Upward IR (IN)
     .     +             IRv_sv(ikl))                       !          IR (OUT)


C +--Sensible Heat Flux
C +  ------------------

          dHSdTv(ikl) = rhT_SV(ikl)* Sigmsv(ikl) *Cp        ! Derivative, t(n)
     .                / rah_sv(ikl)                         ! 
          HSv_sv(ikl) = dHSdTv(ikl)                         ! Value,      t(n)
     .                *(TaT_SV(ikl)-TvegSV(ikl))            !


C +--Latent   Heat Flux
C +  ------------------

C +--Canopy Saturation Specific Humidity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          den_qs =         TvegSV(ikl)- 35.8
          arg_qs = 17.27 *(TvegSV(ikl)-273.16)/den_qs
          qsatvg = .0038 * exp(arg_qs)
          dqs_dT = qsatvg* 4099.2    /(den_qs *den_qs)

C +--Canopy Stomatal Resistance
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          R0Stom = min(         StodSV(ivgtSV(ikl))
     .                /max(epsi,glf_sv(       ikl)),StxdSV)  ! Min Stomatal R.
          F_Stom = pscdSV / max(pscdSV-psivSV(ikl) ,epsi)    ! F(Leaf Wat.Pot.)
C +                                                          ! DR97, eqn. 3.22
          R_Stom =(R0Stom / max(LAIesv(ikl), R0Stom/StxdSV)) ! Can.Stomatal R.
     .           * F_Stom                                    ! DR97, eqn. 3.21

C +--Evaporation / Evapotranspiration
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          SnoMsk = max(zero, sign(unun,snCaSV(ikl)-eps_21))  !
          EvFrac = max(zero, sign(unun,QaT_SV(ikl)-qsatvg))  ! Condensation/
          EvFrac = EvFrac                                    ! Transpiration
     .       + (1.-EvFrac)*((1-SnoMsk)*         rrCaSV(ikl)  !        Switch
     .                                         /rrMxsv(ikl)  !
     .                      +  SnoMsk *min(unun,snCaSV(ikl)  !
     .                                         /rrMxsv(ikl)))!
          Fac_Ev = rhT_SV(ikl) *Sigmsv(ikl)                  ! Idem,  Factor
          FacEvp = Fac_Ev      *EvFrac     / rah_sv(ikl)     !
          Evp_sv(ikl) = FacEvp*(qsatvg     - QaT_SV(ikl))    ! Evaporation
          dEvpdT(ikl) = FacEvp* dqs_dT                       ! Evp Derivative
          FacEvt = Fac_Ev * (1.-EvFrac)    /(rah_sv(ikl)     !
     .                              +R_Stom *Sigmsv(ikl))    !
          EvT_sv(ikl) = FacEvt*(qsatvg     - QaT_SV(ikl))    ! EvapoTranspir.
          dEvTdT(ikl) = FacEvt* dqs_dT                       ! EvT Derivative
          HLv_sv(ikl) =-Lv_H2O*(Evp_sv(ikl)+ EvT_sv(ikl))    ! Latent   Heat
     .                 -Lf_H2O* Evp_sv(ikl)* SnoMsk          !(Subli.Contrib.)
          dHLdTv(ikl) = Lv_H2O*(dEvpdT(ikl)+ dEvTdT(ikl))    !
     .                 +Lf_H2O* dEvpdT(ikl)* SnoMsk          !
c #HC     dHCdTv(ikl) = Cn_dSV* snCaSV(ikl)/ dt__SV          ! Heat  Storage


C +--Imbalance  of the Canopy  Energy Budget
C +  ---------------------------------------

          LAI_OK = max(zero,                                 ! NO Budget if 
     .                 sign(unun, LAI_sv(ikl)-eps_21))       ! no Leaves
          Hv_Tv0 =    (  SoCasv(ikl)         *sol_SV(ikl)    ! Absorbed Solar
     .                 + IR_net                              ! NET      IR
     .                 + HSv_sv(ikl)                         ! Sensible Heat
     .                 + HLv_sv(ikl)                         ! Latent   Heat
     .                ) *LAI_OK                              !
! #e1     ETVg_d(ikl) =  Hv_Tv0                              ! Veg.Energ.Bal.
C +
          Hswich      =          unun
c #NN     Hswich      = max(zero,                            ! Newton-Raphson
c #NN.                      sign(unun,    abs(Hv_Tv0     )   !         Switch
c #NN.                                       -Hv_MIN      )) !


C +--Derivative of the Canopy  Energy Budget
C +  ---------------------------------------

          dHvdTv    =   dIRdTv(ikl) * max(eps_21,tau_Ca)
     .                - dHSdTv(ikl)
     .                - dHLdTv(ikl)
c #HC.                - dHCdTv(ikl)


C +--Update Canopy and Surface/Canopy Temperatures
C +  ---------------------------------------------

          d_Tveg      = Hv_Tv0       / dHvdTv               !
          d_Tveg      =      sign(unun,d_Tveg)              ! Increment
     .                       *min( abs(d_Tveg)     ,dTvMAX) ! Limitor
          TvegSV(ikl) = TvegSV(ikl)  - Hswich      *d_Tveg  ! Newton-Raphson
          Hv_MAX      = max(Hv_MAX,abs(Hv_Tv0     ))        !


C +--Update Vegetation Fluxes
C +  ------------------------

c #NN     IRv_sv(ikl) = IRv_sv(ikl)-dIRdTv(ikl)    *d_Tveg  ! Emitted  IR
c #NN     HSv_sv(ikl) = HSv_sv(ikl)+dHSdTv(ikl)    *d_Tveg  ! Sensible Heat
c #NN     Evp_sv(ikl) = Evp_sv(ikl)-dEvpdT(ikl)    *d_Tveg  ! Evapotranspir.
c #NN     EvT_sv(ikl) = EvT_sv(ikl)-dEvTdT(ikl)    *d_Tveg  ! Evapotranspir.
c #NN     HLv_sv(ikl) = HLv_sv(ikl)+dHLdTv(ikl)    *d_Tveg  ! Latent   Heat
C +
          IRv_sv(ikl) = IRv_sv(ikl)                *LAI_OK
          HSv_sv(ikl) = HSv_sv(ikl)                *LAI_OK
          Evp_sv(ikl) = Evp_sv(ikl)                *LAI_OK
          EvT_sv(ikl) = EvT_sv(ikl)                *LAI_OK
          HLv_sv(ikl) = HLv_sv(ikl)                *LAI_OK
        END DO

c #IX IF (                     nit.lt.nitmax)    GO TO 101
      IF (Hv_MAX.gt.Hv_MIN.and.nit.lt.nitmax)    GO TO 101

        DO ikl=1,klonv
          IRv_sv(ikl) = IRv_sv(ikl)                         ! Emitted  IR
     .   +dIRdTv(ikl) *(TvegSV(ikl)-Tveg_0(ikl))            ! 
          HSv_sv(ikl) = HSv_sv(ikl)                         ! Sensible Heat
     .   -dHSdTv(ikl) *(TvegSV(ikl)-Tveg_0(ikl))            !
          Evp_sv(ikl) = Evp_sv(ikl)                         ! Evaporation
     .   +dEvpdT(ikl) *(TvegSV(ikl)-Tveg_0(ikl))            !
          EvT_sv(ikl) = EvT_sv(ikl)                         ! Transpiration
     .   +dEvTdT(ikl) *(TvegSV(ikl)-Tveg_0(ikl))            !
          HLv_sv(ikl) = HLv_sv(ikl)                         ! Latent   Heat
     .   -dHLdTv(ikl) *(TvegSV(ikl)-Tveg_0(ikl))            !

C +--OUTPUT for Stand Alone NetCDF File
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #NC     HLv_KL(ikl) = HLv_sv(ikl)


C +--Update Canopy Water Content
C +  ---------------------------

          rrCaSV(ikl) = rrCaSV(ikl)-(1.-SnoMsk)*Evp_sv(ikl)*dt__SV
          snCaSV(ikl) = snCaSV(ikl)-    SnoMsk *Evp_sv(ikl)*dt__SV

C +--Correction for Positive Definiteness (see WKarea/EvpVeg/EvpVeg.f)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          rrCaOK =  max(rrCaSV(ikl), 0.)
          snCaOK =  max(snCaSV(ikl), 0.)
          dEvpOK =     (rrCaOK-rrCaSV(ikl)
     .                 +snCaOK-snCaSV(ikl))/dt__SV

          Evp_sv(ikl) = Evp_sv(ikl)       - dEvpOK          ! Evaporation
          HLv_sv(ikl) = HLv_sv(ikl)                         ! Latent   Heat
     .    +(1.-SnoMsk)* Lv_H2O            * dEvpOK          !
     .    +    SnoMsk *(Lv_H2O+Lf_H2O)    * dEvpOK          !

          rrCaSV(ikl) = rrCaOK
          snCaSV(ikl) = snCaOK

        END DO


      return
      end


      subroutine SISVAT_TSo
! #e1.                     (ETSo_0,ETSo_1,ETSo_d)

C +------------------------------------------------------------------------+
C | MAR          SISVAT_TSo                            Wed 30-09-2009  MAR |
C |   SubRoutine SISVAT_TSo computes the Soil/Snow Energy Balance          |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   isotSV   = 0,...,11:   Soil       Type                      |
C |   ^^^^^               0:          Water, Solid or Liquid               |
C |            isnoSV   = total Nb of Ice/Snow Layers                      |
C |            dQa_SV   = Limitation of  Water Vapor  Turbulent Flux       |
C |                                                                        |
C |   INPUT:   sol_SV   : Downward Solar Radiation                  [W/m2] |
C |   ^^^^^    IRd_SV   : Surface Downward  Longwave   Radiation    [W/m2] |
C |            za__SV   : SBL Top    Height                            [m] |
C |            VV__SV   : SBL Top    Wind Speed                      [m/s] |
C |            TaT_SV   : SBL Top    Temperature                       [K] |
C |            rhT_SV   : SBL Top    Air  Density                  [kg/m3] |
C |            QaT_SV   : SBL Top    Specific  Humidity            [kg/kg] |
C |            LSdzsv   : Vertical   Discretization Factor             [-] |
C |                     =    1. Soil                                       |
C |                     = 1000. Ocean                                      |
C |            dzsnSV   : Snow Layer Thickness                         [m] |
C |            ro__SV   : Snow/Soil  Volumic Mass                  [kg/m3] |
C |            eta_SV   : Soil Water Content                       [m3/m3] |
C |            dt__SV   : Time Step                                    [s] |
C |                                                                        |
C |            SoSosv   : Absorbed Solar Radiation by Surfac.(Normaliz)[-] |
C |            IRv_sv   : Vegetation  IR Radiation                  [W/m2] |
C |            tau_sv   : Fraction of Radiation transmitted by Canopy  [-] |
C |            Evg_sv   : Soil+Vegetation Emissivity                   [-] |
C |            Eso_sv   : Soil+Snow       Emissivity                   [-] |
C |            rah_sv   : Aerodynamic Resistance for Heat            [s/m] |
C |            Lx_H2O   : Latent Heat of Vaporization/Sublimation   [J/kg] |
C |            Sigmsv   : Canopy Ventilation Factor                    [-] |
C |            sEX_sv   : Verticaly Integrated Extinction Coefficient  [-] |
C |                                                                        |
C |   INPUT /  TsisSV   : Soil/Ice Temperatures (layers -nsol,-nsol+1,..,0)|
C |   OUTPUT:           & Snow     Temperatures (layers  1,2,...,nsno) [K] |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   OUTPUT:  IRs_SV   : Soil      IR Radiation                    [W/m2] |
C |   ^^^^^^   HSs_sv   : Sensible  Heat Flux                       [W/m2] |
C |            HLs_sv   : Latent    Heat Flux                       [W/m2] |
C |            ETSo_0   : Snow/Soil Energy Power, before Forcing    [W/m2] |
C |            ETSo_1   : Snow/Soil Energy Power, after  Forcing    [W/m2] |
C |            ETSo_d   : Snow/Soil Energy Power         Forcing    [W/m2] |
C |                                                                        |
C |   Internal Variables:                                                  |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |                                                                        |
C |   METHOD: NO   Skin Surface Temperature                                |
C |   ^^^^^^  Semi-Implicit Crank Nicholson Scheme                         |
C |                                                                        |
C | # OPTIONS: #E0: Energy Budget Verification                             |
C | # ^^^^^^^  #kd: KDsvat Option:NO Flux  Limitor     on HL               |
C | #          #KD: KDsvat Option:Explicit Formulation of HL               |
C | #          #NC: OUTPUT for Stand Alone NetCDF File                     |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARCTR.inc"
      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"

      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--OUTPUT
C +  ------

! #e1 real      ETSo_0(klonv)                 ! Soil/Snow Power, before Forcing
! #e1 real      ETSo_1(klonv)                 ! Soil/Snow Power, after  Forcing
! #e1 real      ETSo_d(klonv)                 ! Soil/Snow Power, Forcing


C +--Internal Variables
C +  ==================

      integer   ikl   ,isl   ,jsl   ,ist      !
      integer   ist__s,ist__w                 ! Soil/Water  Body Identifier
      integer   islsgn                        ! Soil/Snow Surfac.Identifier
      real      eps__3                        ! Arbitrary    Low Number
      real      etaMid,psiMid                 ! Layer Interface's Humidity
      real      mu_eta                        !     Soil thermal Conductivity
      real      mu_exp                        ! arg Soil thermal Conductivity
      real      mu_min                        ! Min Soil thermal Conductivity
      real      mu_max                        ! Max Soil thermal Conductivity
      real      mu_sno(klonv),mu_aux          !     Snow thermal Conductivity
      real      mu__dz(klonv,-nsol:nsno+1)    ! mu_(eta,sno)   / dz
      real      dtC_sv(klonv,-nsol:nsno)      ! dt      / C
      real      IRs__D(klonv)                 ! UpwardIR Previous Iter.Contr.
      real      dIRsdT(klonv)                 ! UpwardIR           T Derivat.
      real      f_HSHL(klonv)                 ! Factor common to HS and HL
      real      dRidTs(klonv)                 ! d(Rib)/d(Ts)
      real      HS___D(klonv)                 ! Sensible Heat Flux Atm.Contr.
      real      f___HL(klonv)                 !
      real      HL___D(klonv)                 ! Latent   Heat Flux Atm.Contr.
      REAL      TSurf0(klonv),dTSurf          ! Previous Surface Temperature
      real      qsatsg(klonv),den_qs,arg_qs   ! Soil   Saturat. Spec. Humidity
      real      dqs_dT(klonv)                 ! d(qsatsg)/dTv
      real      Psi(   klonv)                 ! 1st Soil Layer Water Potential
      real      RHuSol(klonv)                 ! Soil Surface Relative Humidity
      real      etaSol                        ! Soil Surface          Humidity
      real      d__eta                        ! Soil Surface Humidity Increm.
      real      Elem_A,Elem_C                 !   Diagonal Coefficients
      real      Diag_A(klonv,-nsol:nsno)      ! A Diagonal
      real      Diag_B(klonv,-nsol:nsno)      ! B Diagonal
      real      Diag_C(klonv,-nsol:nsno)      ! C Diagonal
      real      Term_D(klonv,-nsol:nsno)      !   Independant Term
      real      Aux__P(klonv,-nsol:nsno)      ! P Auxiliary Variable
      real      Aux__Q(klonv,-nsol:nsno)      ! Q Auxiliary Variable
      real      Ts_Min,Ts_Max                 ! Temperature Limits
! #e1 real      Exist0                        ! Existing Layer Switch

      integer   nt_srf,it_srf,itEuBk          ! HL: Surface Scheme
      parameter(nt_srf=10)                    !
      real      agpsrf,xgpsrf,dt_srf,dt_ver   !
      real      etaBAK(klonv)                 !
      real      etaNEW(klonv)                 !
      real      etEuBk(klonv)                 !
      real      fac_dt(klonv),faceta(klonv)   !
      real      PsiArg(klonv),SHuSol(klonv)   !

C +--OUTPUT for Stand Alone NetCDF File
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #NC real          SOsoKL(klonv)             ! Absorbed Solar Radiation
c #NC real          IRsoKL(klonv)             ! Absorbed IR    Radiation
c #NC real          HSsoKL(klonv)             ! Absorbed Sensible Heat Flux
c #NC real          HLsoKL(klonv)             ! Absorbed Latent   Heat Flux
c #NC real          HLs_KL(klonv)             ! Evaporation
c #NC real          HLv_KL(klonv)             ! Transpiration
c #NC common/DumpNC/SOsoKL,IRsoKL
c #NC.             ,HSsoKL,HLsoKL
c #NC.             ,HLs_KL,HLv_KL


C +--Internal DATA
C +  =============

      data      eps__3 /   1.e-3   /          ! Arbitrary    Low Number
      data      mu_exp /  -0.4343  /          !     Soil Thermal Conductivity
      data      mu_min /   0.172   /          ! Min Soil Thermal Conductivity
      data      mu_max /   2.000   /          ! Max Soil Thermal Conductivity
      data      Ts_Min / 175.      /          ! Temperature            Minimum
      data      Ts_Max / 300.      /          ! Temperature Acceptable Maximum
C +                                           ! including   Snow Melt  Energy


C +--Heat Conduction Coefficient (zero in the Layers over the highest one)
C +  ===========================
C +                             ---------------- isl    eta_SV, rho C (isl)
C +
C +--Soil                       ++++++++++++++++        etaMid,    mu (isl)
C +  ----
C +                             ---------------- isl-1  eta_SV, rho C (isl-1)
           isl=-nsol
        DO ikl=1,klonv
          mu__dz(ikl,isl) = 0.

          dtC_sv(ikl,isl) = dtz_SV(isl)                   ! dt / (dz X rho C)
     .                   /((rocsSV(isotSV(ikl))           ! [s / (m.J/m3/K)]
     .                     +rcwdSV*eta_SV(ikl,isl))       !
     .                     *LSdzsv(ikl)            )      !
        END DO
      DO   isl=-nsol+1,0
        DO ikl=1,klonv
          ist    =      isotSV(ikl)                       ! Soil Type
          ist__s =  min(ist, 1)                           ! 1 => Soil
          ist__w =  1 - ist__s                            ! 1 => Water Body

          etaMid = 0.5*(dz_dSV(isl-1)*eta_SV(ikl,isl-1)   ! eta at layers
     .                 +dz_dSV(isl)  *eta_SV(ikl,isl)  )  !     interface
     .                 /dzmiSV(isl)                       ! LSdzsv implicit !
          etaMid =  max(etaMid,epsi)
          psiMid =      psidSV(ist)
     .                *(etadSV(ist)/etaMid)**bCHdSV(ist)
          mu_eta =      3.82      *(psiMid)**mu_exp       ! Soil Thermal
          mu_eta =  min(max(mu_eta, mu_min), mu_max)      ! Conductivity
C +                                                       ! DR97 eq.3.31
          mu_eta =  ist__s *mu_eta +ist__w * vK_dSV       ! Water Bodies
C +                                                       ! Correction
          mu__dz(ikl,isl) = mu_eta/(dzmiSV(isl)           !
     .                             *LSdzsv(ikl))          !

          dtC_sv(ikl,isl) = dtz_SV(isl)                   ! dt / (dz X rho C)
     .                   /((rocsSV(isotSV(ikl))           !
     .                     +rcwdSV*eta_SV(ikl,isl))       !
     .                     *LSdzsv(ikl)            )      !
        END DO
      END DO


C +--Soil/Snow Interface
C +  -------------------

C +--Soil Contribution
C +  ^^^^^^^^^^^^^^^^^
           isl=1
        DO ikl=1,klonv
          ist    =      isotSV(ikl)                       ! Soil Type
          ist__s =  min(ist, 1)                           ! 1 => Soil
          ist__w =  1 - ist__s                            ! 1 => Water Body
          psiMid =      psidSV(ist)                       ! Snow => Saturation
          mu_eta =      3.82      *(psiMid)**mu_exp       ! Soil Thermal
          mu_eta =  min(max(mu_eta, mu_min), mu_max)      ! Conductivity
C +                                                       ! DR97 eq.3.31
          mu_eta =  ist__s *mu_eta +ist__w * vK_dSV       ! Water Bodies

C +--Snow Contribution
C +  ^^^^^^^^^^^^^^^^^
          mu_sno(ikl) =  CdidSV                           !
     .                 *(ro__SV(ikl,isl) /ro_Wat) ** 1.88 !
          mu_sno(ikl) =          max(epsi,mu_sno(ikl))    !
C +...    mu_sno :  Snow Heat Conductivity Coefficient [Wm/K]
C +                 (Yen 1981, CRREL Rep., 81-10)

C +--Combined Heat Conductivity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          mu__dz(ikl,isl) = 2./(dzsnSV(ikl,isl  )         ! Combined Heat
     .                         /mu_sno(ikl)               ! Conductivity
     .                         +LSdzsv(ikl)               !
     .                         *dz_dSV(    isl-1)/mu_eta) ! Coefficient

C +--Inverted Heat Capacity
C +  ^^^^^^^^^^^^^^^^^^^^^^
          dtC_sv(ikl,isl) = dt__SV/max(epsi,              ! dt / (dz X rho C)
     .    dzsnSV(ikl,isl) * ro__SV(ikl,isl) *Cn_dSV)      !
        END DO


C +--Snow
C +  ----

      DO   isl=1,nsno
        DO ikl=1,klonv
          ro__SV(ikl,isl) =                               !
     .                   ro__SV(ikl ,isl)                 !
     .       * max(0,min(isnoSV(ikl)-isl+1,1))            !
        END DO
      END DO

      DO   isl=1,nsno
        DO ikl=1,klonv

C +--Combined Heat Conductivity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          mu_aux      =  CdidSV                           !
     .                 *(ro__SV(ikl,isl) /ro_Wat) ** 1.88 !
          mu__dz(ikl,isl) =                               !
     .      2.                        *mu_aux*mu_sno(ikl) ! Combined Heat
     .     /max(epsi,dzsnSV(ikl,isl  )*mu_sno(ikl)        ! Conductivity
     .              +dzsnSV(ikl,isl-1)*mu_aux     )       ! For upper Layer
          mu_sno(ikl)     =            mu_aux             !

C +--Inverted Heat Capacity
C +  ^^^^^^^^^^^^^^^^^^^^^^
          dtC_sv(ikl,isl) = dt__SV/max(eps__3,            ! dt / (dz X rho C)
     .    dzsnSV(ikl,isl) * ro__SV(ikl,isl) *Cn_dSV)      !
        END DO
      END DO


C +--Uppermost Effective Layer: NO conduction
C +  ----------------------------------------

        DO ikl=1,klonv
          mu__dz(ikl,isnoSV(ikl)+1) = 0.0
        END DO


C +--Energy Budget (IN)
C +  ==================

! #e1   DO ikl=1,klonv
! #e1     ETSo_0(ikl) = 0.
! #e1   END DO
! #e1 DO   isl= -nsol,nsno
! #e1   DO ikl=1,klonv
! #e1     Exist0      = isl -           isnoSV(ikl)
! #e1     Exist0      = 1.  - max(zero,min(unun,Exist0))
! #e1     ETSo_0(ikl) = ETSo_0(ikl)
! #e1.                +(TsisSV(ikl,isl)-TfSnow)*Exist0
! #e1.                                 /dtC_sv(ikl,isl)
! #e1   END DO
! #e1 END DO


C +--Tridiagonal Elimination: Set Up
C +  ===============================

C +--Soil/Snow Interior
C +  ^^^^^^^^^^^^^^^^^^
      DO   isl= -nsol+1,nsno-1
        DO ikl=1,klonv
          Elem_A          =  dtC_sv(ikl,isl)         *mu__dz(ikl,isl)
          Elem_C          =  dtC_sv(ikl,isl)         *mu__dz(ikl,isl+1)
          Diag_A(ikl,isl) = -Elem_A  *Implic
          Diag_C(ikl,isl) = -Elem_C  *Implic
          Diag_B(ikl,isl) =  1.0d+0  -Diag_A(ikl,isl)-Diag_C(ikl,isl)
          Term_D(ikl,isl) =  Explic *(Elem_A         *TsisSV(ikl,isl-1)
     .                               +Elem_C         *TsisSV(ikl,isl+1))
     .             +(1.0d+0 -Explic *(Elem_A+Elem_C))*TsisSV(ikl,isl)
     .  + dtC_sv(ikl,isl)           * sol_SV(ikl)    *SoSosv(ikl)
     .                                              *(sEX_sv(ikl,isl+1)
     .                                               -sEX_sv(ikl,isl  ))
        END DO
      END DO

C +--Soil  lowest Layer
C +  ^^^^^^^^^^^^^^^^^^
           isl= -nsol
        DO ikl=1,klonv
          Elem_A          =  0.
          Elem_C          =  dtC_sv(ikl,isl)         *mu__dz(ikl,isl+1)
          Diag_A(ikl,isl) =  0.
          Diag_C(ikl,isl) = -Elem_C  *Implic
          Diag_B(ikl,isl) =  1.0d+0  -Diag_A(ikl,isl)-Diag_C(ikl,isl)
          Term_D(ikl,isl) =  Explic * Elem_C         *TsisSV(ikl,isl+1)
     .             +(1.0d+0 -Explic * Elem_C)        *TsisSV(ikl,isl)
     .  + dtC_sv(ikl,isl)           * sol_SV(ikl)    *SoSosv(ikl)
     .                                              *(sEX_sv(ikl,isl+1)
     .                                               -sEX_sv(ikl,isl  ))
        END DO

C +--Snow highest Layer (dummy!)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
           isl=  nsno
        DO ikl=1,klonv
          Elem_A          =  dtC_sv(ikl,isl)  *mu__dz(ikl,isl)
          Elem_C          =  0.
          Diag_A(ikl,isl) = -Elem_A  *Implic
          Diag_C(ikl,isl) =  0.
          Diag_B(ikl,isl) =  1.0d+0  -Diag_A(ikl,isl)
          Term_D(ikl,isl) =  Explic * Elem_A  *TsisSV(ikl,isl-1)
     .             +(1.0d+0 -Explic * Elem_A) *TsisSV(ikl,isl)
     .  + dtC_sv(ikl,isl) * (sol_SV(ikl)      *SoSosv(ikl)
     .                                       *(sEX_sv(ikl,isl+1)
     .                                        -sEX_sv(ikl,isl  )))
        END DO

C +--Surface: UPwardIR Heat Flux
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=1,klonv
          isl         = isnoSV(ikl)
          dIRsdT(ikl) = Eso_sv(ikl)* stefan          * 4.      ! - d(IR)/d(T)
     .                             * TsisSV(ikl,isl)           !
     .                             * TsisSV(ikl,isl)           !
     .                             * TsisSV(ikl,isl)           !
          IRs__D(ikl) = dIRsdT(ikl)* TsisSV(ikl,isl) * 0.75    !

C +--Surface: Richardson Number:   T Derivative
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #RC     dRidTs(ikl) =-gravit      *    za__SV(ikl)
c #RC.                              *(1.-Sigmsv(ikl))
c #RC.                /(TaT_SV(ikl) *    VV__SV(ikl)
c #RC.                              *    VV__SV(ikl))

C +--Surface: Turbulent Heat Flux: Factors
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          f_HSHL(ikl) = rhT_SV(ikl) *(1.-Sigmsv(ikl))          !#common factor
     .                              /    rah_sv(ikl)           ! to  HS, HL
          f___HL(ikl) = f_HSHL(ikl) *    Lx_H2O(ikl)

C +--Surface: Sensible  Heat Flux: T Derivative
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          dSdTSV(ikl) = f_HSHL(ikl) *    Cp                    !#- d(HS)/d(T)
c #RC.         *(1.0  -(TsisSV(ikl,isl) -TaT_SV(ikl))          !#Richardson
c #RC.         * dRidTs(ikl)*dFh_sv(ikl)/rah_sv(ikl))          ! Nb. Correct.
          HS___D(ikl) = dSdTSV(ikl) *    TaT_SV(ikl)           !

C +--Surface: Latent    Heat Flux: Saturation Specific Humidity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          den_qs      =         TsisSV(ikl,isl)- 35.8          !
          arg_qs      = 17.27 *(TsisSV(ikl,isl)-273.16)        !
     .                                   / den_qs              !
          qsatsg(ikl) = .0038 *        exp(arg_qs)             !
          dqs_dT(ikl) = qsatsg(ikl)* 4099.2   /(den_qs *den_qs)!
          fac_dt(ikl) = f_HSHL(ikl)/(ro_Wat   * dz_dSV(0))     !
        END DO

C +--Surface: Latent    Heat Flux: Surface    Relative Humidity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
              xgpsrf       =   1.05                            !
              agpsrf       = dt__SV*(   1.0-xgpsrf        )    !
     .                             /(   1.0-xgpsrf**nt_srf)    !
              dt_srf       = agpsrf                            !
              dt_ver       = 0.                                !
            DO ikl=1,klonv
              isl          =          isnoSV(ikl)              !
              etaBAK(ikl)  = max(epsi,eta_SV(ikl ,isl))        !
              etaNEW(ikl)  =          etaBAK(ikl)              !
              etEuBk(ikl)  =          etaNEW(ikl)              !
            END DO                                             !
        DO it_srf=1,nt_srf                                     !
              dt_ver       = dt_ver     +dt_srf                !
            DO ikl=1,klonv                                     !
              faceta(ikl)  = fac_dt(ikl)*dt_srf                !
c #VX         faceta(ikl)  = faceta(ikl)                       !
c #VX.                  /(1.+faceta(ikl)*dQa_SV(ikl))          !    Limitation
                                                               ! by Atm.Conten
c #??.        *max(0,sign(1.,qsatsg(ikl)-QaT_SV(ikl))))        ! NO Limitation
                                                               ! of Downw.Flux
            END DO                                             !
          DO itEuBk=1,2                                        !
            DO ikl=1,klonv
              ist    = max(0,isotSV(ikl)-100*isnoSV(ikl))      ! 0 if    H2O
                                                               !
              Psi(ikl) =                                       !
     .                psidSV(ist)                              ! DR97, Eqn 3.34
     .              *(etadSV(ist)                              !
     .           /max(etEuBk(ikl),epsi))                       !
     .              **bCHdSV(ist)                              !
              PsiArg(ikl) = 7.2E-5*Psi(ikl)                    !
              RHuSol(ikl) =   exp(-min(argmax,PsiArg(ikl)))    !
              SHuSol(ikl) =     qsatsg(ikl)  *RHuSol(ikl)      ! DR97, Eqn 3.15
              etEuBk(ikl) =                                    !
     .       (etaNEW(ikl) + faceta(ikl)*(QaT_SV(ikl)           !
     .                                  -SHuSol(ikl)           !
     .                    *(1.          -bCHdSV(ist)           !
     .                                  *PsiArg(ikl))       )) !
     .      /(1.          + faceta(ikl)* SHuSol(ikl)           !
     .                                  *bCHdSV(ist)           !
     .                                  *PsiArg(ikl)           !
     .                                  /etaNEW(ikl))          !
              etEuBk(ikl) = etEuBk(ikl) -Rootsv(ikl,0)         !
     .                                 /(Ro_Wat*dz_dSV(0))     !
            END DO                                             !
          END DO                                               !
            DO ikl=1,klonv                                     !
              etaNEW(ikl) =  max(etEuBk(ikl),epsi)             !
            END DO                                             !
              dt_srf      =      dt_srf         * xgpsrf       !
        END DO                                                 !
 
C +--Surface: Latent    Heat Flux: Soil/Water Surface Contributions
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=1,klonv                                         !
          isl        =  isnoSV(ikl)                            !
          ist   = max(0,isotSV(ikl)-100*isnoSV(ikl))           ! 0 if    H2O
          ist__s= min(1,ist)                                   ! 1 if no H2O
          ist__w=     1-ist__s                                 ! 1 if    H2O
          d__eta     =  eta_SV(ikl,isl)-etaNEW(ikl)            !
          HL___D(ikl)=( ist__s *ro_Wat *dz_dSV(0)              ! Soil Contrib.
     .                *(etaNEW(ikl)    -etaBAK(ikl)) / dt__SV  !
     .                 +ist__w         *f_HSHL(ikl)            ! H2O  Contrib.
     .                *(QaT_SV(ikl)    -qsatsg(ikl))         ) !
     .                * Lx_H2O(ikl)                            ! common factor

c #DL     RHuSol(ikl) =(QaT_SV(ikl)                            !
c #DL.                 -HL___D(ikl)    / f___HL(ikl))          !
c #DL.                / qsatsg(ikl)                            !
 
C +--Surface: Latent    Heat Flux: T Derivative
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          dLdTSV(ikl) = 0.
c #DL     dLdTSV(ikl) = f___HL(ikl) * RHuSol(ikl) *dqs_dT(ikl) ! - d(HL)/d(T)
c #DL     HL___D(ikl) = HL___D(ikl)                            !
c #DL.                 +dLdTSV(ikl) * TsisSV(ikl,isl)          !
        END DO                                                 !

C +--Surface: Tridiagonal Matrix Set Up
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=1,klonv
          isl             =  isnoSV(ikl)
          TSurf0(ikl)     =  TsisSV(ikl,isl)
          Elem_A          =  dtC_sv(ikl,isl)*mu__dz(ikl,isl)
          Elem_C          =  0.
          Diag_A(ikl,isl) = -Elem_A *Implic
          Diag_C(ikl,isl) =  0.
          Diag_B(ikl,isl) =  1.0d+0 -Diag_A(ikl,isl)
          Diag_B(ikl,isl) =  Diag_B(ikl,isl)
     .  + dtC_sv(ikl,isl) * (dIRsdT(ikl)                       ! Upw. Sol IR
     .                      +dSdTSV(ikl)                       ! HS/Surf.Contr.
     .                      +dLdTSV(ikl))                      ! HL/Surf.Contr.
          Term_D(ikl,isl) =  Explic *Elem_A *TsisSV(ikl,isl-1)
     .             +(1.0d+0 -Explic *Elem_A)*TsisSV(ikl,isl)
          Term_D(ikl,isl) =  Term_D(ikl,isl)
     .  + dtC_sv(ikl,isl) * (sol_SV(ikl)    *SoSosv(ikl)       ! Absorbed
     .                                     *(sEX_sv(ikl,isl+1) ! Solar
     .                                      -sEX_sv(ikl,isl  ))!
     .        +      tau_sv(ikl)      *IRd_SV(ikl)*Eso_sv(ikl) ! Down Atm IR
     .         -(1.0-tau_sv(ikl)) *0.5*IRv_sv(ikl)             ! Down Veg IR
     .                                +IRs__D(ikl)             ! Upw. Sol IR
     .                                +HS___D(ikl)             ! HS/Atmo.Contr.
     .                                +HL___D(ikl)            )! HL/Atmo.Contr.
        END DO


C +--Tridiagonal Elimination
C +  =======================

C +--Forward  Sweep
C +  ^^^^^^^^^^^^^^
        DO ikl=  1,klonv
          Aux__P(ikl,-nsol) = Diag_B(ikl,-nsol)
          Aux__Q(ikl,-nsol) =-Diag_C(ikl,-nsol)/Aux__P(ikl,-nsol)
        END DO

      DO   isl=-nsol+1,nsno
        DO ikl=      1,klonv
          Aux__P(ikl,isl)   = Diag_A(ikl,isl)  *Aux__Q(ikl,isl-1)
     .                       +Diag_B(ikl,isl)
          Aux__Q(ikl,isl)   =-Diag_C(ikl,isl)  /Aux__P(ikl,isl)
        END DO
      END DO

        DO ikl=      1,klonv
          TsisSV(ikl,-nsol) = Term_D(ikl,-nsol)/Aux__P(ikl,-nsol)
        END DO

      DO   isl=-nsol+1,nsno
        DO ikl=      1,klonv
          TsisSV(ikl,isl)   =(Term_D(ikl,isl)
     .                       -Diag_A(ikl,isl)  *TsisSV(ikl,isl-1))
     .                                         /Aux__P(ikl,isl)
        END DO
      END DO

C +--Backward Sweep
C +  ^^^^^^^^^^^^^^
      DO   isl=nsno-1,-nsol,-1
        DO ikl=     1,klonv
          TsisSV(ikl,isl)   = Aux__Q(ikl,isl)  *TsisSV(ikl,isl+1)
     .                                         +TsisSV(ikl,isl)
        END DO
      END DO

C +--Temperature Limits (avoids problems in case of no Snow Layers)
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=     1,klonv
           isl              = isnoSV(ikl)
          dTSurf            = TsisSV(ikl,isl) -     TSurf0(ikl)
          TsisSV(ikl,isl)   = TSurf0(ikl) + sign(1.,dTSurf) ! 180.0 dgC/hr
     .              * min(abs(dTSurf),5.e-2*dt__SV)         ! =0.05 dgC/s
        END DO
      DO   isl=nsno,1      ,-1
        DO ikl=     1,klonv
          TsisSV(ikl,isl)   = max(Ts_Min,       TsisSV(ikl,isl))
          TsisSV(ikl,isl)   = min(Ts_Max,       TsisSV(ikl,isl))
        END DO
      END DO


C +--Update Surface    Fluxes
C +  ========================

        DO ikl=      1,klonv
          isl         = isnoSV(ikl)
          IRs_SV(ikl) = IRs__D(ikl)                          !
     .                - dIRsdT(ikl) * TsisSV(ikl,isl)        !
          HSs_sv(ikl) = HS___D(ikl)                          ! Sensible Heat
     .                - dSdTSV(ikl) * TsisSV(ikl,isl)        ! Downward > 0
          HLs_sv(ikl) = HL___D(ikl)                          ! Latent   Heat
     .                - dLdTSV(ikl) * TsisSV(ikl,isl)        ! Downward > 0

C +--OUTPUT for Stand Alone NetCDF File
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #NC     SOsoKL(ikl) = sol_SV(ikl) * SoSosv(ikl)            ! Absorbed Sol.
c #NC     IRsoKL(ikl) =               IRs_SV(ikl)            ! Up Surf. IR
c #NC.        +     tau_sv(ikl)      *IRd_SV(ikl)*Eso_sv(ikl)! Down Atm IR
c #NC.        -(1.0-tau_sv(ikl)) *0.5*IRv_sv(ikl)            ! Down Veg IR
c #NC     HSsoKL(ikl) = HSs_sv(ikl)                          ! HS
c #NC     HLsoKL(ikl) = HLs_sv(ikl)                          ! HL
c #NC     HLs_KL(ikl) = HLs_sv(ikl) / Lv_H2O                 ! mm w.e./sec
        END DO


C +--Energy Budget (OUT)
C +  ===================

! #e1   DO ikl=1,klonv
! #e1     ETSo_d(ikl) =
! #e1.         (     SoSosv(ikl)      *sol_SV(ikl)             ! Net   Solar
! #e1.         +                       IRs_SV(ikl)             ! Up Surf. IR
! #e1.         +     tau_sv(ikl)      *IRd_SV(ikl)*Eso_sv(ikl) ! Down Atm IR
! #e1.         -(1.0-tau_sv(ikl)) *0.5*IRv_sv(ikl)             ! Down Veg IR
! #e1.                                +HSs_sv(ikl)             ! Sensible
! #e1.                                +HLs_sv(ikl)            )! Latent
! #e1     ETSo_1(ikl) = 0.
! #e1   END DO
! #e1 DO   isl= -nsol,nsno
! #e1   DO ikl=1,klonv
! #e1     Exist0      = isl -           isnoSV(ikl)
! #e1     Exist0      = 1.  - max(zero,min(unun,Exist0))
! #e1     ETSo_1(ikl) = ETSo_1(ikl)
! #e1.                +(TsisSV(ikl,isl)-TfSnow)*Exist0
! #e1.                                 /dtC_sv(ikl,isl)
! #e1   END DO
! #e1 END DO


      return
      end


      subroutine SISVAT_qVg

C +------------------------------------------------------------------------+
C | MAR          SISVAT_qVg                                22-09-2001  MAR |
C |   SubRoutine SISVAT_qVg computes the Canopy Water  Balance             |
C |                                  including  Root   Extraction          |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   ivgtSV   = 0,...,12:   Vegetation Type                      |
C |   ^^^^^               0:          Water, Solid or Liquid               |
C |                                                                        |
C |   INPUT:   rhT_SV   : SBL Top    Air  Density                  [kg/m3] |
C |   ^^^^^    QaT_SV   : SBL Top    Specific  Humidity            [kg/kg] |
C |                                                                        |
C |            TvegSV   : Canopy   Temperature                         [K] |
C |            rrCaSV   : Canopy     Water     Content             [kg/m2] |
C |            rrMxsv   : Canopy Maximum Intercepted Rain          [kg/m2] |
C |            rah_sv   : Aerodynamic Resistance for Heat            [s/m] |
C |            EvT_sv   : EvapoTranspiration                       [kg/m2] |
C |            Sigmsv   : Canopy Ventilation Factor                    [-] |
C |            glf_sv   : Green Leaf Fraction of NOT fallen Leaves     [-] |
C |            LAIesv   : Leaf Area  Index (effective / transpiration) [-] |
C |            psi_sv   : Soil       Water    Potential                [m] |
C |            Khydsv   : Soil   Hydraulic    Conductivity           [m/s] |
C |                                                                        |
C |   INPUT /  psivSV   : Leaf       Water    Potential                [m] |
C |   OUTPUT:                                                              |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   OUTPUT:  Rootsv   : Root Water Pump                        [kg/m2/s] |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   Internal Variables:                                                  |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |                                                                        |
C |   REMARK: Water Extraction by roots calibrated by Evapotranspiration   |
C |   ^^^^^^  (computed in the Canopy Energy Balance)                      |
C |                                                                        |
C | # OPTIONS: #KW: Root Water Flow slowed by Soil Hydraulic Conductivity  |
C | # ^^^^^^^                                                              |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"

      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--Internal Variables
C +  ==================

      integer   ikl   ,isl                    ! Grid Point, Layer Indices
      integer   nitmax,nit                    ! Iterations Counter
      real      PlantW(klonv)                 ! Plant  Water
      real      dPdPsi(klonv)                 ! Plant  Water psi Derivative
      real      psidif                        ! Soil-Canopy  Water Pot. Differ.
      real      Root_W                        ! Root   Water     Flow
      real      RootOK                        ! Roots take Water in Soil Layer
      real      d_psiv                        ! Canopy Water     Increment
      real      dpvMAX                        ! Canopy Water     Increment MAX
      real      BWater                        ! Imbalance of Canopy Water Budg.
      real      BW_MAX                        ! MAX Imbal.of Canopy Water Budg.
      real      BW_MIN                        ! MIN Imbal.of Canopy Water Budg.
      real      dBwdpv                        ! Derivativ.of Canopy Water Budg.
      real      Bswich                        ! Newton-Raphson         Switch
      real      psiv_0(klonv)                 ! Canopy Temperature,  Previous t
      real      EvFrac                        ! Condensat./Transpiration Switch
      real      den_qs,arg_qs,qsatvg          ! Canopy Saturat. Spec. Humidity
      real      EvTran                        ! EvapoTranspiration
      real      dEdpsi                        ! Evapotranspiration  Derivative
      real      Fac_Ev,FacEvT                 ! Evapotranspiration  Factors
      real      denomE                        ! Evapotranspiration  Denominator
      real      F_Stom                        ! Funct.  (Leaf Water Potential)
      real      dFdpsi                        ! Derivative  of F_Stom
      real      denomF                        ! Denominator of F_Stom
      real      F___OK                        ! (psi>psi_c) => F_Stom swich  ON
      real      R0Stom                        ! Minimum Stomatal Resistance
      real      R_Stom                        !         Stomatal Resistance
      real      dRdpsi                        ! Derivat.Stomatal Resistance
      real      numerR                        ! Numerat.Stomatal Resistance


C +--Internal DATA
C +  =============

      data      nitmax /   5     /            ! Maximum  Iterations    Number
      data      dpvMAX /  20.    /            ! Canopy   Water   Increment MAX
      data      BW_MIN /   4.e-8 /            ! MIN Imbal. of Surf.Energy Budg.


C +--Newton-Raphson Scheme
C +  =====================

      nit    = 0
  101 CONTINUE
      nit    = nit + 1
      BW_MAX = 0.


C +--W.Potential of the Previous Time Step
C +  -------------------------------------

        DO ikl=1,klonv
          psiv_0(ikl) = psivSV(ikl)


C +--Extraction of Soil Water through the Plant Roots
C +  ------------------------------------------------

          PlantW(ikl)     = 0.                              ! Plant Water
          dPdPsi(ikl)     = 0.                              ! Idem, Derivat.
        END DO
      DO   isl=-nsol,0
        DO ikl=1,klonv
          psidif = psivSV(ikl)-(DH_dSV(ivgtSV(ikl))         ! Soil-Canopy Water
     .                         +psi_sv(       ikl ,isl))    ! Potential  Diff.
          Root_W = Ro_Wat     * RF__SV(ivgtSV(ikl),isl)     ! If > 0, Contrib.
     .              /max(eps_21,PR_dSV(ivgtSV(ikl))         !     to Root Water
c #KW.                         +Khydsv(ikl   ,isl )*1.e-4   ! (DR97, eqn.3.20)
     .                                                   )  !
C +!!!    Pas de prise en compte de la resistance sol/racine dans proto-svat 
C +       (DR97, eqn.3.20)
          RootOK =      max(zero, sign(unun,psidif))
          Rootsv(ikl,isl) = Root_W*max(zero,psidif)         ! Root  Water
          PlantW(ikl)     = PlantW(ikl) + Rootsv(ikl ,isl)  ! Plant Water
          dPdPsi(ikl)     = dPdPsi(ikl) + RootOK*Root_W     ! idem, Derivat.
        END DO
      END DO


C +--Latent   Heat Flux
C +  ------------------

C +--Canopy Saturation Specific Humidity
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        DO ikl=1,klonv
          den_qs =         TvegSV(ikl)- 35.8
          arg_qs = 17.27 *(TvegSV(ikl)-273.16)/den_qs
          qsatvg = .0038 * exp(arg_qs)

C +--Canopy Stomatal Resistance
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^
          R0Stom = min(         StodSV(ivgtSV(ikl))
     .                /max(epsi,glf_sv(       ikl)),StxdSV) ! Min Stomatal R.
          denomF =              pscdSV-psivSV(ikl)
          F___OK =     max(zero,sign(unun,denomF))
          denomF =     max(epsi,          denomF)           !
          F_Stom =              pscdSV  / denomF            ! F(Leaf Wat.Pot.)
          dFdpsi =             -F_Stom  / denomF            !
C +                                                         ! DR97, eqn. 3.22
          numerR = R0Stom / max(LAIesv(ikl), R0Stom/StxdSV) !
          R_Stom = numerR *                  F_Stom         ! Can.Stomatal R.
C +                                                         ! DR97, eqn. 3.21
          dRdpsi = R_Stom *                  dFdpsi         !

C +--Evaporation / Evapotranspiration
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          EvFrac = max(zero, sign(unun,QaT_SV(ikl)-qsatvg)) ! Condensation/
          EvFrac = EvFrac                                   ! Transpiration
     .       + (1.-EvFrac)     *rrCaSV(ikl)/ rrMxsv(ikl)    !        Switch
          Fac_Ev = rhT_SV(ikl) *Sigmsv(ikl)                 ! idem,  Factor
          denomE = rah_sv(ikl) +R_Stom     * Sigmsv(ikl)
          FacEvT = Fac_Ev * (1.-EvFrac)    / denomE         !
          EvTran = FacEvT     *(qsatvg     - QaT_SV(ikl))   ! EvapoTranspir.
          dEdpsi =(EvTran     / denomE)    * dRdpsi         ! EvT Derivative


C +--Imbalance  of the Canopy  Water  Budget
C +  ---------------------------------------

          BWater      =( PlantW(ikl)                        ! Available  Water
     .                 - EvTran     )*        F___OK        ! Transpired Water

          Bswich      = max(zero,                           ! Newton-Raphson
     .                      sign(unun,    abs(BWater)       !         Switch
     .                                       -BW_MIN))      !


C +--Derivative of the Canopy  Water  Budget
C +  ---------------------------------------

          dBwdpv      = dPdpsi(ikl)
     .                - dEdpsi
          dBwdpv      = sign(  unun,    dBwdpv)             !
     .                *  max(eps_21,abs(dBwdpv))            ! 


C +--Update Canopy and Surface/Canopy Temperatures
C +  ---------------------------------------------

          d_psiv      = BWater       / dBwdpv               !
          d_psiv      =      sign(unun,d_psiv)              ! Increment
     .                       *min( abs(d_psiv)     ,dpvMAX) ! Limitor
          psivSV(ikl) = psivSV(ikl)  - Bswich      *d_psiv  ! Newton-Raphson
          BW_MAX      = max(BW_MAX,abs(BWater))
        END DO


C +--Update Root Water Fluxes | := Evapotranspiration 
C +  ------------------------------------------------

      DO   isl=-nsol,0
        DO ikl=1,klonv
          Rootsv(ikl,isl) = Rootsv(ikl,isl)*EvT_SV(ikl)     ! Root  Water
     .                          /max(eps_21,PlantW(ikl))    !
        END DO
      END DO

      IF (BW_MAX.gt.BW_MIN.and.nit.lt.nitmax)    GO TO 101

      return
      end


      subroutine SISVAT_qSn
     .                     (
! #e1.                      EqSn_0,EqSn_1,EqSn_d
! #m1.                     ,SIsubl,SImelt,SIrnof
     .                     )

C +------------------------------------------------------------------------+
C | MAR          SISVAT_qSn                           Fri 29-Jul-2011  MAR |
C |   SubRoutine SISVAT_qSn updates  the Snow Water Content                |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   isnoSV   = total Nb of Ice/Snow Layers                      |
C |   ^^^^^                                                                |
C |                                                                        |
C |   INPUT:   TaT_SV   : SBL Top    Temperature                       [K] |
C |   ^^^^^    dt__SV   : Time Step                                    [s] |
C |                                                                        |
C |   INPUT /  drr_SV   : Rain Intensity                         [kg/m2/s] |
C |   OUTPUT:  dzsnSV   : Snow Layer Thickness                         [m] |
C |   ^^^^^^   eta_SV   : Snow Water Content                       [m3/m3] |
C |            ro__SV   : Snow/Soil  Volumic Mass                  [kg/m3] |
C |            TsisSV   : Soil/Ice Temperatures (layers -nsol,-nsol+1,..,0)|
C |                     & Snow     Temperatures (layers  1,2,...,nsno) [K] |
C |                                                                        |
C |   OUTPUT:  SWS_SV   : Surficial Water Status                           |
C |   ^^^^^^                                                               |
C |            EExcsv   : Snow Energy in Excess, initial Forcing    [J/m2] |
C |            EqSn_d   : Snow Energy in Excess, remaining          [J/m2] |
C |            EqSn_0   : Snow Energy, before Phase Change          [J/m2] |
C |            EqSn_1   : Snow Energy, after  Phase Change          [J/m2] |
C |            SIsubl   : Snow sublimed/deposed Mass             [mm w.e.] |
C |            SImelt   : Snow Melted           Mass             [mm w.e.] |
C |            SIrnof   : Surficial Water + Run OFF Change       [mm w.e.] |
C |                                                                        |
C |   Internal Variables:                                                  |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |                                                                        |
C | # OPTIONS: #E0: IO for Verification: Energy       Budget               |
C | # ^^^^^^^                                                              |
C | #          #su: IO for Verification: Slush        Diagnostic           |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # SISVAT_qSn.vm        | #vm: OUTPUT/Verification: Energy/Water Budget |
C |                        |      unit 43, SubRoutine  SISVAT_qSn **ONLY** |
C | # SISVAT_qSn.vu        | #vu: OUTPUT/Verification: Slush  Parameteriz. |
C |                        |      unit 44, SubRoutine  SISVAT_qSn **ONLY** |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"

      include  "MARxSV.inc"


C +--OUTPUT
C +  ------

      include "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

! Energy          Budget
! ~~~~~~~~~~~~~~~~~~~~~~
! #e1 real     EqSn_d(klonv)                 ! Energy in Excess, initial
! #e1 real     EqSn_0(klonv)                 ! Snow Energy, befor Phase Change
! #vm real     EqSn01(klonv)                 ! Snow Energy, after Phase Change
! #vm real     EqSn02(klonv)                 ! Snow Energy, after Phase Change
                                             !              .AND. Last Melting 
! #e1 real     EqSn_1(klonv)                 ! Snow Energy, after Phase Change
                                             !              .AND. Mass Redistr.
! Snow/Ice (Mass) Budget
! ~~~~~~~~~~~~~~~~~~~~~~
! #m1 real     SIsubl(klonv)                 ! Snow Deposed Mass
! #m1 real     SImelt(klonv)                 ! Snow Melted  Mass
! #m1 real     SIrnof(klonv)                 ! Local Surficial Water + Run OFF


C +--Internal Variables
C +  ==================

      integer  ikl   ,isn                    !
      integer  nh                            ! Non erodible Snow: up.lay.Index
      integer  LayrOK                        ! 1 (0)  if In(Above) Snow Pack
      integer  k_face                        ! 1 (0)  if Crystal(no) faceted
      integer  LastOK                        ! 1 ==>  1! Snow Layer
      integer  NOLayr                        ! 1     Layer  Update
      integer  noSnow(klonv)                 ! Nb of Layers Updater
      integer  kSlush                        ! Slush Switch
      real     dTSnow                        ! Temperature                  [C]
      real     EExdum(klonv)                 ! Energy in Excess when no Snow
      real     OKmelt                        ! 1 (0)  if        (no) Melting
      real     EnMelt                        ! Energy in excess, for Melting
      real     SnHLat                        ! Energy consumed   in  Melting
      real     AdEnrg,B_Enrg                 ! Additional Energy from  Vapor
      real     dzVap0,dzVap1                 ! Vaporized Thickness          [m]
      real     dzMelt(klonv)                 ! Melted    Thickness          [m]
      real     rosDry                        ! Snow volumic Mass if no Water in
      real     PorVol                        ! Pore volume
      real     PClose                        ! Pore Hole Close OFF Switch
      real     SGDiam                        !      Snow Grain Diameter
      real     SGDmax                        ! Max. Snow Grain Diameter 
      real     rWater                        ! Retained Water           [kg/m2]
      real     drrNEW                        ! New available Water      [kg/m2]
      real     rdzNEW                        ! Snow          Mass       [kg/m2]
      real     rdzsno                        ! Snow          Mass       [kg/m2]
      real     EnFrez                        ! Energy Release    in  Freezing
      real     WaFrez                        ! Water  consumed   in  Melting
      real     RapdOK                        ! 1. ==> Snow melts rapidly
      real     ThinOK                        ! 1. ==> Snow Layer is thin
      real     dzepsi                        ! Minim. Snow Layer Thickness (!)
      real     dz_Min                        ! Minim. Snow Layer Thickness
      real     z_Melt                        ! Last (thin) Layer Melting
      real     rusnew                        ! Surficial Water Thickness   [mm]
      real     zWater                        ! Max Slush Water Thickness   [mm]
      real     zSlush                        !     Slush Water Thickness   [mm]
      real     ro_new                        ! New Snow/ice  Density    [kg/m3]
      real     zc,zt                         ! Non erod.Snow Thickness[mm w.e.]

C +--OUTPUT of SISVAT Trace Statistics (see assignation in PHY_SISVAT)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      integer             isnnew,isinew,isnUpD,isnitr

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx integer             iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1
! #wx common/SISVAT_EV/   iSV_v1,jSV_v1,nSV_v1,kSV_v1,lSV_v1

C +--Energy and Mass Budget
C +  ~~~~~~~~~~~~~~~~~~~~~~
! #vm real     WqSn_0(klonv)                 ! Snow Water+Forcing  Initial
! #vm real     WqSn_1(klonv)                 ! Snow Water+Forcing, Final
! #vm logical         emopen                 ! IO   Switch
! #vm common/Se_qSn_L/emopen                 !
! #vm integer         no_err                 !
! #vm common/Se_qSn_I/no_err                 !
! #vm real     hourer,timeer                 !
! #vm common/Se_qSn_R/timeer                 !

C +--Slush Diagnostic: IO
C +  ~~~~~~~~~~~~~~~~~~~~
! #vu logical         su_opn                 ! IO   Switch
! #vu common/SI_qSn_L/su_opn                 !


C +--DATA
C +  ====

      data      dzepsi/0.0001/                ! Minim. Snow Layer Thickness (!)
c #?? data      dz_Min/0.005/                 ! Minim. Snow Layer Thickness
c ... Warning: Too high for Col de Porte: precludes 1st snow (layer) apparition 
      data      dz_Min/1.e-3/                 ! Minim. Snow Layer Thickness
      data      SGDmax/0.003/                 ! Maxim. Snow Grain Diameter  [m]
                                              ! (Rowe et al. 1995, JGR p.16268)

C +--Energy Budget (IN)
C +  ==================

! #e1   DO ikl=1,klonv
! #e1     EqSn_0(ikl) = 0.
! #e1   END DO
! #e1 DO   isn=nsno,1,-1
! #e1   DO ikl=1,klonv
! #e1     EqSn_0(ikl) = EqSn_0(ikl) + ro__SV(ikl,isn) *dzsnSV(ikl,isn)
! #e1.                *(Cn_dSV      *(TsisSV(ikl,isn) -TfSnow         )
! #e1.                 -Lf_H2O      *(1.              -eta_SV(ikl,isn)))
! #e1   END DO
! #e1 END DO


C +--Water  Budget (IN)
C +  ==================

! #vm   DO ikl=1,klonv
! #vm     WqSn_0(ikl) = drr_SV(ikl) * dt__SV          
! #vm.                 +rusnSV(ikl)
! #vm   END DO
! #vm DO   isn=nsno,1,-1
! #vm   DO ikl=1,klonv
! #vm     WqSn_0(ikl) = WqSn_0(ikl) + ro__SV(ikl,isn) *dzsnSV(ikl,isn)
! #vm   END DO
! #vm END DO


C +--Snow Melt Budget
C +  ================

! #m1   DO ikl=1,klonv
! #m1     SImelt(ikl) = 0.
! #m1     SIrnof(ikl) = rusnSV(ikl) + RnofSV(ikl) * dt__SV
! #m1   END DO


C +--Initialization
C +  ==============

      DO ikl=1,klonv
        noSnow(ikl)   = 0                   ! Nb of Layers Updater
        ispiSV(ikl)   = 0                   ! Pore Hole Close OFF Index
                                            ! (assumed to be the Top of
                                            !  the surimposed Ice Layer)
c #IB   wem_SV(ikl)   = 0.
c #IB   wer_SV(ikl)   = 0.
      END DO


C +--Melting/Freezing Energy
C +  =======================

C +...REMARK: Snow liquid Water Temperature assumed = TfSnow
C +   ^^^^^^
        DO ikl=1,klonv
          EExdum(ikl) = drr_SV(ikl)     * C__Wat *(TaT_SV(ikl)-TfSnow) 
     .                                  * dt__SV
          EExcsv(ikl) = EExdum(ikl)     *    min(1,isnoSV(ikl)) ! Snow exists
          EExdum(ikl) = EExdum(ikl)     -          EExcsv(ikl)  !
! #e1     EqSn_d(ikl) = EExcsv(ikl)                             !
        END DO


C +--Surficial Water Status
C +  ----------------------

        DO ikl=1,klonv
          SWS_SV(ikl) = max(zero,sign(unun,TfSnow
     .                                    -TsisSV(ikl,isnoSV(ikl))))
        END DO

      DO   isn=nsno,1,-1
        DO ikl=1,klonv

C +--Energy, store Previous Content
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          dTSnow      = TsisSV(ikl,isn) -          TfSnow
          EExcsv(ikl) = EExcsv(ikl) 
     .                + ro__SV(ikl,isn) * Cn_dSV * dTSnow
     .                                           * dzsnSV(ikl,isn)
          TsisSV(ikl,isn) =                        TfSnow

C +--Water,  store Previous Content
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          drr_SV(ikl) = drr_SV(ikl)
     .                + ro__SV(ikl,isn)          * eta_SV(ikl,isn) 
     .                                           * dzsnSV(ikl,isn)
     .                / dt__SV
          ro__SV(ikl,isn) =
     .                  ro__SV(ikl,isn) *(1.     - eta_SV(ikl,isn))
          eta_SV(ikl,isn) =  0.


C +--Melting  if EExcsv > 0
C +  ======================

          EnMelt      =    max(zero,          EExcsv(ikl) )

C +--Energy Consumption
C +  ^^^^^^^^^^^^^^^^^^
          SnHLat      = ro__SV(ikl,isn) * Lf_H2O
          dzMelt(ikl) = EnMelt      / max(SnHLat,    epsi )
          noSnow(ikl) = noSnow(ikl) 
     .      + max(zero  ,sign(unun,dzMelt(ikl)                !
     .                            -dzsnSV(ikl ,isn)))         ! 1 if full Melt
     .       *min(1     , max(0 ,1+isnoSV(ikl)-isn))          ! 1 in the  Pack
          dzMelt(ikl) =    
     .              min(dzsnSV(ikl, isn),dzMelt(ikl))
          dzsnSV(ikl,isn) = 
     .                  dzsnSV(ikl,isn) -dzMelt(ikl)
          EExcsv(ikl) = EExcsv(ikl)     -dzMelt(ikl)*SnHLat
c #IB     wem_SV(ikl) = wem_SV(ikl)     -dzMelt(ikl)*ro__SV(ikl,isn)

C +--Water  Production
C +  ^^^^^^^^^^^^^^^^^
          drr_SV(ikl) = drr_SV(ikl)     
     .                + ro__SV(ikl,isn) * dzMelt(ikl)/dt__SV
! #m1     SImelt(ikl) = SImelt(ikl)
! #m1.                + ro__SV(ikl,isn) * dzMelt(ikl)
          OKmelt      =max(zero,sign(unun,drr_SV(ikl)-epsi))

C +--Snow History
C +  ^^^^^^^^^^^^
          k_face          =       min(    istoSV(ikl,isn),istdSV(1)) ! = 1  if
     .                           *max(0,2-istoSV(ikl,isn)          ) ! faceted
          istoSV(ikl,isn) =                                          !
     .        (1.-OKmelt) *               istoSV(ikl,isn)            !
     .      +     OKmelt  *((1-k_face) *  istdSV(2)                  !
     .                     +   k_face  *  istdSV(3)      )           !


C +--Freezing if EExcsv < 0
C +  ======================

          rdzsno      =          ro__SV(ikl,isn) * dzsnSV(ikl ,isn)
          LayrOK      = min(   1, max(0          , isnoSV(ikl)-isn+1))
          EnFrez      = min(zero,                  EExcsv(ikl))
          WaFrez      =   -(     EnFrez          * LayrOK / Lf_H2O)
          drrNEW      = max(zero,drr_SV(ikl)     - WaFrez / dt__SV)
          WaFrez      =    (     drr_SV(ikl)     - drrNEW)* dt__SV
          drr_SV(ikl) =          drrNEW
          EExcsv(ikl) =          EExcsv(ikl)     + WaFrez * Lf_H2O
          EnFrez      = min(zero,EExcsv(ikl))    * LayrOK
          rdzNEW      = WaFrez + rdzsno
          ro__SV(ikl,isn) =      rdzNEW /max(epsi, dzsnSV(ikl,isn))
          TsisSV(ikl,isn) =      TfSnow
     .                + EnFrez /(Cn_dSV *max(epsi, rdzNEW)        )
          EExcsv(ikl) =          EExcsv(ikl)     - EnFrez
c #IB     wer_SV(ikl) = WaFrez                             
c #IB.                + wer_SV(ikl)


C +--Snow Water Content
C +  ==================

C +--Percolation Velocity
C +  ^^^^^^^^^^^^^^^^^^^^
c #PW     SGDiam    = 1.6d-4
c #PW.              + 1.1d-13 *(ro__SV(ikl,isn)*ro__SV(ikl,isn)
c #PW.                         *ro__SV(ikl,isn)*ro__SV(ikl,isn))

C +--Pore   Volume [-]
C +  ^^^^^^^^^^^^^^^^^
          rosDry      =(1.     - eta_SV(ikl,isn))* ro__SV(ikl,isn) !
          PorVol      = 1.     - rosDry          / ro_Ice          !
          PorVol      =      max(PorVol          , zero  )         !

C +--Water  Retention
C +  ^^^^^^^^^^^^^^^^
          rWater      = ws0dSV * PorVol * ro_Wat * dzsnSV(ikl,isn)
          drrNEW      = max(zero,drr_SV(ikl)     - rWater /dt__SV)
          rWater      =    (     drr_SV(ikl)     - drrNEW)*dt__SV
          drr_SV(ikl)     =      drrNEW
          rdzNEW          =      rWater 
     .                         + rosDry          * dzsnSV(ikl,isn)
          eta_SV(ikl,isn) =      rWater / max(epsi,rdzNEW)
          ro__SV(ikl,isn) =      rdzNEW / max(epsi,dzsnSV(ikl,isn))

C +--Pore Hole Close OFF
C +  ^^^^^^^^^^^^^^^^^^^
          PClose = max(zero,
     .                 sign(unun,ro__SV(ikl,isn)
     .                          -roCdSV         ))
          ispiSV(ikl) =          ispiSV(ikl)      *(1.-PClose)
     .                +      max(ispiSV(ikl),isn)    * Pclose
          PClose = max(0   ,                         ! Water under SuPer.Ice
     .                 min (1   ,ispiSV(ikl)         ! contributes to
     .                          -isn            ))   ! Surficial   Water
cXF
          if(ro__SV(ikl,isn) < ro_ice-20.)
     .    PClose = PClose *
     .    (1.-(ro_ice-20.-ro__SV(ikl,isn))/(ro_ice-20.-roCdSV))

          PClose = max(0.,min(1.,PClose))

          if(isn==1) then
               PClose = 1
           ispiSV(ikl)= max(ispiSV(ikl),1)
          endif
cXF
          rusnSV(ikl) =          rusnSV(ikl) 
     .                +          drr_SV(ikl) *dt__SV * PClose
          drr_SV(ikl) =          drr_SV(ikl)      *(1.-PClose)

        END DO
      END DO


C +--Remove Zero-Thickness Layers
C +  ============================

 1000 CONTINUE
           isnitr =          0
      DO   ikl=1,klonv
           isnUpD =          0
           isinew =          0
cXF
        DO isn=1,min(nsno-1,isnoSV(ikl))
           isnnew =(unun-max(zero  ,sign(unun,dzsnSV(ikl,isn)-dzepsi)))
     .             *     max(0     , min(1   ,isnoSV(ikl) +1 -isn ))
           isnUpD =      max(isnUpD,          isnnew)
           isnitr =      max(isnitr,          isnnew)
           isinew =      isn*isnUpD *max(0, 1-isinew)      ! LowerMost  0-Layer
     .                                       +isinew       ! Index
           dzsnSV(ikl,isn) =                  dzsnSV(ikl,isn+isnnew)
           ro__SV(ikl,isn) =                  ro__SV(ikl,isn+isnnew)
           TsisSV(ikl,isn) =                  TsisSV(ikl,isn+isnnew)
           eta_SV(ikl,isn) =                  eta_SV(ikl,isn+isnnew)
           G1snSV(ikl,isn) =                  G1snSV(ikl,isn+isnnew)
           G2snSV(ikl,isn) =                  G2snSV(ikl,isn+isnnew)
           dzsnSV(ikl,isn+isnnew) =(1-isnnew)*dzsnSV(ikl,isn+isnnew)
           ro__SV(ikl,isn+isnnew) =(1-isnnew)*ro__SV(ikl,isn+isnnew)
           eta_SV(ikl,isn+isnnew) =(1-isnnew)*eta_SV(ikl,isn+isnnew)
           G1snSV(ikl,isn+isnnew) =(1-isnnew)*G1snSV(ikl,isn+isnnew)
           G2snSV(ikl,isn+isnnew) =(1-isnnew)*G2snSV(ikl,isn+isnnew)
        END DO
           isnoSV(ikl)   =   isnoSV(ikl)-isnUpD            ! Nb of Snow   Layer
           ispiSV(ikl)   =   ispiSV(ikl)                   ! Nb of SuperI Layer
     .    -isnUpD *max(0,min(ispiSV(ikl)-isinew,1))        ! Update  if I=0

! OUTPUT in SISVAT at specified i,j,k,n (see assignation in PHY_SISVAT)
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! #wx   IF(isnUpD .GT. 0 .AND. ikl .EQ. kSV_v1 .AND.lSV_v1 .EQ. 3)
! #wx.     write(6,*)' MERGE ',isnoSV(ikl),' Grid ',iSV_v1,jSV_v1,nSV_v1

      END DO
      IF  (isnitr.GT.0)                                       GO TO 1000


C +--New upper Limit of the non erodible Snow (istoSV .GT. 1)
C +  ========================================

      DO   ikl=1,klonv
           nh =     0
cXF
        DO isn=  isnoSV(ikl),1,-1
           nh =    nh + isn* min(istoSV(ikl,isn)-1,1)*max(0,1-nh)
        ENDDO
           zc =     0. 
           zt =     0. 
cXF
        DO isn=1,isnoSV(ikl)
           zc =    zc +          dzsnSV(ikl,isn) *ro__SV(ikl,isn)
     .                     * max(0,min(1,nh+1-isn))
           zt =    zt +          dzsnSV(ikl,isn) *ro__SV(ikl,isn)
        END DO
           zWE_SV(ikl) =                 zt
           zWEcSV(ikl) = min(zWEcSV(ikl),zt)
           zWEcSV(ikl) = max(zWEcSV(ikl),zc)
      END DO


C +--Energy Budget (OUT)
C +  ===================

! #vm   DO ikl=1,klonv
! #vm     EqSn01(ikl) =-EqSn_0(ikl)
! #vm.                 -EExcsv(ikl)
! #vm   END DO
! #vm DO   isn=nsno,1,-1
! #vm   DO ikl=1,klonv
! #vm     EqSn01(ikl) = EqSn01(ikl) + ro__SV(ikl,isn) *dzsnSV(ikl,isn)
! #vm.                *(Cn_dSV      *(TsisSV(ikl,isn) -TfSnow         )
! #vm.                 -Lf_H2O      *(1.              -eta_SV(ikl,isn)))
! #vm   END DO
! #vm END DO


C +--"Negative Heat" from supercooled rain
C +   ------------------------------------

      DO ikl=1,klonv
          EExcsv(ikl) = EExcsv(ikl) + EExdum(ikl)


C +--Surficial Water Run OFF
C +  -----------------------

          rusnew      = rusnSV(ikl) * SWf_SV(ikl)
          RnofSV(ikl) = RnofSV(ikl)
     .                +(rusnSV(ikl) - rusnew     ) / dt__SV
          rusnSV(ikl) = rusnew
      END DO


C +--Percolation down the Continental Ice Pack
C +  -----------------------------------------

        DO ikl=1,klonv
          drr_SV(ikl) = drr_SV(ikl) + rusnSV(ikl)
     .                     * (1-min(1,ispiSV(ikl)))/ dt__SV 
          rusnSV(ikl) = rusnSV(ikl)
     .                     *    min(1,ispiSV(ikl))
        END DO


C +--Slush Formation (CAUTION: ADD RunOff Possibility before Activation)
C +  ---------------  ^^^^^^^  ^^^

! #vu IF (.NOT.su_opn)                                              THEN
! #vu          su_opn=.true.
! #vu     open(unit=44,status='unknown',file='SISVAT_qSn.vu')
! #vu     rewind    44
! #vu END IF
! #vu     write(44,440) daHost
 440      format('iSupI    i       dz       ro      eta',
     .            '   PorVol   zSlush     ro_n    eta_n',2x,a18)

c #SU DO   isn=1,nsno
c #SU   DO ikl=1,klonv
c #SU     kSlush = min(1,max(0,isn+1-ispiSV(ikl)))        ! Slush Switch

C +--Available Additional Pore   Volume [-]
C +  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
c #SU     PorVol = 1. - ro__SV(ikl,isn)                   ! [--]
c #SU.           *(1. - eta_SV(ikl,isn))/ ro_Ice          !
c #SU.           -      eta_SV(ikl,isn)                   !
c #SU.                 *ro__SV(ikl,isn) / ro_Wat          !
c #SU     PorVol =  max(PorVol          , zero  )         !
c #SU     zWater =      dzsnSV(ikl,isn) * PorVol * 1000.  ! [mm] OR [kg/m2]
c #SU.           * (1. -SWS_SV(ikl)                       ! 0 <=> freezing
c #SU.                *(1 -min(1,iabs(isn-isnoSV(ikl))))) ! 1 <=> isn=isnoSV
c #SU     zSlush =  min(rusnSV(ikl)     , zWater)         ! [mm] OR [kg/m2]
c #SU     rusnSV(ikl) = rusnSV(ikl)     - zSlush          ! [mm] OR [kg/m2]
c #SU     ro_new      =(dzsnSV(ikl,isn) * ro__SV(ikl,isn) !
c #SU.                 +zSlush                           )!
c #SU.            / max(dzsnSV(ikl,isn) , epsi           )!
! #vu     rusnew          = eta_SV(ikl,isn)               !
c #SU     eta_SV(ikl,isn) =(ro_new - ro__SV(ikl,isn)      !
c #SU.                    *(1.     - eta_SV(ikl,isn)))    !
c #SU.               / max (ro_new , epsi            )    !
! #vu     IF    (isn.le.isnoSV(ikl))                      !
! #vu.    write(44,441) ispiSV(ikl),isn,dzsnSV(ikl,isn)   !
! #vu.                 ,ro__SV(ikl,isn),rusnew            !
! #vu.                 ,PorVol         ,zSlush            !
! #vu.                 ,ro_new         ,eta_SV(ikl,isn)   !
 441      format(2i5,f9.3,f9.1,f9.6,f9.3,f9.6,f9.1,f9.6)  !
c #SU     ro__SV(ikl,isn) =      ro_new                   !
c #SU   END DO
c #SU END DO


C +--Impact of the Sublimation/Deposition on the Surface Mass Balance
C +  ================================================================

      DO ikl=1,klonv
          isn                     = isnoSV(ikl)
          dzVap0                  =                   dt__SV
     .  * HLs_sv(ikl)         * min(isn             , 1   )
     .  /(Lx_H2O(ikl)         * max(ro__SV(ikl,isn) , epsi))
          NOLayr=min(zero,sign(unun,dzsnSV(ikl,isn) + dzVap0))
          dzVap1=min(zero,          dzsnSV(ikl,isn) + dzVap0)


C +--Additional Energy
C +  -----------------

c #VH     AdEnrg = dzVap0 * ro__SV(ikl,isnoSV(ikl))           ! Water   Vapor
c #VH.            *C__Wat *(TsisSV(ikl,isnoSV(ikl)) -TfSnow)  ! Sensible Heat

c #aH     B_Enrg =(Cn_dSV      *(TsisSV(ikl,isn) -TfSnow         )
c #aH.            -Lf_H2O      *(1.              -eta_SV(ikl,isn)))
c #aH.           /(1.          + dzVap0 /max(epsi,dzsnSV(ikl,isn)))
c #aH     eta_SV(ikl,isn) =
c #aH.           max(zero,unun +(B_Enrg 
c #aH.                         -(TsisSV(ikl,isn) -TfSnow)*Cn_dSV)
c #aH.                          /Lf_H2O                          )
c #aH     TsisSV(ikl,isn) =    ( B_Enrg
c #aH.                         +(1.              -eta_SV(ikl,isn))
c #aH.                          *Lf_H2O                          )
c #aH.                         / Cn_dSV
c #aH.                         + TfSnow

! #e1     STOP "PLEASE add Energy (#aH) from deposition/sublimation"


C +--Update of the upper Snow layer Thickness
C +  ----------------------------------------

          dzsnSV(ikl,isn) =
     .           max(zero,  dzsnSV(ikl,isnoSV(ikl)) + dzVap0)
          isnoSV(ikl)     = isnoSV(ikl)             + NOLayr
          isn             = isnoSV(ikl)
          dzsnSV(ikl,isn) = dzsnSV(ikl,isn) + dzVap1
c #IB     wes_SV(ikl)     = ro__SV(ikl,isn) * dzVap0
      END DO


C +--Energy Budget (OUT)
C +  ===================

! #vm   DO ikl=1,klonv
! #vm     EqSn02(ikl) =-EqSn_0(ikl)
! #vm.                 -EExcsv(ikl)
! #vm   END DO
! #vm DO   isn=nsno,1,-1
! #vm   DO ikl=1,klonv
! #vm     EqSn02(ikl) = EqSn01(ikl) + ro__SV(ikl,isn) *dzsnSV(ikl,isn)
! #vm.                *(Cn_dSV      *(TsisSV(ikl,isn) -TfSnow         )
! #vm.                 -Lf_H2O      *(1.              -eta_SV(ikl,isn)))
! #vm   END DO
! #vm END DO


C +--Snow/I Budget
C +  -------------

! #m1   DO ikl=1,klonv
! #m1     SIsubl(ikl) = dt__SV*HLs_sv(ikl)*min(isnoSV(ikl),1)
! #m1.                        /Lx_H2O(ikl)
! #m1     SIrnof(ikl) = rusnSV(ikl) + RnofSV(ikl) * dt__SV
! #m1.                - SIrnof(ikl)
! #m1   END DO


C +--Anticipated Disappearance of a rapidly Melting too thin Last Snow Layer
C +  =======================================================================

      DO ikl=1,klonv
        LastOK = min(1   , max(0   ,iiceSV(ikl)-isnoSV(ikl)+2)
     .                    *min(1   ,isnoSV(ikl)-iiceSV(ikl))
     .                    +min(1   ,isnoSV(ikl))              )
        RapdOK = max(zero,sign(unun,dzMelt(ikl)-epsi         ))
        ThinOK = max(zero,sign(unun,dz_Min     -dzsnSV(ikl,1)))
        z_Melt = LastOK     *RapdOK*ThinOK
        noSnow(ikl)   = noSnow(ikl)   + z_Melt
        z_Melt        =                 z_Melt *dzsnSV(ikl,1) 
        dzsnSV(ikl,1) = dzsnSV(ikl,1) - z_Melt
        EExcsv(ikl)   = EExcsv(ikl)   - z_Melt *ro__SV(ikl,1)
     .                                *(1.     -eta_SV(ikl,1))*Lf_H2O

C +--Water  Production
C +  ^^^^^^^^^^^^^^^^^
        drr_SV(ikl)   = drr_SV(ikl)     
     .                + ro__SV(ikl,1) * z_Melt /dt__SV
      END DO


C +--Update Nb of Layers
C +  ===================

c #EF   IF          (isnoSV(1) .GT. 0)
c #EF.  write(6,6005)noSnow(1)
 6005   format(i3,' (noSnow) ')

      DO ikl=1,klonv
        isnoSV(ikl)   = isnoSV(ikl) 
     .     * min(1,iabs(isnoSV(ikl)-noSnow(ikl)))
      END DO


! Energy Budget (OUT)
! ===================

! #e1   DO ikl=1,klonv
! #e1     EqSn_1(ikl) = 0.
! #e1   END DO
! #e1 DO   isn=nsno,1,-1
! #e1   DO ikl=1,klonv
! #e1     EqSn_1(ikl) = EqSn_1(ikl) + ro__SV(ikl,isn) *dzsnSV(ikl,isn)
! #e1.                *(Cn_dSV      *(TsisSV(ikl,isn) -TfSnow         )
! #e1.                 -Lf_H2O      *(1.              -eta_SV(ikl,isn)))
! #e1   END DO
! #e1 END DO


C +--Water  Budget (OUT)
C +  ===================

! #vm   DO ikl=1,klonv
! #vm     WqSn_0(ikl) = WqSn_0(ikl)
! #vm.                + HLs_sv(ikl)    * dt__SV      
! #vm.             *min(isnoSV(ikl),1) / Lx_H2O(ikl)
! #vm     WqSn_1(ikl) = drr_SV(ikl)    * dt__SV
! #vm.                + rusnSV(ikl)
! #vm.                + RnofSV(ikl)    * dt__SV
! #vm   END DO
! #vm DO   isn=nsno,1,-1
! #vm   DO ikl=1,klonv
! #vm     WqSn_1(ikl) = WqSn_1(ikl)    
! #vm.                + ro__SV(ikl,isn)* dzsnSV(ikl,isn)
! #vm   END DO
! #vm END DO


C +--OUTPUT Budget
C +  =============

! #vm IF (.NOT.emopen)                                              THEN
! #vm          emopen = .true.
! #vm          open(unit=43,status='unknown',file='SISVAT_qSn.vm')
! #vm          rewind 43
! #vm   write(43,43)
 43     format('SubRoutine SISVAT_qSn: Local Energy and Water Budgets',
     .       /,'=====================================================')
! #vm END IF
! #vm DO ikl=1,klonv
! #vm IF (EqSn01(ikl).gt.1.e-3) write(43,431) dahost,EqSn01(ikl)
 431  format(' WARNING (1) in _qSn,',         a18,
     .       ': Energy Unbalance in Phase Change = ',e15.6)
! #vm END DO
! #vm DO ikl=1,klonv
! #vm IF (EqSn02(ikl).gt.1.e-3) write(43,432) dahost,EqSn01(ikl)
 432  format(' WARNING (2) in _qSn,',         a18,
     .       ': Energy Unbalance in Phase Change = ',e15.6)
! #vm END DO
! #vm         timeer=timeer + dt__SV
! #vm         hourer=3600.0
! #vm IF (mod(no_err,11).eq.0)                                      THEN
! #vm         no_err=       1
! #vm   write(43,435)timeer/hourer
 435    format(11('-'),'----------+-',3('-'),'----------+-',
     .          3('-'),'----------+-',3('-'),'----------+-',
     .                 '----------------+----------------+',
     .       /,f8.2,3x,'EqSn_0(1) | ',3x,'EqSn_d(1) | ',
     .              3x,'EqSn_1(1) | ',3x,'EExcsv(1) | ',
     .                 'E_0+E_d-E_1-EE  |   Water Budget |',
     .       /,11('-'),'----------+-',3('-'),'----------+-',
     .          3('-'),'----------+-',3('-'),'----------+-',
     .                 '----------------+----------------+')
! #vm END IF
! #vm IF (abs(EqSn_0(1)+EqSn_d(1)-EqSn_1(1)-EExcsv(1)).gt.epsi.OR.
! #vm.    abs(WqSn_1(1)-WqSn_0(1))                    .gt.epsi    ) THEN
! #vm         no_err=no_err+1
! #vm   write(43,436)   EqSn_0(1),EqSn_d(1)
! #vm.                 ,EqSn_1(1),EExcsv(1)
! #vm.                 ,EqSn_0(1)+EqSn_d(1)-EqSn_1(1)-EExcsv(1)
! #vm.                 ,WqSn_1(1)-WqSn_0(1)
 436    format(8x,f12.0,' + ',f12.0,' - ',f12.0,' - ',f12.3,' = ',f12.3,
     .      '    | ',f15.9)
! #vm END IF

! #e1   DO ikl=1,klonv
! #e1     EqSn_d(ikl) = EqSn_d(ikl) - EExcsv(ikl)
! #e1   END DO

      return
      end


      subroutine SISVAT_GSn

C +------------------------------------------------------------------------+
C | MAR          SISVAT_GSn                                20-09-2003  MAR |
C |   SubRoutine SISVAT_GSn simulates SNOW Metamorphism                    |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT /  isnoSV   = total Nb of Ice/Snow Layers                      |
C |   OUTPUT:  iiceSV   = total Nb of Ice      Layers                      |
C |   ^^^^^^   istoSV   = 0,...,5 :   Snow     History (see istdSV data)   |
C |                                                                        |
C |   INPUT:   TsisSV   : Soil/Ice Temperatures (layers -nsol,-nsol+1,..,0)|
C |   ^^^^^             & Snow     Temperatures (layers  1,2,...,nsno) [K] |
C |            ro__SV   : Soil/Snow Volumic Mass                   [kg/m3] |
C |            eta_SV   : Soil/Snow Water   Content                [m3/m3] |
C |            slopSV   : Surface Slope                                [-] |
C |            dzsnSV   : Snow Layer        Thickness                  [m] |
C |            dt__SV   : Time  Step                                   [s] |
C |                                                                        |
C |   INPUT /  G1snSV   : Dendricity (<0) or Sphericity (>0) of Snow Layer |
C |   OUTPUT:  G2snSV   : Sphericity (>0) or Size            of Snow Layer |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   Formalisme adopte pour la Representation des Grains:                 |
C |   Formalism         for the Representation of  Grains:                 |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                 |
C |                                                                        |
C |             1       - -1                 Neige Fraiche                 |
C |            / \      |                    -------------                 |
C |           /   \     |  Dendricite        decrite  par Dendricite       |
C |          /     \    |  Dendricity                  et Sphericite       |
C |         /       \   |                                                  |
C |        2---------3  -  0                 described by Dendricity       |
C |                                                   and Sphericity       |
C |        |---------|                                                     |
C |        0         1                                                     |
C |        Sphericite                                                      |
C |        Sphericity                                                      |
C |                                                                        |
C |        4---------5  -                                                  |
C |        |         |  |                                                  |
C |        |         |  |  Diametre (1/10eme de mm) (ou Taille)            |
C |        |         |  |  Diameter (1/10th  of mm) (or Size  )            |
C |        |         |  |                                                  |
C |        |         |  |                    Neige non dendritique         |
C |        6---------7  -                    ---------------------         |
C |                                          decrite  par Sphericite       |
C |                                                    et     Taille       |
C |                                          described by Sphericity       |
C |                                                   and       Size       |
C |                                                                        |
C |   Les Variables du Modele:                                             |
C |   Model         Variables:                                             |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^                                             |
C |     Cas Dendritique               Cas non Dendritique                  |
C |                                                                        |
C |     G1snSV        : Dendricite    G1snSV        : Sphericite           |
C |     G2snSV        : Sphericite    G2snSV        : Taille (1/10e mm)    |
C |                                                   Size                 |
C |                                                                        |
C |   Cas Dendritique/ Dendritic Case                                      |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                      |
C |   Dendricite(Dendricity) G1snSV                                        |
C |            varie     de -G1_dSV (-99 par defaut / etoile)          a 0 |
C |            division par -G1_dSV pour obtenir des valeurs entre 1  et 0 |
C |            varies  from -G1_dSV (default -99    / fresh snow)     to 0 |
C |            division  by -G1_dSV to obtain values       between 1 and 0 |
C |                                                                        |
C |   Sphericite(Sphericity) G2snSV                                        |
C |            varie     de  0         (cas completement anguleux)         |
C |                       a  G1_dSV (99 par defaut, cas spherique)         |
C |            division par  G1_dSV pour obtenir des valeurs entre 0  et 1 |
C |            varies  from  0      (full faceted)               to G1_dSV |
C |                                                                        |
C |   Cas non Dendritique / non Dendritic Case                             |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                             |
C |   Sphericite(Sphericity) G1snSV                                        |
C |            varie     de  0         (cas completement anguleux)         |
C |                       a  G1_dSV (99 par defaut, cas spherique)         |
C |            division par  G1_dSV pour obtenir des valeurs entre 0  et 1 |
C |            varies  from  0      (full faceted)               to G1_dSV |
C |                                                                        |
C |   Taille    (Size)       G2snSV                                        |
C |            superieure a  ADSdSV (.4 mm) et ne fait que croitre         |
C |            greater than  ADSdSV (.4 mm) always increases               |
C |                                                                        |
C |   Exemples: Points caracteristiques des Figures ci-dessus              |
C |   ^^^^^^^^^                                                            |
C |                                                                        |
C |               G1snSV    G2snSV     dendricite  sphericite  taille      |
C |                                    dendricity  sphericity  size        |
C |   ------------------------------------------------------------------   |
C |                                                            [1/10 mm]   |
C |     1        -G1_dSV    sph3SN          1           0.5                |
C |     2           0         0             0           0                  |
C |     3           0       G1_dSV          0           1                  |
C |     4           0       ADSdSV                      0       4.         |
C |     5         G1_dSV    ADSdSV-vsphe1               1       3.         |
C |     6           0         --                        0       --         |
C |     7         G1_dSV      --                        1       --         |
C |                                                                        |
C |   par defaut: G1_dSV=99.                                               |
C |                         sph3SN=50.                                     |
C |                         ADSdSV= 4.                                     |
C |                                vsphe1=1.                               |
C |                                                                        |
C |   Methode:                                                             |
C |   ^^^^^^^^                                                             |
C |   1. Evolution Types de Grains selon Lois de Brun et al. (1992):       |
C |      Grain metamorphism according to         Brun et al. (1992):       |
C |      Plusieurs Cas sont a distiguer  /  the different Cases are:       |
C |       1.1 Metamorphose Neige humide  /  wet Snow                       |
C |       1.2 Metamorphose Neige seche   /  dry Snow                       |
C |         1.2.1 Gradient faible        /  low      Temperature Gradient  |
C |         1.2.2 Gradient moyen         /  moderate Temperature Gradient  |
C |         1.2.3 Gradient fort          /  high     Temperature Gradient  |
C |      Dans chaque Cas on separe Neige Dendritique et non Dendritique    |
C |                           le Passage Dendritique -> non Dendritique    |
C |                           se fait lorsque  G1snSV devient > 0          |
C |      the Case of Dentritic or non Dendritic Snow is treated separately |
C |      the Limit   Dentritic -> non Dendritic is reached when G1snSV > 0 |
C |                                                                        |
C |   2. Tassement: Loi de Viscosite adaptee selon le Type de Grains       |
C |      Snow Settling:    Viscosity depends on the   Grain Type           |
C |                                                                        |
C |   3. Update Variables historiques (cas non dendritique seulement)      |
C |      nhSNow defaut                                                     |
C |                0    Cas normal                                         |
C |      istdSV(1) 1    Grains anguleux / faceted cristal                  |
C |      istdSV(2) 2    Grains ayant ete en presence d eau liquide         |
C |                     mais n'ayant pas eu de caractere anguleux    /     |
C |                     liquid water and no faceted cristals before        |
C |      istdSV(3) 3    Grains ayant ete en presence d eau liquide         |
C |                     ayant eu auparavant un caractere anguleux    /     |
C |                     liquid water and    faceted cristals before        |
C |                                                                        |
C |   REFER. : Brun et al.      1989, J. Glaciol 35 pp. 333--342           |
C |   ^^^^^^^^ Brun et al.      1992, J. Glaciol 38 pp.  13-- 22           |
C |            (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |                                                                        |
C |   REFER. : Marbouty, D.     1980, J. Glaciol 26 pp. xxx--xxx           |
C |   ^^^^^^^^ (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |            (for angular shapes)                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # SISVAT_GSn.vp        | #vp: OUTPUT/Verification: Snow   Properties   |
C |                        |      unit 47, SubRoutines SISVAT_zSn, _GSn    |
C | # stdout               | #wp: OUTPUT/Verification: Snow   Properties   |
C |                        |      unit  6, SubRoutine  SISVAT_GSn          |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"


C +--INPUT/OUTPUT
C +  ------------

      include  "MARxSV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/)

C +--OUTPUT
C +  ------

      integer   k


C +--Local  Variables
C +  ================

      logical   vector                        !
      integer   ikl                           !
      integer   isn   ,isnp                   !
      integer   istoOK                        !
      real      G1_bak,G2_bak                 ! Old Values of G1, G2
      real      ro_dry(klonv,      nsno)      ! Dry Density            [g/cm3]
      real      etaSno(klonv,      nsno)      ! Liquid Water Content   [g/cm2]
      real      SnMass(klonv)                 ! Snow   Mass            [kg/m2]
      real      dTsndz                        ! Temperature Gradient
      real      sWater                        !        Water Content       [%]  
      real      exp1Wa                        !
      real      dDENDR                        ! Dendricity Increment
      real      DENDRn                        ! Normalized Dendricity
      real      SPHERn                        ! Normalized Sphericity
      real      Wet_OK                        ! Wet Metamorphism Switch
      real      OK__DE                        !
      real      OK__wd                        ! New G*, from wet Dendritic
      real      G1__wd                        ! New G1, from wet Dendritic
      real      G2__wd                        ! New G2, from wet Dendritic
      real      OKlowT                        !
      real      facVap                        !
      real      OK_ldd                        !
      real      G1_ldd                        !
      real      G2_ldd                        !
      real      DiamGx                        !
      real      DiamOK                        !
      real      No_Big                        !
      real      dSPHER                        !
      real      SPHER0                        !
      real      SPHbig                        !
      real      G1_lds                        !
      real      OK_mdT                        !
      real      OKmidT                        !
      real      OKhigT                        !
      real      OK_mdd                        !
      real      G1_mdd                        !
      real      G2_mdd                        !
      real      G1_mds                        !
      real      OK_hdd                        !
      real      G1_hdd                        !
      real      G2_hdd                        !
      real      OK_hds                        !
      real      G1_hds                        !
      real      T1__OK,T2__OK                 !
      real      T3_xOK,T3__OK,T3_nOK          !
      real      ro1_OK,ro2_OK                 !
      real      dT1_OK,dT2_OK,dT3xOK,dT3_OK   !
      real      dT4xOK,dT4_OK,dT4nOK,AngSno   !
      real      G2_hds,SphrOK,HISupd          !
      real      H1a_OK,H1b_OK,H1__OK          !
      real      H23aOK,H23bOK,H23_OK          !
      real      H2__OK,H3__OK                 !
      real      H45_OK,H4__OK,H5__OK          !
      real      ViscSn,OK_Liq,OK_Ang,OKxLiq   !
      real*8    dSnMas,dzsnew,rosnew,rosmax   !

      real      epsi5                         ! Alpha ev67 single precision	
      real      vdiam1                        ! Small Grains Min.Diam.[.0001m]
      real      vdiam2                        ! Spher.Variat.Max Diam.    [mm]
      real      vdiam3                        ! Min.Diam.|Limit Spher.    [mm]
      real      vdiam4                        ! Min.Diam.|Viscosity Change
      real      vsphe1                        ! Max Sphericity
      real      vsphe2                        ! Low T Metamorphism  Coeff.
      real      vsphe3                        ! Max.Sphericity (history=1)
      real      vsphe4                        ! Min.Sphericity=>history=1      
      real      vtang1,vtang2,vtang3,vtang4   ! Temperature Contribution
      real      vtang5,vtang6,vtang7,vtang8   !
      real      vtang9,vtanga,vtangb,vtangc   ! 
      real      vrang1,vrang2                 ! Density     Contribution
      real      vgang1,vgang2,vgang3,vgang4   ! Grad(T)     Contribution
      real      vgang5,vgang6,vgang7,vgang8   !
      real      vgang9,vganga,vgangb,vgangc   !
      real      vgran6                        ! Max.Sphericity for Settling
      real      vtelv1                        ! Threshold | history = 2, 3
      real       vvap1                        ! Vapor Pressure Coefficient
      real       vvap2                        ! Vapor Pressure Exponent
      real      vgrat1                        ! Boundary weak/mid   grad(T)
      real      vgrat2                        ! Boundary mid/strong grad(T)
      real         vfi                        ! PHI,         strong grad(T)
      real      vvisc1,vvisc2,vvisc3,vvisc4   ! Viscosity Coefficients
      real      vvisc5,vvisc6,vvisc7          ! id., wet Snow
      real      rovisc                        ! Wet Snow Density  Influence
      real        vdz3                        ! Maximum Layer Densification
      real      OK__ws                        ! New G2
      real      G1__ws                        ! New G1, from wet Spheric
      real      G2__ws                        ! New G2, from wet Spheric
      real      husi_0,husi_1,husi_2,husi_3   ! Constants for New G2
      real      vtail1,vtail2                 ! Constants for New G2
      real      frac_j                        ! Time Step            [Day]

      real       vdent1                       ! Wet Snow Metamorphism
      integer   nvdent1                       ! (Coefficients for
      integer   nvdent2                       !           Dendricity)

C +--Snow Properties: IO
C +  ~~~~~~~~~~~~~~~~~~~
! #vp real      G_curr(18),Gcases(18)
! #vp common   /GSnLOC/    Gcases
! #wp real                 D__MAX
! #wp common   /GSnMAX/    D__MAX


C +--DATA
C +  ====

      data       vector/.true./               ! Vectorization  Switch
      data       vdent1/ 0.5e8/               ! Wet Snow Metamorphism
cXF                      tuned for Greenland (2.e8=old value)
      data      nvdent1/ 3   /                ! (Coefficients for
      data      nvdent2/16   /                !           Dendricity)

      data       husi_0 /20.      /           !   10  * 2
      data       husi_1 / 0.23873 /           ! (3/4) /pi
      data       husi_2 / 4.18880 /           ! (4/3) *pi
      data       husi_3 / 0.33333 /           !  1/3
      data       vtail1 / 1.28e-08/           !  Wet Metamorphism
      data       vtail2 / 4.22e-10/           ! (NON Dendritic / Spheric)

      data       epsi5  / 1.0e-5  /           ! 

      data       vdiam1 / 4.0     /           ! Small Grains Min.Diameter

      data       vdiam2 / 0.5     /           ! Spher.Variat.Max Diam.[mm]
      data       vdiam3 / 3.0     /           ! Min.Diam.|Limit Spher.[mm]
      data       vdiam4 / 2.0     /           ! Min.Diam.|Viscosity Change

      data       vsphe1 / 1.0     /           ! Max Sphericity
      data       vsphe2 / 1.0e9   /           ! Low T Metamorphism  Coeff.
      data       vsphe3 / 0.5     /           ! Max.Sphericity (history=1)
      data       vsphe4 / 0.1     /           ! Min.Sphericity=>history=1      

      data       vgran6 / 51.     /           ! Max.Sphericity for Settling
      data       vtelv1 / 5.e-1   /           ! Threshold | history = 2, 3

      data        vvap1 /-6.e3    /           ! Vapor Pressure Coefficient
      data        vvap2 / 0.4     /           ! Vapor Pressure Exponent

      data       vgrat1 /0.05     /           ! Boundary weak/mid   grad(T)
      data       vgrat2 /0.15     /           ! Boundary mid/strong grad(T)
      data          vfi /0.09     /           ! PHI,         strong grad(T)

      data       vvisc1 / 0.70    /           ! Viscosity Coefficients
      data       vvisc2 / 1.11e5  /           !
      data       vvisc3 /23.00    /           !
      data       vvisc4 / 0.10    /           !
      data       vvisc5 / 1.00    /           ! id., wet Snow
      data       vvisc6 / 2.00    /           !
      data       vvisc7 /10.00    /           !
      data       rovisc / 0.25    /           ! Wet Snow Density  Influence
      data         vdz3 / 0.30    /           ! Maximum Layer Densification


C +--DATA (Coefficient Fonction fort Gradient Marbouty)
C +  --------------------------------------------------

      data       vtang1 /40.0/                ! Temperature Contribution
      data       vtang2 / 6.0/                !
      data       vtang3 /22.0/                !
      data       vtang4 / 0.7/                !
      data       vtang5 / 0.3/                !
      data       vtang6 / 6.0/                !
      data       vtang7 / 1.0/                !
      data       vtang8 / 0.8/                !
      data       vtang9 /16.0/                !
      data       vtanga / 0.2/                !
      data       vtangb / 0.2/                !
      data       vtangc /18.0/                !

      data       vrang1 / 0.40/               ! Density     Contribution
      data       vrang2 / 0.15/               !

      data       vgang1 / 0.70/               ! Grad(T)     Contribution
      data       vgang2 / 0.25/               !
      data       vgang3 / 0.40/               !
      data       vgang4 / 0.50/               !
      data       vgang5 / 0.10/               !
      data       vgang6 / 0.15/               !
      data       vgang7 / 0.10/               !
      data       vgang8 / 0.55/               !
      data       vgang9 / 0.65/               !
      data       vganga / 0.20/               !
      data       vgangb / 0.85/               !
      data       vgangc / 0.15/               !

! #wp data       D__MAX / 4.00/               !


C +-- 1. Metamorphoses dans les Strates
C +      Metamorphism
C +      ==============================

      frac_j = dt__SV / 86400.                        ! Time Step [Day]


C +-- 1.1 Initialisation: teneur en eau liquide et gradient de temperature 
C +   ------------------  liquid water content and temperature gradient

       DO ikl=1,klonv
        DO   isn=1,isnoSV(ikl)

          ro_dry(ikl,isn) = 1.e-3 *ro__SV(ikl,isn)    ! Dry Density
     .                    *(1.    -eta_SV(ikl,isn))   !         [g/cm3]
          etaSno(ikl,isn) = 1.e-1 *dzsnSV(ikl,isn)    ! Liquid Water
     .                    *        ro__SV(ikl,isn)    ! Content [g/cm2]
     .                    *        eta_SV(ikl,isn)    !
        END DO
      END DO

c!$OMP PARALLEL DO default(firstprivate)
c!$OMP.shared (/xSISVAT_I/,/xSISVAT_R/,/SoR0SV/,/SoI0SV/,/Sn_dSV/)
       DO ikl=1,klonv
        DO   isn=1,isnoSV(ikl)
          isnp   = min(isn+1,isnoSV(ikl))

          dTsndz = abs( (TsisSV(ikl,isnp)-TsisSV(ikl,isn-1)) *2.e-2
     .            /max(((dzsnSV(ikl,isnp)+dzsnSV(ikl,isn)  )
     .                 *(           isnp -           isn)
     .                 +(dzsnSV(ikl,isn )+dzsnSV(ikl,isn-1))),epsi))
C +...    Factor 1.d-2 for Conversion K/m --> K/cm


C +-- 1.2 Metamorphose humide 
C +       Wet Snow Metamorphism
C +       ---------------------

          Wet_OK = max(zero,sign(unun,eta_SV(ikl,isn)-epsi))


C +--     Vitesse de diminution de la dendricite
C +       Rate of the dendricity decrease
C +       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          sWater=1.d-1*ro__SV(ikl,isn)*eta_SV(ikl,isn)
     .       /max(epsi,ro_dry(ikl,isn))
C +...    sWater:Water Content [%]  
C +              1.d-1= 1.d2(1->%) * 1.d-3(ro__SV*eta_SV:kg/m3->g/cm3) 

          exp1Wa=   sWater**nvdent1
          dDENDR=max(exp1Wa/nvdent2,vdent1*exp(vvap1/TfSnow))

C +-- 1.2.1 Cas dendritique/dendritic Case
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          OK__wd=max(zero,                            !
     .               sign(unun,-G1snSV(ikl,isn)       !
     .                         -epsi           ))     !

          DENDRn=-G1snSV(ikl,isn)/G1_dSV  ! Normalized Dendricity (+)
          SPHERn= G2snSV(ikl,isn)/G1_dSV  ! Normalized Sphericity
          DENDRn= DENDRn -dDENDR *frac_j  ! New        Dendricity (+)
          SPHERn= SPHERn +dDENDR *frac_j  ! New        Sphericity

          OK__DE=max(zero,                            ! IF 1., 
     .               sign(unun, DENDRn                ! NO change
     .                         -epsi           ))     ! Dendr. -> Spheric

          G1__wd=OK__DE *    (      -DENDRn*G1_dSV)   ! Dendritic
     .      +(1.-OK__DE)* min(G1_dSV,SPHERn*G1_dSV)   ! Dendr. -> Spheric
          G2__wd=OK__DE * min(G1_dSV,SPHERn*G1_dSV)   ! Spheric
     .      +(1.-OK__DE)*(ADSdSV-min(SPHERn,vsphe1))  ! Spher. -> Size

C +-- 1.2.2 Cas non dendritique non completement spherique
C +         Evolution de la Sphericite seulement.
C +         Non dendritic and not completely spheric Case
C +         Evolution of    Sphericity only (not size)
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          OK__ws=max(zero,                            !
     .               sign(unun, G1_dSV                !
     .                         -epsi5                 !
     .                         -G1snSV(ikl,isn)))     !

          SPHERn= G1snSV(ikl,isn)/G1_dSV
          SPHERn= SPHERn +dDENDR *frac_j
          G1__ws=         min(G1_dSV,SPHERn*G1_dSV)

C +-- 1.2.3 Cas non dendritique et spherique / non dendritic and spheric
C +         Evolution de la Taille seulement / Evolution of Size only
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          G2__ws =  husi_0
     .           *( husi_1
     .            *(husi_2 *( G2snSV(ikl,isn)/husi_0)**3
     .                      +(vtail1 +vtail2 *exp1Wa    )*dt__SV))
     .           ** husi_3


C +-- 1.3 Metamorposes seches / Dry Metamorphism
C +       --------------------------------------


C +-- 1.3.1 Calcul Metamorphose faible/low Gradient (0.00-0.05 deg/cm)
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          OKlowT=max(zero,                            !
     .               sign(unun, vgrat1                !
     .                         -dTsndz         ))     !

          facVap=exp(vvap1/TsisSV(ikl,isn))

C +-- 1.3.1.1 Cas dendritique / dendritic Case

          OK_ldd=max(zero,                            !
     .               sign(unun,-G1snSV(ikl,isn)       !
     .                         -epsi           ))     !

          DENDRn=-G1snSV(ikl,isn)     /G1_dSV
          SPHERn= G2snSV(ikl,isn)     /G1_dSV
          DENDRn= DENDRn-vdent1*facVap*frac_j
          SPHERn= SPHERn+vsphe2*facVap*frac_j

          OK__DE=max(zero,                            ! IF 1., 
     .               sign(unun, DENDRn                ! NO change
     .                         -epsi           ))     ! Dendr. -> Spheric

          G1_ldd= OK__DE *    (      -DENDRn*G1_dSV)  ! Dendritic
     .       +(1.-OK__DE)* min(G1_dSV,SPHERn*G1_dSV)  ! Dendr. -> Spheric
          G2_ldd= OK__DE * min(G1_dSV,SPHERn*G1_dSV)  ! Spheric
     .       +(1.-OK__DE)*(ADSdSV-min(SPHERn,vsphe1)) ! Spher. -> Size 

C +-- 1.3.1.2 Cas non dendritique / non dendritic Case

          SPHERn=G1snSV(ikl,isn)/G1_dSV
          DiamGx=G2snSV(ikl,isn)*0.1

          istoOK=min( abs(istoSV(ikl,isn)-
     .                    istdSV(1)      ),1)         ! zero if istoSV = 1
          DiamOK=max(zero,  sign(unun,vdiam2-DiamGx))
          No_Big=    istoOK+DiamOK
          No_Big=min(No_Big,unun)

          dSPHER=           vsphe2*facVap*frac_j      !
          SPHER0=    SPHERn+dSPHER                    ! small grains
          SPHbig=    SPHERn+dSPHER                    ! big   grains
     .        *exp(min(zero,vdiam3-G2snSV(ikl,isn)))  ! (history = 2 or 3)
          SPHbig=       min(vsphe3,SPHbig)            ! limited sphericity
          SPHERn= No_Big *  SPHER0
     .      + (1.-No_Big)*  SPHbig

          G1_lds=       min(G1_dSV,SPHERn*G1_dSV)

C +-- 1.3.2 Calcul Metamorphose Gradient Moyen/Moderate (0.05-0.15)
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          OK_mdT=max(zero,                            !
     .               sign(unun, vgrat2                !
     .                         -dTsndz))              !
          OKmidT=               OK_mdT  *(1.-OKlowT)  !
          OKhigT=          (1. -OK_mdT) *(1.-OKlowT)  !

          facVap=vdent1*exp(vvap1/TsisSV(ikl,isn))
     .                 *   (1.e2 *dTsndz)**vvap2

C +-- 1.3.2.1 cas dendritique / dendritic case.

          OK_mdd=max(zero,                            !
     .               sign(unun,-G1snSV(ikl,isn)       !
     .                         -epsi           ))     !

          DENDRn=-G1snSV(ikl,isn)/G1_dSV
          SPHERn= G2snSV(ikl,isn)/G1_dSV
          DENDRn= DENDRn - facVap*frac_j
          SPHERn= SPHERn - facVap*frac_j

          OK__DE=max(zero,                            ! IF 1., 
     .               sign(unun, DENDRn                ! NO change
     .                         -epsi           ))     ! Dendr. -> Spheric

          G1_mdd= OK__DE *    (      -DENDRn*G1_dSV)  ! Dendritic
     .       +(1.-OK__DE)* max(zero  ,SPHERn*G1_dSV)  ! Dendr. -> Spheric
          G2_mdd= OK__DE * max(zero  ,SPHERn*G1_dSV)  ! Spheric
     .       +(1.-OK__DE)*(ADSdSV-max(SPHERn,zero  )) ! Spher. -> Size 

C +-- 1.3.2.2 Cas non dendritique / non dendritic Case

          SPHERn=G1snSV(ikl,isn)/G1_dSV
          SPHERn=         SPHERn-facVap*frac_j
          G1_mds=max(zero,SPHERn*G1_dSV)

C +-- 1.3.3 Calcul Metamorphose fort / high Gradient
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          facVap=vdent1*exp(vvap1/TsisSV(ikl,isn))
     .                 *   (1.e2 *dTsndz)**vvap2

C +-- 1.3.3.1 Cas dendritique / dendritic Case

          OK_hdd=max(zero,                            !
     .               sign(unun,-G1snSV(ikl,isn)       !
     .                         -epsi           ))     !

          DENDRn=-G1snSV(ikl,isn)/G1_dSV              !
          SPHERn= G2snSV(ikl,isn)/G1_dSV              !
          DENDRn= DENDRn - facVap*frac_j              !
          SPHERn= SPHERn - facVap*frac_j              ! Non dendritic
C +                                                   ! and angular
          OK__DE=max(zero,                            ! IF 1., 
     .               sign(unun, DENDRn                ! NO change
     .                         -epsi  ))              ! Dendr. -> Spheric

          G1_hdd= OK__DE *    (      -DENDRn*G1_dSV)  ! Dendritic
     .       +(1.-OK__DE)* max(zero  ,SPHERn*G1_dSV)  ! Dendr. -> Spheric
          G2_hdd= OK__DE * max(zero  ,SPHERn*G1_dSV)  ! Spheric
     .       +(1.-OK__DE)*(ADSdSV-max(SPHERn,zero  )) ! Spher. -> Size 

C +-- 1.3.3.2 Cas non dendritique non completement anguleux.
C +           non dendritic and spericity gt. 0

          OK_hds=max(zero,                            !
     .               sign(unun, G1snSV(ikl,isn)       !
     .                         -epsi           ))     !

          SPHERn= G1snSV(ikl,isn)/G1_dSV
          SPHERn= SPHERn - facVap*frac_j
          G1_hds= max(zero,SPHERn*G1_dSV)

C +-- 1.3.3.3 Cas non dendritique et anguleux
C +           dendritic and spericity = 0.

          T1__OK = max(zero,sign(unun,TsisSV(ikl,isn)-TfSnow+vtang1))
          T2__OK = max(zero,sign(unun,TsisSV(ikl,isn)-TfSnow+vtang2))
          T3_xOK = max(zero,sign(unun,TsisSV(ikl,isn)-TfSnow+vtang3))
          T3__OK =                    T3_xOK  * (1. - T2__OK)
          T3_nOK =              (1. - T3_xOK) * (1. - T2__OK)
          ro1_OK = max(zero,sign(unun,vrang1-ro_dry(ikl,isn)))
          ro2_OK = max(zero,sign(unun,ro_dry(ikl,isn)-vrang2))
          dT1_OK = max(zero,sign(unun,vgang1-dTsndz         ))
          dT2_OK = max(zero,sign(unun,vgang2-dTsndz         ))
          dT3xOK = max(zero,sign(unun,vgang3-dTsndz         ))
          dT3_OK =                    dT3xOK  * (1. - dT2_OK)
          dT4xOK = max(zero,sign(unun,vgang4-dTsndz         ))
          dT4_OK =                    dT4xOK  * (1. - dT3_OK)
     .                                        * (1. - dT2_OK)
          dT4nOK =              (1. - dT4xOK) * (1. - dT3_OK)
     .                                        * (1. - dT2_OK)

C +-- Influence de la Temperature /Temperature Influence
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          AngSno = 
     .      T1__OK                                                       ! 11
     .    *(T2__OK*(vtang4+vtang5*(TfSnow       -TsisSV(ikl,isn))        ! 12
     .                    /vtang6)                                       !
     .     +T3__OK*(vtang7-vtang8*(TfSnow-vtang2-TsisSV(ikl,isn))        ! 13
     .                    /vtang9)                                       !
     .     +T3_nOK*(vtanga-vtangb*(TfSnow-vtang3-TsisSV(ikl,isn))        ! 14
     .                    /vtangc))                                      !

C +-- Influence de la Masse Volumique /Density Influence
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     .    * ro1_OK
     .        *(   ro2_OK*(1. - (ro_dry(ikl,isn)-vrang2)                 !   
     .                                  /(vrang1-vrang2))                !
     .         +1.-ro2_OK                                )               !   

C +-- Influence du Gradient de Temperature /Temperature Gradient Influence
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     .        *(   dT1_OK*(dT2_OK*vgang5*(dTsndz-vgang6)                 ! 15
     .                                  /(vgang2-vgang6)                 !
     .                    +dT3_OK*vgang7                                 ! 16
     .                    +dT4_OK*vgang9                                 ! 17
     .                    +dT4nOK*vgangb                )                ! 18
     .         +1.-dT1_OK                                )               !
     .    + ro1_OK
     .        *    dT1_OK*(dT3_OK*vgang8*(dTsndz-vgang2)
     .                                  /(vgang3-vgang2)
     .                    +dT4_OK*vganga*(dTsndz-vgang3)
     .                                  /(vgang4-vgang3)
     .                    +dT4nOK*vgangc*(dTsndz-vgang4)
     .                                  /(vgang1-vgang4))

          G2_hds = G2snSV(ikl,isn) + 1.d2 *AngSno*vfi     *frac_j


C +--New Properties
C +  --------------

          G1_bak          = G1snSV(ikl,isn)
          G2_bak          = G2snSV(ikl,isn)

          G1snSV(ikl,isn) = Wet_OK * (    OK__wd             *G1__wd    !  1
     .                               +(1.-OK__wd)*    OK__ws *G1__ws    !  2
     .                               +(1.-OK__wd)*(1.-OK__ws)*G1_bak)   !  3
     .               +(1. - Wet_OK)                                     !
     .                *(    OKlowT  *(    OK_ldd             *G1_ldd    !  4
     .                               +(1.-OK_ldd)            *G1_lds)   !  5
     .                    + OKmidT  *(    OK_mdd             *G1_mdd    !  6
     .                               +(1.-OK_mdd)            *G1_mds)   !  7
     .                    + OKhigT  *(    OK_hdd             *G1_hdd    !  8
     .                               +(1.-OK_hdd)*    OK_hds *G1_hds    !  9
     .                               +(1.-OK_hdd)*(1.-OK_hds)*G1_bak))  ! 10

cXF
      if(G1snSV(ikl,isn)<0.1)
     .    G2_hds = G2snSV(ikl,isn) + 1.d1 *AngSno*vfi     *frac_j
cXF


          G2snSV(ikl,isn) = Wet_OK * (    OK__wd             *G2__wd    !  1
     .                               +(1.-OK__wd)*    OK__ws *G2_bak    !  2
     .                               +(1.-OK__wd)*(1.-OK__ws)*G2__ws)   !  3
     .               +(1. - Wet_OK)                                     !
     .                *(    OKlowT  *(    OK_ldd             *G2_ldd    !  4
     .                               +(1.-OK_ldd)            *G2_bak)   !  5
     .                    + OKmidT  *(    OK_mdd             *G2_mdd    !  6
     .                               +(1.-OK_mdd)            *G2_bak)   !  7
     .                    + OKhigT  *(    OK_hdd             *G2_hdd    !  8
     .                               +(1.-OK_hdd)*    OK_hds *G2_bak    !  9
     .                               +(1.-OK_hdd)*(1.-OK_hds)*G2_hds))  ! 10

C +--Snow Properties: IO Set Up
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~
! #vp     G_curr( 1) =     Wet_OK             *    OK__wd             
! #vp     G_curr( 2) =     Wet_OK             *(1.-OK__wd)*    OK__ws 
! #vp     G_curr( 3) =     Wet_OK             *(1.-OK__wd)*(1.-OK__ws)
! #vp     G_curr( 4) = (1.-Wet_OK)*    OKlowT *    OK_ldd             
! #vp     G_curr( 5) = (1.-Wet_OK)*    OKlowT *(1.-OK_ldd)            
! #vp     G_curr( 6) = (1.-Wet_OK)*    OKmidT *    OK_mdd             
! #vp     G_curr( 7) = (1.-Wet_OK)*    OKmidT *(1.-OK_mdd)            
! #vp     G_curr( 8) = (1.-Wet_OK)*    OKhigT *    OK_hdd             
! #vp     G_curr( 9) = (1.-Wet_OK)*    OKhigT *(1.-OK_hdd)*    OK_hds 
! #vp     G_curr(10) = (1.-Wet_OK)*    OKhigT *(1.-OK_hdd)*(1.-OK_hds)
! #vp     G_curr(11) =     T1__OK                         * G_curr(10)
! #vp     G_curr(12) =     T2__OK                         * G_curr(10)
! #vp     G_curr(13) =     T3__OK                         * G_curr(10)
! #vp     G_curr(14) =     T3_nOK                         * G_curr(10)
! #vp     G_curr(15) =     ro1_OK*     dT1_OK *    dT2_OK * G_curr(10)
! #vp     G_curr(16) =     ro1_OK*     dT1_OK *    dT3_OK * G_curr(10)
! #vp     G_curr(17) =     ro1_OK*     dT1_OK *    dT4_OK * G_curr(10)
! #vp     G_curr(18) =     ro1_OK*     dT1_OK *    dT4nOK * G_curr(10)

! #vp     Gcases( 1) = max(Gcases( 1),G_curr( 1))
! #vp     Gcases( 2) = max(Gcases( 2),G_curr( 2))
! #vp     Gcases( 3) = max(Gcases( 3),G_curr( 3))
! #vp     Gcases( 4) = max(Gcases( 4),G_curr( 4))
! #vp     Gcases( 5) = max(Gcases( 5),G_curr( 5))
! #vp     Gcases( 6) = max(Gcases( 6),G_curr( 6))
! #vp     Gcases( 7) = max(Gcases( 7),G_curr( 7))
! #vp     Gcases( 8) = max(Gcases( 8),G_curr( 8))
! #vp     Gcases( 9) = max(Gcases( 9),G_curr( 9))
! #vp     Gcases(10) = max(Gcases(10),G_curr(10))
! #vp     Gcases(11) = max(Gcases(11),G_curr(11))
! #vp     Gcases(12) = max(Gcases(12),G_curr(12))
! #vp     Gcases(13) = max(Gcases(13),G_curr(13))
! #vp     Gcases(14) = max(Gcases(14),G_curr(14))
! #vp     Gcases(15) = max(Gcases(15),G_curr(15))
! #vp     Gcases(16) = max(Gcases(16),G_curr(16))
! #vp     Gcases(17) = max(Gcases(17),G_curr(17))
! #vp     Gcases(18) = max(Gcases(18),G_curr(18))

C +--Snow Properties: IO
C +  ~~~~~~~~~~~~~~~~~~~
! #vp     IF          (isn    .le.     isnoSV(ikl))
! #vp.    write(47,471)isn            ,isnoSV(ikl)                    ,
! #vp.                 TsisSV(ikl,isn),ro__SV(ikl,isn),eta_SV(ikl,isn),
! #vp.                 G1_bak         ,G2_bak         ,istoSV(ikl,isn),
! #vp.                 dTsndz,
! #vp.                (       k ,k=1,18),
! #vp.                (G_curr(k),k=1,18),
! #vp.                (Gcases(k),k=1,18),
! #vp.                 Wet_OK,OK__wd,G1__wd,G2__wd,
! #vp.                     1.-OK__wd,OK__ws,G1__ws,1.-OK__ws,G2__ws,
! #vp.              1.-Wet_OK,OKlowT,OK_ldd,G1_ldd,          G2_ldd,
! #vp.                            1.-OK_ldd,G1_lds,
! #vp.                        OKmidT,OK_mdd,G1_mdd,          G1_mdd,
! #vp.                            1.-OK_mdd,G1_mds,
! #vp.                        OKhigT,OK_hdd,G1_hdd,          G2_hdd,
! #vp.                            1.-OK_hdd,OK_hds,          G1_hds,
! #vp.                                             1.-OK_hds,G2_hds,
! #vp.                 G1snSV(ikl,isn),
! #vp.                 G2snSV(ikl,isn)
 471      format(
     .         /,' isn     =  ',i4,6x,'(MAX.:',i4,')',  
     .         /,' T       =  ',f8.3,
     .         /,' ro      =  ',f8.3,
     .         /,' eta     =  ',f8.3,
     .         /,' G1      =  ',f8.3,
     .         /,' G2      =  ',f8.3,
     .         /,' Histor. =  ',i4  ,
     .         /,' Grad(T) =  ',f8.3,'                   ' ,18i3  ,
     ./,         '                       Current    Case: ',18f3.0,
     ./,         '                       Cases performed: ',18f3.0,
     ./,' ------------------------------------------------------------',
     .             '-----------+------------------+------------------+',
     ./,' Status                                                      ',
     .             '           | G1               | G2               |',
     ./,' ------------------------------------------------------------',
     .             '-----------+------------------+------------------+',
     ./,'    Wet_OK: ',f8.3,'                  OK__wd: ',f8.3,'       ',
     .             '           | G1__wd: ',f8.3,' | G2__wd: ',f8.5,' |',
     ./,'                                   1.-OK__wd: ',f8.3,' OK__ws',
     .             ': ',f8.3,' | G1__ws: ',f8.3,' |                  |',
     ./,'                                                    1.-OK__ws',
     .             ': ',f8.3,' |                  | G2__ws: ',f8.5,' |',
     ./,' 1.-Wet_OK: ',f8.3,' OKlowT: ',f8.3,' OK_ldd: ',f8.3,'       ',
     .             '           | G1_ldd: ',f8.3,' | G2_ldd: ',f8.5,' |',
     ./,'                                   1.-OK_ldd: ',f8.3,'       ',
     .             '           | G1_lds: ',f8.3,' |                  |',
     ./,'                     OKmidT: ',f8.3,' OK_mdd: ',f8.3,'       ',
     .             '           | G1_mdd: ',f8.3,' | G2_mdd: ',f8.5,' |',
     ./,'                                   1.-OK_mdd: ',f8.3,'       ',
     .             '           | G1_mds: ',f8.3,' |                  |',
     ./,'                     OKhigT: ',f8.3,' OK_hdd: ',f8.3,'       ',
     .             '           | G1_hdd: ',f8.3,' | G2_hdd: ',f8.5,' |',
     ./,'                                   1.-OK_hdd: ',f8.3,' OK_hds',
     .             ': ',f8.3,' | G1_hds: ',f8.3,' |                  |',
     ./,'                                                    1.-OK_hds',
     .             ': ',f8.3,' |                  | G2_hds: ',f8.5,' |',
     ./,' ------------------------------------------------------------',
     .             '-----------+------------------+------------------+',
     ./,'                                                             ',
     .             '           |         ',f8.3,' |         ',f8.5,' |',
     ./,' ------------------------------------------------------------',
     .             '-----------+------------------+------------------+')
        END DO
      END DO
c!$OMP END PARALLEL DO

C +-- 2. Mise a Jour Variables Historiques (Cas non dendritique)
C +      Update of the historical Variables
C +      =======================================================

      IF (vector)                                                   THEN
cXF
         DO  ikl=1,klonv
          DO isn=1,isnoSV(ikl)
          SphrOK = max(zero,sign(unun,       G1snSV(ikl,isn)))
          H1a_OK = max(zero,sign(unun,vsphe4-G1snSV(ikl,isn)))
          H1b_OK =     1   - min(1   ,       istoSV(ikl,isn))
          H1__OK =                    H1a_OK*H1b_OK
          H23aOK = max(zero,sign(unun,vsphe4-G1_dSV
     .                                      +G1snSV(ikl,isn)))
          H23bOK = max(zero,sign(unun,etaSno(ikl,isn)
     .                      /max(epsi,dzsnSV(ikl,isn))
     .                                      -vtelv1         ))
          H23_OK =                    H23aOK*H23bOK
          H2__OK =     1   - min(1   ,       istoSV(ikl,isn))
          H3__OK =     1   - min(1   ,   abs(istoSV(ikl,isn)-istdSV(1)))
          H45_OK = max(zero,sign(unun,TfSnow-TsisSV(ikl,isn)+epsi))
          H4__OK =     1   - min(1   ,   abs(istoSV(ikl,isn)-istdSV(2)))
          H5__OK =     1   - min(1   ,   abs(istoSV(ikl,isn)-istdSV(3)))

          HISupd          =
     .    SphrOK*(H1__OK                             *istdSV(1)
     .       +(1.-H1__OK)*    H23_OK         *(H2__OK*istdSV(2)
     .                                        +H3__OK*istdSV(3))
     .       +(1.-H1__OK)*(1.-H23_OK) *H45_OK*(H4__OK*istdSV(4)
     .                                        +H5__OK*istdSV(5)))
          istoSV(ikl,isn) =   HISupd  +
     .           (1.-min(unun,HISupd))               *istoSV(ikl,isn)
        END DO
        END DO
      ELSE 


C +-- 2. Mise a Jour Variables Historiques (Cas non dendritique)
C +      Update of the historical Variables
C +      =======================================================

        DO ikl=1,klonv
        DO isn=iiceSV(ikl),isnoSV(ikl)
          IF  (G1snSV(ikl,isn).ge.0.)                               THEN
            IF(G1snSV(ikl,isn).lt.vsphe4.and.istoSV(ikl,isn).eq.0)  THEN
                   istoSV(ikl,isn)=istdSV(1)
            ELSEIF(G1_dSV-G1snSV(ikl,isn)         .lt.vsphe4.and.
     .             etaSno(ikl,isn)/dzsnSV(ikl,isn).gt.vtelv1)       THEN
              IF  (istoSV(ikl,isn).eq.0)
     .             istoSV(ikl,isn)=   istdSV(2)
              IF  (istoSV(ikl,isn).eq.istdSV(1))  
     .             istoSV(ikl,isn)=   istdSV(3)
            ELSEIF(TsisSV(ikl,isn).lt.TfSnow)                       THEN
              IF  (istoSV(ikl,isn).eq.istdSV(2))  
     .             istoSV(ikl,isn)=   istdSV(4)
              IF  (istoSV(ikl,isn).eq.istdSV(3))  
     .             istoSV(ikl,isn)=   istdSV(5)
            END IF
          END IF
        END DO
        END DO
      END IF


C +-- 3. Tassement mecanique /mechanical Settlement
C +      ==========================================

        DO ikl=1,klonv
          SnMass(ikl) = 0.
        END DO
cXF
      DO ikl=1,klonv
        DO   isn=isnoSV(ikl),1,-1
          dSnMas     = 100.*dzsnSV(ikl,isn)*ro_dry(ikl,isn)
          SnMass(ikl)=      SnMass(ikl)+0.5*dSnMas
          ViscSn     =      vvisc1         *vvisc2
     .               *exp(vvisc3           *ro_dry(ikl,isn)
     .                   +vvisc4*abs(TfSnow-TsisSV(ikl,isn)))
     .                                     *ro_dry(ikl,isn)/rovisc

C +-- Changement de Viscosite si Teneur en Eau liquide
C +   Change of the Viscosity if liquid Water Content
C +   ------------------------------------------------

          OK_Liq     =    max(zero,sign(unun,etaSno(ikl,isn)-epsi))
          OK_Ang     =    max(zero,sign(unun,vgran6-G1snSV(ikl,isn)))
     .                *(1-min(1   , abs(istoSV(ikl,isn)-istdSV(1))))
! #wp     IF (G1snSV(ikl,isn).gt.0..AND.G1snSV(ikl,isn).lt.vsphe4
! #wp.                             .AND.istoSV(ikl,isn).eq.     0)
! #wp.    THEN
! #wp       write(6,*) ikl,isn,' G1,G2,hist,OK_Ang  ',
! #wp.          G1snSV(ikl,isn), G2snSV(ikl,isn),istoSV(ikl,isn),OK_Ang
! #wp       stop "Grains anguleux mal d?finis"
! #wp     END IF
          OKxLiq     =    max(zero,sign(unun,vtelv1-etaSno(ikl,isn)
     .                                    /max(epsi,dzsnSV(ikl,isn))))
     .               *    max(0   ,sign(1   ,istoSV(ikl,isn)
     .                                      -istdSV(1)      ))
          ViscSn     =  
     .    ViscSn*(    OK_Liq/(vvisc5+vvisc6*etaSno(ikl,isn)
     .                            /max(epsi,dzsnSV(ikl,isn)))
     .           +(1.-OK_Liq)                               )
     .          *(    OK_Ang*exp(min(ADSdSV,G2snSV(ikl,isn)-vdiam4))
     .           +(1.-OK_Ang)                                       )
     .          *(    OKxLiq*        vvisc7
     .           +(1.-OKxLiq)              )


C +-- Calcul nouvelle Epaisseur / new Thickness
C +   -----------------------------------------

          dzsnew         =
     .    dzsnSV(ikl,isn) 
     .     *max(vdz3,
     .         (unun-dt__SV*max(SnMass(ikl)*cos(slopSV(ikl)),unun)
     .                     /max(ViscSn                      ,epsi)))
          rosnew         = dble(ro__SV(ikl,isn)) *dble(dzsnSV(ikl,isn))
     .                            /max(0.000001d0,dzsnew)
          rosmax         = 1.d0   /( (1.d0 -eta_SV(ikl,isn)) /ro_Ice
     .                               +      eta_SV(ikl,isn)  /ro_Wat)
          rosnew         =                        min(rosnew ,rosmax)
          dzsnew         = dble(dzsnSV(ikl,isn)) *dble(ro__SV(ikl,isn))
     .                            /max(0.000001d0,rosnew)
          ro__SV(ikl,isn)= rosnew
          dzsnSV(ikl,isn)= dzsnew
          ro_dry(ikl,isn)= ro__SV(ikl,isn)*(1.-eta_SV(ikl,isn))*1.e-3
C +...    ro_dry: Dry Density (g/cm3)
C +
          SnMass(ikl)    = SnMass(ikl)+dSnMas*0.5
        END DO
      END DO


! OUTPUT/Verification (stdout)
! ============================

! #wp DO ikl = 1,klonv
! #wp DO isn = 1,isnoSV(ikl)
! #wp   IF (G1snSV(ikl,isn).gt.0. .AND. G2snSV(ikl,isn).gt.D__MAX) THEN
! #wp     write(6,6600) G1snSV(ikl,isn),G2snSV(ikl,isn),ikl,isn
 6600     format(/,'WARNING in _GSn: G1,G2 =',2f9.3,'  (ikl,isn) =',2i4)
! #wp     D__MAX =                      G2snSV(ikl,isn)
! #wp   END IF
! #wp   IF (                            G2snSV(ikl,isn).lt.0.    ) THEN
! #wp     write(6,6601) G1snSV(ikl,isn),G2snSV(ikl,isn),ikl,isn
 6601     format(/,'ERROR 1 in _GSn: G1,G2 =',2f9.3,'  (ikl,isn) =',2i4)
! #wp     STOP
! #wp   END IF
! #wp   IF (G1snSV(ikl,isn).gt.G1_dSV+epsi                       ) THEN
! #wp     write(6,6602) G1snSV(ikl,isn),G2snSV(ikl,isn),ikl,isn
 6602     format(/,'ERROR 2 in _GSn: G1,G2 =',2f9.3,'  (ikl,isn) =',2i4)
! #wp     STOP
! #wp   END IF
! #wp   IF (G1snSV(ikl,isn).lt.0.                           .AND.
! #wp.      G2snSV(ikl,isn).gt.G1_dSV+epsi                       ) THEN
! #wp     write(6,6603) G1snSV(ikl,isn),G2snSV(ikl,isn),ikl,isn
 6603     format(/,'ERROR 3 in _GSn: G1,G2 =',2f9.3,'  (ikl,isn) =',2i4)
! #wp     STOP
! #wp   END IF
! #wp END DO
! #wp END DO

      return
      end


      subroutine SISVAT_qSo
! #m0.                     (Wats_0,Wats_1,Wats_d)

C +------------------------------------------------------------------------+
C | MAR          SISVAT_qSo                                 6-04-2001  MAR |
C |   SubRoutine SISVAT_qSo computes the Soil      Water  Balance          |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   PARAMETERS:  klonv: Total Number of columns =                        |
C |   ^^^^^^^^^^        = Total Number of continental     grid boxes       |
C |                     X       Number of Mosaic Cell per grid box         |
C |                                                                        |
C |   INPUT:   isnoSV   = total Nb of Ice/Snow Layers                      |
C |   ^^^^^    isotSV   = 0,...,11:   Soil       Type                      |
C |                       0:          Water, Solid or Liquid               |
C |                                                                        |
C |   INPUT:   rhT_SV   : SBL Top    Air  Density                  [kg/m3] |
C |   ^^^^^    drr_SV   : Rain   Intensity                       [kg/m2/s] |
C |            LSdzsv   : Vertical   Discretization Factor             [-] |
C |                     =    1. Soil                                       |
C |                     = 1000. Ocean                                      |
C |            dt__SV   : Time   Step                                  [s] |
C |                                                                        |
C |            Lx_H2O   : Latent Heat of Vaporization/Sublimation   [J/kg] |
C |            HLs_sv   : Latent Heat  Flux                         [W/m2] |
C |            Rootsv   : Root   Water Pump                      [kg/m2/s] |
C |                                                                        |
C |   INPUT /  eta_SV   : Water      Content                       [m3/m3] |
C |   OUTPUT:  Khydsv   : Soil   Hydraulic    Conductivity           [m/s] |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   OUTPUT:  RnofSV   : RunOFF Intensity                       [kg/m2/s] |
C |   ^^^^^^   Wats_0   : Soil Water,  before Forcing                 [mm] |
C |            Wats_1   : Soil Water,  after  Forcing                 [mm] |
C |            Wats_d   : Soil Water          Forcing                 [mm] |
C |                                                                        |
C |   Internal Variables:                                                  |
C |   ^^^^^^^^^^^^^^^^^^                                                   |
C |            z_Bump   : (Partly)Bumpy Layers Height                  [m] |
C |            z0Bump   :         Bumpy Layers Height                  [m] |
C |            dzBump   :  Lowest Bumpy Layer:                         [m] |
C |            etBump   :         Bumps Layer Averaged Humidity    [m3/m3] |
C |            etaMid   : Layer Interface's Humidity               [m3/m3] |
C |            eta__f   : Layer             Humidity  (Water Front)[m3/m3] |
C |            Dhyd_f   : Soil  Hydraulic Diffusivity (Water Front) [m2/s] |
C |            Dhydif   : Soil  Hydraulic Diffusivity               [m2/s] |
C |            WgFlow   : Water         gravitational     Flux   [kg/m2/s] |
C |            Wg_MAX   : Water MAXIMUM gravitational     Flux   [kg/m2/s] |
C |            SatRat   : Water         Saturation        Flux   [kg/m2/s] |
C |            WExces   : Water         Saturation Excess Flux   [kg/m2/s] |
C |            Dhydtz   : Dhydif * dt / dz                             [m] |
C |            FreeDr   : Free Drainage Fraction                       [-] |
C |            Elem_A   : A Diagonal Coefficient                           |
C |            Elem_C   : C Diagonal Coefficient                           |
C |            Diag_A   : A Diagonal                                       |
C |            Diag_B   : B Diagonal                                       |
C |            Diag_C   : C Diagonal                                       |
C |            Term_D   :   Independant Term                               |
C |            Aux__P   : P Auxiliary Variable                             |
C |            Aux__Q   : Q Auxiliary Variable                             |
C |                                                                        |
C |   TUNING PARAMETER:                                                    |
C |   ^^^^^^^^^^^^^^^^                                                     |
C |            z0soil   : Soil Surface averaged Bumps Height           [m] |
C |                                                                        |
C |   METHOD: NO   Skin Surface Humidity                                   |
C |   ^^^^^^  Semi-Implicit Crank Nicholson Scheme                         |
C |           (Partial) free Drainage, Water Bodies excepted (Lakes, Sea)  |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C | #          #m0: Water  Budget Verification                             |
C | #          #m1: Snow/I Budget Verification                             |
C |                                                                        |
C | # OPTIONS: #GF: Saturation Front                                       |
C | # ^^^^^^^  #GH: Saturation Front allows Horton Runoff                  |
C | #          #GA: Soil Humidity Geometric Average                        |
C | #          #BP: Parameterization of Terrain Bumps                      |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # SISVAT_qSo.vw        | #vw: OUTPUT/Verif+Detail: H2O    Conservation |
C |                        |      unit 42, SubRoutine  SISVAT_qSo **ONLY** |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"

      include  "MARxSV.inc"
      include  "MARySV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/,/ySISVAT_I/,/ySISVAT_R/)

C +--OUTPUT
C +  ------

! Water (Mass) Budget
! ~~~~~~~~~~~~~~~~~~~
! #m0 real      Wats_0(klonv)                 ! Soil Water,  before forcing
! #m0 real      Wats_1(klonv)                 ! Soil Water,  after  forcing
! #m0 real      Wats_d(klonv)                 ! Soil Water          forcing


C +--Internal Variables
C +  ==================

      integer   isl   ,jsl   ,ist   ,ikl      !
      integer   ikm   ,ikp   ,ik0   ,ik1      !
      integer   ist__s,ist__w                 ! Soil/Water Body Identifier
c #BP real      z0soil                        ! Soil Surface Bumps Height  [m]
c #BP real      z_Bump                        !(Partly)Bumpy Layers Height [m] 
c #BP real      z0Bump                        !        Bumpy Layers Height [m] 
c #BP real      dzBump                        ! Lowest Bumpy Layer: 

c #BP real      etBump(klonv)                 ! Bumps Layer Averaged Humidity
      real      etaMid                        ! Layer Interface's Humidity
      real      Dhydif                        ! Hydraulic Diffusivity   [m2/s]
      real      eta__f                        ! Water Front Soil Water Content
      real      Khyd_f                        ! Water Front Hydraulic Conduct.
      real      Khydav                        ! Hydraulic Conductivity   [m/s]
      real      WgFlow                        ! Water gravitat. Flux [kg/m2/s]
      real      Wg_MAX                        ! Water MAX.grav. Flux [kg/m2/s]
      real      SatRat                        ! Saturation      Flux [kg/m2/s]
      real      WExces                        ! Saturat. Excess Flux [kg/m2/s]
      real      SoRnOF(klonv)                 ! Soil     Run    OFF
      real      Dhydtz(klonv,-nsol:0)         ! Dhydif * dt / dz           [m]
      real      Elem_A,Elem_B,Elem_C          !   Diagonal Coefficients
      real      Diag_A(klonv,-nsol:0)         ! A Diagonal
      real      Diag_B(klonv,-nsol:0)         ! B Diagonal
      real      Diag_C(klonv,-nsol:0)         ! C Diagonal
      real      Term_D(klonv,-nsol:0)         !   Independant Term
      real      Aux__P(klonv,-nsol:0)         ! P Auxiliary Variable
      real      Aux__Q(klonv,-nsol:0)         ! Q Auxiliary Variable
      real      etaaux(klonv,-nsol:-nsol+1)   ! Soil Water Content     [m3/m3]
      real      FreeDr                        ! Free Drainage Fraction (actual)
      real      FreeD0                        ! Free Drainage Fraction (1=Full)

! Water (Mass) Budget
! ~~~~~~~~~~~~~~~~~~~
c #mw logical         mwopen                  ! IO   Switch
c #mw common/Sm_qSo_L/mwopen                  !
c #mw real     hourwr,timewr                  !
c #mw common/Sm_qSo_R/timewr                  !
c #mw real            Evapor(klonv)           !


C +--Internal DATA
C +  =============

c #BP data      z0soil/0.020/                 ! Soil Surface Bumps Height  [m]
      data      FreeD0/1.000/                 ! Free Drainage Fraction (1=Full)


! Water  Budget (IN)
! ==================

! #m0   DO ikl=1,klonv
! #m0     Wats_0(ikl) = 0.                    ! OLD RunOFF Contrib.
! #m0     Wats_d(ikl) = drr_SV(ikl)           ! Water Surface Forc.
! #m0   END DO

! #m0      isl= -nsol
! #m0   DO ikl=1,klonv
! #m0     Wats_0(ikl) = Wats_0(ikl) 
! #m0.      + ro_Wat *( eta_SV(ikl,isl)   *dz78SV(isl)
! #m0.                + eta_SV(ikl,isl+1) *dz_8SV(isl) ) * LSdzsv(ikl)
! #m0   END DO

! #m0 DO   isl= -nsol+1,-1
! #m0   DO ikl=1,klonv
! #m0     Wats_0(ikl) = Wats_0(ikl) 
! #m0.      + ro_Wat *( eta_SV(ikl,isl)   *dz34SV(isl)
! #m0.                +(eta_SV(ikl,isl-1)
! #m0.                 +eta_SV(ikl,isl+1))*dz_8SV(isl) ) * LSdzsv(ikl)
! #m0   END DO
! #m0 END DO 

! #m0      isl=  0
! #m0   DO ikl=1,klonv
! #m0     Wats_0(ikl) = Wats_0(ikl) 
! #m0.      + ro_Wat *( eta_SV(ikl,isl)   *dz78SV(isl)
! #m0.                + eta_SV(ikl,isl-1) *dz_8SV(isl) ) * LSdzsv(ikl)
! #m0   END DO


C +--Gravitational Flow
C +  ==================

C +...    METHOD: Surface Water Flux saturates successively the soil layers 
C +       ^^^^^^  from up to below, but is limited by infiltration capacity.
C +               Hydraulic Conductivity again contributes after this step,
C +               not redundantly because of a constant (saturated) profile.

C +--Flux  Limitor
C +  ^^^^^^^^^^^^^
           isl=0
        DO ikl=1,klonv
          ist    = isotSV(ikl)                     ! Soil Type
          ist__s = min(ist, 1)                     ! 1 => Soil
          ist__w = 1 - ist__s                      ! 1 => Water Body
          Dhydif = s1__SV(ist)
     .               *max(epsi,eta_SV(ikl,isl))    ! Hydraulic Diffusivity
     .                      **(bCHdSV(ist)+2.)     ! DR97, Eqn.(3.36)
          Dhydif = ist__s    * Dhydif              !
     .           + ist__w    * vK_dSV              ! Water Bodies
C +
          Khydav = ist__s    * Ks_dSV(ist)         ! DR97  Assumption
     .           + ist__w    * vK_dSV              ! Water Bodies
C +
          Wg_MAX = ro_Wat     *Dhydif              ! MAXimum  Infiltration
     .           *(etadSV(ist)-eta_SV(ikl,isl))    !          Rate
     .           /(dzAvSV(isl)*LSdzsv(ikl)    )    !
     .          +  ro_Wat     *Khydav              ! 

C +--Surface Horton RunOFF
C +  ^^^^^^^^^^^^^^^^^^^^^
          SoRnOF(ikl) =
     .                max(zero,drr_SV(ikl)-Wg_MAX)
          drr_SV(ikl) =        drr_SV(ikl)-SoRnOF(ikl)
        END DO

c #GF DO   isl=0,-nsol,-1
c #GF   DO ikl=1,klonv
c #GF     ist    = isotSV(ikl)                     ! Soil Type
c #GF     ist__s = min(ist, 1)                     ! 1 => Soil
c #GF     ist__w = 1 - ist__s                      ! 1 => Water Body

C +--Water Diffusion
C +  ^^^^^^^^^^^^^^^
c #GF     Dhydif = s1__SV(ist)
c #GF.               *max(epsi,eta_SV(ikl,isl))    ! Hydraulic Diffusivity
c #GF.                      **(bCHdSV(ist)+2.)     ! DR97, Eqn.(3.36)
c #GF     Dhydif = ist__s    * Dhydif              !
c #GF.           + ist__w    * vK_dSV              ! Water Bodies

C +--Water Conduction (without Horton Runoff)
C +  ^^^^^^^^^^^^^^^^
c #GF     Khyd_f =             Ks_dSV(ist)
C +...    Uses saturated K ==> Horton Runoff ~0    !

C +--Water Conduction (with    Horton Runoff)
C +  ^^^^^^^^^^^^^^^^
c #GH     ik0    = nkhy       *eta_SV(ikl,isl)
c #GH.                        /etadSV(ist)
c #GH     eta__f         =            1.
c #GH.   -aKdtSV(ist,ik0)/(2. *dzAvSV(isl)
c #GH.                        *LSdzsv(ikl))
c #GH     eta__f         = max(eps_21,eta__f)
c #GH     eta__f         = min(etadSV(ist),
c #GH.                         eta_SV(ikl,isl) +
c #GH.   (aKdtSV(ist,ik0)     *eta_SV(ikl,isl)
c #GH.   +bKdtSV(ist,ik0))   /(dzAvSV(isl)
c #GH.                        *LSdzsv(ikl))
c #GH.                       / eta__f          )
c #GH     eta__f         = .5*(eta_SV(ikl,isl)
c #GH.                        +eta__f)

c #gh     eta__f         =     eta_SV(ikl,isl)

c #GH     ik0    = nkhy       *eta__f
c #GH.                        /etadSV(ist)
c #GH     Khyd_f =
c #GH.   (aKdtSV(ist,ik0)     *eta__f
c #GH.   +bKdtSV(ist,ik0))    /dt__SV

c #GF     Khydav = ist__s    * Khyd_f              ! DR97  Assumption
c #GF.           + ist__w    * vK_dSV              ! Water Bodies

C +--Gravitational Flow
C +  ^^^^^^^^^^^^^^^^^^
c #GF     Wg_MAX =                                 ! MAXimum  Infiltration
c #GF.             ro_Wat     *Dhydif              !          Rate
c #GF.           *(etadSV(ist)-eta_SV(ikl,isl))    ! 
c #GF.           /(dzAvSV(isl)*LSdzsv(ikl)    )    !
c #GF.          +  ro_Wat     *Khydav              ! 

c #WR     write(6,6001) isl,drr_SV(ikl)*3.6e3,Wg_MAX     *3.6e3
 6001     format(i3,'  vRain ,Wg_MAX ',2e12.3,' mm/hr')
c #GF     WgFlow =  min(Wg_MAX,drr_SV(ikl))        ! Infiltration Rate
c #GF     WExces =  max(zero  ,drr_SV(ikl)-WgFlow) ! Water Excess => RunOff
c #WR     write(6,6002)     WgFlow     *3.6e3,WExces     *3.6e3
 6002     format(3x,'  WgFlow,WExces ',2e12.3,' mm/hr')
c #GF     SoRnOF(ikl) =        SoRnOF(ikl)+WExces  !
c #GF     drr_SV(ikl) =        WgFlow              !
c #WR     write(6,6003)     SoRnOF(ikl)*3.6e3,drr_SV(ikl)*3.6e3
 6003     format(3x,'  SoRnOF,drr_SV ',2e12.3,' mm/hr')
c #GF     SatRat =(etadSV(ist)-eta_SV(ikl,isl))    ! Saturation   Rate
c #GF.            *ro_Wat     *dzAvSV(isl)         !
c #GF.                        *LSdzsv(ikl)/dt__SV  !
c #GF     SatRat =  min(SatRat,drr_SV(ikl))        !
c #GF     drr_SV(ikl) =        drr_SV(ikl)-SatRat  ! Water Flux for Below
c #WR     write(6,6004)     SatRat     *3.6e3,drr_SV(ikl)*3.6e3
 6004     format(3x,'  SatRat,drr_SV ',2e12.3,' mm/hr')
c #WR     write(6,6005)     eta_SV(ikl,isl)*1.e3
c #GF     eta_SV(ikl,isl) =    eta_SV(ikl,isl)     ! Saturation
c #GF.                        +SatRat*dt__SV       !
c #GF.                       /(ro_Wat*dzAvSV(isl)  !
c #GF.                               *LSdzsv(ikl)) !
c #WR     write(6,6005)     eta_SV(ikl,isl)*1.e3
 6005     format(3x,'  eta_SV,       ',e12.3,' g/kg')
c #GF   END DO
c #GF END DO
c #GF   DO ikl=1,klonv
c #GF     SoRnOF(ikl)     =    SoRnOF(ikl)         ! RunOFF Intensity
c #GF.                    +    drr_SV(ikl)         ! [kg/m2/s]
C +!!!    Inclure la possibilite de creer une mare sur un bedrock impermeable
c #GF     drr_SV(ikl) = 0.
c #GF   END DO


C +--Temperature Correction due to a changed Soil Energy Content
C +  ===========================================================

C +!!!    Mettre en oeuvre le couplage humidit?-?nergie


C +--Full Resolution of the Richard's Equation
C +  =========================================

C +...    METHOD: Water content evolution results from water fluxes 
C +       ^^^^^^  at the layer boundaries
C +               Conductivity is approximated by a piecewise linear profile. 
C +               Semi-Implicit Crank-Nicholson scheme is used. 
C +              (Bruen, 1997, Sensitivity of hydrological processes 
C +                            at the land-atmosphere interface. 
C +                            Proc. Royal Irish Academy,  IGBP symposium 
C +                            on global change and the Irish Environment. 
C +                            Publ.: Maynooth)

C +                      - - - - - - - -   isl+1/2   - -  ^   
C +                                                       |                       
C +   eta_SV(isl)        ---------------   isl     -----  +--dz_dSV(isl)  ^
C +                                                       |               |
C +   Dhydtz(isl) etaMid - - - - - - - -   isl-1/2   - -  v  dzmiSV(isl)--+
C +                                                                       |
C +   eta_SV(isl-1)      ---------------   isl-1   -----                  v

C +--Transfert       Coefficients
C +  ----------------------------

      DO   isl=-nsol+1,0
        DO ikl=1,klonv
          ist    =      isotSV(ikl)                       ! Soil Type
          ist__s =      min(ist, 1)                       ! 1 => Soil
          ist__w =      1 - ist__s                        ! 1 => Water Body
          etaMid =     (dz_dSV(isl)  *eta_SV(ikl,isl-1)   ! eta at layers
     .                 +dz_dSV(isl-1)*eta_SV(ikl,isl)  )  !     interface
     .           /(2.0* dzmiSV(isl))                      ! LSdzsv implicit !
c #GA     etaMid = sqrt(dz_dSV(isl)  *eta_SV(ikl,isl-1)   ! Idem, geometric
c #GA.                 *dz_dSV(isl-1)*eta_SV(ikl,isl)  )  !       average
c #GA.           /(2.0* dzmiSV(isl))                      ! (Vauclin&al.1979)
          Dhydif          =    s1__SV(ist)                ! Hydraul.Diffusi.
     .  *(etaMid         **(   bCHdSV(ist)+2.))           ! DR97, Eqn.(3.36)
          Dhydtz(ikl,isl) =    Dhydif*dt__SV              !
     .                              /(dzmiSV(isl)         !
     .                               *LSdzsv(ikl))        !
          Dhydtz(ikl,isl) =    Dhydtz(ikl,isl) * ist__s   ! Soil
     .        +0.5*dzmiSV(isl)*LSdzsv(ikl)     * ist__w   ! Water bodies

        END DO
      END DO
           isl=-nsol
        DO ikl=1,klonv
          Dhydtz(ikl,isl) =    0.0                        !
        END DO


C +--Tridiagonal Elimination: Set Up
C +  -------------------------------

C +--Soil/Snow Interior
C +  ^^^^^^^^^^^^^^^^^^
      DO   isl=-nsol,-nsol+1
        DO ikl=1,klonv
          etaaux(ikl,isl) =  eta_SV(ikl,isl)
        END DO
      END DO

      DO   isl=-nsol+1,-1
        DO ikl=1,klonv
          ist      =         isotSV(ikl)
          ikm      = nkhy *  eta_SV(ikl,isl-1) / etadSV(ist)
          ik0      = nkhy *  eta_SV(ikl,isl)   / etadSV(ist)
          ikp      = nkhy *  eta_SV(ikl,isl+1) / etadSV(ist)
          Elem_A   =         Dhydtz(ikl,isl)   
     .                    -  aKdtSV(ist,ikm)* dziiSV(isl)  *LSdzsv(ikl)
          Elem_B   =      - (Dhydtz(ikl,isl)
     .                      +Dhydtz(ikl,isl+1)
     .                      -aKdtSV(ist,ik0)*(dziiSV(isl+1)
     .                                       -dzi_SV(isl) )*LSdzsv(ikl))
          Elem_C   =         Dhydtz(ikl,isl+1) 
     .                    +  aKdtSV(ist,ikp)* dzi_SV(isl+1)*LSdzsv(ikl)
          Diag_A(ikl,isl) =  dz_8SV(isl)        *LSdzsv(ikl)
     .                      -Implic            * Elem_A
          Diag_B(ikl,isl) =  dz34SV(isl)        *LSdzsv(ikl)
     .                      -Implic            * Elem_B
          Diag_C(ikl,isl) =  dz_8SV(isl)        *LSdzsv(ikl)
     .                      -Implic            * Elem_C

          Term_D(ikl,isl) = (dz_8SV(isl) *LSdzsv(ikl)
     .                      +Explic      *Elem_A     )*eta_SV(ikl,isl-1)
     .                    + (dz34SV(isl) *LSdzsv(ikl)
     .                      +Explic      *Elem_B     )*eta_SV(ikl,isl)
     .                    + (dz_8SV(isl) *LSdzsv(ikl)
     .                      +Explic      *Elem_C     )*eta_SV(ikl,isl+1)
     .                    + (bKdtSV(ist,ikp)* dzi_SV(isl+1)
     .                      +bKdtSV(ist,ik0)*(dziiSV(isl+1)
     .                                       -dzi_SV(isl)  )
     .                      -bKdtSV(ist,ikm)* dziiSV(isl)   )
     .                                      * LSdzsv(ikl)
     .                    -  dt__SV         * Rootsv(ikl,isl)/ro_Wat
        END DO
      END DO

           isl=-nsol
        DO ikl=1,klonv
          ist      =         isotSV(ikl)
c #       FreeDr   =         FreeD0            *  min(ist,1)
          FreeDr   =         iWaFSV(ikl)       *  min(ist,1)
          ik0      = nkhy *  eta_SV(ikl,isl  ) / etadSV(ist)
          ikp      = nkhy *  eta_SV(ikl,isl+1) / etadSV(ist)
          Elem_A   =         0.
          Elem_B   =      - (Dhydtz(ikl,isl+1) 
     .                      -aKdtSV(ist,ik0)*(dziiSV(isl+1)*LSdzsv(ikl)
     .                                       -FreeDr                  ))
          Elem_C   =         Dhydtz(ikl,isl+1) 
     .                    +  aKdtSV(ist,ikp)* dzi_SV(isl+1)*LSdzsv(ikl)
          Diag_A(ikl,isl) =  0.
          Diag_B(ikl,isl) =  dz78SV(isl) *LSdzsv(ikl)
     .                      -Implic      *Elem_B
          Diag_C(ikl,isl) =  dz_8SV(isl) *LSdzsv(ikl)
     .                      -Implic      *Elem_C

          Term_D(ikl,isl) = (dz78SV(isl) *LSdzsv(ikl)
     .                      +Explic      *Elem_B     )*eta_SV(ikl,isl)
     .                    + (dz_8SV(isl) *LSdzsv(ikl)
     .                      +Explic      *Elem_C     )*eta_SV(ikl,isl+1)
     .                    + (bKdtSV(ist,ikp)* dzi_SV(isl+1)*LSdzsv(ikl)
     .                      +bKdtSV(ist,ik0)*(dziiSV(isl+1)*LSdzsv(ikl)
     .                                       -FreeDr                  ))
     .                    -  dt__SV         * Rootsv(ikl,isl)/ro_Wat
        END DO

           isl=0
        DO ikl=1,klonv
          ist      =         isotSV(ikl)
          ikm      = nkhy *  eta_SV(ikl,isl-1) / etadSV(ist)
          ik0      = nkhy *  eta_SV(ikl,isl)   / etadSV(ist)
          Elem_A   =         Dhydtz(ikl,isl)   
     .                    -  aKdtSV(ist,ikm)* dziiSV(isl)*LSdzsv(ikl)
          Elem_B   =      - (Dhydtz(ikl,isl)
     .                      +aKdtSV(ist,ik0)* dzi_SV(isl)*LSdzsv(ikl))
          Elem_C   =         0.
          Diag_A(ikl,isl) =  dz_8SV(isl) *LSdzsv(ikl)
     .                    -  Implic      *Elem_A
          Diag_B(ikl,isl) =  dz78SV(isl) *LSdzsv(ikl)
     .                    -  Implic      *Elem_B
          Diag_C(ikl,isl) =  0.
C +
          Term_D(ikl,isl) = (dz_8SV(isl) *LSdzsv(ikl)
     .                      +Explic      *Elem_A     )*eta_SV(ikl,isl-1)
     .                    + (dz78SV(isl) *LSdzsv(ikl)
     .                      +Explic      *Elem_B     )*eta_SV(ikl,isl)
     .                    - (bKdtSV(ist,ik0)* dzi_SV(isl)
     .                      +bKdtSV(ist,ikm)* dziiSV(isl))*LSdzsv(ikl)
     .            + dt__SV *(HLs_sv(ikl)    *     (1-min(1,isnoSV(ikl)))
     .                                                   / Lx_H2O(ikl)
     .                      +drr_SV(ikl)
     .                      -Rootsv(ikl,isl)             )/ro_Wat 
        END DO
C +
C +
C +--Tridiagonal Elimination
C +  =======================
C +
C +--Forward  Sweep
C +  ^^^^^^^^^^^^^^
        DO ikl=  1,klonv
          Aux__P(ikl,-nsol) = Diag_B(ikl,-nsol)
          Aux__Q(ikl,-nsol) =-Diag_C(ikl,-nsol)/Aux__P(ikl,-nsol)
        END DO
C +
      DO   isl=-nsol+1,0   
        DO ikl=      1,klonv
          Aux__P(ikl,isl)   = Diag_A(ikl,isl)  *Aux__Q(ikl,isl-1)
     .                       +Diag_B(ikl,isl)
          Aux__Q(ikl,isl)   =-Diag_C(ikl,isl)  /Aux__P(ikl,isl)
        END DO
      END DO
C +
        DO ikl=      1,klonv
          eta_SV(ikl,-nsol) = Term_D(ikl,-nsol)/Aux__P(ikl,-nsol)
        END DO
C +
      DO   isl=-nsol+1,0   
        DO ikl=      1,klonv
          eta_SV(ikl,isl)   =(Term_D(ikl,isl)
     .                       -Diag_A(ikl,isl)  *eta_SV(ikl,isl-1))
     .                                         /Aux__P(ikl,isl)
        END DO
      END DO

C +--Backward Sweep
C +  ^^^^^^^^^^^^^^
      DO   isl=-1,-nsol,-1
        DO ikl= 1,klonv
          eta_SV(ikl,isl)   = Aux__Q(ikl,isl)  *eta_SV(ikl,isl+1)
     .                                         +eta_SV(ikl,isl)
        END DO
      END DO


C +--Horton RunOFF Intensity
C +  =======================

      DO   isl=0,-nsol,-1
        DO ikl=1,klonv
          ist    =   isotSV(ikl)                   ! Soil Type
          SatRat =  (eta_SV(ikl,isl)-etadSV(ist))  ! OverSaturation Rate
     .              *ro_Wat         *dzAvSV(isl)   !
     .                              *LSdzsv(ikl)   !
     .                              /dt__SV        !
          SoRnOF(ikl)     =          SoRnOF(ikl)   !
     .                    + max(zero,SatRat)       !
          eta_SV(ikl,isl) = max(epsi               !
c #ED.                         +etamSV(isotSV(ikl))!
     .                         ,eta_SV(ikl,isl))   !
          eta_SV(ikl,isl) = min(eta_SV(ikl,isl)    !
     .                         ,etadSV(ist)    )   !
        END DO
      END DO

C +--IO, for Verification
C +  ~~~~~~~~~~~~~~~~~~~~
c #WR     write(6,6010) 
 6010     format(/,1x)
      DO   isl= 0,-nsol,-1
        DO ikl= 1,klonv
          ist      =          isotSV(ikl)
          ikp      = nkhy  *  eta_SV(ikl,isl)  /etadSV(ist)
          Khydsv(ikl,isl)   =(aKdtSV(ist,ikp)  *eta_SV(ikl,isl)
     .                       +bKdtSV(ist,ikp)) *2.0/dt__SV
c #WR     write(6,6011) ikl,isl,eta_SV(ikl,isl)*1.e3,
c #WR.                  ikp,    aKdtSV(ist,ikp),bKdtSV(ist,ikp),
c #WR.                          Khydsv(ikl,isl)
 6011     format(2i3,f8.1,i3,3e12.3)
        END DO
      END DO


C +--Additional RunOFF Intensity
C +  ===========================

        DO ikl=1,klonv
          ist      =          isotSV(ikl)
          ik0      = nkhy  *  etaaux(ikl,-nsol  ) /etadSV(ist)
c #       FreeDr   =          FreeD0            *  min(ist,1)
          FreeDr   =          iWaFSV(ikl)       *  min(ist,1)
          SoRnOF(ikl) =  SoRnOF(ikl)
     .                + (aKdtSV(ist,ik0)*(etaaux(ikl,-nsol)*Explic
     .                                   +eta_SV(ikl,-nsol)*Implic)
     .                 + bKdtSV(ist,ik0)                           )
     .                 * FreeDr          *ro_Wat           /dt__SV

C +--Full Run OFF: Update
C +  ~~~~~~~~~~~~~~~~~~~~
          RnofSV(ikl) = RnofSV(ikl)     + SoRnOF(ikl)
        END DO


C +--Temperature Correction due to a changed Soil Energy Content
C +  ===========================================================

C +!!!    Mettre en oeuvre le couplage humidit?-?nergie


C +--Bumps/Asperites Treatment
C +  =========================

C +--Average over Bump Depth (z0soil)
C +  --------------------------------

c #BP       z_Bump      = 0.
c #BP     DO ikl=1,klonv
c #BP       etBump(ikl) = 0.
c #BP     END DO
C +
c #BP DO     isl=0,-nsol,-1
c #BP       z0Bump      = z_Bump
c #BP       z_Bump      = z_Bump      +  dzAvSV(isl)
c #BP   IF (z_Bump.lt.z0soil)                                       THEN
c #BP     DO ikl=1,klonv
c #BP       etBump(ikl) = etBump(ikl) +  dzAvSV(isl)   *eta_SV(ikl,isl)
c #BP     END DO
c #BP   END IF
c #BP   IF (z_Bump.gt.z0soil.AND.z0Bump.lt.z0soil)                  THEN
c #BP     DO ikl=1,klonv
c #BP       etBump(ikl) = etBump(ikl) + (z0soil-z0Bump)*eta_SV(ikl,isl)
c #BP       etBump(ikl) = etBump(ikl) /  z0soil
c #BP     END DO
c #BP   END IF
c #BP END DO


C +--Correction
C +  ----------

c #BP       z_Bump      = 0.
c #BP DO     isl=0,-nsol,-1
c #BP       z0Bump =  z_Bump
c #BP       z_Bump =  z_Bump +dzAvSV(isl)
c #BP   IF (z_Bump.lt.z0soil)                                       THEN
c #BP     DO ikl=1,klonv
c #BP       eta_SV(ikl,isl) = etBump(ikl)
c #BP     END DO
c #BP   END IF
c #BP   IF (z_Bump.gt.z0soil.AND.z0Bump.lt.z0soil)                  THEN
c #BP       dzBump          =    z_Bump -  z0soil
c #BP     DO ikl=1,klonv
c #BP       eta_SV(ikl,isl) =(etBump(ikl)    *(dzAvSV(isl)-dzBump)
c #BP.                      + eta_SV(ikl,isl)*             dzBump)
c #BP.                      /                  dzAvSV(isl)
c #BP     END DO
c #BP   END IF
c #BP END DO


C +--Positive Definite
C +  =================

c #BP DO   isl= 0,-nsol,-1
c #BP   DO ikl= 1,klonv
c #BP     eta_SV(ikl,isl)   =          max(epsi,eta_SV(ikl,isl))
c #BP   END DO
c #BP END DO


C +--Water  Budget (OUT)
C +  ===================

! #m0   DO ikl=1,klonv
! #m0     Wats_d(ikl) = Wats_d(ikl)                    ! 
! #m0.                + drr_SV(ikl)     *zero          ! Precipitation is
C +                                      \______________ already included
! #m0.                + HLs_sv(ikl)
! #m0.          *(1-min(isnoSV(ikl),1)) /Lx_H2O(ikl)   ! Evaporation
! #m0.                - SoRnOF(ikl)                    ! Soil RunOFF Contrib.
! #m0     Wats_1(ikl) = 0.                             !
c #mw     Evapor(ikl) = HLs_sv(ikl)     *dt__SV        !
c #mw.          *(1-min(isnoSV(ikl),1)) /Lx_H2O(ikl)   !
! #m0   END DO

! #m0 DO   isl= -nsol,0
! #m0   DO ikl=1,klonv
! #m0     Wats_d(ikl) = Wats_d(ikl)                    ! 
! #m0.                - Rootsv(ikl,isl)                ! Root Extract.
! #m0   END DO
! #m0 END DO 
! #m0   DO ikl=1,klonv
! #m0     Wats_d(ikl) = Wats_d(ikl)     *dt__SV        ! 
! #m0   END DO

! #m0      isl= -nsol
! #m0   DO ikl=1,klonv
! #m0     Wats_1(ikl) = Wats_1(ikl) 
! #m0.      + ro_Wat *( eta_SV(ikl,isl)   *dz78SV(isl)
! #m0.                + eta_SV(ikl,isl+1) *dz_8SV(isl) ) *LSdzsv(ikl)
! #m0   END DO

! #m0 DO   isl= -nsol+1,-1
! #m0   DO ikl=1,klonv
! #m0     Wats_1(ikl) = Wats_1(ikl) 
! #m0.      + ro_Wat *( eta_SV(ikl,isl)   *dz34SV(isl)
! #m0.                +(eta_SV(ikl,isl-1)
! #m0.                 +eta_SV(ikl,isl+1))*dz_8SV(isl) ) *LSdzsv(ikl)
! #m0   END DO
! #m0 END DO 

! #m0      isl=  0
! #m0   DO ikl=1,klonv
! #m0     Wats_1(ikl) = Wats_1(ikl) 
! #m0.      + ro_Wat *( eta_SV(ikl,isl)   *dz78SV(isl)
! #m0.                + eta_SV(ikl,isl-1) *dz_8SV(isl) ) *LSdzsv(ikl)
! #m0   END DO


C +--Water  Budget (IO)
C +  ==================

c #mw IF (.NOT.mwopen)                                              THEN
c #mw          mwopen = .true.
c #mw          open(unit=42,status='unknown',file='SISVAT_qSo.vw')
c #mw          rewind 42
c #mw   write(42,42)
 42     format('SubRoutine SISVAT_qSo: Local Water Budget',
     .       /,'=========================================')
c #mw END IF
c #mw         timewr=timewr + dt__SV
c #mw         hourwr=3600.0
c #mw IF (mod(timewr,hourwr).lt.epsi)
c #mw.  write(42,420)timewr/hourwr
 420    format(11('-'),'----------+--------------+-',
     .          3('-'),'----------+--------------+-',
     .                 '----------------+----------------+',
     .       /,f8.2,3x,'Wats_0(1) |    Wats_d(1) | ',
     .              3x,'Wats_1(1) | W_0+W_d-W_1  | ',
     .                 '   Soil Run OFF |   Soil Evapor. |',
     .       /,11('-'),'----------+--------------+-',
     .          3('-'),'----------+--------------+-',
     .                 '----------------+----------------+')
c #mw   write(42,421)   Wats_0(1),Wats_d(1)
c #mw.                 ,Wats_1(1) 
c #mw.                 ,Wats_0(1)+Wats_d(1)-Wats_1(1)
c #mw.                 ,SoRnOF(1),Evapor(1)
 421    format(8x,f12.6,' + ',f12.6,' - ',f12.6,' = ',f12.6,' | ',f12.6,
     .      '      ',f15.6)

      return
      end


      subroutine SISVAT_wEq( labWEq ,istart)

C +------------------------------------------------------------------------+
C | MAR          SISVAT_wEq                                22-09-2001  MAR |
C |   SubRoutine SISVAT_wEq computes the Snow/Ice  Water  Equivalent       |
C |                                                                        |
C |                                                                        |
C |   Preprocessing  Option: SISVAT IO (not always a standard preprocess.) |
C |   ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^                                     |
C |   FILE                 |      CONTENT                                  |
C |   ~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |
C | # SISVAT_wEq.ve        | #ve: OUTPUT/Verification: Snow/Ice Water Eqv. |
C |                        |      unit 45, SubRoutine  SISVAT_wEq **ONLY** |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include  "MARphy.inc"
      include  "MAR_SV.inc"
      include  "MARxSV.inc"
!$OMP threadprivate(/xSISVAT_I/,/xSISVAT_R/)


      character*6         labWEq
      integer             istart

      logical             logWEq
      common/SISVAT_wEq_L/logWEq


C +--Local  Variables
C +  ================

      integer  ikl   ,isn
      real     SnoWEQ,IceWEQ


C +--Switch Initialization
C +  =====================

      IF (.NOT.logWEq)                                              THEN
               logWEq = .true.
               open(unit=45,status='unknown',file='SISVAT_wEq.ve')
               rewind    45
      END IF


C +--Snow Water Equivalent
C +  =====================

           ikl   = 1
      IF          (isnoSV(ikl).gt.iiceSV(ikl))                      THEN

          SnoWEQ = 0.
        DO isn   = iiceSV(ikl)+1 ,isnoSV(ikl)
          SnoWEQ = SnoWEQ       + ro__SV(ikl,isn) * dzsnSV(ikl,isn) 
        END DO

      END IF


C +--Ice  Water Equivalent
C +  =====================

      IF        (iiceSV(1).gt.0)                                    THEN

          IceWEQ = 0.
        DO isn   =             1 ,iiceSV(ikl)
          IceWEQ = IceWEQ       + ro__SV(ikl,isn) * dzsnSV(ikl,isn) 
        END DO

      END IF


C +--OUTPUT
C +  ======

      IF (istart.eq.1)                                              THEN
        write(45,45)dahost,i___SV(lwriSV(1)),j___SV(lwriSV(1)),
     .              n___SV(lwriSV(1))
 45     format(a18,10('-'),'Pt.',3i4,60('-'))
      END IF

      write(45,450) labWEq,IceWEQ,iiceSV(ikl),SnoWEQ
     .                    ,IceWEQ+SnoWEQ,isnoSV(ikl)
     .                                  ,drr_SV(ikl)*dt__SV
     .                                  ,dsn_SV(ikl)*dt__SV
     .                                  ,BufsSV(ikl)
 450  format(a6,3x,'  I+S =',f11.4,'(',i2,') +',f11.4,' =',
     .                       f11.4,'(',i2,')',
     .             '  drr =', f7.4,
     .             '  dsn =', f7.4,
     .             '  Buf =', f7.4)

      return
      end


      subroutine PHY_KDsvat(ihamr_KDs,nhamr_KDs)

C +------------------------------------------------------------------------+
C | MAR PHYSICS                                             7-06-2002  MAR |
C |   SubRoutine PHY_KDsvat    interfaces MAR        with        the       |
C |              DeRidder Soil Vegetation Atmosphere Transfer Scheme       |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables (MAR)
C +  ======================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'   
      include 'MARgrd.inc'
      include 'MAR_GE.inc'   
C +
      include 'MAR_DY.inc'  
C +
c #HY include 'MAR_HY.inc'  
      include 'MAR_RA.inc'  
C +
      include 'MAR_SL.inc'    
c #SN include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'    
C +
      include 'MAR_WK.inc'  
      include 'MAR_IO.inc'  
C +
      integer  ihamr_KDs ,nhamr_KDs
      integer  newglfKDs
C +
C +
C +--Local  Variables
C +  ================
C +
      logical   glfFIX
      integer   n        ,ii       ,iprnt
C +
      real      czemin
      real      vdt      ,vVAir    ,vTAir    ,vQAir    ,argqs ,vqsat
      real      vRadS    ,vRadL    ,crain    ,vRain    ,rhAir ,psrfc
      real      vzAir    ,cosZA
      real      vTsBr    ,vTsIR    ,vAlbS    ,vEmiS    
      real      vTa_S    ,vQa_S    ,vHS_S    ,vHL_S    ,vTauS
C +
C +
C +--DATA
C +  ====
C +
      data glfFIX/ .false.   /
      data czemin/0.10000e-03/
C +
C +
C +--Update Green Leaf Fraction
C +  ==========================
C +
c #GP                                      glfFIX = .true.
c #TV IF (vegmod .AND. reaLBC .AND.  .NOT. glfFIX)                THEN
C +
C +          ******
c #TV   call INIglf(ihamr_KDs,nhamr_KDs,newglfKDs)
C +          ******
C +
c #TV END IF
C +
C +
C +--Surface Physics
C +  ===============
C +
      DO j=jp11,my1
      DO i=ip11,mx1
C +
                                                     IO_loc = IO_gen
        if (IO_gen.ge.1.and.jmmMAR.eq.0.and.jssMAR.eq.0) then
         do 60 ii=1,5
          if (igrdIO(ii).eq.i.and.(jgrdIO(ii).eq.j)) IO_loc = IO_gen+2
  60     continue
        end if
C +
       go to (1,2,3,4,4) isolSL(i,j) 
C +
C +--Ocean 
C +  ~~~~~
 1     continue
C +
C +          ***************
c #FR        call SRFfrm_sea
C +          ***************
C +
       go to 10
C +
C +--Sea Ice 
C +  ~~~~~~~
 2     continue
C +
C +          ****************
c #FR        call SRFfrm_sice
C +          ****************
C +
       go to 10
C +
C +--Ice  + Snow 
C +  ~~~~~~~~~~~
 3     continue
C +
c #sn   if (snomod) then 
C +
C +          ***************
c #sn        call SRFmod_sno
C +          ***************
C +
c #sn   else 
C +
C +          ***************
c #FR        call SRFfrm_sno
C +          ***************
C +
c #sn   end if 
C +
       go to 10
C +
C +--Soil + Snow 
C +  ~~~~~~~~~~~
 4     continue
C +
c #sn   IF      (snomod)                                          THEN 
C +
C +          ***************
c #sn        call SRFmod_sno
C +          ***************
C +
c #sn   ELSE
C +
C +--Vegetation
C +  ~~~~~~~~~~
c #SV     IF     (vegmod)                                         THEN 
C +
c #SV               vdt= dtPhys
C +
c #SV             vVAir=  ssvSL(i,j,mz)
c #SV             vTAir= tairDY(i,j,mz)
c #SV             vQAir=   qvDY(i,j,mz)
c #SV             argqs= 17.27e0*(vTAir-273.e0)/(vTAir-36.0e0)
c #SV             vqsat=  3.8e-3*exp(argqs)
c #SV         IF (vqsat.LE.vQAir) vQAir=vqsat
C +
c #SV             vRadS= sol_SL(i,j) / (1.-albeSL(i,j))
c #SV             RAdsol(i,j)= vRadS
c #SV             vRadL= RAd_ir(i,j)
C +
c #HY             crain= rainHY(i,j)
c #SV             vRain=(crain      -rai0HY(i,j))*1000./dtPhys
c #HY                    rai0HY(i,j)=rainHY(i,j)
C +
c #SV             rhAir= rolvDY(i,j,mz)                 *1.0e+3
c #SV             psrfc=( pstDY(i,j)+ptopDY)            *1.0e+3
c #SV             vzAir=(gplvDY(i,j,mz)-gplvDY(i,j,mzz))*grvinv
C +
c #SV                          cosZA =     czenGE(i,j)
c #SV         IF (vRadS.GT.0.) cosZA = max(cosZA,czemin)
c #SV         if (jmmMAR.eq.0.and.jssMAR.eq.0)                    THEN
c #SV             iprnt   =  1
c #SV         ELSE
c #SV             iprnt   =  0
c #SV         END IF
C +
C +           *********
c #SV         call svat
c #SV.          (vvair,vTAir,vQAir,vRadS,vRadL,vRain,cosZA,rhAir,vzAir,
c #SV.           i    ,j    ,iprnt,vdt  ,
c #SV.           vTsBr,vTsIR,vAlbS,vEmiS,vTa_S,vQa_S,vHS_S,vHL_S,vTauS)
C +           *********
C +
c #SV         eps0SL(i,j)  =     vEmiS
c #SV         tsrfSL(i,j,1)=     vTa_S
c #SV         tviRA (i,j)  =     vTsIR
c #SV         qvapSL(i,j)  = min(vQa_S,qvswDY(i,j,mzz))
c #SV         SLuqsl(i,j,1)=    -vHL_S/(rhAir*Lv_H2O)
c #SV         hlatSL(i,j)  =     vHL_S
c #SV         SLutsl(i,j,1)=    -vHS_S/(rhAir*cp)
c #SV         hsenSL(i,j)  =     vHS_S
c #SV         SLuusl(i,j,1)=       sqrt(vTauS/rhAir)
c #SV         albeSL(i,j)  =     vAlbS
C +
c #SV     ELSE
C +
C +--Soil
C +  ~~~~
C +              ****************
c #FR            call SRFfrm_soil
C +              ****************
C +
c #SV     END IF
C +
c #sn   END IF 
C +
       go to 10
C +
 10    continue
C +
      END DO
      END DO
                                                     IO_loc = IO_gen
C +
C +
C +--Lateral Boundary Conditions Surface Variables
C +  =============================================
C +
c #SA IF(.not.sALONE) THEN
        DO n=1,mw
          DO j=1,my
            tsrfSL( 1,j,n) = tsrfSL(ip11,j,n)
            tsrfSL(mx,j,n) = tsrfSL( mx1,j,n)
             dtgSL( 1,j,n) = 0.
             dtgSL(mx,j,n) = 0.
          END DO
         IF (mmy.GT.1)                                            THEN
          DO i=1,mx
            tsrfSL(i, 1,n) = tsrfSL(i,jp11,n)
            tsrfSL(i,my,n) = tsrfSL(i, my1,n)
             dtgSL(i, 1,n) = 0.
             dtgSL(i,my,n) = 0.
          END DO
         END IF
        END DO
c #SA ELSE
c #SA   DO n=1,mw
c #SA     DO j=1,my
c #SA        dtgSL( 1,j,n) =  dtgSL(ip11,j,n)
c #SA        dtgSL(mx,j,n) =  dtgSL( mx1,j,n)
c #SA     END DO
c #SA     DO i=1,mx
c #SA        dtgSL(i, 1,n) =  dtgSL(i,jp11,n)
c #SA        dtgSL(i,my,n) =  dtgSL(i, my1,n)
c #SA     END DO
c #SA   END DO
c #SA END IF
C +
      return
      end
      subroutine SRFfrm_sea
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            19-09-2001  MAR |
C |   SubRoutine SRFfrm_sea computes the Surface Energy Balance over SEA   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   Refer. : Thom and Oliver, 1977, QJRMS 103, pp. 345-- 357             |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   INPUT  : sol_SL(mx,my)  : Absorbed Solar Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ RAd_ir(mx,my)  : Downward    IR Flux (+ <=> Downward)(W/m2) |
C |            albeSL(mx,my)  : Surface Albedo                             |
C |            eps0SL(mx,my)  : Surface IR Emissivity                      |
C |            tsrfSL(mx,my,1): Sea Surface Temperature                (K) |
C |                                                                        |
C |   OUTPUT : firdSL(mx,my)  : Atmospheric IR Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ firmSL(mx,my)  : Surface     IR Flux (+ <=>   Upward)(W/m2) |
C |            hsenSL(mx,my)  : Sensible  Heat Flux (+ <=> Downward)(W/m2) |
C |            hlatSL(mx,my)  : Latent    Heat Flux (+ <=> Downward)(W/m2) |
C |         -> SLuqsl(i,j,1)  : Water Vapor Flux from Surface  (kg.m/kg/s) |
C |            hbalSL(mx,my)  : Sum Atmospher. Flux (+ <=>Surf.Loss)(W/m2) |
C |            tsrfSL(mx,my,1): New Sea Surface Temperature            (K) |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_LB.inc'
C +
      include 'MAR_RA.inc'
C +
      include 'MAR_SL.inc'
      include 'MAR_PO.inc'
C +
      include 'MAR_IO.inc'
C +
C +
C +--Local   Variable
C +  ================
C +
      real     radnet,rho10m,qst   ,qsa   ,relhum,pr    ,rhos  ,eggl  
      real     gamp  ,aqsat ,dqsat ,qs10  ,den   ,dnum  ,egpm  ,eg
      real     zeta  
      real     tsrfwn
C +
      real     swab  ,apha  ,beta
      logical  qpm
C +
C +
C +--DATA
C +  ====
C +
      data swab/2.05e8/
C +...     swab:50m X 4000J/kg/K X 1025kg/m3 
C +             50m (Oceanic Mixed Layer Depth)
C +                   4000J/kg/K (Sea Water Heat Capacity)
C +                                1025kg/m3 (Sea Water Density)
      data apha/0.50e0/,beta/0.50e0/
      data  qpm/.false./
C +
C +
C +--Water and Snow Accumulation
C +  ===========================
C +
      hwatSL(i,j) = hwatSL(i,j) + precSL(i,j)
      precSL(i,j) = 0.d0
      hsnoSL(i,j) = hsnoSL(i,j) + snobSL(i,j) + snohSL(i,j)
      snobSL(i,j) = 0.d0
      snohSL(i,j) = 0.d0
C +
C +
C +--Surface Heat Fluxes
C +  ===================
C +
C +--Total Radiative Downward Heat Flux
C +  ----------------------------------
C +
      RAdsol(i,j) = sol_SL(i,j) /(1.d0-albeSL(i,j))
      firdSL(i,j) = RAd_ir(i,j) *      eps0SL(i,j)
      radnet      = sol_SL(i,j)      + firdSL(i,j) 
     .            - eps0SL(i,j)*stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .                                *tsrfSL(i,j,1)*tsrfSL(i,j,1)
C +
C +
C +--Sensible Heat Flux
C +  ------------------
C +
      rho10m      = rolvDY(i,j,mz)*1000.d0
C +...rho10m      : specific mass at first Sigma Level (kg/m3)
C +
      hsenSL(i,j) =-rho10m *cp *SLutsl(i,j,1)
C +
C +
C +--Evaporation
C +  -----------
C +
C +--Specific Humidity at Sea-Atmosphere Interface
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      qst      = qvswDY(i,j,mzz)
      qsa      = qvswDY(i,j,mz)
      relhum   = qvDY(i,j,mz) / qsa
C +
      qvapSL(i,j)= qst
      pr         =(pstDY(i,j) +ptopDY)      * 1.d1
      rhos       = pr/(RDryAi *TairSL(i,j)) * 1.d2
C +
C +--Bulk Aerodynamic Formula
C +  ~~~~~~~~~~~~~~~~~~~~~~~~
      eggl= rho10m* cdhSL(i,j,1)*SLuusl(i,j,1) *(qst-qvDY(i,j,mz))
c _UQ eggl= rho10m* ch0SL(i,j  )* ssvSL(i,j,mz)*(qst-qvDY(i,j,mz))
C +UQ eggl=-rhos  *SLuqsl(i,j,1)
C +UQ     : When   u q *  is computed used flux profile relationships 
C +         (e.g. Duynkerke and van den Broecke, 1993)
C +
C +--Water Vapor Flux at Sea -Atmosphere Interface (Thom & Oliver, 1977)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      gamp = 4.08d-04*(1.d0+rsurSL(i,j)/raerSL(i,j))
C +...rsurSL : `bulk' stomatal resistance (Thom & Oliver, 1977, p. 347)
C +...raerSL : aerodynamic resistance (computed in routine TURsbl)
C +
      aqsat= 1.d0/(237.3d0+tairDY(i,j,mz))
      dqsat= qst *4098.0d0*aqsat*aqsat
      qs10 = qvswDY(i,j,mz)
      den  = dqsat+gamp
      dnum =(radnet*.9d0)*dqsat 
     .     + rhos*cp*(qs10-qvDY(i,j,mz))/raerSL(i,j)
      egpm = dnum/den/Lv_H2O
C +
      if (qpm) then
       eg = egpm
      else
       eg = eggl
      end if
C +
C +--Latent Heat Flux
C +  ~~~~~~~~~~~~~~~~
      SLuqsl(i,j,1)=  - eg / rhos
      hlatSL(i,j)  =    eg * Lv_H2O
      roseSL(i,j)  =    roseSL(i,j) - eg * dtPhys / ro_Wat
      roseSL(i,j)  =max(roseSL(i,j),zero)
C +
C +
C +--Sea Surface Energy Balance + Swab Ocean
C +  ---------------------------------------
C +
      firmSL(i,j)  = eps0SL(i,j)   *stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .                                    *tsrfSL(i,j,1)*tsrfSL(i,j,1)
      hbalSL(i,j)  = firmSL(i,j)   + hsenSL(i,j) + hlatSL(i,j) 
     .             - sol_SL(i,j)   - firdSL(i,j)
C +
      IF (.not.polmod)                                            THEN
               tsrfSL(i,j,1)= tsrfSL(i,j,1) - hbalSL(i,j) *dtPhys /swab
        IF    (reaLBC)
     .         tsrfSL(i,j,1)= sst_LB(i,j)
      ELSE
        IF    (tsrfSL(i,j,1).gt.tfrwat)                           THEN
               tsrfwn       = tsrfSL(i,j,1) - hfraPO(i,j) *silfPO /swab
               tsrfwn   = max(tsrfwn,tfrwat)
               hfraPO(i,j)  = hfraPO(i,j)
     .                      -(tsrfSL(i,j,1) - tsrfwn)     *swab /silfPO
               tsrfSL(i,j,1)= tsrfwn
        END IF
C +
      END IF
C +
C +
C +--`Surface' Specific Humidity
C +  ---------------------------
C +
      qvapSL(i,j) = qst
C +
C +
C +--Output on Listing if IO_loc. ge. 3
C +  ==================================
C +
      if ((((IO_loc.ge.3.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.4.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.5)                            )       ).or.
     .       IO_loc.ge.7                                          ) then
C +
C +    ***********
       call TIMcor
C +    ***********
C +
       zeta = (gplvDY(i,j,mz)-gplvDY(i,j,mzz)) / (gravit*SLlmol(i,j,1))
C +
       write(4,980)jdplus,mmplus,jhlrGE(i,j),minuGE,i,j
 980   format(/,' Open-Ocean Model ',i2,'/',i2,1x,i2,'h',i2,'LT',
     .                                ' -- Grid Point (',i5,',',i5,')',
     . /,' ==========================================================')
       write(4,981)            tsrfSL(i,j,1),1.d2*albeSL(i,j)
       write(4,984) RAdsol(i,j),   firmSL(i,j),  firdSL(i,j)
       write(4,982) uairDY(i,j,mz),vairDY(i,j,mz),ssvSL(i,j,mz),zeta
       write(4,985) 1.d3*SL_z0(i,j,1),1.d3*SL_r0(i,j,1)
       write(4,983)      cdhSL(i,j,1),
     .                  SLuusl(i,j,1),SLutsl(i,j,1),1.d3*SLuqsl(i,j,1)
       write(4,987) 100*relhum,qvapSL(i,j),hsenSL(i,j),hlatSL(i,j)
       write(4,991) roseSL(i,j),eg
       write(4,992) 1.d2*hsnoSL(i,j)
       write(4,988) hbalSL(i,j)
C +
 981   format('           ',  8x ,4x,'   Tg(Ocea)=',f7.2,2x,
     .        '   Albedo =',f7.2,2x,'           ', 12x )
 984   format(' RS (Dwn.)=', f8.2,4x,'   IR  (Up)=',f7.2,2x,
     .        '   IR(Dwn)=',f8.2,2x)
 982   format(' u (S.Lay)=', f8.2,4x,'   v(S.Lay)=',f7.2,2x,
     .        '   | V |  =',f7.2,2x,'   zeta   =',f12.6)
 985   format(' WATER    :',12x,     '   z0      =',f9.4,
     .        '   r0     =',f9.4,23x,'(X 1000)')
 983   format(' Comp.DRAG=',f12.6,   '    u *    =',f9.4,   
     .        '   u th * =',f9.4,   '   u q *  =',f12.6,'(X 1000)')
 987   format(' Rela.Hum.=', f8.2,4x,'   q(Surf.)=',f9.4,   
     .        '   H0     =',f7.2,2x,'   HL     =', f8.2)
 991   format('           ',     13x,'  Dew     =',f9.4,   
     .        '           ', 9x ,   '   eg     =',f12.6)
 992   format(44x,'   H Snow =',f8.2,'cm')
 988   format(' Ener.Bal.=',f8.2) 
C +
      end if
      return
      end
      subroutine SRFfrm_sice
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            19-09-2001  MAR |
C |   SubRoutine SRFfrm_sice computes surface energy balance of SEA ICE    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Deardorff,       1978, JGR    83, pp.1889--1903             |
C |   ^^^^^^^^ Thom and Oliver, 1977, QJRMS 103, pp. 345-- 357             |
C |                                                                        |
C |   ASSUMPT. Sea Ice is assumed to be covered by snow                    |
C |   ^^^^^^^^                                                             |
C |                                                                        |
C |   ASSUMPT. SRFfrm_sice is active every dtPhys and                      |
C |   ^^^^^^^^             gives a surface temperature increment over dt   |
C |                              for  next dtPhys period                   |
C |                                                                        |
C |   INPUT  : sol_SL(mx,my)   : Absorbed Solar Flux(+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ RAd_ir(mx,my)   : Downward    IR Flux(+ <=> Downward)(W/m2) |
C |            albeSL(mx,my)   : Surface Albedo                            |
C |            eps0SL(mx,my)   : Surface IR Emissivity                     |
C |            tsrfSL(mx,my,mw): Surface   Temperature                 (K) |
C |            t2_SL (mx,my)   : Deep      Temperature                 (K) |
C |            d1_SL (mx,my)   : rhos * cs *(depth diurnal wave)  (J/m2/K) |
C |                                                                        |
C |   OUTPUT : firdSL(mx,my)   : Atmospheric IR Flux(+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ firmSL(mx,my)   : Surface     IR Flux(+ <=>   Upward)(W/m2) |
C |            hsenSL(mx,my)   : Sensible  Heat Flux(+ <=> Downward)(W/m2) |
C |            hlatSL(mx,my)   : Latent    Heat Flux(+ <=> Downward)(W/m2) |
C |         => SLuqsl(i,j,1)   : Water Vapor Flux from Surface (kg.m/kg/s) |
C |            hbalSL(mx,my)   : Sum Atmospher. Flux(+ <=>Surf.Loss)(W/m2) |
C |         =>  dtgSL(mx,my,mw): Surface Temperature Change over dt    (K) |
C |         =>  t2_SL(mx,my)   : Deep      Temperature                 (K) |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_RA.inc'
C +
      include 'MAR_SL.inc'
c #PO include 'MAR_PO.inc'
C +
      include 'MAR_IO.inc'
C +
      real     qsat0D
C +
C +
C +--Local  Variables
C +  ================
C +
      real     xf(2),yf(2)
C +
      integer  lsf
      real     radnet,rho10m,qst   ,qso   ,qsa   ,relhum,pr    ,rhos  
      real     eg    ,ego   ,fup0  ,fup1  ,fup2  ,tpx   ,t6min ,dmel
      real     rcdi  ,cdhi  ,faci  ,zeta
c #PO real     cool
C +
      real     apha  ,beta    
C +
C +
C +--DATA
C +  ====
C +
      data apha/.5e0/,beta/.5e0/
C +...     apha  and  beta  are Numerical Parameters
C +
C +--Snow Accumulation
C +  =================
C +
      hsnoSL(i,j) = hsnoSL(i,j) + snobSL(i,j) + snohSL(i,j)
      snobSL(i,j) = zero
      snohSL(i,j) = zero
C +
C +
C +--Surface Heat Fluxes (Sea Ice)
C +  ===================
C +
C +--Total Radiative Downward Heat Flux
C +  ----------------------------------
C +
      RAdsol(i,j) = sol_SL(i,j)/(1.d0-albeSL(i,j))
      firdSL(i,j) = RAd_ir(i,j)*      eps0SL(i,j)
      radnet      = sol_SL(i,j)     + firdSL(i,j) 
     .            - eps0SL(i,j)*stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .                                *tsrfSL(i,j,1)*tsrfSL(i,j,1)
C +
C +
C +--Sensible Heat Flux
C +  ------------------
C +
      rho10m     = rolvDY(i,j,mz)*1000.d0
C +...rho10m     : specific mass at first Sigma Level (kg/m3)
C +
      hsenSL(i,j)=-rho10m*cp*SLutsl(i,j,1)
C +
C +
C +--Evaporation
C +  -----------
C +
                                                                 lsf = 1
      qst    = qsat0D(tsrfSL(i,j,1) ,unun,     pstDY(i,j),ptopDY,lsf)
C +
                                                                 lsf = 0
      if (nSLsrf(i,j).eq.2) 
     .qso    = qsat0D(tsrfSL(i,j,2) ,unun,     pstDY(i,j),ptopDY,lsf)
      qsa    = qvswDY(i,j,mz)
      relhum = qvDY(i,j,mz) / qsa
C +
      pr     = (pstDY(i,j)+ptopDY)      * 1.d1
      rhos   =  pr/(RDryAi*TairSL(i,j)) * 1.d2
C +
C +--Water Vapor Flux at Ice-Atmosphere Interface (Bulk Aerodynamic Formula)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      eg  = rho10m*cdhSL(i,j,1)*SLuusl(i,j,1) *(qst-qvDY(i,j,mz))
c _UQ eg  = rho10m*ch0SL(i,j  )* ssvSL(i,j,mz)*(qst-qvDY(i,j,mz))
C +UQ eg  =-rhos  *SLuqsl(i,j,1)
C +UQ     : When   u q *  is computed used flux profile relationships 
C +         (e.g. Duynkerke and van den Broecke, 1993)
C +
      if (nSLsrf(i,j).eq.2) 
     .ego = rho10m*cdhSL(i,j,2)*SLuusl(i,j,2) *(qso-qvDY(i,j,mz))
C +
C +--Latent Heat Flux
C +  ~~~~~~~~~~~~~~~~
      SLuqsl(i,j,1)=  - eg / rhos
      if (nSLsrf(i,j).eq.2) 
     .SLuqsl(i,j,2)=  - ego/ rhos
C +
      hlatSL(i,j)  =    eg * Ls_H2O
      roseSL(i,j)  =    roseSL(i,j) - eg * dtPhys / ro_Wat
      roseSL(i,j)  =max(roseSL(i,j),zero)
C +
C +
C +--Sea-Ice Energy Balance Model (Deardorff, 1978)
C +  ============================ (Implicit Numerical Scheme) -
C +                               ============================= 
C +
      fup0= eps0SL(i,j)*stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)*tsrfSL(i,j,1)
      fup1=-3.d0*fup0                                     *tsrfSL(i,j,1)
      fup2= 4.d0*fup0                                    
C +...fup1+fup2*tsrfSL(t+dt) : 1st order Taylor Serie Expansion 
C +   of upward IR Flux (stefan * tsrfSL**4)
C +
      xf(1) = -3.72d0*(fup1 +hsenSL(i,j) +hlatSL(i,j) 
     .                      -sol_SL(i,j) -firdSL(i,j)) /d1_SL(i,j)
      yf(1) = -7.4d0 *(     - t2_SL(i,j)             ) /cs2SL
      xf(2) = -3.72d0*(fup2                          ) /d1_SL(i,j)
      yf(2) = -7.4d0                                   /cs2SL
      tpx   = (tsrfSL(i,j,1)*(1.d0+beta*(xf(2)+yf(2))*dtPhys)
     .                                 +(xf(1)+yf(1))*dtPhys)
     .      /                (1.d0-apha*(xf(2)+yf(2))*dtPhys)
C +...Caution: Sea-Ice is assumed to be covered with snow, 
C +            and snow parameters are used here to define   d1_SL(i,j)
C +
C +--Snow Melting 
C +  ------------
C +
        dtgSL(i,j,1) = (tpx   -tsrfSL(i,j,1))*dt/dtPhys
       t6min         =  tpx
C +... t6min:           extrapolated new temperature after period dtPhys
C +
      if (t6min.ge.TfSnow) then
       fmelSL(i,j)   = d1_SL(i,j)/(3.72d0*dtPhys)    *(t6min-TfSnow)
     .      *                (1.d0-apha* xf(2)       *dtPhys)
C +... fmelSL(i,j)   :snow melting flux                                (W/m2)
C +
       dmel          = fmelSL(i,j)*dtPhys/(ro_Wat*Lf_H2O)
C +
        dtgSL(i,j,1) =(TfSnow-tsrfSL(i,j,1)) *dt/dtPhys
       tpx           = TfSnow
      else
       fmelSL(i,j)   = 0.d0
       dmel          = 0.d0
      end if
C +
      firmSL(i,j)    = fup1 + (apha*tpx+beta*tsrfSL(i,j,1)) *fup2
      hbalSL(i,j)    = firmSL(i,j) + hsenSL(i,j) + hlatSL(i,j) 
     .               - sol_SL(i,j) - firdSL(i,j)
C +
C +
C +--Temperature below the Surface / Sea-Ice vertical Accretion 
C +  ----------------------------------------------------------
C +
c #PO if (polmod) then
c #PO  rcdi  = C__Wat *ro_Ice * hicePO(i,j)
c #PO  cdhi  =         cdsice / hicePO(i,j)
c #PO else
       rcdi  = C__Wat *ro_Ice * hic0
       cdhi  =         cdsice / hic0
c #PO end if
       faci  =         cdhi   / rcdi             
C +
      t2_SL(i,j)=   (t2_SL(i,j) *(1.d0               -beta*faci *dtPhys) 
     .           +(faci*tfrwat  -(hbalSL(i,j)+fmelSL(i,j))/rcdi)*dtPhys)
     .                          /(1.d0               +apha*faci *dtPhys)
C +...One-Layer Model for t2_SL
C +
c #PO cool        = cdhi   * (tfrwat-t2_SL(i,j)) 
c #PO focnPO(i,j) = cool + fracoh * max(zero,cool)
C +...                     fracoh = 0.25
C +***Hibler (1984), Ocean Heat Flux: 25% of cooling (ANTARCTIC Ocean)
C +   (Hansen and Takahashi Eds) 
C +   Geophys. Monogr. 29, M. Ewing Vol. 5, AGU, p. 241
C +
c #PO   hicePO(i,j) = hicePO(i,j) + focnPO(i,j) *dtPhys/ siclf
c #PO   hicePO(i,j) = max(zero,hicePO(i,j))
C +
C +
C +--`Surface' Specific Humidity
C +  ---------------------------
C +
      qvapSL(i,j) = qst
C +
C +
C +--Output on Listing if IO_loc .ge. 3
C +  ==================================
C +
      if ((((IO_loc.ge.3.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.4.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.5)                            )       ).or.
     .       IO_loc.ge.7                                          ) then
C +
C +    ***********
       call TIMcor
C +    ***********
C +
       zeta = (gplvDY(i,j,mz)-gplvDY(i,j,mzz)) / (gravit*SLlmol(i,j,1))
C +
       write(4,980)jdplus,mmplus,jhlrGE(i,j),minuGE,i,j
 980   format(/,' Sea-Ice Model ',i2,'/',i2,1x,i2,'h',i2,'LT',
     .                              ' -- Grid Point (',i5,',',i5,')',
     .  /,' =======================================================')
C +
       write(4,981) t2_SL(i,j),tsrfSL(i,j,1),1.d2*albeSL(i,j),d1_SL(i,j)
       write(4,982) RAdsol(i,j),sol_SL(i,j),     firmSL(i,j),firdSL(i,j)
       write(4,983) uairDY(i,j,mz),vairDY(i,j,mz),ssvSL(i,j,mz),zeta
c #PO if (polmod) then
c #PO  write(4,984) 1.d2*hicePO(i,j),1.d3*SL_z0(i,j,1),1.d3*SL_r0(i,j,1)
c #PO else
       write(4,984) 1.d2*hic0       ,1.d3*SL_z0(i,j,1),1.d3*SL_r0(i,j,1)
c #PO end if
       write(4,985) cdhSL(i,j,1),
     .             SLuusl(i,j,1),    SLutsl(i,j,1),  1.d3*SLuqsl(i,j,1)
       write(4,986) 1.d2*relhum,qvapSL(i,j),hsenSL(i,j),  hlatSL(i,j)
       write(4,991)             hbalSL(i,j), dtgSL(i,j,1),roseSL(i,j),eg
       write(4,992) 1.d2*hsnoSL(i,j)
C +
       if (SLsrfl(i,j,2).gt.zero) then
        write(4,987) SLsrfl(i,j,2),1.d3*SL_z0(i,j,2) 
        write(4,988) SLuusl(i,j,2),SLutsl(i,j,2),1.d3*SLuqsl(i,j,2)
        write(4,989)    -rho10m*cp*SLutsl(i,j,2),
     .                                   -rhos*Ls_H2O*SLuqsl(i,j,2)
        write(4,990) SLuus (i,j)  ,SLuts (i,j)  ,1.d3*SLuqs (i,j)  
       end if
C +
 981   format(' T2 (Deep)=', f8.2,4x,'   Tg(SIce)=',f7.2,2x,
     .        '   Albedo =',f7.2,2x,'   r.c.d1 =  ',e12.4)
 982   format(' RS (Dwn.)=', f8.2,4x,'   RS(Abs.)=',f7.2,2x,
     .        '   IR (Up)=',f7.2,2x,'   IR(Dwn)=',f8.2,2x)
 983   format(' u (S.Lay)=', f8.2,4x,'   v(S.Lay)=',f7.2,2x,
     .        '   | V |  =',f7.2,2x,'   zeta   =',f12.6)
 984   format(' SEA ICE  : Hi/cm=',f5.1,  '   z0      =',f9.4,
     .        '   r0     =',f9.4,23x,'(X 1000)')
 985   format(' Comp.DRAG=',f12.6,   '    u *    =',f9.4,   
     .        '   u th * =',f9.4,   '   u q *  =',f12.6,'(X 1000)')
 986   format(' Rela.Hum.=', f8.2,4x,'   q(Surf.)=',f9.4,   
     .        '   H0     =',f7.2,2x,'   HL     =', f8.2)
 991   format(' Energ.B. =', f8.2,4x,'   d (Tg)  =',f9.4,   
     .        '   Rime   =',f9.4,   '   eg     =',f12.6)
 992   format(44x,'   H Snow =',f8.2,'cm')
 987   format(' POLYNYA  : Frac.=',f5.3,  '   z0      =',f9.4,
     .        '           ', 9x ,23x,'(X 1000)')
 988   format(               23x ,   '    u *    =',f9.4,   
     .        '   u th * =',f9.4,   '   u q *  =',f12.6,'(X 1000)')
 989   format('           ',     12x,'            ', 9x,    
     .        '   H0     =',f7.2,2x,'   HL     =', f8.2)
 990   format(' POLYNYA/SEA-ICE AVERAGE:  u *    =',f9.4,   
     .        '   u th * =',f9.4,   '   u q *  =',f12.6,'(X 1000)')
C +
      if (jhurGE.eq.0.and.minuGE.eq.0) then
       hmelSL(i,j)=            dmel
      else
       hmelSL(i,j)=hmelSL(i,j)+dmel
C +... hmelSL     :cumulative snowmelt height       (m water equivalent)
C +
      end if
C +
      end if
      return
      end
      subroutine SRFfrm_sno
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            16-09-2001  MAR |
C |   SubRoutine SRFfrm_sno computes the surface energy balance over SNOW  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Deardorff,       1978, JGR    83, pp.1889--1903             |
C |   ^^^^^^^^ Thom and Oliver, 1977, QJRMS 103, pp. 345-- 357             |
C |                                                                        |
C |   ASSUMPT. SRFfrm_sno  is active every dtPhys and                      |
C |   ^^^^^^^^             gives a surface temperature increment over dt   |
C |                              for  next dtPhys period                   |
C |                                                                        |
C |   INPUT  : sol_SL(mx,my)  : Absorbed Solar Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ RAd_ir(mx,my)  : Downward    IR Flux (+ <=> Downward)(W/m2) |
C |            albeSL(mx,my)  : Surface Albedo                             |
C |            eps0SL(mx,my)  : Surface IR Emissivity                      |
C |            tsrfSL(mx,my,1): Surface   Temperature                  (K) |
C |            t2_SL (mx,my)  : Deep      Temperature                  (K) |
C |            d1_SL (mx,my)  : rhos * cs *(depth diurnal wave)   (J/m2/K) |
C |             ex.: SNOW: 330kg/m3 *2000J/kg/K *sqrt(0.27e-6m2/s *86400s) |
C |                                                                        |
C |   OUTPUT : firdSL(mx,my)  : Atmospheric IR Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ firmSL(mx,my)  : Surface     IR Flux (+ <=>   Upward)(W/m2) |
C |            hsenSL(mx,my)  : Sensible  Heat Flux (+ <=> Downward)(W/m2) |
C |            hlatSL(mx,my)  : Latent    Heat Flux (+ <=> Downward)(W/m2) |
C |         => SLuqsl(i,j,1)  : Water Vapor Flux from Surface  (kg.m/kg/s) |
C |            hbalSL(mx,my)  : Sum Atmospher. Flux (+ <=>Surf.Loss)(W/m2) |
C |         =>  dtgSL(mx,my,1): Snow Surface Temperature Change over dt(K) |
C |         =>  t2_SL(mx,my)  : Deep      Temperature                  (K) |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_RA.inc'
C +
      include 'MAR_SL.inc'
C +
      include 'MAR_IO.inc'
C +
      real     qsat0D
C +
C +
C +--Local  Variables
C +  ================
C +
      real     xf(2),yf(2)
C +
      integer  lsf
      real     radnet,rho10m,qst   ,qsa   ,relhum,pr    ,rhos  ,egdd
      real     gamp  ,aqsat ,dqsat ,qs10  ,den   ,dnum  ,egpm  ,eg
      real     fup0  ,fup1  ,fup2  ,tpx   ,t6min ,dmel  ,zeta
C +
      real     apha  ,beta
      logical  qpm
C +
C +
C +--DATA
C +  ====
C +
      data     apha/.5e0/,beta/.5e0/
      data     qpm /.false./
C +
C +
C +--Snow Accumulation
C +  =================
C +
      if (snohSL(i,j).gt.0.d0) then
           ro_SL(i,j) =  0.d0
          SaltSL(i,j) =  0.38
C +...    SaltSL      :  Threshold Friction Velocity for Blowing Snow 
C +                      (Budd et al., 1966, Byrd Snow Project)
      end if
C +
          hsnoSL(i,j) =  hsnoSL(i,j) + snobSL(i,j) + snohSL(i,j)
          snobSL(i,j) =  zero
          snohSL(i,j) =  zero
C +
C +
C +--Surface Heat Fluxes
C +  ===================
C +
C +
C +--Total Radiative Downward Heat Flux
C +  ----------------------------------
C +
      RAdsol(i,j) = sol_SL(i,j)/(1.d0-albeSL(i,j))
      firdSL(i,j) = RAd_ir(i,j)*      eps0SL(i,j)
      radnet      = sol_SL(i,j)     + firdSL(i,j) 
     .            - eps0SL(i,j)*stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .                                *tsrfSL(i,j,1)*tsrfSL(i,j,1)
C +
C +--Sensible Heat Flux
C +  ------------------
C +
      rho10m     = rolvDY(i,j,mz)*1000.d0
C +...rho10m     : specific mass at first Sigma Level (kg/m3)
C +
      hsenSL(i,j)=-rho10m*cp*SLutsl(i,j,1)
C +
C +
C +--Evaporation
C +  -----------
C +
      qst    = qvsiDY(i,j,mzz)
C +...qst    : saturation specific humidity, surface (kg/kg)
C +
      qsa    = qvswDY(i,j,mz)
      relhum = qvDY(i,j,mz) / qsa
C +
      pr     = (pstDY(i,j) +ptopDY)     * 1.d1
      rhos   =  pr/(RDryAi*TairSL(i,j)) * 1.d2
C +
C +--Water Vapor Flux at Snow-Atmosphere Interface (Bulk Aerodynamic Formula)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      egdd= rho10m*cdhSL(i,j,1)*SLuusl(i,j,1) *(qst-qvDY(i,j,mz))
c _UQ egdd= rho10m*ch0SL(i,j  )* ssvSL(i,j,mz)*(qst-qvDY(i,j,mz))
C +UQ egdd=-rhos  *SLuqsl(i,j,1)
C +UQ     : When   u q *  is computed used flux profile relationships 
C +         (e.g. Duynkerke and van den Broecke, 1993)
C +
C +--Water Vapor Flux at Snow-Atmosphere Interface (Thom & Oliver, 1977)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      gamp = 4.08d-04*(1.d0+rsurSL(i,j)/raerSL(i,j))
C +...rsurSL : `bulk' stomatal resistance (Thom & Oliver, 1977, p. 347)
C +...raerSL : aerodynamic resistance (computed in routine TURsbl)
C +
      aqsat= 1.d0/(237.3d0+tairDY(i,j,mz))
      dqsat= qst*4098.d0*aqsat*aqsat
      den  = dqsat+gamp
      qs10 = qsat0D(tairDY(i,j,mz),sigma(mz),pstDY(i,j),ptopDY,lsf)
C +...qs10 : saturation specific humidity, 1st Sigma Level (kg/kg) 
C +
      dnum = (radnet*.9d0)*dqsat 
     .     + rhos*cp*(qs10-qvDY(i,j,mz))/raerSL(i,j)
      egpm = dnum/den/Ls_H2O
C +
      if (qpm) then
       eg = egpm
      else
       eg = egdd
      end if
C +
C +--Latent Heat Flux
C +  ~~~~~~~~~~~~~~~~
      SLuqsl(i,j,1)=  - eg / rhos
      hlatSL(i,j)  =    eg * Ls_H2O
      roseSL(i,j)  =    roseSL(i,j) - eg * dtPhys / ro_Wat
      roseSL (i,j) =max(roseSL(i,j),zero)
C +
C +
C +--Soil Energy Balance Model (Deardorff(1978, JGR, p.1891)
C +  ========================= (Implicit Numerical Scheme) -
C +                           ============================= 
C +
      fup0= eps0SL(i,j)*stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)*tsrfSL(i,j,1)
      fup1=-3.d0*fup0                                     *tsrfSL(i,j,1)
      fup2= 4.d0*fup0                                    
C +...fup1+fup2*tsrfSL(t+dt) : 1st order Taylor Serie Expansion 
C +   of upward IR Flux (stefan * tsrfSL**4)
C +
      xf(1) = -3.72d0*(fup1 +hsenSL(i,j) +hlatSL(i,j) 
     .                      -sol_SL(i,j) -firdSL(i,j)) /d1_SL(i,j)
      yf(1) = -7.4d0 *(     - t2_SL(i,j)             ) /cs2SL
      xf(2) = -3.72d0*(fup2                          ) /d1_SL(i,j)
      yf(2) = -7.4d0                                   /cs2SL
      tpx   = (tsrfSL(i,j,1)*(1.d0+beta*(xf(2)+yf(2))*dtPhys)
     .                                 +(xf(1)+yf(1))*dtPhys)
     .      /                (1.d0-apha*(xf(2)+yf(2))*dtPhys)
C +
C +
C +--Snow Melting 
C +  ------------
C +
        dtgSL(i,j,1) = (tpx   -tsrfSL(i,j,1))*dt/dtPhys
       t6min         =  tpx
C +... t6min:           extrapolated new temperature after period dtPhys
C +
      if (t6min.ge.TfSnow) then
       fmelSL(i,j)   = d1_SL(i,j)/(3.72d0*dtPhys)    *(t6min-TfSnow)
     .                      *(1.d0-apha *xf(2)       *dtPhys)
C +... fmelSL(i,j)   :snow melting flux                                (W/m2)
C +
       dmel          = fmelSL(i,j)*dtPhys/(1000.d0*3.34d5)
        ro_SL(i,j)   = ro_SL0(i,j)
       SaltSL(i,j)   = 1.d2
C +... SaltSL: Here an impossible Value
C +           (Preclude Saltation)
        dtgSL(i,j,1) =(TfSnow-tsrfSL(i,j,1))*dt/dtPhys
       tpx           = TfSnow
      else
       fmelSL(i,j)   = 0.d0
       dmel          = 0.d0
      end if
C +
      firmSL(i,j)    = fup1 + (apha*tpx+beta*tsrfSL(i,j,1)) *fup2
      hbalSL(i,j)    = firmSL(i,j) + hsenSL(i,j) + hlatSL(i,j) 
     .               - sol_SL(i,j) - firdSL(i,j)
C +
C +
C +--Snow Deep Layer Temperature
C +  ---------------------------
C +
      xf(1)     =    xf(1) -3.72d0 *fmelSL(i,j) /d1_SL(i,j)
      t2_SL(i,j)=   (t2_SL(i,j) *(1.d0+beta* xf(2)*0.0141d0*dtPhys)
     .                                     + xf(1)*0.0141d0*dtPhys)
     .          /                (1.d0-apha* xf(2)*0.0141d0*dtPhys)
C +***Deardorff 1978, (9) p.1891,    with 0.0141 = 1 / (3.72 * sqrt(365))
C +
C +
C +--`Surface' Specific Humidity
C +  ---------------------------
C +
      qvapSL(i,j) = qst
C +
C +
C +--Output on Listing if IO_loc .ge. 3
C +  ==================================
C +
      if ((((IO_loc.ge.3.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.4.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.5)                            )       ).or.
     .       IO_loc.ge.7                                          ) then
C +
C +    ***********
       call TIMcor
C +    ***********
C +
       zeta = (gplvDY(i,j,mz)-gplvDY(i,j,mzz)) / (gravit*SLlmol(i,j,1))
C +
       write(4,980)jdplus,mmplus,jhlrGE(i,j),minuGE,i,j
 980   format(/,' Snow F.R. Model ',i2,'/',i2,1x,i2,'h',i2,'LT',
     .                              ' --    Grid Point (',i5,',',i5,')',
     ./,' ============================================================')
C +
       write(4,988) t2_SL(i,j),tsrfSL(i,j,1),1.d2*albeSL(i,j),d1_SL(i,j)
       write(4,984) RAdsol(i,j),sol_SL(i,j),     firmSL(i,j),firdSL(i,j)
       write(4,982) uairDY(i,j,mz),vairDY(i,j,mz),ssvSL(i,j,mz),zeta
       write(4,985) 1.d3*SL_z0(i,j,1), 1.d3*SL_r0(i,j,1)
       write(4,983)      cdhSL(i,j,1),
     .                  SLuusl(i,j,1),SLutsl(i,j,1),1.d3*SLuqsl(i,j,1)
       write(4,987) 1.d2*relhum,qvapSL(i,j),hsenSL(i,j),hlatSL(i,j)
       write(4,991) hbalSL(i,j),      dtgSL(i,j,1),roseSL(i,j),egdd
       write(4,992) fmelSL(i,j),1.d2*hmelSL(i,j)  ,egpm
       write(4,993)             1.d2*hsnoSL(i,j)
 988   format(' T2 (Deep)=', f8.2,4x,'   Tg(Snow)=',f7.2,2x,
     .        '   Albedo =',f7.2,2x,'   r.c.d1 =  ',e14.4)
 984   format(' RS (Dwn.)=', f8.2,4x,'   RS(Abs.)=',f7.2,2x,
     .        '   IR (Up)=',f7.2,2x,'   IR(Dwn)=',f8.2,2x)
 982   format(' u (S.Lay)=', f8.2,4x,'   v(S.Lay)=',f7.2,2x,
     .        '   | V |  =',f7.2,2x,'   zeta   =',f12.6)
 985   format(' SNOW     :',12x,     '   z0      =',f9.4,
     .        '   r0     =',f9.4,23x,'(X 1000)')
 983   format(' Comp.DRAG=',f12.6,   '    u *    =',f9.4,   
     .        '   u th * =',f9.4,   '   u q *  =',f12.6,'(X 1000)')
 987   format(' Rela.Hum.=', f8.2,4x,'   q(Surf.)=',f9.4,   
     .        '   H0     =',f7.2,2x,'   HL     =', f8.2)
 991   format(' Energ.B. =', f8.2,4x,'   d (Tg)  =',f9.4,   
     .        '   Rime   =',f9.4,   '   eg(D.) =',f12.6)
 992   format(' Fmel     =', f8.2,4x,'   Cumulative SnowMelt H',  
     .           ' (cmWE):',f8.3,  '    eg(P.) =',f12.6)
 993   format('           ',     12x,'   Cumulative SnowPrec H',  
     .           ' (cm**):',f8.3)
C +
      end if
C +
      if (jhurGE.eq.0.and.minuGE.eq.0) then
       hmelSL(i,j) =                dmel
      else
       hmelSL(i,j) =  hmelSL(i,j) + dmel
C +... hmelSL      :  cumulative snowmelt height (m water equivalent)
C +
      end if
C +
       fmelSL(i,j) = -fmelSL(i,j)
C +... fmelSL(i,j) :  sign convention: fmelSL(i,j) is a heat loss
C +
      return
      end
      block data SRFdat_sno
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            15-01-2002  MAR |
C |   Block Data SRFdat_sno defines physical constants of the SNOW MODEL   |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARdim.inc'
C +
c #sn include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'
C +
C +
C +--DATA
C +  ====
C +
c #sn data    h0SNo  /3.00e-2/
C +...        h0SNo:  Thickness     of the upper Snow Layer             [m]
C +
c #sn data    zxSNo  /1.00e+2/
C +...        zxSNo:  Maximum Depth of the       Snow Model             [m]
C +
c #sn data    gSNmax  /3.0e-3/
C +...        gSNmax:  Maximum Grain Size                               [m]
C +
c #sn data    vg1SNo/ 99.e0/
C +...        vg1SNo: Conversion 0/99 --> 0/1 pour Sphericite et Dendricite
C +
c #sn data    dtSNh  / 3.6e+3/
C +...        dtSNh: Time Step for Settling and Metamorphism (3600.sec)
C +
c #sn data    taSNo  / 6.0e+4/
c #sn data    tfSNo  / 0.3e00/
c #sn data    teSNo  /23.0e00/
C +...        taSNo, tfSNo and teSNo are Snow Settling Parameters
C +***             (see Brun et al. 1989, JGl 35 121,              p.334)
C +
c #sn data    roSNf  / 300.e0/
C +...        roSNf:  Maximum Density of Blown Snow                 [kg/m3]
C +***             (see Greuell and Konzelmann 1994, Glob. Plan. Change 9,
C +***                  Zuo     and Oerlemans  1995, J.Gla.,in press,p.14,
C +                     Zuo     and Oerlemans  1996, J.Gla., 42, 305--317)
C +
c #sn data    waSN   / 200.e0/
C +...        waSN:    200 mm: Melt Water Scaling Factor (Slush Albedo)
C +***             (see Zuo     and Oerlemans  1995, J.Gla.,in press,p.24,
C +                     Zuo     and Oerlemans  1995, J.Gla., 42, 305--317)
C +
c #sn data    w0SNo  /0.07d00/  
c +CP data    w0SNo  /0.10d00/                        
C +...        w0SNo:  Snow Layer Maximum Water Content         [%Pore Vol.]
C +***        w0SNo=.10:Brun et al. 1989, J.Glac. 35, p.   334, 
C +***        w0SNo=.07:ETH Camp
C +***        w0SNo=.05:CROCUS
C +***        w0SNo=.04:Rowe et al. 1995, JGR 100 D8, p. 16267, 
C +                                       col. 1 last 4rd line)
C +
c #sn data    asluSN  / 0.45e0/
C +...        asluSN:  Slush Albedo
C +
c #sn data    aiceSN  / 0.55e0/
C +...        aiceSN:  Ice   Albedo
C +
c #sn data    DiEtSN  / 1.00e0/
C +...        DiEtSN:  Diametre opt. Etoile /          + Optical Diameter
C +
c #sn data    DiGfSN  / 3.00e0/
C +...        DiGfSN:  Diametre opt. Grain fin/        . Optical Diameter
C +
c #sn data    DiFcSN  / 4.00e0/
C +...        DiFcSN:  Diametre opt. jeune Face plane/ # Optical Diameter
C +
c #sn  data   den1SN / 17.12e0/
c #sn  data   den2SN /128.00e0/
c #sn  data   den3SN /-20.00e0/
C +...        den1SN,2,3:      Coefficients Formule "GIRAUD" 
C +                                         Dendricite Neige Fraiche
C +
c #sn  data   sph1SN /  7.87e0/
c #sn  data   sph2SN / 38.00e0/
c #sn  data   sph3SN / 50.00e0/
c #sn  data   sph4SN / 90.00e0/
C +...        sph1SN,2,3,4:    Coefficients Formule "GIRAUD"
C +                                         Sphericite Neige Fraiche
C +
c #sn  data   rho1SN / 0.109e3/              
c #sn  data   rho2SN / 0.006e3/              
c #sn  data   rho3SN / 0.026e3/              
c #sn  data   rh12SN / 0.500e0/
C +...        rho1SN,2,3,12:   Coefficients Formule "PAHAUT" 
C +                                         Densite    Neige Fraiche
C +
c #sn  data   rh10SN / 0.850e3 / 
C +...        rh10SN:   Seuil  Densite pour Densification neige si Eau
C +
c #sn  data   rh11SN / 0.250e0 / 
C +...        rh11SN:   Densite       modif Viscosite           si Neige humide
C +
c #sn data    nhSNo1/1/,  nhSNo2/2/,  nhSNo3/3/,  nhSNo4/4/, nhSNo5/5/
C +...        Reperes pour caracteriser l'Historique d'une Couche de Neige
C +
c #sn data    SNmdz1 / 1.00e00/, SNmdz2 /100.00e00/
c #sn data    SNmdz3 / 1.50e00/, SNmdz4 /  4.00e00/
c #sn data    SNmdz5 /20.00e00/, SNmdz6 / 50.00e00/
c #sn data    SNmdz7 / 1.20e00/, SNmdz8 /  0.60e00/
C +...        for aggregation criterion   (    dz)
C +
c #sn data    SNtyp1 / 2.00e+1/, SNtyp2 /  2.00e00/
c #sn data    SNtyp3 / 3.70e+1/, SNtyp4 /  5.00e00/
c #sn data    SNtyp5 / 1.00e00/, SNtyp6 /400.00e00/
C +...        for aggregation criterion   (* type)
C +
c #sn data    SNdag1 / 1.50e00/, SNdag2 / 10.00e00/
c #sn data    SNdag3 / 9.00e00/, SNdag4 / 37.00e00/
c #sn data    SNdag5 / 1.00e00/, SNdag6 /200.00e00/
C +...        for aggregation criterion   (*  age)
C +
c #sn data    fcSNo  /-7.8e00/
C +...             (see Male        1980,            (96)          p.376
C +***               in Dynamics of Snow and Ice Masses, S. Colbeck Ed.)
C +
c #sn data    roiwSN / 920.e-3/
C +...        roiwSN: Density Ratio (Ice / Water)                       [-]
C +
c #sn data    c1SNo/12.9600e+4/,c2SNo/2.160e+6/,c3SNo/1.400e+2/
C +   data    c1SNo/2.796e+4/,c2SNo/2.160e+6/,c3SNo/1.400e+2/
C +...        Run Off Parameters 
C +           86400*1.5 day     ...*25 days (Modif. ETH Camp: 86400*0.3day)
C +***        (Zuo and Oerlemans 1995, J.Glacio. in press, p.14(22) & p.15)
C +           (Zuo and Oerlemans 1996, J.Glacio. 42, 305--317)
C +
c #sn data    viwaSN / 1.0e-6/
C +...        viwaSN: Kinematic Viscosity of Water at 20.C           [m2/s]
C +
c #sn data    gethSN /0.0e0/
C +...        gethSN: Deep Soil  Heat Flux                           [W/m2]
C +
c #sn data    epSN1  /1.0e-1/
C +
      end
      subroutine SRFini_sno
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            21-03-2002  MAR |
C |   SubRoutine SRFini_sno initialises the SNOW MODEL                     |
C |                                     over the Antarctic Ice Sheet       |
C +------------------------------------------------------------------------+
C |                                                                        |
C | # OPTIONS:                                                             |
C | # ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
c #BS include 'MAR_BS.inc'
C +
      include 'MAR_SL.inc'
c #sn include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'
C +
      include 'MAR_IO.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      integer   nb_ice,idtPh ,idtsn ,mgi   ,mh1   ,n     
      integer   nb_sno,nprec ,nk    ,nj    ,ni    ,nbhour
      real      timyr ,timyr0,ts_yrm,dtsyrm
      real      rrsno ,rmg01 ,rxsno ,drsno 
      real      ts0   ,dtset ,t2_SL0
      real      PrecLa,hprec ,rprec ,hardS ,zprec ,tprec
      real      ver_d ,ver_n ,ver_x ,dznew ,rate  ,ordr  
      real      r__dz ,facdz ,factim,SaltMo,SaltSU,Salt_U,Por_BS
      real      omega ,argti ,ts_yr ,diffs ,faczs ,diffi ,faczi 
      real      depth ,argzz ,albedo,roSNew,alphar,slopx ,slopy
      real      npreci(mg)
c #AB real      dopsno, dsqr,SRFdia_sno, Dirsol, Difsol 
C +
      logical   zsnINI
      real      dtsn0 ,dtwa0 ,windav,SaltMx,HypLat,slope
C +
C +
C +--DATA
C +  ====
C +
      data    zsnINI /.true./
C +
      data    dtsn0  /360.0e00/
C +...        dtsn0:  Snow       Model Time Step is 6   min             [s]
C +
      data    dtwa0  / 30.0e00/
C +...        dtwa0:  Water Flow Model Time Step is 1/6 min             [s]
C +
      data    windav / 10.0e00/
C +...        windav: Averaged Wind Velocity (huge Ice Sheets)
C +
c #BS data    SaltMx  /-5.83e-2/
C +...        SaltMx: Maximum Snow Mobility affecting Erodibility   [kg/m3]
C +
      data    HypLat/  75.0e00/
C +...        HypLat: Latitude where for Hypothetical Min Precipitation
C +
      data    slope/    1.0e00/
C +...        slope :  Cosine of the Surface slope
C +
c #sn         nb_ice =  0
C +
C +
C +--Time        Scales
C +  ==================
C +
c #sn     timyr        =((njyrGE(mmarGE)+jdarGE) *  24.d0 
c #sn.                                  +jhurGE) *  36.d2
C +
c #sn if (GElat0.gt.0.0d0) then
c #sn     timyr0       =  njyrGE( 5)             * 864.d2
c #sn else
c #sn     timyr0       =  njyrGE(11)             * 864.d2
c #sn end if
C +
C +
C +--Temperature Scales
C +  ==================
C +
c #sn     ts_yrm       = -40.d00 +70.d00 *cos(GElat0*degrad) 
c #sn.                           -6.5d-3 * sh(imez,jmez)
C +...    ts_yrm       :  Anual Mean  Surface Temperature (rough climatology)
C +
c #sn     dtsyrm       =  40.d00 -40.d00 *cos(GElat0*degrad) 
C +...    dtsyrm       :  Anual Cycle Surface Temperature (rough climatology)
C +
C +
C +--Time Step (Verification)
C +  ========================
C +
        ntSNo  =     dtPhys/dtsn0
        ntSNo  = max(iun   ,ntSNo)
        dtSNo  =     dtPhys/ntSNo
        idtPh  =     dtPhys
        idtsn  =     dtSNh
        if (mod(idtsn,idtPh).ne.0) 
     .stop'++++++++ dtPhys is improperly specified ++++++++++++++++++++'
C +
        ntwaSN =     dtSNo/dtwa0 
        ntwaSN = max(iun,  ntwaSN)
C +...  ntwaSN :Nb Iterations (for Stability in the computation of
C +                            the Water Flow in Snow Pack)
        dtwaSN =     dtSNo/ntwaSN
C +
C +
C +--Vertical Discretization
C +  =======================
C +
C +--Geometric Progression Parameter
C +  -------------------------------
C +
c #sn  mgi   = max(1,mg0)
c #sn  mh1   = max(1,mh )
C +... mg0:    Ice   Layers reference Number
C +    mg:     Total Layers reference Number
C +    mh;     Soil  Layers reference Number
C +
c #sn      rrsno = 2.0d0
c #sn      rmg01 = 1.0d0/mg1
 100   continue
c #sn      rxsno =   ((rrsno-1.0d0)*zxSNo/h0SNo)**rmg01
c #sn      drsno = abs(rrsno-rxsno)
c #sn      rrsno =           rxsno
c #sn  if (drsno.lt.epsi) go to 101
c #sn  go to 100
 101   continue
C +
C +
C +--Reference Discretisation
C +  ------------------------
C +
c #sn      znSNo(mgg)   = 0.d+0
c #sn    DO n=mg,mg0+1,-1
c #sn      dzSNo(n)     = h0SNo*rrsno**(mg -n)
c #sn      znSNo(n)     = znSNo(n+1) +dzSNo(n)
c #sn    ENDDO
c #sn  IF (mg0.gt.0)                                              THEN
c #sn    DO n=   mgi,1,-1
c #sn      dzSNo(n)     = h0SNo*rrsno**(mg0-n)
c #sn      znSNo(n)     = znSNo(n+1) +dzSNo(n)
c #sn    ENDDO
c #sn  END IF
C +
C +
C +--Snow/Ice Cover Thickness and Density Initialisation (Reference Point)
C +  =====================================================================
C +
C +--Snow Cover Building Parameters
C +  ------------------------------
C +
c #sn   ts0          =   270.0d0
c #sn   dtset        = 86400.0d0
C +...  dtset        : Settling Time Step
C +
C +
C +--Ice Sheet Temperature
C +  ---------------------
C +
c #sn   t2_SL0       =     TfSnow +   ts_yrm
C +
c #sn   PrecLa       = min(HypLat,abs(GElat0))
c #sn   hprec        =     (1.00d00 - PrecLa/90.d00)         /365.d0
C +...  Crude Climatology:  1.00mWE/yr ~30m/yr at the Equator and
C +                         0.33mWE/yr ~10m/yr at 60N and 60S
C +                         Conversion [m/yr] -> [m/day] => 1/365
C +
c #sn   rprec        =max(r0sno,
c #sn.                    rho1SN+rho2SN*    (ts_yrm)
c #sn.                          +rho3SN*sqrt(windav))
C +...  Formule "PAHAUT" Densite Neige Fraiche (CEN/CROCUS)
C +
c #HS   hardS        =           blsno 
c #HS   rprec        =max(rprec ,hardS)
C +...  Wind Hardened Snow
C +
c #sn   zprec        =    ro_Wat * hprec / rprec
C +...  Snow Thickness Increment after an Hypothetical Precipitation
C +
c #sn   tprec        =    1.0d0  / hprec
C +     tprec        : Inverse of the Precipitation Rate   [day/mWE]
C +
C +
C +--Loop on the Snow Layers
C +  -----------------------
C +
c #sn      ver_d  =   20.
c #sn  DO                 nb_sno=mg0+1,mg
c #sn      ver_n  =   mgg-nb_sno
c #sn      ver_x  =   ver_n /ver_d
C +
C +--Nb Precip. Events  in Snow Layer nb_sno
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn      nprec  =   0
c #sn      npreci(nb_sno) = tprec * ver_x * ver_x * ver_x
C +...     Bottom Snow Layer must be roughly 1 mWE thick
C +
c #sn    IF  (abs(GElat0).lt.60.d0) 
c #sn.     npreci(nb_sno) =    npreci(nb_sno)/2.d1
c #sn      npreci(nb_sno) =max(npreci(nb_sno),unun)
C +...     Limitation of the Snow Thickness outside the Ice Sheets
C +
C +--1st Occurrence     of Snow Layer nb_sno
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn       roSNo(nb_sno) =    rprec
c #sn       dzSNo(nb_sno) =    zprec
C +
C +--Precipitation occurs UNTIL Event npreci:  START
C +  ~~~~________~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 1010    continue
C +      --------
C +
C +--Surface Grains Characteristics
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn      g1SNo(nb_sno) = max(min(den1SN*windav-den2SN,den3SN),-vg1SNo)
c #sn      g2SNo(nb_sno) = min(max(sph1SN*windav-sph2SN,sph3SN), sph4SN)
C +...     Formule "GIRAUD" Dendricite, Sphericite Neige Fraiche (CEN)
C +
c #HS      g1SNo(nb_sno) =                   vg1SNo
c #HS      g2SNo(nb_sno) =                   DiGfSN
C +...     Wind Hardened Snow
C +
C +--Hypothetical Temperature Profile
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn              nk  = nb_sno+1
c #sn        znSNo(nk) = 0.0d00
c #sn      DO      nk  = nb_sno,1,-1
c #sn        znSNo(nk) = znSNo(nk+1) +dzSNo(nk)
c #sn      END DO
C +
c #sn      DO      nk  = 1,nb_sno
c #sn        tiSNo(nk) =         tairDY(imez,jmez,mz)
c #sn.        +(t2_SL0          -tairDY(imez,jmez,mz)) 
c #sn.             *sqrt(znSNo(nk)   /znSNo( 1))
C ###        Quadratic Approximation TO BE REFINED
C +
c #sn      END DO
C +
C +--Metamorphism and Settling: Layer nb_sno and underneath
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn      DO nbhour = 1,24
C +
C +          ***************
c #sn        call SRFmtm_sno(slope,nb_sno,mg0)
C +          ***************
C +
c #sn      END DO
C +
C +--Settling           of Snow Layer nb_sno and underneath
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c +          stress       = 0.0d0
c +        DO n=nb_sno,mg0+1,-1
c +          eta          = taSNo/(1.d0-tfSNo)
c +  .           *exp(teSNo * roSNo(n) /ro_Wat
c +  .               +epSN1 *(TfSnow-ts0)    )
c +          stress       = roSNo(n)*dzSNo(n)+stress
c +          dzsnew       = dzSNo(n)         *exp(-stress*dtset/eta)
c +          rosnew       = roSNo(n)*dzSNo(n)/dzsnew
c +          rosnew       = min(rosnew,ro_Ice)
c +          dzSNo(n)     = roSNo(n)*dzSNo(n)/rosnew
c +          roSNo(n)     = rosnew
c +        END DO
C +
C +--Hypothetical Precipitation Event
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn        nprec        = nprec    +     1
c #sn        dznew        =               dzSNo(nb_sno)+      zprec
c #sn        roSNo(nb_sno)=(roSNo(nb_sno)*dzSNo(nb_sno)+rprec*zprec)
c #sn.                                   /dznew
c #sn        dzSNo(nb_sno)= dznew
C +
C +--Precipitation occurs UNTIL Event npreci:  END
C +  ~~~~_____________________________~~~~~~____
c #sn    if (nprec.le.npreci(nb_sno)) go to 1010
C +      ---------------------------------------
C +
c #sn  END DO
C +
C +
C +--Loop on the Ice  Layers
C +  -----------------------
C +
c #sn  IF   (mg0.gt.0)                                            THEN                                                         
c #sn    DO        nb_ice=mgi,1,-1
c #sn        rate          = 1.9d+0
c #sn        ordr          = mg0-nb_ice
c #sn        dzSNo(nb_ice) = 5.0d-2 * rate ** ordr
c #sn        roSNo(nb_ice) = ro_Ice
c ###        roSNo(nb_ice) = 8.0d+2
C +***       Ice Density of Pore Hole Close OFF is 800.kg/m3
C +         (e.g. Greuell&Konzelmann 1994, Glob.Plan.Change 9, 4.5 p.100)
c #sn        g1SNo(nb_ice) = vg1SNo
c #sn        g2SNo(nb_ice) = 3.0d+1
c #sn    END DO
c #sn  END IF
C +
C +
C +--Loop on the Soil Layers
C +  -----------------------
C +
c #sn  IF      (mh.gt.0)                                          THEN
c #sn    DO nk=-mh,0
c #sn          r__dz      = -nk/2
c #sn          facdz      =  10.0**r__dz
c #sn      IF (mod(nk,2).eq.0)                                    THEN
c #sn          dzSNo(nk)  =  2.d-2*facdz
c #sn      ELSE
c #sn          dzSNo(nk)  =  6.d-2*facdz
c #sn      END IF
c #sn    END DO
c #sn  END IF
C +
c #sn          dzSNo(-mh) =  0.d00
C +
C +
C +--Reference Point: Vertical Discretization revised
C +  ------------------------------------------------
C +
c #sn  DO n=mg,-mh+1,-1
c #sn    znSNo(n) = znSNo(n+1) +dzSNo(n)
c #sn  END DO 
C +
c #sn  DO n=mg,    1,-1
c #sn    dzSNr(n) =             dzSNo(n)
c #sn  END DO
C +
C +--Vertical Discretization key Parameters defined for the whole Domain
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  DO nj=1,my
c #sn  DO ni=1,mx
c #sn    IF      (isolSL(ni,nj).eq.3)                             THEN
c #sn             nsSNow(ni,nj) = mg1
c #sn             niSNow(ni,nj) = mg0
c #sn    ELSE
c #sn             nsSNow(ni,nj) =   0
c #sn             niSNow(ni,nj) =   0
c #sn    END IF
c #sn  END DO
c #sn  END DO
C +
C +
C +--New Soil Time Constant
C +  ----------------------
C +
c #sn  IF           (mh.gt.0)                                     THEN
c #sn          znSNo( 0)    =              dzSNo( 0)
c #sn   IF          (mh.gt.1)                                     THEN
c #sn     DO         nk     =-1,-mh1,-1
c #sn          znSNo(nk)    = znSNo(nk+1) +dzSNo(nk)
c #sn     END DO
c #sn   END IF
c #sn          factim       = znSNo(-mh)  *znSNo(-mh) /(0.0864d0*0.15d0)
C +...         Deardorff 1978, JGR p.1891, kappa_s(muddy water): 0.15d-6
C +
c #sn          cs2SL        = cs2SL       *factim
c #sn          t2SLtn       = 1.d0/dtPhys-0.5d0/cs2SL
c #sn          t2SLtd       = 1.d0/dtPhys+0.5d0/cs2SL
c #sn          factim       =         sqrt(factim)
C +
C +--New Soil Time Constant: Generalization to the whole Domain
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn     DO nj=1,my
c #sn     DO ni=1,mx
c #sn          d1_SL(ni,nj) = d1_SL(ni,nj)*factim
c #sn     END DO
c #sn     END DO
C +
c #sn  ELSE
C +
c #sn          factim       = 1.00d0
C +  
c #sn  END IF
C +
C +
C +--Blowing Snow Model Initialisation (Constants)
C +  =============================================
C +
c #BS    FacRBS      =            2.868d00
c #BS    FacSBS      = 1.000d00 / FacRBS   
c #BS    FacTBS      =            0.085d00
c #BS    FacUBS      = 1.000d00 / FacTBS
C +
c #BS    g1__BS      =  99.00d00
c #BS    g2__BS      =  DiGfSN
C +
c #BS    SaltMo      = -0.833d-2 * g1__BS - 0.583d-2 * g2__BS + 0.833d00
c #BS    SaltSU      = (1.000d00 + SaltMo)           * FacSBS
c #BS    Salt_U      =        -log(SaltSU)           * FacUBS
C +...   Salt_U      :  Guyomarc'h & Merindol (1997), Ann. Glac.
C +
c #BS    Por_BS      =  1.000d00 - blsno /ro_Ice
c #BS    SheaBS      =                   Por_BS/(unun-Por_BS) 
C +...   SheaBS ==> Arg(sqrt(shear)) with shear the max shear stress in snow:
C +      shear       =  3.420d00 * exp(-(Por_BS      +Por_BS)
C +  .                                 /(unun        -Por_BS))
C +      SheaBS      :  see de Montmollin         (1978), 
C +                     These Univ. Sci. Medic. Grenoble, Fig. 1 p. 124
C +
C +
C +--Soil / Snow-Ice Cover Dry Initialisation (Full Domain, x,y independant)
C +  =======================================================================
C +
C +--Annual Temperature Wave: Parameters
C +  -----------------------------------
C +
c #sn     omega            =  2.0d00 * pi  / 315360.d2
c #sn     argti            =  omega  * (timyr -timyr0)
c #sn     ts_yr            =  TfSnow + ts_yrm +dtsyrm *sin(argti)
C +...    ts_yr :      Actual Surface  Temperature  (Climatology)
C +
C +--Soil (Clay, see Deardorff 1978 JGR, p.1891)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn     diffs            =  1.2d-6 *           2.d0
c #sn     faczs            =       sqrt(omega/ diffs)
C +
C +--Ice
C +  ~~~
c #sn     diffi            =  .27d-6 *           2.d0
c #sn     faczi            =       sqrt(omega/ diffi)
C +
C +
C +--Ocean and/or Snow-free  Soil: Snow Model Parameters
C +  ---------------------------------------------------
C +
c #sn DO nj=1,my
c #sn DO ni=1,mx
C +
c #sn   IF  ( isolSL(ni,nj).lt.3                                 .OR.
c #sn.       (isolSL(ni,nj).gt.3.and.tairDY(ni,nj,mz).gt.TfSnow)) THEN
C +
c #sn     DO               nk=mg1,1,-1
c #sn         dzSNow(ni,nj,nk) =  zero
c #sn         roSNow(ni,nj,nk) =  zero
c #sn         g1SNow(ni,nj,nk) =  zero
c #sn         g2SNow(ni,nj,nk) =  zero
c #sn         nhSNow(ni,nj,nk) =  0
c #sn     END DO
C +
c #sn         tiSNow(ni,nj, 1) =  tairDY(ni,nj,mz)
c #sn         tiSNow(ni,nj, 0) =  tairDY(ni,nj,mz)
C +
c #sn     IF              (mh.gt.0)                               THEN
c #sn         depth            =  0.0d0
c #sn       DO      nk=-1,-mh1,-1
c #sn         depth            =  depth            + dzSNo(nk)
c #sn         argzz            =  depth            * faczs
c #sn         tiSNow(ni,nj,nk) =  
c #sn.        TfSnow + ts_yrm  +  dtsyrm *exp(-argzz) *sin(argti-argzz)
c ###.       +tairDY(ni,nj,mz) -  ts_yr 
C +...        Correction from the Sounding
C +
c #sn       END DO
C +
c #sn     END IF
C +
C +
C +--Snow-Ice Cover over Ice/Soil: Snow Model Parameters
C +  ---------------------------------------------------
C +
c #sn   ELSE
c #sn       DO             nk=mg1,mg0+1,-1
c #sn         dzSNow(ni,nj,nk) =  dzSNo(nk)
c #sn         roSNow(ni,nj,nk) =  roSNo(nk) 
c #sn         g1SNow(ni,nj,nk) =  g1SNo(nk) 
c #sn         g2SNow(ni,nj,nk) =  g2SNo(nk) 
c #sn         nhSNow(ni,nj,nk) =  0
c #sn       END DO
C +
c #sn     IF (       mg0.gt.0)                                    THEN
c #sn       DO nk=   mgi,1,-1
c #sn         dzSNow(ni,nj,nk) =  dzSNo(nk)
c #sn         roSNow(ni,nj,nk) =  roSNo(nk) 
c #sn         g1SNow(ni,nj,nk) =  g1SNo(nk) 
c #sn         g2SNow(ni,nj,nk) =  g2SNo(nk) 
c #sn         nhSNow(ni,nj,nk) =  nhSNo2
c #sn       END DO
c #sn     END IF
C +
c #sn     IF (isolSL(ni,nj)   .ne.3     )                         THEN
c #sn      IF(tairDY(ni,nj,mz).gt.TfSnow)                         THEN
c #sn         albedo = 0.70
c #sn      ELSE
c #sn         albedo = 0.85
c #sn      END IF
c #sn     ELSE
c #sn         albedo = alb0SL(ni,nj)
c #sn     END IF
C +
C +
C +--Soil / Snow-Ice Cover Dry Initialisation (Full Domain, x,y   dependant)
C +  =======================================================================
C +
C +--Temperature
C +  -----------
C +
c #sn         tiSNow(ni,nj,mg)    =  tairDY(ni,nj,mz)
c #sn         tiSNow(ni,nj,mg1)   =  tairDY(ni,nj,mz)
C +
c #sn         depth               =  0.0d0
c #sn       DO             nk=mg1-1,1,-1
c #sn         depth               =  depth            + dzSNow(ni,nj,nk)
c #sn         argzz               =  depth            * faczi
c #sn         tiSNow(ni,nj,nk)    =  
c #sn.        TfSnow + ts_yrm     +  dtsyrm*exp(-argzz)*sin(argti-argzz)
c ###.       +tairDY(ni,nj,mz)    -  ts_yr 
C +...        Correction from the Sounding
C +
c #sn       END DO
C +
c #sn       DO         nk=0,-mh,-1
c #sn         depth               =  depth            + dzSNo(nk)
c #sn         argzz               =  depth            * faczi
c #sn         tiSNow(ni,nj,nk)    =  
c #sn.        TfSnow + ts_yrm     +  dtsyrm*exp(-argzz)*sin(argti-argzz)
c ###.       +tairDY(ni,nj,mz)    -  ts_yr 
C +...        Correction from the Sounding
C +
c #sn       END DO
C +
c #sn         t2_SL(ni,nj)        = t2_SL0
C +...        t2_SL               : here Annual Mean Ice Sheet Temperature
C +
C +
C +--Heat Capacity and Density
C +  -------------------------
C +
c #sn         d1_SL(ni,nj)                  = 0.6257d+6        * factim
C +...        d1 = ro_Ice csnow sqrt(kappas Tau1) (Deardorff 1978), assuming
C +                ro_Ice csnow             = 9.2000d+2 kg/m3  * 2105 J/kg/K 
C +                                         = 1.9366d+6 J/m3/K
C +                                  kappas = cdice/csnow/ro_Ice
C +                                         = 1.2000d-6 m2/s                 
C +
C +
C +--Temperature: Correction in Snow
C +  -------------------------------
C +
c #sn       DO             nk=mg1,mg0+1,-1
c #sn         IF (tiSNow(ni,nj,nk).ge. TfSnow)                    THEN
c #sn             tiSNow(ni,nj,nk) =   TfSnow
c #sn             g1SNow(ni,nj,nk) =   vg1SNo
C +...            old snow, with maximum sphericity
C +
c #sn             g2SNow(ni,nj,nk) =       30.d0
C +...            old snow, Size [0.1mm] = 30         
C +
c #sn             nhSNow(ni,nj,nk) =   nhSNo2
C +...            Liquid and no faceted cristals before
C +
c #sn         END IF
C +
c #sn       END DO
C +
c #sn             tiSNow(ni,nj,mgg) =  min(tiSNow(ni,nj,mgg),TfSnow)
c #sn             tiSNow(ni,nj,  0) =      tiSNow(ni,nj,  1)
C +
c #sn     IF     (albedo          .ge.aiceSN)                     THEN
c #sn       DO                 nk=mg1,mg0+1,-1
c #sn         IF (tiSNow(ni,nj,nk).ge.TfSnow)                     THEN
c #sn             waSNow(ni,nj,nk)= w0SNo*(ro_Ice/roSNow(ni,nj,nk)-1.d0)
c #sn.                                   /(roiwSN-w0SNo)
C +...            Minimum Water Content is assumed
C +
c #sn         ELSE
c #sn             waSNow(ni,nj,nk) = 0.d0
c #sn             nhSNow(ni,nj,nk) = 0
c #sn         END IF
c #sn       END DO
C +
c #sn     ELSE
C +
c #sn       DO nk=mg1,1,-1
c #sn         IF (roSNow(ni,nj,nk).lt.800.d0)                     THEN
c #sn             roSNew          = ro_Wat+    roSNow(ni,nj,nk)
c #sn.                                    *(1.-1.              /roiwSN)
c #sn             waSNow(ni,nj,nk)= ro_Wat*(1.-roSNow(ni,nj,nk)/ro_Ice)
c #sn.                         /roSNew
c #sn             roSNow(ni,nj,nk)= roSNew
C +...            Maximum Water Content is assumed (==> Slush)
C +
c #sn         ELSE
c #sn             waSNow(ni,nj,nk)= 0.d0
c #sn         END IF
c #sn             nhSNow(ni,nj,nk)= nhSNo2
c #sn       END DO
C +
c #sn     END IF
C +
C +
C +--Blowing Snow Model Parameters
C +  -----------------------------
C +  
c #sn     IF     (nhSNow(ni,nj,mg1).le.nhSNo1)                    THEN
c #sn              ro_SL(ni,nj) =  0.d0
C +
c #BS       IF   (g1SNow(ni,nj,mg1).lt.0.d0)                      THEN
c #BS             SaltMo        = -0.750d-2*g1SNow(ni,nj,mg1) 
c #BS.                            -0.500d-2*g2SNow(ni,nj,mg1)+0.500d00
C +...            SaltMo        :  Guyomarc'h & Merindol, 1998, Ann. Glac.
C +                      CAUTION:  Guyomarc'h & Merindol Dendricity Sign is +
C +                      ^^^^^^^^                    MAR Dendricity Sign is -
c #BS       ELSE
c #BS             SaltMo        = -0.833d-2*g1SNow(ni,nj,mg1) 
c #BS.                            -0.583d-2*g2SNow(ni,nj,mg1)+0.833d00
c #BS       END IF
C +
c #BS       IF   (nhSNow(ni,nj,mg1).ge.nhSNo2)SaltMo=min(SaltMo,SaltMx)
C +
c #BS             SaltSU        = (1.000d00 + SaltMo)         * FacSBS
c #BS             Salt_U        =        -log(SaltSU)         * FacUBS
C +...            Salt_U        :  Guyomarc'h & Merindol, 1997, Ann. Glac.
C +
c #BS             SaltSL(ni,nj) =             Salt_U / 26.5d00
C +...            Us(U10)       :  Budd et al.            1966, Ant.Res.Ser.9
C +                           (see Pomeroy & Gray 1995 NHRI Sci.Rep.7(30)p.62)
C +
C +--PBSM Parameterization of the Saltation Threshold
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #LP             tair_C        =  TairSL(ni,nj)-TfSnow
c #LP             tair2C        =  tair_C       *tair_C
c #LP             Salt_U        =  9.43d00 + 0.18d00*tair_C + 3.30d-3*tair2C
C +...            Salt_U        :  Li and Pomeroy 1997, JAM (3) p. 211
C +
c #LP             arg_Us        =  1.295d0 * log(abs(Salt_U))
c #LP             SaltSL(ni,nj) =                exp(arg_Us) /44.2d00
C +...            Us(U10)       :  Pomeroy 1988 
C +
c #sn     ELSE
c #sn              ro_SL(ni,nj) =  roSNow(ni,nj,mg1)
c #BS             SaltSL(ni,nj) =  1.d2
c #sn     END IF 
C +
c #sn   END IF 
C +
c #sn END DO
c #sn END DO
C +
C +
C +--Surficial Water
C +  ---------------
C +
c #sn DO nj=1,my
c #sn DO ni=1,mx
c #sn   IF (dzSNow(ni,nj,1).gt.0.d0)                              THEN
c #sn       alphar        =     (albedo     -0.15d0)/0.4d0
c #sn       waSNru(ni,nj) =     -waSN   *log(alphar)
c #sn       waSNru(ni,nj) =  max(waSNru(ni,nj),zero)
C +***      Inversion of the Zuo and Oerlemans (1995, (24) p.15 RelationShip) 
C +                   describing the SLush Influence on Albedo (.4 = .55-.15)
c #sn   END IF
c #sn END DO
c #sn END DO
C +
C +
C +--Fall Line Slope
C +  ---------------
C +
c #sn DO nj=jp11,my1
c #sn DO ni=ip11,mx1
c #sn    slopx        =(sh(ip1(ni),nj)-sh(im1(ni),nj))*dxinv2
c #sn    slopy        =(sh(ni,jp1(nj))-sh(ni,jm1(nj)))*dyinv2
c #sn    slopSN(ni,nj)=sqrt(slopx*slopx+slopy*slopy)
c #sn    slwaSN(ni,nj)=exp(-dtSNo/
c #sn.                     (c1SNo+c2SNo*exp(-c3SNo*slopSN(ni,nj))))
C +...   slwaSN(ni,nj): Normalized Surficial Water Variation during dtSNo
C +***    (Zuo and Oerlemans 1995, J.Glacio. in press, p.14(22) and p.15)
C +
c #sn END DO
c #sn END DO
C +
C +
C +--Snow Age
C +  --------
C +
c #sn DO nj=1,my
c #sn DO ni=1,mx
c #sn DO nk=1,mg1
c #sn    agSNow(ni,nj,nk) =  zero
c #sn END DO
c #sn END DO
c #sn END DO
C +
C +
C +--Snow Grain Size (for Albedo Computation)
C +  ----------------------------------------
C +
c #AB write(21,2130)
 2130 format(/,' INTERACTIVE SNOW ALBEDO (BRUN et al. 1992)')
C +
c #AB DO nj=1,my
c #AB DO ni=1,mx
c #AB   IF(dzSNow(ni,nj,1).gt.0.d0)                               THEN
C +
C +                     **********
c #AB     dopsno      = SRFdia_sno(g1SNow(ni,nj,mg1),g2SNow(ni,nj,mg1))
C +                     **********
C +
c #AB     dsqr        = sqrt(dopsno)
C +
C +
C +--Snow Albedo: Influence of Age and Grain Size
C +  ============================================
C +
C +            **********
c #AB     call SRFalb_sno(alb0SL(ni,nj),alb0SL_1(ni,nj),alb0SL_2(ni,nj),
c #AB.                  alb0SL_3(ni,nj),dopsno,dsqr,
c #AB.                    roSNow(i,j,mg1),waSNow(i,j,mg1),
c #AB.                    agSNow(i,j,mg1),DirSol,DifSol,Cld_SL(ni,nj))
C +            **********
C +
C +...    alb0SL        : Integrated background snow albedo, 
C +                       adapted from Brun et al. 1991, J Glaciology
c #AB   END IF
c #AB END DO
c #AB END DO
C +
C +
C +--OUTPUT
C +  ======
C +
c #sn  write(4,106)mg0,mg,h0SNo,rrsno,zxSNo
 106   format(/,'SNOW MODEL INITIALISATION',
     .        /,'=========================',
     .        /,' Maximum  Nb Levels    (mg)    =', i9,
     .        /,' Standard Nb Levels    (mg0)   =', i9,
     .        /,' Minimum Thickness     (h0SNo) =', f9.3,
     .        /,' Progression Parameter (rrsno) =',f12.6,
     .        /,' Maximum Depth         (zxSNo) =', f9.3,
     .       //,' Discretisation:',
     .        /,' ---------------')
c #sn  write(4,107)(dzSNo(n),n=mg1,1,-1)
 107   format((' dz[m]: ',10f8.3))
c #sn  write(4,108)(znSNo(n),n=mg1,1,-1)
 108   format((' z [m]: ',10f8.3))
c #sn  write(4,109)(roSNo(n),n=mg1,1,-1)
 109   format((' rho* : ',10f8.3))
C +
c #sn  write(4,4000) GElat0,PrecLa,1.d2*hprec*ro_Wat/rprec,tprec,rprec
 4000  format(
     .    /,' Snow Model Initiatisation:  Latitude:',f8.1,
     .    /,' ==========================',
     .    /,' Precipitation: Hypothetical Latitude:',f8.1,
     .    /,'                        Rate         :',f9.2, ' cm/day',
     .    /,'                Inverse Rate         :',f8.1,' day/mWE',
     .    /,'                Density              :',f8.1,'  kg/m3 ',
     .   //,'  Layer | Nb Day | Thickness | Thickness |  Density  |',
     .    /,'        | Precip.|   [cmWE]  |    [cm]   |  [kg/m3]  |',
     .    /,'--------+--------+-----------+-----------+-----------+')
C +
c #sn   write(4,4001)         (           nb_sno,npreci(nb_sno),
c #sn.                         1.d2*dzSNo(nb_sno)*roSNo(nb_sno)/ro_Wat,
c #sn.                         1.d2*dzSNo(nb_sno),roSNo(nb_sno)       ,
c #sn.                                    nb_sno=mg1,mg0+1,-1         )
 4001   format((i7,' |',f7.0,' |',3(f10.2,' |')))
C +
c #sn IF (mg0.gt.0)                                               THEN
c #sn   write(4,4002)         (           nb_ice,               
c #sn.                         1.d2*dzSNo(nb_ice)*roSNo(nb_ice)/ro_Wat,
c #sn.                         1.d2*dzSNo(nb_ice),roSNo(nb_ice)       ,
c #sn.                                    nb_ice=mgi,1,-1             )
 4002   format((2(i7,' |'),10x,' |' ,2(f10.2,' |')))
c #sn END IF
C +
c #sn   write(4,4003)
 4003   format(
     .    /,'--------+--------+-----------+-----------+-----------+',/)
C +
C +
C +--END   OF SNOW MODEL INITIALISATION------------------------------------
C +
C +
      return
      end
      subroutine SRFmod_sno
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                             3-12-2002  MAR |
C |   SubRoutine SRFmod_sno computes the SNOW surface energy balance       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Brun   et al.      1989, JGlac  35, pp. 333-- 342           |
C |   ^^^^^^^^ Kondo and Yamazaki 1990, JAM    29, pp. 375-- 383           |
C |            Rowe et al.        1995, JGR   100, pp. 16265--73           |
C |            Thom  and Oliver   1977, QJRMS 103, pp. 345-- 357           |
C |            Deardorff          1978, JGR    83, pp.1889--1903           |
C |                                                                        |
C |   ASSUMPT. SRFmod_sno  is active every dtPhys and                      |
C |   ^^^^^^^^             gives a surface temperature increment over dt   |
C |                              for  next dtPhys period                   |
C |            Soil Surface Temperature (Layer 0) may be large than 0C     |
C |                                                                        |
C |   INPUT  : sol_SL(mx,my)  : Absorbed Solar Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ RAd_ir(mx,my)  : Downward    IR Flux (+ <=> Downward)(W/m2) |
C |            albeSL(mx,my)  : Surface Albedo                             |
C |            eps0SL(mx,my)  : Surface IR Emissivity                      |
C |            tsrfSL(mx,my,1): Snow Pack Surface Temperature          (K) |
C |            t2_SL (mx,my)  : Snow Pack Bottom  Temperature          (K) |
C |            tiSNow(i,j,n)  : Snow Cover Internal Temperature        (K) |
C |            waSNow(i,j,n)  : Snow Cover Water content           (kg/kg) |
C |            roSNow(i,j,n)  : Snow       Density                 (kg/m3) |
C |            dzSNow(i,j,n)  : Snow Layer Thickness                   (m) |
C |            g1SNow(i,j,n)  : Snow Layer Dendricity(<0) or Spericity(>0) |
C |            g2SNow(i,j,n)  : Snow Layer Spericity (>0) or Size     (mm) |
C |            nhSNow(i,j,n)  : Snow Layer Historicity                     |
C |            bsnoSL(mx,my)  : Snow Accumulated Erosion               (m) |
C |            snobSL(mx,my)  : Snow             Erosion               (m) |
C |            hsnoSL(mx,my)  : Snow Accumulated Precipitation         (m) |
C |            snohSL(mx,my)  : Snow             Precipitation         (m) |
C |            bmel           : Water run off at Soil(Ice)-Snow Interface  |
C |            d1_SL (mx,my)  : rhos * cs *(depth diurnal wave)   (J/m2/K) |
C |                             describes  Soil-------Surface  Interface   |
C |                             (in contrast with other MAR_SL variables   |
C |                             describing Atmosphere-Surface  Interface   |
C |             ex.: ICE : 920kg/m3 *2000J/kg/K *sqrt(0.27e-6m2/s *86400s) |
C |             ex.: SNOW: 330kg/m3 *2000J/kg/K *sqrt(0.27e-6m2/s *86400s) |
C |                                                                        |
C |   OUTPUT : firdSL(mx,my)  : Atmospheric IR Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ firmSL(mx,my)  : Surface     IR Flux (+ <=>   Upward)(W/m2) |
C |            hsenSL(mx,my)  : Sensible  Heat Flux (+ <=> Downward)(W/m2) |
C |            hlatSL(mx,my)  : Latent    Heat Flux (+ <=> Downward)(W/m2) |
C |         => SLuqsl(i,j,1)  : Water Vapor Flux from Surface  (kg.m/kg/s) |
C |            hbalSL(mx,my)  : Sum Atmospher. Flux (+ <=>Surf.Loss)(W/m2) |
C |         =>  dtgSL(mx,my,1): Snow Surface Temperature Change over dt(K) |
C |         =>  t2_SL(mx,my)  : Snow Bottom  Temperature               (K) |
C |         => tiSNow(i,j,n)  : Snow Cover Internal Temperature        (K) |
C |         => waSNow(i,j,n)  : Snow Cover Water content           (kg/kg) |
C |         => roSNow(i,j,n)  : Snow       Density                 (kg/m3) |
C |         => dzSNow(i,j,n)  : Snow Layer Thickness                   (m) |
C |         =>  ro_SL(i,j,n)  : Snow Surface Pseudo Density                |
C |         => hsnoSL(mx,my)  : Snow Accumulated Precipitation         (m) |
C |            wet_IB(mx,my)  : Curr. Srf. Mass Balance             (mmWE) |
C |            wei0IB(mx,my)  : Bottom Ice added during last Hour   (mmWE) |
C |            wei1IB(mx,my)  : Bottom Ice added during last Day    (mmWE) |
C |            weh_IB(mx,my)  : Curr. Srf. Mass Balance: Sublimation (mWE) |
C |            wem_IB(mx,my)  : Curr. Srf. Mass Balance:     Melting (mWE) |
C |            wemmIB(mx,my)  : Curr. Srf. Mass Balance: onlyMelting (mWE) |
C |            wemrIB(mx,my)  : Curr. Srf. Mass Balance:  refreezing (mWE) |
C |            wer_IB(mx,my)  : Curr. Srf. Mass Balance:        Rain (mWE) |
C |            wes_IB(mx,my)  : Curr. Srf. Mass Balance:        Snow (mWE) |
C |            weu_IB(mx,my)  : Curr. Srf. Mass Balance:     run-off (mWE) |
C |                                                                        |
C |   OPTIONS:   #AB: Interactive Snow Albedo (Brun    et al.       1991)  |
C |   ^^^^^^^^   #AG: Snow Aging Col de Porte (Brun    et al.       1991)  |
C |              #GK: Interactive Snow Albedo (Greuell & Konzelmann 1994)  |
C |              ^^^: Ice--snow Water Content                              |
C |                   Initialisation f(Albedo)(van de Wal Oerlemans 1994)  |
C |              #SL: Slush Albedo   f(wnsno) (Zuo     &  Oerlemans 1996)  |
C |              #RU: Slush: Internal Run OFF of Water Excess              |
C |              #SM: Diagnostics Integrated Melting  (fmelSL) and         |
C |                                          Freezing (freeSL)             |
C |              #CP: Col de Porte Parameterization (for Validation only)  |
C |              #BM: Snow Densification under blowing snow / DO NOT USE   |
C |                   without switching off   ACCUMULATION of BLOWN SNOW)  |
C |              #IB: Output for Ice-Sheet Mass Balance                    |
C |              #GL: ETH-Camp (1990-1991) & Greenland 3D simulation       |
C |                                                                        |
C |   VERIFIC.:  #Se: Energy Conservation: Summary, Output                 |
C |   ^^^^^^^^^  #SE: Energy Conservation: Summary, Output+                |
C |              #SF: Energy Conservation: Atmospheric Forcing, Conduction |
C |              #WM: Water  Conservation: Melting, Freezing               |
C |              #WB: Blowing Snow:  Additional Output                     |
C |              #WR:        Verification: Full Output                     |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C + 
C +-- 0. Variables Declaration 
C +   ========================
C +
C +-- 0.1 General Variables
C +   ---------------------
C +
      include 'MARphy.inc'
      include 'MARCTR.inc'  
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
c #HY include 'MAR_HY.inc'
c #BS include 'MAR_BS.inc'
      include 'MAR_RA.inc'
C +
      include 'MAR_SL.inc'
c #sn include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'
c #IB include 'MARsSN.inc'
c #IB include 'MAR_IB.inc'
C +
      include 'MAR_IO.inc' 
C +
C +
C +-- 0.2 Routine Internal Variables
C +   ------------------------------
C +
c #sn real     facust
c #sn common/SRFmod_sno_loc/facust
C +
c #sn real     cdsno  (-mh:mg)
C +...         cdsno: Thermal Conductivity in Snow
C +                   mg: maximum nbr of snow layers (cfr MAR_SN.inc)
C +
c #sn real     tnsno(2,-mh:mgg)
C +
c #BS real     zdrift     (mg)
c #BS real     zdepos     (mg)
c #BS real     SaltSI     (mgg)
C +...Snow Drift
C +
c #sn real     dgsno      (mg)
c #sn real     exsnoSP    (mg,3) ! Snow Extinction Coefficient "   spectral"
c #sn real     exsno      (mg)   ! Snow Extinction Coefficient "no-spectral"
C +...Snow Optical Properties
C +
c #sn real     dqmel      (mg)
c #sn real     wnmel      (mg)
c #sn real     snwae      (mg)
c #sn real     wnsno      (mg)
c #sn real     uwsno      (mgg)
C +...Water Flux
C +
c #sn real     cs_SV(  -mh:0 )
C +...Soil Heat Capacity [J/m3/K]
C +
c #sn real     aasno   ( -mh:mg)  ,bbsno  (-mh:mg), ccsno (-mh:mg)
c #sn real     ddsno  (2,-mh:mg)  ,ffsno  (-mh:mg), ggsno (-mh:mgg)
c #sn real     hhsnoSP (-mh:mgg,3),hhsno  (-mh:mgg)
c #sn real     ppsno   (-mh:mg)   ,qqsno  (-mh:mg), xxsno (-mh:mg)
C +...Auxiliary Variables of the Gaussian Elimination Procedure
C +
c #sn real     sisno(      mg)
C +...Auxiliary Variable  for Layer Aggregation Procedure
C +
c #SF real     ttaux(  -mh:mg)
C +...Auxiliary Variable  for Verification of Energy Consistency
C +
c #SE real         wwater(9)
c #SE character*44 mroute(9),nroute
C +...List of Activated Physical Processes 
C +
C +
C +-- 0.3 Other Variables
C +   -------------------
C +
c #BM real    fro   ,xro   ,dro   ,dg1  
c #BS real    hSalta,sSalta,sSaldt,bsnoEW,Por_BS,ShearX,SaltSU  
c #BS real    ArgFac,Fac_Mo,ArguSi,zsnow ,xdrift,redist,tdepos
c #BS real    bsno_z,dzweqo,bsno_x,dzweqn,bsno  ,tnsnoS,tdrift,rdrift
c #BS real    hsno_z,PorSno,Salt_f,PorRef,ro_new,hsno_x,Salt_U,SaltMo
c #CP real    TotSol,cdColP,dts_ta,hsunst
c #DG real    sqrarg,rosnmi   
c #GK real    rosrf   
c #IB real    dwe
c #LP real    tair_C,tair2C,arg_Us 
c #SE real    hsensd,entop1,entop2,dentop,dtemp0
c #SE real    dheat ,heat2 ,heat1m,heat2m,dheatm      
c #Se real    pheat ,heat1 ,aheat ,wheat ,hdeep        
c #SF real    rocsdz    
c #SA real    albCROCUS_1,albCROCUS_2,albCROCUS_3,albCROCUS
c #SA real    albHeq0_1,albHeq0_2,albHeq0_3,albHeq0
c #SA real    albHle10_1,albHle10_2,albHle10_3,albHle10
c #SA real    snowheight
c #sn real    tfv_vk,SaltMx,hdrift,rbsnow,h_mWE ,h0mWE
c #sn real    typmin,wghmin,wghmax
c #sn real    temp_z_mes(15),temp_mod(15), absSOL(3)
c #sn real    s1SNv ,s1SN1 ,s1SN2 ,s2SNv ,s2SN1 ,s2SN2 
c #sn real    s3SNv ,s3SN1 ,s3SN2
c #sn real    slush ,avden ,avwat ,superim
c #sn real    epsloc,radnet,rho10m,cdTurb,hsensi,hsenst
c #sn real    qst   ,qsat0D  ,qsa   ,relhum,pr    ,rhos
c #sn real    egdd  ,rsurXX,gamp  ,aqsat ,dqsat ,den   ,qs10  ,dnum  
c #sn real    egpm  ,eg    ,subli
c #sn real    hsnofake_old ,hsnofake_new
c #sn real    fhsno ,hsnoEW,sno_cm
c #sn real    zdzmax,zdzmin,zdtmax,zdamax,SRFdtp_sno,simin
c #sn real    fhwat ,dwater,dsqr  ,dopsno,SRFdia_sno,DirSol,DifSol
c #sn real    tiSNowfake,roSNowfake,albedofake,g1SNowfake,g2SNowfake
c #sn real    dopsnofake,  dsqrfake
c #sn real    albedofake1,albedofake2,albedofake3
c #sn real    albedo_icel1,albedo_icel2,albedo_icel3,albedo_icel
c #sn real    snow_height ,albedo_old
c #sn real    ffup  ,coeft ,coefi ,coefdt,coeftn,coefin,coefto,coefio
c #sn real    freezw,freezt,freeze,dfreez,afreez,wfreez 
c #sn real    water0,snodry,water ,energy,wexces,wnmax ,wnuse
c #sn real    volsno,volpor,volwat,volmel,volsnn,vrowat,volmax 
c #sn real    roscor,rorap1,rovar ,rosnew,dzvar ,rorap2,rosmax 
c #sn real    wasndi,wasnew,bmel  ,bheat ,cheat ,eners ,enerm ,sheat
c #sn real    watert,wamel ,watmax,twwat ,dwwat
c #sn real    rosneu,wnsneu,wstag ,roexc ,wssno ,wnra  ,wnr3  ,perwa
c #sn real    wnmov ,uwmxn ,uwmxn1,row   ,ros   ,rowmin,rownew 
c #sn real    tisn_2,slope ,dtemp ,dz    ,fmel  ,zeta
c #SW real    qwater       
C +
c #BS integer mobile,nb_acr
c #SE integer iroute  
c #sn integer leuler
c #sn integer nb_sno,nb_ice,n,nb_superim,nb_slush
c #sn integer mh1,lsf,itsno,ne,nn,iter,neu,n1,iact,mm,n_min
C +
C +
C +-- 0.4 Data
C +   --------
C +
      logical qpm
c #SM logical diagno
c #AB logical albCEN
C +
      data    qpm     /.false./
c #SM data    diagno  /.true. /
c #AB data    albCEN  /.true. /
C +
      data    tfv_vk  / 5.1e-1/
C +...        tfv/vk: Terminal Fall Velocity / Von Karman Cst = .216 / .4
C +                   (Wamser & Lykosov 1995 Contr.Atm.Phys. 68, p.90)
C +
c #BS data    SaltMx  /-5.83e-2/
C +...        SaltMx: Maximum Snow Density affecting Erodibility (kg/m3)
C +
c #BS data    rbsnow  / 5.00e+1/
C +...        rbsnow: Minimum Snow Density affecting Erodibility (kg/m3)
C +
c #BS data    hdrift  / 1.00e+1/
C +...        hdrift: Inverse Thickness of the erodible Snow Layer (1/m)
C +
c #BS data    h_mWE   / 1.00e-4/
C +...        h_mWE:  Minimum Thickness of an  eroded   Snow Layer (mWE)
C +
      data    h0mWE   / 2.00e-3/
C +...        h0mWE:  Minimum Thickness of a   new      Snow Layer (mWE)
C +
      data    typmin  / 5.00e00/
C +...        typmin: Calcul Difference Maximum  de Types  de Neige
C +
      data    wghmin  / 1.50e00/
C +...        wghmin: Critere Min Couche Inferieure en Aggregation forcee
C +
      data    wghmax  / 5.00e00/
C +...        wghmax: Poids   Max Somme des Couches en Aggregation forcee
C +
c #CP data    hsunst  / 5.00e00/
C +...        hsunst: Coeffic. 'Col de Porte Unstable Sensible Heat Flux'
C +
      data    leuler/0/
C +...        leuler=0 =>       Forward  Scheme
C +           leuler=1 => Euler Backward Scheme
C +
C +CP data    s1SNv/0.590e00/,s2SNv/0.310e00/,s3SNv/0.100e00/
      data    s1SNv/0.606e00/,s2SNv/0.301e00/,s3SNv/0.093e00/
      data    s1SN1/0.950e00/,s2SN1/0.050e00/,s3SN1/0.000e00/
      data    s1SN2/0.660e00/,s2SN2/0.270e00/,s3SN2/0.070e00/
C +...        0.3--0.8micr.m  0.8--1.5micr.m  1.5--2.8micr.m
C +           Fractions of total solar irradiance in 3 spectral intervals
C +***        (see Eric Martin Sept. 1996, CROCUS, Subroutine METEO)
C +***        (see Feagle and Businger 1981, Int.Geoph.Ser. 25, p.215-222)
C +
C +-------------------------------------------------------------------------
C +--BEGIN OF SNOW MODEL----------------------------------------------------
C +-------------------------------------------------------------------------
C +
C +-- 1. Snow Cover Top Layer (Surface) Index 
C +   =======================================
C +
C +-- 1.1 Initialisation
C +   ------------------
C +
c #sn   nb_sno = nsSNow(i,j)
C +
c #sn IF        (isolSL(i,j).eq.3)                                THEN
c #sn   nb_ice = niSNow(i,j)
c #sn ELSE
c #sn   nb_ice = 0
c #sn END IF     
C +
        mh1    = max(1,mh)
C +
C +      
C +-- 1.2 Normalized Surficial Water Variation during dtSNo
C +   -----------------------------------------------------
C +
c #sn IF (iterun.le.1)                                            THEN
c #sn     slwaSN(i,j)=exp(-dtSNo/(c1SNo+c2SNo*exp(-c3SNo*slopSN(i,j))))
C +....   slwaSN: internal liquid water content in excess of the maximum 
C +               water saturation
c #sn     slopGE(i,j)=cos(atan(slopSN(i,j)))
C +...    slopGE .....Cosine of Fall Line Angle
c #sn END IF
C +
C +
C +
C +-- 1.3 First output
C +   ----------------                                                 
C +
c #sn IF (iterun.eq.0) THEN
c #sn IF (nb_sno.gt.0) THEN
c #sn      znSNo(nb_sno) = dzSNow(i,j,nb_sno)
c #sn      snwae(nb_sno) = roSNow(i,j,nb_sno)*dzSNow(i,j,nb_sno)
c #sn.	             *1.d3/ro_Wat
c #sn   DO n=nb_sno-1,1,-1
c #sn      znSNo(n)      = dzSNow(i,j,n) + znSNo(n+1)    ! snow height
c #sn      snwae(n)      = roSNow(i,j,n) *dzSNow(i,j,n)  ! water Content  
c #sn.               *1.d3/ro_Wat        + snwae(n+1)
c #sn   END DO
c #sn ELSE
c #sn      snwae(1)      = 0.d00
c #sn END IF 
C +
C +   ************
c +sn call analyse(iterun, nb_sno,nb_ice,nb_superim,
c +sn.             nb_slush,superim,slush,avden,avwat)
C +   ************
C +
c +sn siiceSN(i,j) = superim     ! Superimposed Ice Height 
c +sn slushSN(i,j) = slush       ! Slush Height of Snow Pack 
c +sn avdenSN(i,j) = avden       ! Average Density       (excluding slush)
c +sn avwatSN(i,j) = avwat       ! Average Water Content (excluding slush)
c +sn nsiiSN (i,j) = nb_superim  
c +sn nsluSN (i,j) = nb_slush    
c #sn END IF
C +
C +
C +-- 2. Snow Cover Energetic Forcing
C +   ===============================
C +
C +-- 2.1 Solar Heat Flux at the Surface
C +   ----------------------------------
C +
c #CP DirSol     = RAdsol(i,j)
c #CP DifSol     = sol_SL(i,j)
c #CP TotSol     = DirSol + DifSol
C +
c #GL IF (ETH_Camp)
c #GL.sol_SL(i,j)= RAdsol(i,j)*(1.d0-albeSL(i,j)) ! Absorbed Solar Heat Flux 
C + 
      RAdsol(i,j)= sol_SL(i,j)/(1.d0-albeSL(i,j)) ! Downward Solar heat flux
C +
c #CP RAdsol(i,j)= DirSol + DifSol
c #CP sol_SL(i,j)=(DirSol + DifSol) *(1.d0-albeSL(i,j))
C +
C +-- 2.1.1 Spectral dependence on solar zenith angle
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if (iterun.eq.0) then        ! albedo for the 3 spectral bands
       alb0SL_1(i,j) = alb0SL(i,j) ! 0.3-->0.8micr.m
       alb0SL_2(i,j) = alb0SL(i,j) ! 0.8-->1.5micr.m  
       alb0SL_3(i,j) = alb0SL(i,j) ! 1.5-->2.8micr.m
      endif
C +
      alb0SL_2(i,j)  = alb0SL_2(i,j) 
     .               + 0.50d0      ! 50 % : empirical value 
     .               *(albeSL  (i,j) - alb0SL(i,j))/s2SNv
      alb0SL_3(i,j)  = alb0SL_3(i,j) 
     .               + 0.50d0      ! 50 % : empirical value
     .               *(albeSL  (i,j) - alb0SL(i,j))/s3SNv 
C +
C +***(see Wiscombe and Warren, dec1980, J.Atmos.Sc: pg 2723)      
C +
      alb0SL_2(i,j)  = max(alb0SL_2(i,j),0.01)
      alb0SL_2(i,j)  = min(alb0SL_2(i,j),0.99) 
      alb0SL_3(i,j)  = max(alb0SL_3(i,j),0.01)
      alb0SL_3(i,j)  = min(alb0SL_3(i,j),0.99)
C +
C +-- 2.1.2 Spectral solar heat flux available at the surface
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      absSOL(1)  = s1SNv * (1.0-alb0SL_1(i,j)) * RAdsol(i,j) 
      absSOL(2)  = s2SNv * (1.0-alb0SL_2(i,j)) * RAdsol(i,j) 
      absSOL(3)  = s3SNv * (1.0-alb0SL_3(i,j)) * RAdsol(i,j) 
C +
c #CP s1SNv      = 0.606d0
c #CP s2SNv      = 0.310d0
c #CP s3SNv      = 0.093d0
c #CP if (TotSol.gt.0.0d0) then
c #CP  s1SNv=(S1SNv * DirSol +s1SN1* DifSol *(1.d0-Cld_SL(i,j))
c #CP.      + S1SN2 * DifSol * Cld_SL(i,j))/TotSol
c #CP  s2SNv=(S2SNv * DirSol +s2SN1* DifSol *(1.d0-Cld_SL(i,j))
c #CP.      + s2SN2 * DifSol * Cld_SL(i,j))/TotSol
c #CP  s3SNv=(S3SNv * DirSol +s3SN1* DifSol *(1.d0-Cld_SL(i,j))
c #CP.      + s3SN2 * DifSol * Cld_SL(i,j))/TotSol
c #CP  if (s3SNv.le.0.0d0) s3SNv = epsi
c #CP end if
C +
C +
C +-- 2.2 Long-Wave Heat Flux at the Surface
C +   --------------------------------------
C +
      if (nb_sno.gt.0) then
          epsloc = 1.00d0              
      else
          epsloc = eps0SL(i,j) ! Surface IR Emissivity (=0.97)
      end if
C +      
      firdSL(i,j)= (RAd_ir(i,j)*epsloc) 
C +
C +     
C +-- 2.3 Total Radiative Downward Heat Flux
C +   --------------------------------------
C +
      radnet     = sol_SL(i,j)+ firdSL(i,j) 
     .           - epsloc *stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .           * tsrfSL(i,j,1)*tsrfSL(i,j,1)
C +
C +
C +-- 2.4 Sensible Heat Flux
C +   ----------------------
C +
      rho10m     = rolvDY(i,j,mz)*1000.d0
C +...rho10m     : specific mass at first Sigma Level (kg/m3)
C +
      hsenSL(i,j)=-rho10m*cp*SLutsl(i,j,1) 
C +      
C +...hsenSL(i,j)=-rho10m*cp*SLuusl(i,j,1)*cdhSL(i,j,1)*pcap
C +  .           *(pktaDY(i,j,mz)
C +  .            -tsrfSL(i,j,1)*exp(-cap*log(pstDY(i,j)+ptopDY)))
C +...Expansion of           SLutsl(i,j,1): see TURsbl
C +
      cdTurb     = rho10m * cp * SLuusl(i,j,1) * cdhSL(i,j,1)*pcap
      hsensi     = cdTurb * pktaDY(i,j,mz)
      hsenst     = cdTurb * exp(-cap*log(pstDY(i,j)+ptopDY))
C +
c #SE hsensd     = hsenSL(i,j)  + hsensi - hsenst *tsrfSL(i,j,1)
c #SE if (abs(hsensd).gt.epSN1) 
c #SE.write(29,1200) jdaMAR,jhaMAR,jmmMAR,hsensd,hsenSL(i,j)
 1200 format(//,i4,':',i2,':',i2,5x,'|dHS|:',f9.1,
     .        /,                15x,'  HS :',f9.1,' before Snow  Model')
C +
C +-- 2.4.1 Parameterization Col de Porte
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +  (see Lejeune et Martin 1995, Note CEN, p.42)
C +
c #CP                     cdColP = 3.09d0 * ssvSL(i,j,mz)
c #CP if (cdColP.lt.1.05) cdColP = 1.05d0
C +
c #CP     dts_ta                 =         tsrfSL(i,j,1)-tairDY(i,j,mz)
c #CP if (dts_ta.gt.0.d0) cdColP = cdColP 
c #CP.                           *(1.00d0+min(hsunst,dts_ta)/hsunst)
c #CP hsenSL(i,j)= 1.5d+0*cdColP * dts_ta
c #CP hsensi     = 1.5d+0*cdColP *                       tairDY(i,j,mz)
c #CP hsenst     = 1.5d+0*cdColP
C +...             1.5d+0//Extinction Coefficient Correction in SRFext_sno
C +
C +
C +-- 2.5 Evaporation and/or Sublimation
C +   ----------------------------------
C +
                                                                 lsf = 0
      qst    = qsat0D(tsrfSL(i,j,1) ,unun,     pstDY(i,j),ptopDY,lsf)
C +...qst    : saturation specific humidity, surface (kg/kg)
C +
                                                                 lsf = 1
      qsa    = qsat0D(tairDY(i,j,mz),sigma(mz),pstDY(i,j),ptopDY,lsf)
      relhum =          qvDY(i,j,mz) / qsa
C +
      pr     = (pstDY(i,j) +ptopDY)    * 10.d0
      rhos   =  pr/(RDryAi*TairSL(i,j))*100.d0
C +      
C +-- 2.5.1 Water Vapor Flux at Snow-Atmosphere Interface
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +-- 2.5.1 a) Bulk Aerodynamic Formula
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
      egdd= rho10m*cdhSL(i,j,1)*SLuusl(i,j,1) *(qst-qvDY(i,j,mz))
C +      
c _UQ egdd= rho10m*ch0SL(i,j  )* ssvSL(i,j,mz)*(qst-qvDY(i,j,mz))
C +UQ egdd=-rhos  *SLuqsl(i,j,1)
C +UQ     : When   u q *  is computed used flux profile relationships
C +         (e.g. Duynkerke and van den Broecke, 1993)
C +...egdd [kg/m2/s]
C +
C +-- 2.5.1 b) Thom & Oliver (1977)
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
      if (nb_sno.gt.0)      then
                            rsurXX=0.00d0
      else
                            rsurXX=rsurSL(i,j)
      end if
C +
      gamp = 4.08d-04*(1.d0+rsurXX/raerSL(i,j))
C +...rsurSL : `bulk' stomatal resistance (Thom & Oliver, 1977, p. 347)
C +...raerSL : aerodynamic resistance (computed in routine TURsbl)
C +
      aqsat= 1.d0/(237.3d0+tairDY(i,j,mz))
      dqsat= qst*4098.d0*aqsat*aqsat
      den  = dqsat+gamp
      qs10 = qsat0D(tairDY(i,j,mz),sigma(mz),pstDY(i,j),ptopDY,lsf)
C +...qs10 : saturation specific humidity, 1st Sigma Level (kg/kg)
C +
      dnum = (radnet*.9d0)*dqsat 
     .     + rhos*cp*(qs10-qvDY(i,j,mz))/raerSL(i,j)
      egpm = dnum/den/Ls_H2O
C +
C +
      if (nb_sno.gt.0) then  ! Tundra is dry
         eg    = egdd        ! Bulk Aerodynamic Formula
      else
         eg    = egpm        ! Thom & Oliver (1977)
      endif
C +
C +
c #CP  eg = 1.5d+0*cdColP *(qst-qvDY(i,j,mz))/cp
C +
C +-- 2.5.2 Sublimation of Saltating Snow
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS IF (SLuusl(i,j,1).gt.SaltSL(i,j))                           THEN
c #BS     hSalta       =   hSalBS(i,j)
c #BS ELSE
c #BS     hSalta       =   0.0d+0
c #BS END IF
c #BS     sSalta       =   hSalta*rho10m*(qst-qvDY(i,j,mz))
c #BS     sSaldt       =   sSalta/dtPhys
C +...    sSaldt [kg/m2/s]
C +
c #BS     eg   =  eg   +   sSaldt
C +
C +-- 2.5.3 Latent Heat Flux
C +   ~~~~~~~~~~~~~~~~~~~~~~
          SLuqsl(i,j,1)= -eg / rhos
C +
      IF (tsrfSL(i,j,1).lt.TfSnow)                                THEN
          hlatSL(i,j)  =  eg * Ls_H2O
      ELSE
          hlatSL(i,j)  =  eg *(Ls_H2O-Lf_H2O)
      END IF
C +
C +-- 2.5.4 Impact of Sublimation on Surface Water Budget
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          subli        =   eg * dtPhys / ro_Wat  
C +
          roseSL(i,j)  =   roseSL(i,j) - subli
C +...    roseSL       :   Deposed Water Budget [mWE]
C +
C +
C +-- 3. Snow Cover Dry Mass  Forcing
C +   ===============================
C +
C +-- 3.1 Snow fall
C +   -------------
C +
c #sn  hsnofake_old= hsnoSL(i,j)
C +
c #sn  fhsno       = csnow*(snobSL(i,j)   +snohSL(i,j)       )
c #sn.             * ro_Wat*(tairDY(i,j,mz)-tiSNow(i,j,nb_sno))
c #sn.             / dtPhys 
C +
C +-- 3.1.1  Blown Snow (Erosion)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS  bsnoSL(i,j) = bsnoSL(i,j) + snobSL(i,j) ! Snow Accumulated Erosion 
c #BS  snobSL(i,j) = zero                      ! Snow Erosion 
c #BS  bsnoEW      = bsnoSL(i,j)
C +
C +-- 3.1.2  All Snow (Deposition)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
       hsnoSL(i,j) = hsnoSL(i,j) + snohSL(i,j) ! Snow Accumulated Precip.      
       snohSL(i,j) = zero                      ! Snow Precipitation 
       hsnoEW      = hsnoSL(i,j)
C +
C +-- 3.1.3  Snow age
C +   ~~~~~~~~~~~~~~~
c #sn  if     (nb_sno.ge.1)  then
c #sn   do n=1,nb_sno
c #sn    agSNow(i,j,n) = agSNow(i,j,n) + dtPhys / 86400.d0
c #sn   end do
c #sn  end if
c #sn  if     (nb_sno.lt.mg) then
c #sn   do n=  nb_sno +1,mg
c #sn    agSNow(i,j,n) = 0.0d00
c #sn   end do
c #sn  end if
C +
C +
C +-- 3.2 Erosion
C +   -----------
C +
c #BS IF (nb_sno .gt. 0)                                          THEN
C +
C +-- 3.2.1 Mobile Snow Layers (from Snow Pack Top, using Snow Drift Index)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~
c #BS        mobile         =  nb_sno + 1
c #BS        SaltSI(mobile) =  0.0d00
 101     continue
c #BS    IF (SaltSI(mobile).lt.0.0d00)                       go to 100
c #BS        mobile=mobile  -  1
c #BS    IF (mobile        .lt.1     )                       go to 100
C +
c #BS    IF(g1SNow(i,j,mobile).lt.0.d0)                           THEN
c #BS      SaltMo         = -0.750d-2 * g1SNow(i,j,mobile) 
c #BS.                      -0.500d-2 * g2SNow(i,j,mobile)+ 0.500d00
C +...     SaltMo      :     Guyomarc'h & Merindol, 1997, Ann. Glac.
C +             CAUTION:     Guyomarc'h & Merindol Dendricity Sign is +
C +             ^^^^^^^^                       MAR Dendricity Sign is -
c #BS    ELSE
c #BS      SaltMo         = -0.833d-2 * g1SNow(i,j,mobile) 
c #BS.                      -0.583d-2 * g2SNow(i,j,mobile)+ 0.833d00
c #BS    END IF
C +
c #BS    IF (nhSNow(i,j,mobile).ge.nhSNo2)SaltMo = min(SaltMo,SaltMx)
C +
C +-- 3.2.2 Influence of Density on Shear Stress
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS      Por_BS      =  1.000d00    - roSNow(i,j,mobile)/ro_Ice
c #BS      ShearX      =                   Por_BS/(unun-Por_BS) 
C +...     ShearX ==> Arg(sqrt(shear)) with shear = max shear stress in snow:
C +        shear       =  3.420d00 * exp(-(Por_BS      +Por_BS)
C +  .                                   /(unun        -Por_BS))
C +                       see de Montmollin         (1978),
C +                       These Univ. Sci. Medic. Grenoble, Fig. 1 p. 124
C +
c #BS      SaltSU      =      (1.00d0+SaltMo)          *FacSBS
c #BS      ArgFac      =   max(zero  ,SheaBS-ShearX)
c #BS      Fac_Mo      =   exp(       ArgFac       )
C +
C +-- 3.2.3 Snow Drift Index
C +   ~~~~~~~~~~~~~~~~~~~~~~
c #BS      SaltSU         =  exp(Fac_Mo*log(SaltSU))
c #BS      ArguSi         =     -FacTBS                *ssvSL(i,j,mz)
c #BS      SaltSI(mobile) =     (SaltSU-exp(ArguSi))   *FacRBS
C +...     SaltSI         :  Snow Drift Index                         
C +                         (Guyomarc'h & Merindol, 1997, Ann. Glac.)
C +
c #BS    go to 101
 100     continue
c #BS        mobile =  mobile + 1
C +
C +-- 3.2.4 Weighting the Amount of Snow to erode
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS    IF (bsnoSL(i,j).lt.     0.0d00)
c #BS.       mobile = min(mobile,nb_sno)
c #BS    IF (mobile     .le.     nb_sno)                          THEN
c #BS        zsnow     =         0.0d00
c #BS        xdrift    =         0.0d00
c #BS     DO n=nb_sno,mobile,-1
c #BS        zsnow     =  0.50d0 * dzSNow(i,j,n)
c #BS.                 * (3.25d0 - SaltSI    (n))+zsnow
c #BS        zdrift(n) =  exp( max(argmin,-zsnow *hdrift)) *SaltSI(n)
c #BS        xdrift    =           zdrift    (n) +xdrift
c #BS        zsnow     =  0.50d0 * dzSNow(i,j,n)
c #BS.                 * (3.25d0 - SaltSI    (n))+zsnow
c #BS     END DO
c #BS     IF                                     (xdrift.gt.0.d0) THEN
c #BS       do n=nb_sno,mobile,-1
c #BS        zdrift(n) =  zdrift(n)              /xdrift
c #BS       end do
c #BS     ELSE
c #BS       do n=nb_sno,mobile,-1
c #BS        zdrift(n) =                                    0.d0
c #BS       end do
c #BS     END IF
C +
C +-- 3.2.5 Weighting the Amount of Snow to depose
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS        redist    =  nb_sno - mobile + 1
c #BS        zsnow     =  0.0d00
c #BS        tdepos    =  0.0d00
c #BS     do n=nb_sno,mobile,-1
c #BS        zdepos(n) =  exp(-zsnow)
c #BS        tdepos    =       tdepos + zdepos(n)
c #BS        zsnow     =       zsnow  + dzSNow(i,j,n) *roSNow(i,j,n)
c #BS     end do
c #BS     do n=nb_sno,mobile,-1
c #BS        zdepos(n) =                zdepos(n)     /tdepos
c #BS     end do
C +...
c #BS    END IF
C +  
c #BS END IF
C +
C +-- 3.2.6 Weighted  Erosion
C +   ~~~~~~~~~~~~~~~~~~~~~~~
c #BS IF (nb_sno .gt. 0      .and.
c #BS.    mobile .le. nb_sno .and. bsnoSL(i,j).lt.0.d00)          THEN
C +
c #BS     bsno_z             = bsnoSL(i,j)
C +
c #BS     do n=nb_sno,mobile,-1
c #BS     dzweqo             = dzSNow(i,j,n)     *roSNow(i,j,n)
c #BS.                                           /ro_Wat
c #BS     bsno_x             = bsno_z            *zdrift(n)
c #BS     dzweqn             = dzweqo            +bsno_x                  
c #BS     dzweqn         = max(dzweqn,    h_mWE)
c #BS     bsnoSL(i,j)        = bsnoSL(i,j)       +dzweqo - dzweqn
c #BS     dzSNow(i,j,n)      = dzweqn            *ro_Wat
c #BS.                                           /roSNow(i,j,n)
c #BS     end do
C +
c #BS ELSE 
c #BS.IF (nb_sno .eq. 0)                                          THEN
c #BS     bsno               = bsnoSL(i,j)       +hsnoSL(i,j)
c #BS     bsno           = min(bsno  ,     zero)
c #BS     hsnoSL(i,j)        = bsnoSL(i,j)-bsno  +hsnoSL(i,j)
c #BS     bsnoSL(i,j)        = bsno
c #BS END IF
C +
C +
C +-- 3.3 Accumulation of blow snow
C +   -----------------------------
C +
c #BS tnsnoS = tiSNow(i,j,nb_sno+1)
C +
c #BS IF (iterun.le.1)                                            THEN
c #BS  DO k=1,mz
c #BS     zsigma(k) = (gplvDY(imez,jmez,k)-gplvDY(imez,jmez,mzz))*grvinv
c #BS  END DO
c #BS     facust = demi *tfv_vk  *log(zsigma(mz1)/zsigma(    mz))
c #BS END IF
c #BS     tdrift =                exp(-facust    /SLuusl(i,j,1 ))
c #BS     rdrift = qsHY(i,j,mz1) /max( epsi      ,  qsHY(i,j,mz))
C +
C +-- 3.3.1 Deposition of first blown snow layer
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS IF (rdrift.le.tdrift.and.((nb_sno.eq.0.and.hsnoSL(i,j).gt.h0mWE)))
c #BS.THEN
c #BS                            nb_sno  =            1
c #BS                 g1SNow(i,j,nb_sno) = vg1SNo
c #BS                 g2SNow(i,j,nb_sno) = DiGfSN
c #BY                 g2SNow(i,j,nb_sno) = 0.87d0
C +...                Budd et al. 1966, 2~m Average /Table 5 p. 97
C +                   (not accepted in Brun et al. Grains Characteristics) 
C +
c #BS                 tiSNow(i,j,nb_sno) = min(TfSnow,tairDY(i,j,mz))
c #BS                 roSNow(i,j,nb_sno) =                         blsno 
c #BS                 dzSNow(i,j,nb_sno) =     ro_Wat *hsnoSL(i,j)/blsno
C +...                Conversion  [mWE] -----> [mSnow]
C +
c #BS                 hsnoSL(i,j)        =     0.d0
c #BS                 waSNow(i,j,nb_sno) =     0.d0
c #BS                 agSNow(i,j,nb_sno) =     0.d0
C +
c #BS             IF (tsrfSL(i,j,1).lt.TfSnow)                    THEN
c #BS                 nhSNow(i,j,nb_sno) =     0   
c #BS             ELSE
c #BS                 nhSNow(i,j,nb_sno) =     nhSNo2
c #BS             END IF
C +
c #BS ELSE
C +
C +-- 3.3.2 Subsequent Deposition
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS.IF (rdrift.le.tdrift.and.((nb_sno.gt.0.and.hsnoSL(i,j).gt. epsi)))            
c #BS.THEN
C +...    rdrift <  tdrift ==> assume precipitating Snow = blown Snow
C +
C +-- 3.3.3 Aggregation in case of     mobile Snow Layers
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS  IF (mobile.le.nb_sno)                                      THEN
C +
c #BS                 hsno_z             = hsnoSL(i,j)
C +
c #BS   DO nb_acr=nb_sno,mobile,-1
c #BS     DO    n=nb_sno,nb_acr,-1
c #BS                 g1SNow(i,j,n+1)    = g1SNow(i,j,n)
c #BS                 g2SNow(i,j,n+1)    = g2SNow(i,j,n)
c #BS                 tiSNow(i,j,n+1)    = tiSNow(i,j,n)
c #BS                 roSNow(i,j,n+1)    = roSNow(i,j,n)
c #BS                 dzSNow(i,j,n+1)    = dzSNow(i,j,n)
c #BS                 waSNow(i,j,n+1)    = waSNow(i,j,n)
c #BS                 agSNow(i,j,n+1)    = agSNow(i,j,n)
c #BS                 nhSNow(i,j,n+1)    = nhSNow(i,j,n)
c #BS     END DO
C +
C +...     nb_acr layer is hypothetical 
C +                    (contains blown snow to be aggregated to layer n)
c #BS                            nb_sno  = nb_sno  +  1
c #BS                 g1SNow(i,j,nb_acr) = vg1SNo
c #BS                 g2SNow(i,j,nb_acr) = DiGfSN
c #BY                 g2SNow(i,j,nb_acr) = 0.87d0
C +...                Budd et al. 1966, 2~m Average /Table 5 p. 97
C +                   (not accepted in Brun et al. Grains Characteristics) 
C +
c #BS                 tiSNow(i,j,nb_acr) = min(TfSnow,tairDY(i,j,mz))
C +
C +-- 3.3.4 Density of deposited blown Snow (de Montmollin, 1978)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS                 PorSno =      1.0d00     -  roSNow(i,j,nb_acr)
c #BS.                                         /  ro_Ice
c #BS                 Salt_f =      SaltSL(i,j)/  SLuusl(i,j,1)
c #BS                 Salt_f =  min(Salt_f     ,  unun)
c #BS                 PorRef =      PorSno     / (1.0d00 - PorSno)
c #BS.                         +log(Salt_f)
c #BS                 Por_BS =      PorRef     / (1.0d00 + PorRef)
c #BS                 ro_new =      ro_Ice     * (1.0d00 - Por_BS)
c #BS                 ro_new =  max(ro_new     ,  blsno )
C +
c #BS                 roSNow(i,j,nb_acr) =            ro_new
c #BS                 hsno_x             =     hsno_z*zdepos(nb_acr)
C +
c #BS                 dzSNow(i,j,nb_acr) =     ro_Wat *hsno_x    /ro_new
C +...                Conversion  [mWE] -----> [mSnow]
C +
c #BS                 hsnoSL(i,j)        =     hsnoSL(i,j)       -hsno_x
C +
c #BS                 waSNow(i,j,nb_acr) =     0.d0
C +
c #BS             IF            (nb_acr.gt.1)                     THEN
c #BS                 agSNow(i,j,nb_acr) =     agSNow(i,j,nb_acr-1)
c #BS             ELSE
c #BS                 agSNow(i,j,nb_acr) =     0.d0
c #BS             END IF
C +
c #BS             IF (tsrfSL(i,j,1).lt.TfSnow)                    THEN
c #BS                 nhSNow(i,j,nb_acr) =     0   
c #BS             ELSE
c #BS                 nhSNow(i,j,nb_acr) =     nhSNo2
c #BS             END IF
C +
C +                   ***************
c #BS                 call SRFagr_sno(nb_acr,nb_sno)
C +                   ***************
C +
C +...            REMARK: a too thick surface layer is splitted 
C +               ^^^^^^^ (see SRFstr_sic)
C +
c #BS   END DO
C +
C +-- 3.3.5 Aggregation in case of NON mobile Snow Layers
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS  ELSE
c #BS                            nb_sno  = nb_sno + 1
c #BS                 g1SNow(i,j,nb_sno) = vg1SNo
c #BS                 g2SNow(i,j,nb_sno) = DiGfSN
c #BY                 g2SNow(i,j,nb_sno) = 0.87d0
C +...                Budd et al. 1966, 2~m Average /Table 5 p. 97
C +                   (not accepted in Brun et al. grains characteristics) 
C +
c #BS                 tiSNow(i,j,nb_sno) = min(TfSnow,tairDY(i,j,mz))
C +
C +-- 3.3.6 Density of deposited blown Snow (de Montmollin, 1978)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS                 PorSno =      1.0d00     -  roSNow(i,j,nb_sno-1)
c #BS.                                         /  ro_Ice
c #BS                 Salt_f =      SaltSL(i,j)/  SLuusl(i,j,1)
c #BS                 Salt_f =  min(Salt_f     ,  unun)
c #BS                 PorRef =      PorSno     / (1.0d00 - PorSno)
c #BS.                         +log(Salt_f)
c #BS                 Por_BS =      PorRef     / (1.0d00 + PorRef)
c #BS                 ro_new =      ro_Ice     * (1.0d00 - Por_BS)
c #BS                 ro_new =  max(ro_new     ,  blsno )
C +
c #BS                 roSNow(i,j,nb_sno) =           ro_new
c #BS                 dzSNow(i,j,nb_sno) =     ro_Wat*hsnoSL(i,j)/ro_new
C +...                Conversion  [mWE] -----> [mSnow]
C +
c #BS                 hsnoSL(i,j)        =     0.d0
C +
c #BS                 waSNow(i,j,nb_sno) =     0.d0
C +
c #BS             if            (nb_sno.gt.1) then
c #BS                 agSNow(i,j,nb_sno) =     agSNow(i,j,nb_sno-1)
c #BS             else
c #BS                 agSNow(i,j,nb_sno) =     0.d0
c #BS             end if
C +
c #BS             if (tsrfSL(i,j,1).lt.TfSnow) then
c #BS                 nhSNow(i,j,nb_sno) =     0   
c #BS             else
c #BS                 nhSNow(i,j,nb_sno) =     nhSNo2
c #BS             end if
C +
C +                   ***************
c #BS                 call SRFagr_sno(nb_sno-1,nb_sno)
C +                   ***************
C +
C +...            REMARK: a too thick surface layer is splitted 
C +               ^^^^^^^ (see SRFstr_sic)
C +
c #BS  END IF
C +
c #BS END IF
C +
c #BS tiSNow(i,j,nb_sno+1) = tnsnoS
C +
C +
C +-- 3.4 Accumulation of fresh snow 
C +   ------------------------------
C +
c #sn if (hsnoSL(i,j).gt.h0mWE) then ! Minimum new snow layer thikness 
C +
C +-- 3.4.1 Layer Aggregation Procedure
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  if(nb_sno     .ge.mg1)   then
C +
C +-- 3.4.1 a) Weights of Layers Interfaces
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #sn    znSNo(mg)= dzSNow(i,j,nb_sno)
c #sn    do n=mg1   ,1,-1
c #sn    znSNo(n) = dzSNow(i,j,n) + znSNo(n     +1)
c #sn    end do
C +
c #sn   do n=nb_sno,nb_ice+2,-1
c #sn    sno_cm   =  1.d2  *        znSNo(nb_ice+1)
C +
c #sn    zdzmax   =            (SNmdz4-                  n     /SNmdz5)
c #sn.                     *max(SNmdz1,                 sno_cm /SNmdz6)
C +
C +...   zdzmax   =  dzSNr(n)
C +
c #sn    zdzmin   =            (SNmdz4-                 (n  -1)/SNmdz5)
c #sn.                     *max(SNmdz1,                 sno_cm /SNmdz6)
C +
C +...   zdzmin   =  dzSNr(n-1)
C +
c #sn    zdtmax   =  SNtyp1*   (SNtyp2-                  n     /SNtyp3)
c #sn.                     *min(SNtyp4,max(SNtyp5,      sno_cm /SNtyp6))
C +
C +...   zntotn   =  max(unun,znSNo(1)/mg)
C +      zntotn   : "normalized" Thickness
C +
C +...   typrel   = zntotn/ 4.d0
C +      zdtmax   = 2.0d1 *(2.d0-     n/(0.75d0*mg)) 
C +  .                 *min(typmin,max(unun,typrel))
C +
c #sn    zdamax   =  SNdag1*   (SNdag2-           SNdag3*n     /SNdag4)
c #sn.                     *max(SNdag5,         znSNo(nb_ice+1)/SNdag6)
C +
C +...   agerel   = zntotn/ 2.d0
C +      zdamax   = 1.5d0 *(1.d1-9.d0*n/(0.75d0*mg0))
C +  .                 *           max(unun,agerel) 
C +
c #sn    sisno(n) =(dzSNow(i,j,n)/zdzmax +dzSNow(i,j,n-1)/zdzmin)*1.d2
c #sn    sisno(n) = min( sisno(n)                             ,  wghmax)
c #sn   if (dzSNow(i,j,n)+dzSNow(i,j,n-1) .gt.  2.d0     *zdzmin*wghmin)
c #sn.   sisno(n) =      sisno(n)                             +  wghmax
C +
c #sn    sisno(n) =      sisno(n)
C +
C +                 **********
c #sn.            + SRFdtp_sno(g1SNow(i,j,n)  ,g2SNow(i,j,n),
c #sn.                         g1SNow(i,j,n-1),g2SNow(i,j,n-1),
c #sn.                         nhSNow(i,j,n)  ,nhSNow(i,j,n-1),
c #sn.                         roSNow(i,j,n)  ,roSNow(i,j,n-1)) / zdtmax
C +                 **********
C +
c #sn.            -(agSNow(i,j,n)             -agSNow(i,j,n-1)) / zdamax
C +
c #sn   end do
C +
C +-- 3.4.1 b) Minimum Weight ==> Index of Interface to be aggregated
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #sn      simin  = sisno(nb_ice+2)
c #sn      n_min  =       nb_ice+2 
c #sn   do n = nb_sno,    nb_ice+3,-1
c #sn   if(simin.gt.sisno(n)) then
c #sn      simin  = sisno(n)
c #sn      n_min  =       n 
c #sn   end if
c #sn   end do
C +
C +-- 3.4.1 c) Aggregation
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
C +     ***************
c #sn   call SRFagr_sno(n_min-1,nb_sno)
C +     ***************
C +
c #sn  end if
C +
C +-- 3.4.2 Creation of a New Layer
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  nb_sno              = nb_sno+1
c #sn  tiSNow(i,j,nb_sno)  = min(TfSnow,tairDY(i,j,mz))
c #sn  tiSNow(i,j,nb_sno+1)=            tiSNow(i,j,nb_sno)
C +
C +-- 3.4.3 Inclusion of Wind and Temperature Effects (CROCUS parameterization)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c +GL  IF(tairDY(i,j,mz).ge.268.15) THEN   
c #sn  roSNow(i,j,nb_sno)= max(r0sno,
c #sn.                         rho1SN+rho2SN*   (tairDY(i,j,mz)-TfSnow)
c #sn.                               +rho3SN*sqrt(ssvSL(i,j,mz)))
C +... Formule "PAHAUT" Densite Neige Fraiche (CEN)
C +
c #sn  dzSNow(i,j,nb_sno)= hsnoSL(i,j)  *ro_Wat/    roSNow(i,j,nb_sno)
C +... Conversion  because hsnoSL(i,j) expressed in mWE
C +
c #sn  g1SNow(i,j,nb_sno)= max(min(den1SN*ssvSL(i,j,mz)-den2SN,den3SN)
c #sn.                        ,-vg1SNo)
c #sn  g2SNow(i,j,nb_sno)= min(max(sph1SN*ssvSL(i,j,mz)-sph2SN,sph3SN)
c #sn.                        , sph4SN)
C +... Formule "GIRAUD" Dendricite, Sphericite Neige Fraiche (CEN)
C + 
c +GL  ELSE 
c #GL  IF (.not.ETH_Camp) THEN    ! For Greenland fresh snow 
c #GL  roSNow(i,j,nb_sno)= 300.0d0
c #GL  dzSNow(i,j,nb_sno)= hsnoSL(i,j) *ro_Wat/roSNow(i,j,nb_sno)
c #GL  g1SNow(i,j,nb_sno)= 99.0d0
c #GL  g2SNow(i,j,nb_sno)= 3.0d0
c #GL  END IF                     
C +
C +-- 3.4.4 Fresh Snow Water Content
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn   waSNow(i,j,nb_sno)= 0.d0          ! Snow Cover Water content
c #sn   agSNow(i,j,nb_sno)= 0.d0          ! Snow Age
c #sn   hsnoSL(i,j)       = 0.d0          ! Snow Accumulated Precipitation 
c #sn  if (tsrfSL(i,j,1).lt.TfSnow) then 
c #sn   nhSNow(i,j,nb_sno)= 0             ! Layer historics
c #sn  else
c #sn   nhSNow(i,j,nb_sno)= nhSNo2         
c #sn  end if
C +
c #Se   pheat             = roSNow(i,j,nb_sno) * dzSNow(i,j,nb_sno)
c #Se.                    *(csnow              * tiSNow(i,j,nb_sno)
c #Se.                     +Lf_H2O             * waSNow(i,j,nb_sno))
C +...  pheat             : Equivalent Energy Amount from Snow Precipitation
C +
c #Se else  
c #Se   pheat             = 0.d00
c #sn end if
C +
C +-- 3.4.5 Update of albedo when "new" layer is too small to be created
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  tiSNowfake        = min(TfSnow,tairDY(i,j,mz))
c +GL  IF(tairDY(i,j,mz).ge.268.15) THEN    
c #sn  roSNowfake        = max(r0sno,
c #sn.                         rho1SN+rho2SN*   (tairDY(i,j,mz)-TfSnow)
c #sn.                               +rho3SN*sqrt(ssvSL(i,j,mz)))
c #sn  g1SNowfake        = max(min(den1SN*ssvSL(i,j,mz)-den2SN,den3SN)
c #sn.                        ,-vg1SNo)
c #sn  g2SNowfake        = min(max(sph1SN*ssvSL(i,j,mz)-sph2SN,sph3SN)
c #sn.                        , sph4SN)
C +
c +GL  ELSE 
c #GL  IF (.not.ETH_Camp) THEN    ! For Greenland fresh snow 
c #GL  roSNowfake= 300.0d0
c #GL  g1SNowfake= 99.0d0
c #GL  g2SNowfake= 3.0d0
c #GL  END IF 
C +
C +
C +-- 4. Snow Cover Water Forcing
C +   ===========================
C +
c #sn   fhwat       = 0.0d0
C +
c #sn  if (nb_sno.eq.0) then 
c #sn   hwatSL(i,j) = hwatSL(i,j)  +precSL(i,j)
C +...  hwatSL(i,j) : Liquid Precipitation available for the Ground [m]
C +
c #sn  else
c #sn   dwater      = precSL(i,j)  *ro_Wat
C +...  dwater      : Water Amount due to Liquid Precipitation  [kg/m2]
C +
c #sn   waSNru(i,j) = waSNru(i,j)  +dwater
c #sn   fhwat       = csnow        *dwater 
c #sn.              *(tairDY(i,j,mz)-tiSNow(i,j,nb_sno))/dtPhys
C +...  fhwat       : Heat amount due to liquid precipitation  
C +      ==>CAUTION : Heat Capacity of Snow used, not of Water)
c #sn  end if
C +
        precSL(i,j) = 0.0d0
C +
C +
C +-- 5. Snow Cover: Local Initialisation
C +   ===================================
C +
C +-- 5.1 Snow Temperature and Water Content
C +   --------------------------------------
C +
c #sn  do n=-mh,nb_sno+1
c #sn  tnsno  (1,n) = tiSNow(i,j,n)
c #sn  end do
c #sn if     (nb_sno.gt.0) then
c #sn  do n=1,nb_sno
c #sn  wnsno    (n) = waSNow(i,j,n)
c #sn  end do
c #sn end if
C +
C +
C +-- 6. Soil Local Characteristics
C +   =============================
C +
C +
C +-- 6.1 Soil Heat Capacity
C +   ----------------------
C +
c #sn IF     (mh.gt.0)                                            THEN
c #sn   DO n=-mh1+1,0
c #sn     cs_SV    (n) = dzSNo(n) * 0.56d+6 * 4.18d00
C +...    Deardorff 1978 JGR p1891: 0.56  [cal/cm3/K] (Clay Pasture)
C +
C +
C +-- 6.2 Soil  Conductivity
C +   ----------------------
C +
c #sn     cdsno    (n) =            0.56d+6 * 4.18d00 * 1.20d-6
C +...    cdsno    : Soil Heat Conductivity Coefficient 
C +       Deardorff 1978 JGR p1891:       [Wm/K]      (Clay Pasture)
C +
c #sn   END DO
c #sn END IF
C +
C +  ===========================
C +--BEGIN OF INTERNAL TIME LOOP--------------------------------------------
C +  ===========================
C +
c #sn DO itsno = 1,ntSNo
C +
C +
C +-- 7. Snow Cover Energy and Water Content
C +   ======================================
C +
c #SE   DO iroute= 1,8
c #SE      wwater(iroute)= wwater(iroute+1)
c #SE      mroute(iroute)= mroute(iroute+1)
c #SE      wwater(9)     = waSNru(i,j)
c #SE      mroute(9)     = nroute
c #SE   END DO
c #SE      nroute        ='                                            '
C +
c #Se      heat1 =(csnow     *TfSnow           +Lf_H2O) *waSNru(i,j)
C +...             Energy included in Surficial Water
C +
c #Se.            +d1_SL(i,j)*tiSNow(i,j,-mh)           /3.72d0
C +...             Energy of          Soil      Layer
C +
c #Se   IF      (mh  .gt.0)                                       THEN
c #Se     DO n= -mh1+1,0
c #Se       heat1 = heat1
c #Se.            + cs_SV(n)                            *tiSNow(i,j,n)
c #Se     END DO
c #Se   END IF
C +
c #Se   IF    (nb_sno.ge.1)                                       THEN
c #Se     DO n=nb_sno,1,-1
c #Se       heat1 = heat1
c #Se.       + csnow     *roSNow(i,j,n)  *dzSNow(i,j,n) *tiSNow(i,j,n)
c #Se.       + Lf_H2O    *roSNow(i,j,n)  *dzSNow(i,j,n) *waSNow(i,j,n)
c #Se     END DO
c #Se   END IF
C +
c #SW       dwater =           - waSNru(i,j)
c #SW   IF      (nb_sno.ge.1)                                     THEN
c #SW     DO n=1,nb_sno
c #SW       dwater =  dwater   - wnsno(n) *roSNow(i,j,n) *dzSNow(i,j,n)
c #SW     END DO
c #SW   END IF
C +
C +
C +-- 8. Snow Cover Local Characteristics
C +   ===================================
C +
C +-- 8.1 Snow Thickness
C +   ------------------
C +
c #sn  znSNo(mg) = dzSNow(i,j,mg)
c #sn DO    n=mg1,1,-1
c #sn  znSNo(n)  = dzSNow(i,j,n) + znSNo(n+1)
c #sn END DO
C +
C +
C +-- 8.2 Snow Conductivity
C +   ---------------------
C +
c #sn if     (nb_sno.gt.0) then
c #sn  do n=1,nb_sno
c #sn cdsno(n) = cdice     * (roSNow(i,j,n) /ro_Wat) ** 1.88d0
c #sn cdsno(n) = max(cdsno(n), 0.03)
C +...cdsno    : Snow Heat Conductivity Coefficient              [Wm/K]
C +               (Yen 1981, CRREL Rep., 81-10)
c #sn  end do
C +
C +
C +-- 8.3 Snow Grain Size
C +   -------------------
C +
c #sn  do n  = 1,nb_sno
c #sn  dgsno(n)  = 1.6d-4
c #sn.           + 1.1d-13 *(roSNow(i,j, n)*roSNow(i,j, n)
c #sn.                      *roSNow(i,j, n)*roSNow(i,j, n))
C +... dgsno(n)  : Grain Size (Loth et al. 1993 JGR 98 D6 p.10454)
C +                      from  Anderson    1976
c #sn  dgsno(n)  = min (dgsno(n),gSNmax)
C +...                           gSNmax = 3mm (Rowe et al. 1995, JGR p.16268)
c #sn  dsqr      = sqrt(dgsno(n))
C +... CAUTION:  Cold snow metamorphism and                       . 
C +              related grain size increase                     / \  
C +              (Loth et al. 1993 JGR 98 D6 p. 10454)          / | \
C +              are not included                              /  |  \
C +                                                           /   o   \
C +                                                          /_________\
C +
C +                   **********
c #AB  if (g2SNow(i,j,n).lt.0d0) g2SNow(i,j,n) = epsi    
c #AB  dopsno      = max(zero,SRFdia_sno(g1SNow(i,j,n),g2SNow(i,j,n)))
C +                   **********
C +
c #AB  dsqr        = sqrt(dopsno)  ! "optical" grain size
C +
C +
C +-- 8.4 Snow Extinction Coefficient
C +   -------------------------------
C +
c #sn  exsno(n) = 3.8d-3   * roSNow(i,j, n)/dsqr
C +... Bohren and Barkstrom 1974, JGR 98, no D6, p.10454
C +    exsno(n) = 40.d00
C +... exsno(n) = 40 m^-1,
C +    Kondo  and Yamazaki  1990, JAM 29,        pp.375--383

C +         **********
c #AB  call SRFext_sno(exsno(n),exsnoSP(n,1),exsnoSP(n,2) ,exsnoSP(n,3),
c #AB.                 dopsno  ,dsqr      ,roSNow(i,j,n),waSNow(i,j,n),
c #AB.                 DirSol  ,DifSol    ,Cld_SL(i,j))
C +         **********
C +
c #sn  end do
C +
C +
C +-- 8.5 CROCUS snow albedo parametrization
C +   --------------------------------------
C +
      albedofake1    = 0.0d0
      albedofake2    = 0.0d0
      albedofake3    = 0.0d0
      albedofake     = 0.0d0
      albedo_icel    = 0.0d0
      albedo_icel1   = 0.0d0
      albedo_icel2   = 0.0d0
      albedo_icel3   = 0.0d0
c #SA albHeq0_1      = 0.0d0
c #SA albHeq0_2      = 0.0d0	  
c #SA albHeq0_3      = 0.0d0
c #SA albHeq0        = 0.0d0
c #SA albHle10_1     = 0.0d0
c #SA albHle10_2     = 0.0d0	  
c #SA albHle10_3     = 0.0d0
c #SA albHle10       = 0.0d0	         
C +
C +
C +-- 8.5.1 Snow Albedo: Influence of Age and Grain Size 
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
C +
C +    ***************
c #sn  call SRFalb_sno(alb0SL(i,j),alb0SL_1(i,j),alb0SL_2(i,j),
c #sn.                  alb0SL_3(i,j),dopsno,dsqr,
c #sn.                  roSNow(i,j,nb_sno),waSNow(i,j,nb_sno),
c #sn.                  agSNow(i,j,nb_sno),DirSol,DifSol,Cld_SL(i,j))
C +    ***************
C +
c #SA  albCROCUS_1 = alb0SL_1(i,j)
c #SA  albCROCUS_2 = alb0SL_2(i,j)
c #SA  albCROCUS_3 = alb0SL_3(i,j)
c #SA  albCROCUS   = alb0SL(i,j)
C +       
C +... alb0SL      : Integrated background snow albedo,
C +                   adapted from Brun et al. 1991, J Glaciology
C +
C +-- 8.5.2 Snow Albedo: Correction in Case of a very light Snowfall
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  hsnofake_new     = hsnoSL(i,j) ! Snow Accumulated Precipitation 
C +
c #sn  IF                (hsnoSL(i,j).gt.0.0001d0 .and.
c #sn.                    hsnofake_new.gt.hsnofake_old)          THEN
C +
C +                         **********
c #sn   IF (g2SNowfake .lt. zero) g2SNowfake = epsi 
c #sn   dopsnofake       = max(zero,SRFdia_sno(g1SNowfake,g2SNowfake))
C +                         **********
C +
c #sn   dsqrfake         = sqrt(dopsnofake)
C +
C +     ***************
c #sn   call SRFalb_sno(albedofake,albedofake1,albedofake2,albedofake3,
c #sn.                  dopsnofake,dsqrfake,roSNowfake,zero,zero,
c #sn.                  DirSol,DifSol,cld_SL(i,j))
C +     ***************
C +
c #sn   hsnofake_old    = hsnofake_new
c #sn  ELSE 
c #sn   albedofake      = zero
c #sn  ENDIF
C +
C +-- 8.5.3 Snow Albedo: Correction in case of surface ice lense
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  albedo_icel= zero
c #sn  IF (nb_sno.gt.1) THEN
c #sn   if (roSNow(i,j,nb_sno)*(1.d0-wasnow(i,j,nb_sno)).ge.850.d0 .and.
c #sn.   rosnow(i,j,nb_sno-1)*(1.d0-wasnow(i,j,nb_sno-1)).lt.850.d0)then  
C +	
c #sn    IF (g2SNow(i,j,nb_sno-1).lt.zero) g2SNow(i,j,nb_sno-1) = 0.0d0
C +
C +               **********
c #sn    dopsno = SRFdia_sno(g1SNow(i,j,nb_sno-1),g2SNow(i,j,nb_sno-1))
C +               **********                   
C +
c #sn    dsqr   = sqrt(dopsno)
C +
C +      ***************
c #sn    call SRFalb_sno(albedo_icel,albedo_icel1,albedo_icel2,
c #sn.                   albedo_icel3,dopsno,dsqr,roSNow(i,j,nb_sno-1),
c #sn.                   waSNow(i,j,nb_sno-1),agSNow(i,j,nb_sno-1),
c #sn.                   DirSol,DifSol,cld_SL(i,j))
C        ***************
C +
c #sn   end if
c #sn  ENDIF
C +
c #GL  IF (maskSN(i,j) .le. 90) THEN 
c #sn   IF (nsiiSN(i,j) .eq. nb_sno) THEN
c #sn    snow_height = 0.0d0
c #sn   ELSE
c #sn    snow_height = znSNo(nsiiSN(i,j)+1)
c #sn   ENDIF
c #GL  ELSE 
c #GL   snow_height = 1.0d0 ! Large value because firn-area => never ice !)
c #GL  ENDIF 
C +
C +-- 8.5.4 Snow Albedo: Correction in case of water on bare ice
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  IF (snow_height.eq.zero) THEN
c #sn   albedo_old     = alb0SL(i,j)
c #sn   alb0SL(i,j)    = 0.20d0-(0.20d0-aiceSN)*exp(-waSNru(i,j)/waSN)
c #sn   alb0SL_2(i,j)  = alb0SL_2(i,j)
c #sn.                 - 0.50d0      ! 50 % : empirical value
c #sn.                 *(albedo_old  - alb0SL(i,j))/s2SNv
c #sn   alb0SL_3(i,j)  = alb0SL_3(i,j)
c #sn.                 - 0.50d0      ! 50 % : empirical value
c #sn.                 *(albedo_old  - alb0SL(i,j))/s3SNv
c #sn   alb0SL_2(i,j)  = max(alb0SL_2(i,j),0.01)
c #sn   alb0SL_2(i,j)  = min(alb0SL_2(i,j),0.99)
c #sn   alb0SL_3(i,j)  = max(alb0SL_3(i,j),0.01)
c #sn   alb0SL_3(i,j)  = min(alb0SL_3(i,j),0.99)
c #SA   albHeq0_1      = alb0SL_1(i,j)
c #SA   albHeq0_2      = alb0SL_2(i,j)	  
c #SA   albHeq0_3      = alb0SL_3(i,j)
c #SA   albHeq0        = alb0SL(i,j)
c #sn   if (albedofake .ne.zero) then
c #sn    alb0SL(i,j)   = albedofake
c #sn    alb0SL_1(i,j) = albedofake1
c #sn    alb0SL_2(i,j) = albedofake2
c #sn    alb0SL_3(i,j) = albedofake3
c #sn   endif
C + 
C +-- 8.5.5 Snow Albedo: Correction in case of a shallow (<10cm) 
C +                      snow cover on top of ice
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  ELSE IF (snow_height                         .lt.0.10d0) THEN
c #sn   if (albedo_icel.ne.0.0d0) then
c #sn    alb0SL(i,j)  = albedo_icel
c #sn    alb0SL_1(i,j)= albedo_icel1
c #sn    alb0SL_2(i,j)= albedo_icel2
c #sn    alb0SL_3(i,j)= albedo_icel3
c #sn   endif
c #sn  if (tiSNow(i,j,nb_sno) .eq. tfsnow)                      then
c #sn   if (nb_ice.gt.0) then
c #sn    albedo_old    = alb0SL(i,j)
c #sn    alb0SL(i,j)   = aiceSN
c #sn.                 +(alb0SL(i,j)-aiceSN)* snow_height   / 0.1d0
c #sn    alb0SL_1(i,j) = alb0SL_1(i,j) 
c #sn.                 - 0.90d0    ! 90 % : empirical value
c #sn.                 *(albedo_old - alb0SL(i,j))/s1SNv
c #sn    alb0SL_2(i,j) = alb0SL_2(i,j) 
c #sn.                 - 0.10d0    ! 10 % : empirical value
c #sn.                 *(albedo_old - alb0SL(i,j))/s2SNv
c #sn    alb0SL_1(i,j) = max(alb0SL_1(i,j),0.01)
c #sn    alb0SL_1(i,j) = min(alb0SL_1(i,j),0.99)
c #sn    alb0SL_2(i,j) = max(alb0SL_2(i,j),0.01)
c #sn    alb0SL_2(i,j) = min(alb0SL_2(i,j),0.99)
c #SA    albHle10_1    = alb0SL_1(i,j)
c #SA    albHle10_2    = alb0SL_2(i,j)	  
c #SA    albHle10_3    = alb0SL_3(i,j)
c #SA    albHle10      = alb0SL(i,j)
C +.... See Wiscome et al, dec1980, J. Atmos. S., pg 2725
c #sn   else
c #sn    albedo_old    = alb0SL(i,j)
c #sn    alb0SL(i,j)   = albsSL(i,j)
c #sn.                 +(alb0SL(i,j)-albsSL(i,j))* snow_height / 0.1d0
c #sn    alb0SL_1(i,j) = alb0SL_1(i,j) 
c #sn.                 - 0.90d0    ! 90 % : empirical value
c #sn.                 *(albedo_old - alb0SL(i,j))/s1SNv
c #sn    alb0SL_2(i,j) = alb0SL_2(i,j) 
c #sn.                 - 0.10d0    ! 10 % : empirical value
c #sn.                 *(albedo_old - alb0SL(i,j))/s2SNv
c #sn    alb0SL_1(i,j) = max(alb0SL_1(i,j),0.01)
c #sn    alb0SL_1(i,j) = min(alb0SL_1(i,j),0.99)
c #sn    alb0SL_2(i,j) = max(alb0SL_2(i,j),0.01)
c #sn    alb0SL_2(i,j) = min(alb0SL_2(i,j),0.99)
c #SA    albHle10_1    = alb0SL_1(i,j)
c #SA    albHle10_2    = alb0SL_2(i,j)	  
c #SA    albHle10_3    = alb0SL_3(i,j)
c #SA    albHle10      = alb0SL(i,j)
C +.... See Wiscome et al, dec1980, J. Atmos. S., pg 2725
c #sn   endif
c #sn  endif
c #sn   if (albedofake .ne.0.0d0) then
c #sn    alb0SL(i,j)   = albedofake
c #sn    alb0SL_1(i,j) = albedofake1
c #sn    alb0SL_2(i,j) = albedofake2
c #sn    alb0SL_3(i,j) = albedofake3
c #sn   endif
C +
C +   Case of deep snow pack (> 10cm)
C +
c #sn  ELSE
c #sn   if (albedo_icel.ne.zero) then
c #sn    alb0SL(i,j)   = albedo_icel
c #sn    alb0SL_1(i,j) = albedo_icel1
c #sn    alb0SL_2(i,j) = albedo_icel2
c #sn    alb0SL_3(i,j) = albedo_icel3
c #sn   endif
c #sn   if (albedofake .ne.zero) then
c #sn    alb0SL(i,j)   = albedofake
c #sn    alb0SL_1(i,j) = albedofake1
c #sn    alb0SL_2(i,j) = albedofake2
c #sn    alb0SL_3(i,j) = albedofake3
c #sn   endif
c #sn  ENDIF
C +
C +-- 8.5.6 Snow albedo: Influence of coudiness (+ option #MR)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
c #MR  alb0SL(i,j)   = alb0SL(i,j)   + 0.05 *(cld_SL(i,j)-0.50)
c #MR  alb0SL_1(i,j) = alb0SL_1(i,j) + 0.05 *(cld_SL(i,j)-0.50)
c #MR  alb0SL_2(i,j) = alb0SL_2(i,j) + 0.05 *(cld_SL(i,j)-0.50)
c #MR  alb0SL_3(i,j) = alb0SL_3(i,j) + 0.05 *(cld_SL(i,j)-0.50)
c #MR  alb0SL_1(i,j) = max(alb0SL_1(i,j),0.01)
c #MR  alb0SL_1(i,j) = min(alb0SL_1(i,j),0.99)
c #MR  alb0SL_2(i,j) = max(alb0SL_2(i,j),0.01)
c #MR  alb0SL_2(i,j) = min(alb0SL_2(i,j),0.99)
c #MR  alb0SL_3(i,j) = max(alb0SL_3(i,j),0.01)
c #MR  alb0SL_3(i,j) = min(alb0SL_3(i,j),0.99)
C +
C +    Influence of cloudiness (cld_SL = cloud fraction) from 
C +    Greuell et al, Global et Planetary Change, 1994 (9):91-114
C +
C +-- 8.5.7 Snow Albedo: Minimum albedo = 30%
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
c #SN  albedo_old    = alb0SL(i,j)
c #SN  alb0SL(i,j)   = max(alb0SL(i,j),0.30d0)
c #SN  alb0SL_1(i,j) = alb0SL_1(i,j)
c #SN.               - 0.34d0
c #SN.               *(albedo_old - alb0SL(i,j))/s1SNv
c #SN  alb0SL_2(i,j) = alb0SL_2(i,j)
c #SN.               - 0.33d0
c #SN.               *(albedo_old - alb0SL(i,j))/s2SNv
c #SN  alb0SL_3(i,j) = alb0SL_3(i,j)
c #SN.               - 0.33d0
c #SN.               *(albedo_old - alb0SL(i,j))/s3SNv     
c #SN  alb0SL_1(i,j) = max(alb0SL_1(i,j),0.01d0)
c #SN  alb0SL_1(i,j) = min(alb0SL_1(i,j),0.99d0)
c #SN  alb0SL_2(i,j) = max(alb0SL_2(i,j),0.01d0)
c #SN  alb0SL_2(i,j) = min(alb0SL_2(i,j),0.99d0)
c #SN  alb0SL_3(i,j) = max(alb0SL_3(i,j),0.01d0)
c #SN  alb0SL_3(i,j) = min(alb0SL_3(i,j),0.99d0)
C +     
C +-- 8.5.8 Snow Albedo: Function of Snow Density
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #GK   rosrf       = max(roSNow(i,j,nb_sno),roSNf)
c #GK   alb0SL(i,j) = 0.58d0 + (rosrf-ro_Ice) 
c #GK.       *(0.85d0-0.58d0) /(roSNf-ro_Ice)
c ###.       + 0.05d0*(cloudn-0.5d0)
C +***  Greuell and Konzelmann (1994) parameterization 
C +     (Glob. Plan. Change 9, (4) p.95)
C +     cloudn  is the cloud fraction
C +
C +--  8.5.9 Snow Albedo: Function of Snow Density and Slush
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SL  if  (tiSNow(i,j,nb_sno).lt.TfSnow) then
c #AB   if (.not.albCEN) then
c #SL    alb0SL(i,j) = 0.85d0 + (roSNow(i,j,nb_sno)-roSNf) 
c #SL.        *(aiceSN-0.85d0) /(ro_Wat            -roSNf)
c #AB   end if
c #SL  else
c #SL   if (waSNru(i,j).le.0.d0) then
c #SL    alb0SL(i,j) = 0.85d0 + (roSNow(i,j,nb_sno)-roSNf) 
c #SL.        *(asluSN-0.85d0) /(ro_Wat            -roSNf)
c #SL   else
c #SL    alb0SL(i,j) = 0.15d0 + (aiceSN-0.15d0)*exp(-waSNru(i,j)/waSN)
c #SL   end if
C +...  SLush Influence on Albedo
C +***  Zuo and Oerlemans J.Glacio. (1995), in press, (23, 24) p.15)
C +     (adapted, i.e. 0.85d0 in place of 0.75d0 in case of dry snow)
c #SL  end if
C +
c #sn else
C +     
C +-- 8.5.10 Snow Albedo: Case of tundra (nb_sno = 0)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        alb0SL(i,j)   = albsSL(i,j)
        alb0SL_1(i,j) = alb0SL(i,j)
        alb0SL_2(i,j) = alb0SL(i,j)
        alb0SL_3(i,j) = alb0SL(i,j)
C +        
c #sn end if
C +
C +-- 8.6 Albedo Output
C +  ~~~~~~~~~~~~~~~~~~
C +
c #SA IF (iterun.eq.0)                                         THEN
c #SA  open(unit=46,status='replace',file='Albedo.out')
c #SA  rewind(   46)
c #SA END IF
C +
c #SA  snowheight = 0.0d0     
c #SA DO k = 1, mg
c #SA  snowheight = snowheight + dzSNow(1,1,k)
c #SA END DO
c #SA  snowheight = snowheight * 100-2000 ! For ETH-Camp
C +
c #SA     write(46,460)iyrrGE,mmarGE,jdarGE,jhurGE,minuGE
 460      format('---------------------------------+----+',
     .          '-------+-------+-------+-------+-------+-------+'
     .         /,'Snow/Ice Pack  ',i5,4(i3),' |    |',
     .          ' z [m] |0.3/0.8|0.8/1.5|1.5/2.8| Full  |Opt[mm]|',
     .         /,'---------------------------------+----+',
     .          '-------+-------+-------+-------+-------+-------+')
C +       ______________________________________________________________
c #SA     write(46,461)            snowheight,
c #SA.                             alb0SL_1(i,j),alb0SL_2(i,j),
c #SA.                             alb0SL_3(i,j),
c #SA.                             alb0SL(i,j)
 461      format('Integrated Snow/Ice/Soil  Albedo |',
     .            3x,' |',  f6.2,' |' ,4(f6.3,' |'), 6x ,' |')
C +       ______________________________________________________________
c #SA     write(46,462)            waSNru(i,j), 
c #SA.                             TairDY(i,j,mz),tsrfSL(i,j,1),
c #SA.                             SL_z0(i,j,1),SL_r0(i,j,1)
 462      format('Surface waSNru TairDY tsrf Z0 R0 |',
     .            3x,' |',  f6.3,'w|' , f7.2,'|',f7.2,'|',
     .            1( 6x, ' |'), f6.3,' |' ,f6.4,' |')
C +       ______________________________________________________________
c #SA     write(46,463)            roSNow(i,j,nb_sno), 
c #SA.                             g1SNow(i,j,nb_sno),
c #SA.                             g2SNow(i,j,nb_sno),
c #SA.                             waSNow(i,j,nb_sno),
c #SA.                           	nhSNow(i,j,nb_sno)  
 463       format('Snow     ro g1 g2 waSNow nhSNow |',
     .            3x,' |',  f7.3,'|' , f6.2,' |',f6.2,' |',
     .            f7.2,'|', i6,' |' ,i7,' |')     
C +       ______________________________________________________________
c #SA     write(46,464)            albCROCUS_1,albCROCUS_2,
c #SA.                             albCROCUS_3,albCROCUS
 464      format('Albedo CROCUS                    |'
     .            ,'    |',   6x ,' |' ,4(f6.3,' |'), 6x ,' |')
C +       ______________________________________________________________
c #SA     write(46,465)            albedo_icel1,albedo_icel2,
c #SA.                             albedo_icel3,albedo_icel
 465      format('Albedo ice lence                 |'
     .            ,'    |',   6x ,' |' ,4(f6.3,' |'), 6x ,' |')
C +       ______________________________________________________________
c #SA     write(46,466)            albedofake1,albedofake2,
c #SA.                             albedofake3,albedofake
 466      format('Albedo albedofake                |'
     .            ,'    |',   6x ,' |' ,4(f6.3,' |'), 6x ,' |')
C +       ______________________________________________________________
c #SA     write(46,467)            albHeq0_1,albHeq0_2,
c #SA.                             albHeq0_3,albHeq0
 467      format('Albedo snow height = 0           |'
     .            ,'    |',   6x ,' |' ,4(f6.3,' |'), 6x ,' |')
C +       ______________________________________________________________
c #SA     write(46,468)            albHle10_1,albHle10_2,
c #SA.                             albHle10_3,albHle10
 468      format('Albedo snow height < 10          |'
     .            ,'    |',   6x ,' |' ,4(f6.3,' |'), 6x ,' |')
C +       ______________________________________________________________
C +
C +-- 9. Snow Energy Balance Model (Euler Bckward)
C +   ===========================================
C +
c #sn do ne =     1,2
c #sn do n  = -mh+1,mg
c #sn ddsno(ne,n) = zero
C +...ddsno       : Snow Layer Heating, in particular:
C +   ddsno( 2,n) : Contribution from Melting and Freezing.
C +
c #sn end do
c #sn end do
C +
c #sn do ne = 1,leuler + 1 ! BEGIN OF EULER BACKWARD
C +
C +...Euler Backward Scheme is used in the Computation    
C +                            of Melting and Freezing when leuler .eq. 1
C +
C +
C +-- 9.1 Working Coefficients are reset to zero
C +   ------------------------------------------
C +
c #sn      do n  = mg,-mh,-1
c #sn      aasno(n)       = zero
c #sn      bbsno(n)       = zero
c #sn      ccsno(n)       = zero
c #sn      hhsnoSP(n,1)   = zero
c #sn      hhsnoSP(n,2)   = zero
c #sn      hhsnoSP(n,3)   = zero
c #sn      ffsno(n)       = zero
c #sn      ggsno(n)       = zero
c #sn      ppsno(n)       = zero
c #sn      qqsno(n)       = zero
c #sn      end do 
c #sn      ggsno(mgg)     = zero
c #sn      hhsnoSP(mgg,1) = zero
c #sn      hhsnoSP(mgg,2) = zero
c #sn      hhsnoSP(mgg,3) = zero
C +
C +
C +-- 9.2 Substratum Heat Capacity
C +   ----------------------------
C +
c #sn     ffsno(-mh) = 0.5d0 * dtSNo *3.72d0 / 
c #sn.                 d1_SL(i,j)
C +                    d1_SL = rhos * cs *(depth diurnal wave)   (J/m2/K) 
C +                 ex.: ICE = 920kg/m3 *2000J/kg/K *sqrt(0.27e-6m2/s *86400s) 
C +                 ex.: SNOW= 330kg/m3 *2000J/kg/K *sqrt(0.27e-6m2/s *86400s) 
C +
C + d1_SL describes  Soil-------Surface interface in contrast with other 
C +                  MAR_SL variables describing Atmosphere-Surface Interface     
C +
C + See Deardorff (1978, p.1891, col.2, para 2) Surface Heat Capacity
C +
c #sn IF (mh.gt.0)                                                THEN
c #sn   do n  = 0,-mh1+1 ,-1
c #sn     ffsno(n)   = 0.5d0 * dtSNo         / cs_SV(n)
c #sn   end do
c #sn END IF
C +
C +
C +-- 9.3 Integrated Extinction
C +   -------------------------
C +
c #sn do nn  = 1,3
c #sn  hhsno  (nb_sno+1)    = 1.d0 !Integrated Ext. of Solar Irradiance
c #sn  hhsnoSP(nb_sno+1,nn) = 1.d0 !Integrated Ext. of Solar Irradiance
c #sn enddo
C +
c #sn if(nb_sno.ge.1) then
c #sn  do nn  = 1,3
c #sn   do n  = nb_sno,1,-1 ! 1 => Instruction hhsno(0)=0.d0 is implicit
C +
c #sn    if (hhsno(n+1).lt.epsi) then
c #sn     hhsno(n)      = zero 
c #sn    else
c #sn     hhsno(n)      = hhsno(n+1)        *
c #sn.                    exp(-exsno(n)     *dzSNow(i,j,n))
c #sn    end if
C +
c #AB    if (hhsnoSP(n+1,nn).lt.epsi) then
c #AB     hhsnoSP(n,nn) = zero
c #AB    else
c #AB     hhsnoSP(n,nn) = hhsnoSP(n+1,nn)   *
c #AB.                    exp(-exsnoSP(n,nn)*dzSNow(i,j,n))
c #AB    end if
c #sn   end do
c #sn  end do
C +
C +
C +-- 9.4 Working Coefficients update (Bulk)
C +   -------------------------------------
C +
c #sn  do n  = nb_sno,1,-1
c #sn   ffsno(n) = 0.5d0 * dtSNo / (csnow*dzSNow(i,j,n)*roSNow(i,j,n))
c #sn  end do
C +
c #sn end if
C +
C +-- 9.4.1 Snow
C +   ~~~~~~~~~~
c #sn if      (nb_sno   .ge.2) then
c #sn   do n = nb_sno,2,-1
c #sn   ggsno(n) =  2.00d00
c #sn.           / (dzSNow(i,j,n)/cdsno(n)+dzSNow(i,j,n-1)/cdsno(n-1))
C +...  ggsno    :  Conduction Factor at Snow Layer Interface
C +
c #sn   end do
c #sn end if
C +
C +-- 9.4.1 Soil
C +   ~~~~~~~~~~
c #sn if      (nb_sno+mh.ge.1) then
c #sn  if     (mh.eq.0)        then
c #sn   ggsno(nb_sno+1) = 2.00d00      *cdsno(nb_sno)/dzSNow(i,j,nb_sno)
c #sn   ggsno(1)        = 2.00d00      *cdsno(1)     /dzSNow(i,j,1)
c #sn  else
c #sn   if    (nb_sno   .ge.1) then
c #sn   ggsno(nb_sno+1) = 2.00d00      *cdsno(nb_sno)/dzSNow(i,j,nb_sno)
c #sn   ggsno(1)        = 2.00d00
c #sn.           / (dzSNow(i,j,1)/cdsno(1)+dzSNo  (0)/cdsno(0)  )
c #sn   else
c #sn   ggsno(nb_sno+1) = 2.00d00      *cdsno(nb_sno)/dzSNo     (nb_sno)
c #sn   end if
c #sn   if       (mh.gt. 1) then
c #sn   do n = 0,-mh1+2,-1
c #sn   ggsno(n)        = 2.00d00
c #sn.           / (dzSNo     (n)/cdsno(n)+dzSNo(n-1)/cdsno(n-1))
c #sn   end do
c #sn   ggsno(-mh+1)    = 2.00d00      *cdsno(-mh+1) /dzSNo(-mh+1)
c #sn   end if
c #sn  end if
C +
C +
C +-- 9.5 Energy balance equation 
C +   ---------------------------
C +
C +-- 9.5.1 Bottom
C +   ~~~~~~~~~~~~
C + 
c #sn  aasno  (-mh)  = - ffsno(-mh) *ggsno(-mh+1)
c #sn  ccsno  (-mh)  =   zero
c #sn  bbsno  (-mh)  =   1.d0-aasno(  -mh)+.5d0*7.4d0*dtSNo/cs2SL
c #sn  ddsno(1,-mh)  =       -aasno(  -mh)                         
c #sn.                       *tnsno(1,-mh+1)
c #sn.               +  (1.d0+aasno(  -mh)-.5d0*7.4d0*dtSNo/cs2SL) 
c #sn.                       *tnsno(1,-mh)
c #sn.               +  (absSOL(1)*(hhsnoSP(-mh+1,1)-hhsnoSP(-mh,1)) 
c #sn.               +   absSOL(2)*(hhsnoSP(-mh+1,2)-hhsnoSP(-mh,2)) 
c #sn.               +   absSOL(3)*(hhsnoSP(-mh+1,3)-hhsnoSP(-mh,3)) 
c _AS                +  (sol_SL(i,j) *(hhsno(-mh+1)-hhsno(-mh))
c #sn.               +   gethSN                                )
C +...                   gethSN: Prescribed Deep Soil  Heat Flux
C +
c #sn.                  *2.d0*ffsno(  -mh)
C +
c #sn.               +   t2_SL(i,j)            *7.4d0*dtSNo/cs2SL
C +...                   t2_SL: Soil (Ice) Diurnally Averaged Temperature
C +
C +-- 9.5.2 Internal
C +   ~~~~~~~~~~~~~~
c #sn  if              (mh+  nb_sno.ge.2) then
c #sn   do      n   = - mh+1,nb_sno-1
c #sn   aasno  (n)  = - ffsno(n)  * ggsno(n+1)
c #sn   ccsno  (n)  = - ffsno(n)  * ggsno(n)
c #sn   bbsno  (n)  =   1.d0   - aasno(n)  - ccsno(n)
c #sn   ddsno(1,n)  = - aasno(n)           * tnsno(1,n+1) 
c #sn.                - ccsno(n)           * tnsno(1,n-1)
c #sn.        + (1.d0  +aasno(n)+ccsno(n)) * tnsno(1,n)
c _AS         + (sol_SL(i,j)*(hhsno(n+1) -hhsno(n)))*2.d0*ffsno(n)
c #sn.        + (absSOL(1)*(hhsnoSP(n+1,1)-hhsnoSP(n,1)))*2.d0*ffsno(n)
c #sn.        + (absSOL(2)*(hhsnoSP(n+1,2)-hhsnoSP(n,2)))*2.d0*ffsno(n)
c #sn.        + (absSOL(3)*(hhsnoSP(n+1,3)-hhsnoSP(n,3)))*2.d0*ffsno(n)
c #sn   end do
c #sn  end if
C +
c #sn end if
C +
C +-- 9.5.3 Surface
C +   ~~~~~~~~~~~~~
c #sn   ffup     =   epsloc      *stefan 
c #sn.     *tnsno(1,nb_sno+1)*tnsno(1,nb_sno+1)*tnsno(1,nb_sno+1)
C +...   fup linearized: -stefan T^4 := -4 ffup T_n+1 + 3 ffup T_n
C +
c #sn   coeft          =  
c #sn.        ffup     *   4.0d0
C +...        ffup     *   4.0d0                   (fully implicit)
C +     OR:   ffup     *   2.0d0
C +                        2.0d0 in place of 4.0d0 (Crank Nicholson)
C +
c #sn.     +  hsenst            
C +  .     +  hsenst                               (fully implicit)
C +  .  OR:+  hsenst   *   0.5d0                   (Crank Nicholson)
C +
c #sn   coefi          =  
c _AS        sol_SL(i,j)*(hhsno(nb_sno+1)    - hhsno(  nb_sno))
c #sn.     +  absSOL(1)*(hhsnoSP(nb_sno+1,1)  - hhsnoSP(nb_sno,1))
c #sn.     +  absSOL(2)*(hhsnoSP(nb_sno+1,2)  - hhsnoSP(nb_sno,2))
c #sn.     +  absSOL(3)*(hhsnoSP(nb_sno+1,3)  - hhsnoSP(nb_sno,3))
c #sn.     +  firdSL(i,j)
c #sn.     +  ffup     *   3.0d0              * tnsno(1,nb_sno+1)
C +...     +  ffup     *   3.0d0              * tnsno(1,nb_sno+1)
C +                                                (fully implicit)
C +...  OR:+  ffup                            * tnsno(1,nb_sno+1)
C +                                                (Crank Nicholson)
c #sn.     +  hsensi
C +...     -  hsenst   *   0.5d0              * tnsno(1,nb_sno+1)
C +                                                (Crank Nicholson)
C +     OR:   NIHIL                                (fully implicit)
C +
c #sn.     -  hlatSL(i,j)
C +
c #sn if       (nb_sno.eq.0.and.mh.ge.1) then
C +...if       (nb_sno         +mh.ge.1) then
C +  (if Snow Skin Temperature  is   computed)
C +
c #sn   coefdt         =   ggsno(nb_sno+1)    + coeft
c #sn   coeftn         =   ggsno(nb_sno+1)    * coeft / coefdt
c #sn   coefin         =   ggsno(nb_sno+1)    * coefi / coefdt
c #sn   coefto         =                        coeft 
c #sn   coefio         =                        coefi
c #sn   coeft          =                        coeftn
c #sn   coefi          =                        coefin
c #sn end if
C +
c #sn   aasno  (nb_sno)=         zero
c #sn   ccsno  (nb_sno)= - ffsno(nb_sno)   * ggsno(nb_sno)
c #sn   bbsno  (nb_sno)=         1.d0      - ccsno(nb_sno)
c #sn.     + coeft              *2.d0      * ffsno(nb_sno)
c #sn   ddsno(1,nb_sno)=
c #sn.     +(1.0d0        +ccsno(nb_sno))  * tnsno(1,nb_sno)
c #sn.     +(coefi+fhwat+fhsno) *2.d0      * ffsno(nb_sno)
C +
c #sn if       (nb_sno+mh.ge.1) then
c #sn   ddsno(1,nb_sno)=   ddsno(1,nb_sno)
c #sn.                   - ccsno(  nb_sno) * tnsno(1,nb_sno-1)
c #sn else
c #sn   bbsno  (nb_sno)=   bbsno(  nb_sno)+.5d0*7.4d0*dtSNo/cs2SL
c #sn   ddsno(1,nb_sno)=   ddsno(1,nb_sno)
c #sn.                  +  gethSN              *2.0d0*ffsno(0)
C +...                     gethSN: Prescribed Deep Soil  Heat Flux
C +
c #sn.   +(t2_SL(i,j)-.5d0*tnsno(1,nb_sno))    *7.4d0*dtSNo/cs2SL
C +...     t2_SL:          Soil (Ice) Diurnally Averaged Temperature
C +
c #sn end if
C +
C +-- 9.5.4 Forward Sweep
C +   ~~~~~~~~~~~~~~~~~~~
c #sn   ppsno(-mh) =  bbsno  (-mh)
c #sn   qqsno(-mh) = -aasno  (-mh)                                       
c #sn.             /  ppsno  (-mh)
c #sn   xxsno(-mh) = (ddsno(1,-mh) + ddsno(2,-mh))                         
c #sn.             /  ppsno  (-mh)
c #sn  if       (mh  +nb_sno.gt.0) then
c #sn   do    n=-mh+1,nb_sno
c #sn   ppsno(n) =  bbsno  (n)              + ccsno(n) * qqsno(n-1)
c #sn   qqsno(n) = -aasno  (n)                                       
c #sn.            / ppsno  (n)
c #sn   xxsno(n) = (ddsno(1,n) + ddsno(2,n) - ccsno(n) * xxsno(n-1)) 
c #sn.            / ppsno  (n)
c #sn   end do
c #sn  end if
C +
C +-- 9.5.5 Backward Sweep -> Update of tnsno(1,n) is tnsno(2,n)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn   tnsno(2,nb_sno) = xxsno(nb_sno)
c #sn  if        (nb_sno  + mh.gt.0) then
c #sn   do      n=nb_sno-1,-mh,-1
c #sn   xxsno  (n)   = xxsno(n+1) * qqsno(n) + xxsno(n)
c #sn   tnsno(2,n)   =                         xxsno(n)
C +...  tnsno(2,n)   is a first Guess to be corrected by including 
C +                  Phase Transformations of Water
c #sn   end do
c #sn  end if
C +
c #sn if       (nb_sno.eq.0.and.mh.ge.1) then
C +...if       (nb_sno         +mh.ge.1) then
C +  (if Snow Skin Temperature  is   computed)
C +
c #sn   tnsno(2,nb_sno+1) = 
c #sn.  (coefio+ggsno(nb_sno+1)*0.5d0*(tnsno(2,nb_sno)+tnsno(1,nb_sno)))
c #sn.  /coefdt
c #sn else
c #sn   tnsno(2,nb_sno+1) =                            tnsno(2,nb_sno)
c #sn end if
C +
C +
C +-- 9.6 Effective Flux
C +   ------------------
C +
C +-- 9.6.1 Upward I.R. Flux
C +   ~~~~~~~~~~~~~~~~~~~~~~
c #sn   firmSL(i,j)  =  ffup*(2.d0*tnsno(2,nb_sno+1)
c #sn.                       -     tnsno(1,nb_sno+1))
C +...  Crank-Nicholson
C +
C +...  firmSL(i,j)  =  ffup*(4.d0*tnsno(2,nb_sno+1)
C +  .                       -3.d0*tnsno(1,nb_sno+1))
C +     Strictly Implicit
C +
C +-- 9.6.2 Upward H.S. Flux
C +   ~~~~~~~~~~~~~~~~~~~~~~
c #sn   hsenSL(i,j)  = -hsensi 
c #sn.        + 0.5d00 *hsenst  * (tnsno(2,nb_sno+1)+tnsno(1,nb_sno+1))
C +
C +-- 9.6.3 Upward H.L. Flux
C +   ~~~~~~~~~~~~~~~~~~~~~~
C +  Rem: Must be updated before restoring
C +       humid snow temperature to the freezing point
C +
c #sn   hbalSL(i,j)  =  firmSL(i,j)+hsenSL(i,j)+hlatSL(i,j)
c #sn.                 -sol_SL(i,j)-firdSL(i,j)
C +...  hbalSL       :  Atmospheric  Heat  Forcing
C +
c #Se   aheat        =(coefi 
c #Se.               + absSOL(1)*(hhsnoSP(nb_sno,1)-hhsnoSP(-mh,1))
c #Se.               + absSOL(2)*(hhsnoSP(nb_sno,2)-hhsnoSP(-mh,2))
c #Se.               + absSOL(3)*(hhsnoSP(nb_sno,3)-hhsnoSP(-mh,3))
c #Se.               - coeft    * tnsno(2,nb_sno)          )*dtPhys
C +...  AHeat        :  Atmospheric  Heat  Input
C +
C +-- 9.6.4 Energy Conservation after Conduction and Atmosph. Forcing Steps
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #SF     n=nb_sno+1
C      write(6,6000) n,tnsno(1,n),tairDY(i,j,mz),tnsno(2,n)
c #SF  do n=nb_sno,-mh,-1
c #SF   n1 = n-1
c #SF   n1 = max(-mh,n1)
c #SF  if (n.eq. -mh) then 
c #SF   rocsdz   =                d1_SL(i,j)             /3.72d0
c #SF  else
c #SF   if(n.le.   0) then
c #SF   rocsdz   =  cs_SV(n)
c #SF   else
c #SF   rocsdz   =  csnow       *dzSNow(i,j,n)           *roSNow(i,j,n)
c #SF   end if
c #SF  end if
c #SF  if (n.eq.nb_sno) then
c #SF   ttaux(n) =  tnsno(1,n)  -dtSNo *0.5d0*
c #SF. (ggsno(n)  *(tnsno(2,n)  +tnsno(1,n)   -tnsno(2,n1)-tnsno(1,n1))
c #SF. )/ rocsdz                +dtSNo *(coefi+fhwat      +fhsno
c #SF.                                  -coeft*tnsno(2,nb_sno))
c #SF.  / rocsdz
c #SF  else
c #SF   ttaux(n) =  tnsno(1,n)  +dtSNo *0.5d0*
c #SF. (ggsno(n+1)*(tnsno(2,n+1)+tnsno(1,n+1)-tnsno(2,n )-tnsno(1,n ))
c #SF. -ggsno(n)  *(tnsno(2,n)  +tnsno(1,n)  -tnsno(2,n1)-tnsno(1,n1))
c #SF. )/ rocsdz                +dtSNo
c #SF.  * (absSOL(1)*(hhsnoSP(n+1,1)-hhsnoSP(n,1))
c #SF.    +absSOL(2)*(hhsnoSP(n+1,2)-hhsnoSP(n,2))
c #SF.    +absSOL(3)*(hhsnoSP(n+1,3)-hhsnoSP(n,3))                   )
c #SF.  / rocsdz
c #SF  end if
c #SF  if (n.eq.-mh)
c #SF.  ttaux(n) =  ttaux(n)    -dtSNo*7.4d0*(0.5d0*
c #SF.             (tnsno(2,n)  +tnsno(1,n)) -t2_SL(i,j))/cs2SL
c #SF.                          +dtSNo*gethSN/rocsdz                       
C      write(6,6000) n,tnsno(1,n),ttaux(n),tnsno(2,n)
 6000  format(i6,3f15.9)
c #SF  enddo
C      write(6,6003)   t2_SL(i,j)
 6003  format(21x,f15.9)
C +
C +
C +-- 9.7 Melting and Freezing
C +   ------------------------
C +
C +-- 9.7.1 Energy required for Melting and Freezing (Reset)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn  if (ne.eq.1.and.nb_sno.ge.1) then
c #sn     tnsno(2,nb_sno+1) = min(tnsno(2,nb_sno+1),TfSnow)
C +
C +  Rem: No Skin Temperature is computed in the Snow Model
C +
c #SM     fmelSL(i,j)     = 0.d0
c #SM     freeSL(i,j)     = 0.d0
c #sn   do n=nb_sno,1,-1
C +...              +-> Layer zero is not taken into account 
C +                     (T > T_Fus allowed)
C +
C +-- 9.7.2 Melting  if T > T_Fusion
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn   if (tnsno(2,n).gt.TfSnow) then
c #sn     ddsno(2,n)      = TfSnow      -  tnsno(2,n)
c #SM     fmelSL(i,j)     = fmelSL(i,j) +  ddsno(2,n) 
c #SM.                    *csnow *roSNow(i,j,n) *dzSNow(i,j,n) /dtSNo
C +
C +-- 9.7.2 a) ROUTE
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #SE     if (ddsno(2,n).lt.0.d0.and.nroute( 1: 1).eq.' ') then
c #SE                                nroute( 1: 1)  = 'M'
c #SE                  write(nroute( 2: 2),'(i1)')     n/10
c #SE                  write(nroute( 3: 3),'(i1)') mod(n,10)
c #SE     end if
C +
c #sn   else
C +
C +-- 9.7.3 Freezing  if T     < T_Fusion .AND. W     > 0
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn    if (   tnsno(2,n).lt.TfSnow         .and.
c #sn.       (  wnsno  (n).gt.0.d0      .or.
c #sn.        (         n .eq.nb_sno.and.
c #sn.         waSNru(i,j).gt.0.d0       )  )     ) then
c #sn      freezw= wnsno(n)   *Lf_H2O/ csnow
C +...     freezw: Water Available for Freezing   [kg/kg --> K]
C +
C +-- 9.7.3 a) ROUTE
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #SE     if (freezw    .gt.0.d0.and.nroute( 5: 5).eq.' ') then
c #SE                                nroute( 5: 5)  = 'i'
c #SE                  write(nroute( 6: 6),'(i1)')     n/10
c #SE                  write(nroute( 7: 7),'(i1)') mod(n,10)
c #SE     end if
C +
c #sn      freezt= TfSnow-tnsno(2,n)
C +...     freezt: Energy releasible by Freezing            [K]
C +                (otherwise T :> T_Fusion)
c #sn      freeze= min(freezw,freezt)
C +
C +-- 9.7.3 b) ROUTE
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #SE     if (freezt    .gt.0.d0.and.nroute( 9: 9).eq.' ') then
c #SE                                nroute( 9: 9)  = 'F'
c #SE                  write(nroute(10:10),'(i1)')     n/10
c #SE                  write(nroute(11:11),'(i1)') mod(n,10)
c #SE     end if
C +
C +-- 9.7.4 Additional Freezing of Surficial Water
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn     if  (         n .eq.nb_sno .and.       
c #sn.         waSNru(i,j).gt.0.d0                ) then
C +
c #SE      entop1=( TfSnow            *csnow+Lf_H2O)*waSNru(i,j)
c #SE.           +  tnsno(2,n)        *csnow
c #SE.                                *roSNow(i,j,n)*dzSNow(i,j,n)
c #SE.           +  wnsno(  n)        *Lf_H2O
c #SE.                                *roSNow(i,j,n)*dzSNow(i,j,n)
C +
c #sn      dfreez= max(freezt-freezw,zero)
c #sn      dfreez= dfreez*roSNow(i,j,n)*dzSNow(i,j,n)*csnow/Lf_H2O
C +...     dfreez: Remaining Freezing Potential   [in kg/m2 of H2O] 
C +
c #sn      afreez= waSNru(i,j)
C +...     afreez: Water available for Freezing   [in kg/m2 of H2O]
C +
c #sn      wfreez= max(dfreez-afreez,zero)
c #sn      wfreez=    (dfreez-wfreez)     
C +...     wfreez: Additional Freezing of Surficial Water   [kg/m2]
C +
C +-- 9.7.4 a) ROUTE
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #SE      if (wfreez    .gt.0.d0.and.nroute(13:13).eq.' ') then
c #SE                                 nroute(13:13)  = 'I'
c #SE                   write(nroute(14:14),'(i1)')     n/10
c #SE                   write(nroute(15:15),'(i1)') mod(n,10)
c #SE      end if
C +
c #sn      water0        =       wnsno(n)  *roSNow(i,j,n)*dzSNow(i,j,n) 
c #sn      snodry        = (1.d0-wnsno(n)) *roSNow(i,j,n)*dzSNow(i,j,n)
C +
C +-- 9.7.4 b) New Snow Layer Status including Surficial Water
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #sn      waSNru(i,j)   = waSNru(i,j)   - wfreez
c #sn      water         = water0        + wfreez 
C +
c #sn      tnsno   (2,n) =((water0+snodry) *tnsno   (2,n)
c #sn.                    + wfreez         *TfSnow       ) 
c #sn.                   / (water +snodry)
c #sn      dzSNow(i,j,n) = dzSNow(i,j,n) + wfreez /ro_Ice 
c #sn      roSNow(i,j,n) = (water +snodry) /dzSNow(i,j,n)
c #sn      wnsno     (n) =  water         /(roSNow(i,j,n)*dzSNow(i,j,n))
C +
C +-- 9.7.4 c) Freezing  if T_new < T_Fusion .AND. W_new > 0
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #sn      freezw        =        wnsno(  n)  *Lf_H2O /csnow
c #sn      freezt        = TfSnow-tnsno(2,n)
c #sn      freeze        = min(freezw,freezt)
C +
c #SE      freezw        =     freeze         *csnow /Lf_H2O
c #SE      entop2=((tnsno(2,n)+freeze)*csnow+Lf_H2O) *waSNru(i,j)
c #SE.           + (tnsno(2,n)+freeze)*csnow
c #SE.                                *roSNow(i,j,n)*dzSNow(i,j,n)
c #SE.           + (wnsno(  n)-freezw)*Lf_H2O
c #SE.                                *roSNow(i,j,n)*dzSNow(i,j,n)
c #SE      dentop=  entop2            -entop1
c #SE      dtemp0=  tnsno(2,n)+freeze -TfSnow
c #SE      if (abs(dentop).gt.epsi) 
c #SE.      write(29,1207) jdaMAR,jhaMAR,jmmMAR,dentop,nb_sno,
c #SE.                     waSNru(i,j),dtemp0
 1207       format(i4,':',i2,':',i2,5x,'DHeat:',f9.1,' Top Layer',i9,
     .           /,10x,             5x,'SurfW:',d9.3,' dTempSurf',d9.3)
C +
c #sn     end if
C +
C +-- 9.7.5 Effective Freezing
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn      ddsno(2,n)      =   freeze
c #SM      freeSL(i,j)     =   freeSL(i,j) +  ddsno(2,n) 
c #SM.                 *csnow *roSNow(i,j,n) *dzSNow(i,j,n) /dtSNo
c #sn    else
c #sn      ddsno(2,n)      = zero
c #sn    end if
c #sn   end if
c #sn   if (leuler.eq.0)   tnsno(2,n) = tnsno(2,n) + ddsno(2,n)
C +
C +  Rem: Do later an update of wnsno(n) using 
C +       vrowat and ddsno(2,n)
C + 
c #sn   end do
c #sn  end if
C +
c #sn  end do ! END OF EULER BACKWARD
C +
C +
C +-- 9.8 Snow Surface Energy  INPUT  
C +   ------------------------------
C +
c #Se wheat      = (fhwat      +fhsno)                *dtPhys
C +...Wheat      :  Precipit. => Heat  Input
C +
c #Se hdeep      = - d1_SL(i,j) * (0.5d0*(tnsno(1,-mh)+tnsno(2,-mh))
c #Se.                                  - t2_SL(i,j)                )
c #Se.                          *  7.4d0*dtPhys       /(3.72d0*cs2SL)
c #Se.             + gethSN     *        dtPhys
C +
C +
C +-- 10. Snow Water Balance Model (mg levels)
C +   ========================================
C +
C +-- 10.1 Additional Water Content
C +   -----------------------------
C +
c #sn  do n=1,mg 
c #sn   wnmel(n) =  0.d0
c #sn   dqmel(n) =  0.d0
c #sn  end do 
C +
c #sn   energy   =  0.d0
c #sn   wexces   =  0.d0
c #sn  if    (nb_sno.ge.1) then
c #sn  do n=1,nb_sno
c #sn   wnmel(n)= -  ddsno(2,n)  *csnow         /Lf_H2O
c #sn   dqmel(n) =     wnmel(n)  *roSNow(i,j,n) *dzSNow(i,j,n)
C +...  dqmel    :  Mass of exchanged Water during Phase Change
C +     dqmel < 0:  Freezing
C +     dqmel > 0:  Melting
C +
c #sn   wnmel(n)=      wnmel(n)          
c #sn.            +   energy        / (roSNow(i,j,n)*dzSNow(i,j,n))
c #sn   wnmax   = 1.d0-wnsno(n)
C +...  wnmax   : Melting Limit
C +
c #sn   wnuse   =  min(wnmel(n),wnmax)
c #sn   energy  =     (wnmel(n)-wnuse)*roSNow(i,j,n)*dzSNow(i,j,n)
C +...  energy  : Energy Excess (in mmWE or kg/m2) 
C +
c #sn   wnmel(n)=      wnuse
C +
c #sn   volsno  =(1.d0-wnsno(n))      *roSNow(i,j,n)             /ro_Ice
C +...  volsno  : Volume (per Unit Vol.) of Snow/Ice (Pores Excluded)
C +
c #sn   volpor  =(1.d0-volsno)
c #sn.          *(1.d0-wnsno(n)-max(zero,wnmel(n)))
c #sn.       /max(unun-wnsno(n),epsi)
C +...  volpor  : Volume (per Unit Vol.) of           Pores
C +              (HYP: Melting Snow/Ice/Water Volume NOT included)
C +
c #sn   volwat  =      wnsno(n)       *roSNow(i,j,n)             /ro_Wat
c #sn.               + wexces                       /dzSNow(i,j,n)
C +...  volwat  : Volume (per Unit Vol.) of Water (before Melting)
C +              (Including Water Excess   from Layers underneath)
C +
c #sn   volmel  =      wnmel(n)       *roSNow(i,j,n)             /ro_Wat
C +...  volmel  : Melted(>0)/Frozen(<0) Snow/Ice (in fraction of Volume)
C +
C +-- 10.1.1 Water in Excess of Available Pore Volume 
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn   wexces  = max(zero,volwat+volmel-volpor) 
C +...  wexces  : Water Excess                   (in fraction of Volume)
C +
C +-- 10.1.1 a) ROUTE
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #SE     if (wexces    .gt.0.d0.and.nroute(17:17).eq.' ') then
c #SE                                nroute(17:17)  = 'W'
c #SE                  write(nroute(18:18),'(i1)')     n/10
c #SE                  write(nroute(19:19),'(i1)') mod(n,10)
c #SE     end if
C +
c #sn   volsnn  = volsno-volmel/roiwSN
c #sn   volsnn  =    max(volsnn,epsi)
c #sn   volwat  = volwat+volmel-wexces
c #sn   wexces  = wexces*dzSNow(i,j,n)
C +
c #sn   vrowat  = volwat*ro_Wat
c #sn   rosnew  = vrowat+volsnn*ro_Ice
c #sn   roscor  = vrowat+volsno*ro_Ice
c #sn   wnsno(n)= vrowat/rosnew
C +
c #sn   rorap1  = rosnew/roSNow(i,j,n)
c #sn   rovar   = max(unun,rorap1)
c #sn   dzvar   = min(unun,rorap1)
C +
c #sn   rorap2  = roscor/rosnew
c #sn   rorap2  = max(unun,rorap2)
C +***  In case of Melting, constant ICE Density is maintained by rorap2
C +     (Rowe et al. 1995, JGR 100 p.16268, 1st col., 1st para)
C +
c #sn   roSNow(i,j,n) =  roSNow(i,j,n)  *rovar * rorap2
c #sn   dzSNow(i,j,n) =  dzSNow(i,j,n)  *dzvar / rorap2
C +
c #sn  end do
C +
c #sn   wexces = wexces * ro_Wat
C +...  wexces conversion: [m3/m2]-->[kg/m2]
C +
c #sn  end if
C +
C +
C +-- 10.2 Snow Cover Energy
C +   ----------------------
C +
c #SE  heat2 =(tnsno(2,nb_sno)*csnow+Lf_H2O) *(wexces+waSNru(i,j))
C +...         Energy included in Surficial Water
C +
c #SE.        +tnsno(2,-mh)   *d1_SL(i,j)    / 3.72d0
C +...         Energy of          Soil      Layer
C +
c #SE if     (mh  .gt.0) then
c #SE  do n= -mh1+1,0
c #SE  heat2 = heat2
c #SE.       + cs_SV(n)                             *tnsno   (2,n)
c #SE  end do
c #SE end if
C +
c #SE if   (nb_sno.ge.1) then
c #SE  do n=nb_sno,1,-1
c #SE  heat2 = heat2 
c #SE.       + csnow *roSNow(i,j,n)  *dzSNow(i,j,n) *tnsno   (2,n)
c #SE.       + Lf_H2O*roSNow(i,j,n)  *dzSNow(i,j,n) *wnsno     (n)  
c #SE  end do
c #SE end if
C +
C +
C +-- 10.3 Snow Cover Energy Balance
C +   ------------------------------
C +
c #SE dheat = heat2 -heat1 -aheat -wheat -hdeep
c #SE if (abs(dheat).gt.epSN1) write(29,1203) jdaMAR,jhaMAR,jmmMAR,dheat
 1203 format(//,i4,':',i2,':',i2,5x,'DHeat:',f9.1,' before Water Model')
C +
C +
C +-- 10.4 Limitation of Snow/Ice Specific Mass to Ice Specific Mass
C +   --------------------------------------------------------------
C +
c #sn  if  (nb_sno.ge.1) then
C +
c #sn  do n=nb_sno,1,-1
c #sn   rosmax        = min(roSNow(i,j,n)*(unun-wnsno(n)),ro_Ice)
c #sn   rosnew        =     roSNow(i,j,n)*      wnsno(n) +rosmax
C +
C +-- 10.4.1 ROUTE
C +   ~~~~~~~~~~~~
c #SE     if (roSNow(i,j,n).gt.rosnew.and.nroute(21:21).eq.' ') then
c #SE                                     nroute(21:21)  = 'E'
c #SE                       write(nroute(22:22),'(i1)')     n/10
c #SE                       write(nroute(23:23),'(i1)') mod(n,10)
c #SE     end if
C +
c #sn   dzSNow(i,j,n) =     roSNow(i,j,n)* dzSNow(i,j,n)/ rosnew
c #sn   roSNow(i,j,n) =     rosnew
C +
c #sn  end do
C +
c #sn  end if
C +
C +
C +-- 10.5 Surficial Water [mmWE or kg/m2] Run Off
C +   --------------------------------------------
C +
c #sn   wasndi      = 0.d0
c #sn   waSNru(i,j) = waSNru(i,j)  + wexces
c #RU   wasnew      = waSNru(i,j)  * slwaSN(i,j)
C +***  (Zuo and Oerlemans 1995, J.Glacio. in press, p.14(22) and p.15)
C +     (Zuo and Oerlemans 1996, J.Glacio. 42, 305--317)
c #RU   wasndi      = waSNru(i,j)  - wasnew
c #RU   waSNru(i,j) = wasnew
c #WR   write(6,6001)nb_sno
 6001   format(i8,9x,'waSNru',9x,'watmax',9x,'volpor',9x,'volwat',
     .                        9x,'volmax',9x,' dwwat',9x,' tnsno')
C +
C +
C +-- 10.6 Possible Melting of the last Snow Layer
C +   --------------------------------------------
C +
c #sn   bmel     = 0.d0
c #sn   bheat    = 0.d0
C +
c #sn   IF (mh    .ge.1) then
c #sn       cheat = cs_SV(0)
c #sn   else
c #sn       cheat = d1_SL(i,j) /3.72d0
c #sn   END IF
C +
c #sn   IF (nb_sno.eq.1) then
C +
c #sn       eners = ( tnsno(  2,0)-TfSnow) *cheat
C +...      Soil Layer Energy available for Melting
C +
c #sn       enerm = ((TfSnow-tnsno(  2,1)) *csnow
c #sn.              +(1.d0  -wnsno(    1)) *Lf_H2O)
c #sn.                                     *roSNow(i,j,1)*dzSNow(i,j,1)
C +...      Snow Layer Energy consumable in Melting
C +
c #SE       heat1m = tnsno(  2,0) *cheat
c #SE.             +(tnsno(  2,1) *csnow
c #SE.              +wnsno(    1) *Lf_H2O) *roSNow(i,j,1)*dzSNow(i,j,1)
C +
c #sn    IF(eners.gt.enerm) then
C +
c #sn       watert = roSNow(i,j,1)*dzSNow(i,j,1)
c #sn       water  = watert                     *      wnsno(1)
c #sn       wamel  = watert                     *(1.d0-wnsno(1))
C +...      wamel  : additional melted Water
C +
c #sn       bmel   = bmel  +(water - dqmel(1))      /ro_Wat
C +...      When nb_sno=1-->0        dqmel(1): not included in H2O Budget
C +                      old water :           not included in H2O Budget
C +                                            ==> include         here !
C +
c #sn       bheat  = bheat - watert*(Lf_H2O + csnow*TfSnow)
c #sn       tnsno(2,0) = tnsno(2,0) - enerm /cheat
c #sn       tnsno(2,1) = tnsno(2,0)
c #sn       wnsno(  1) = 0.d0
c #sn       dqmel(  1) = 0.d0
c #sn       roSNow(i,j,1) = 0.d0
c #sn       dzSNow(i,j,1) = 0.d0
c #sn       nb_sno = 0
c #SE       heat2m = tnsno(  2,0) *cheat
c #SE.                     + watert*(Lf_H2O + csnow*TfSnow)
c #SE       dheatm = heat2m - heat1m
c #SE       write(6,6050)jdaMAR,jhaMAR,jmmMAR,heat1m,heat2m,dheatm
 6050       format(3i3,f15.3,' - ',f15.3,' =',f15.6)
c #sn    else
c #sn       wamel    = 0.d0
c #sn    END IF
C +
c #sn   else
c #sn       wamel    = 0.d0
c #sn   END IF
C +
C +
C +-- 10.7 Possible Aggregation of last snow layer above old ice
C +   ----------------------------------------------------------
C +
c #sn   IF   (           nb_sno-nb_ice .eq. 1      .and.
c #sn.                          nb_ice .gt. 0      )                THEN
c #sn     IF (dzSNow(i,j,nb_sno)       .lt. 0.002d0)                THEN
c #sn                         n=nb_ice
C +
C +           ***************
c #sn         call SRFagr_sic(n,nb_sno,nb_ice)
C +           ***************
C +
c #sn     END IF
c #sn   END IF
C +
C +
C +-- 10.8 Water Percolation in Snow
C +   ------------------------------
C +
c #sn  if  (nb_sno.ge.1)             then
C +
c #sn  do iter  =1,ntwaSN
C +
c #sn     n=nb_sno      
C +
c #sn   volsno  =(1.d0-wnsno(n))      *roSNow(i,j,n)             /ro_Ice
C +...  volsno  : Volume (per Unit Vol.) of Snow/Ice (Pores Excluded)
C +
c #sn   volpor  = 1.d0-volsno 
C +...  volpor  : Volume (per Unit Vol.) of           Pores
C +
c #sn   volwat  =      wnsno(n)       *roSNow(i,j,n)             /ro_Wat
C +...  volwat  : Volume (per Unit Vol.) of Water (before Melting)
c #sn   volmax  =  max(volpor-volwat,zero)
c #sn   watmax  =      volmax        *ro_Wat        *dzSNow(i,j,n)
C +
c #sn   twwat       =     TfSnow
c #sn   dwwat       = min(waSNru(i,j),watmax)
c #sn   waSNru(i,j) =     waSNru(i,j) -dwwat
c #WR   write(6,6002)iter,waSNru(i,j),watmax,volpor,volwat,volmax,
c #WR.                                dwwat ,tnsno(2,nb_sno)
 6002   format(i8,7d15.6)
C +
c #sn  do n=nb_sno,1,-1
C +
C +-- 10.8.1 Water   IN
C +   ~~~~~~~~~~~~~~~~~
c #sn   rosnew        =  roSNow(i,j,n) + dwwat / dzSNow(i,j,n)
c #sn   tnsno(2,n)    = (tnsno(2,n)    * roSNow(i,j,n) 
c #sn.                 + twwat         * dwwat / dzSNow(i,j,n))
c #sn.                /  rosnew
C +...  Remark: Heat Contribution from Rain (as Rain Temperature > T_fs),
C +                               is included in the Surface Heat Flux
C +
c #sn   wnsno  (n)    = (wnsno  (n)    * roSNow(i,j,n)
c #sn.                 +                 dwwat / dzSNow(i,j,n))
c #sn.                /  rosnew
c #sn   roSNow(i,j,n) =  rosnew
C +
C +-- 10.8.2 Water FLOW
C +   ~~~~~~~~~~~~~~~~~
c #sn   rosneu = roSNow(i,j,n)
c #sn   wnsneu = wnsno     (n)
C +
c #sn   do neu = 1,1
C +...      Euler Backward Scheme if: [do neu=1,2]
C +
c #sn   if(ro_Ice.gt.rosneu*(1.d0-wnsneu)+1.2d2) then
C +***     Ice Density of Pore Hole Close OFF is 800.kg/m3 => 920-800=1.2d2
C +       (e.g. Greuell and Konzelmann 1994, Glob.Plan.Change 9, 4.5 p.100)
C +
c #sn   wstag = w0SNo*max(zero,unun-rosneu*(unun-wnsneu)/ro_Ice)
c #sn.               *ro_Wat/rosneu
C +...  wstag : Minimum                              RETAINED Water Mass
C +
c #sn   roexc = ro_Ice/rosneu-1.0d00
c #sn   wssno =        wnsneu*roiwSN / (roexc +wnsneu)
C +...  wssno : Fraction of the Pore Volume Containing MOVING Water
C +
c #sn   else
c #sn   wssno =     0.d0
C +
c #sn   end if
C +
C +-- 10.8.2 a) ROUTE
C +   ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
c #SE     if (wssno     .gt.0.d0.and.nroute(25:25).eq.' ') then
c #SE                                nroute(25:25)  = 'S'
c #SE                  write(nroute(26:26),'(i1)')     n/10
c #SE                  write(nroute(27:27),'(i1)') mod(n,10)
c #SE     end if
C +
c #sn   wnra  =    (wssno -w0SNo) / (unun -w0SNo)
c #sn   wnra  = max(wnra,zero)
C +***  wnra  : Effective Saturation (Rowe et al. 1995 JGR p.16267 (6))
C +            
c #sn   wnr3  =     wnra*wnra*wnra
C +
c #sn   perwa = 0.077*dgsno(n)*dgsno(n)*exp(fcSNo*rosneu/ro_Wat)
C +...  perwa : intrinsic Snow Permeability 
C +             (Male 1980, in Dynamics of Snow and Ice Masses,
C +              S. Colbeck Ed., (96) p.376)
c #sn   uwsno(n) = gravit  *perwa    *wnr3  / viwaSN
C +...  uwsno(n) : Water Velocity  in  the Snow Pack
C +             (Male 1980, in Dynamics of Snow and Ice Masses, 
C +              S. Colbeck Ed., pp.374-376)
C +
c #sn   n1       =     n -1
c #sn   n1       = max(n1,1)
C +
c #sn   wnmov    = max(  wnsno     (n)   -wstag          , zero )
c #sn   uwmxn    =(      wnmov           *roSNow(i,j,n)  / ro_Wat)
c #sn.                                   *dzSNow(i,j,n)  / dtwaSN
C +...  uwmxn    | Maximum OUTPUT from layer n   before free of water
C +
c #sn   uwmxn1   =
c #sn.           +(1.d0 
c #sn.            -(1.d0-wnsno     (n1)) *roSNow(i,j,n1) / ro_Ice
c #sn.            -      wnsno     (n1)  *roSNow(i,j,n1) / ro_Wat)
c #sn.                                   *dzSNow(i,j,n1) / dtwaSN
C +...  uwmxn1   | Maximum  INPUT in   layer n-1 before saturated
C +
c #sn.           +(n1-n+1)*uwmxn
C +...           +(n1-n+1)*uwmxn = 0     (every layer except bottom layer)
C +                                uwmxn (bottom layer) 
C +              => Free    INPUT     under the snow-ice-water cover
C +
c #sn   uwsno(n) = min(uwsno(n),uwmxn )
c #sn   uwsno(n) = min(uwsno(n),uwmxn1)
c #sn   uwsno(n) = max(uwsno(n),zero  )
C +
C +-- 10.8.3 Water OUT
C +   ~~~~~~~~~~~~~~~~
c #sn   dwwat         = -ro_Wat        * uwsno(n) * dtwaSN
c #sn   rosnew        =  roSNow(i,j,n) + dwwat  / dzSNow(i,j,n)
c #sn   wnsneu        = (wnsno     (n) * roSNow(i,j,n)
c #sn.                 +                 dwwat  / dzSNow(i,j,n))
c #sn.                /  rosnew
C +
c #sn   wnsneu        =  max(zero,wnsneu)
c #sn   dwwat         =  dzSNow(i,j,n) *(wnsneu  *rosnew
c #sn.                                  -wnsno(n)*roSNow(i,j,n))
C +...  Flux Limitor on dwwat
C +
c #sn   rosnew        =  roSNow(i,j,n) + dwwat  / dzSNow(i,j,n)
c #sn   rosneu        =  rosnew
C +
c #sn   end do
c #sn   wnsno     (n) =  wnsneu
c #sn   roSNow(i,j,n) =  rosneu
C +...  End Euler Backward Scheme
C +
c #sn   twwat         =  tnsno(2,n)
c #sn   dwwat         = -dwwat
C +
c #sn  end do
C +
C +-- 10.8.4 Runoff Budget (Bottom)  [kg/m2]
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #sn   bmel   =  bmel  +  dwwat / ro_Wat
C +...  bmel   :  Melted Water percolating through the Model Bottom
C +
c #sn   bheat  =  bheat -  dwwat *(Lf_H2O + csnow*twwat)
C +...  BHeat  :  Bottom       Heat 'Input'
C +              (In fact      Heat  Loss by Runoff)
c #sn  end do
C +
c #sn  else  
C +
c #sn  do n=mg    ,1,-1
c #sn   uwsno(n) = 0.d0
c #sn   wnsno(n) = 0.d0
c #sn  end do
C +
c #sn  end if
C +
C +
C +-- 10.9 Internal  Water         [kg/m3] Run Off
C +   --------------------------------------------
C +
c #RU  if  (nb_sno.gt.0)             then
C +
c #RU  do n=nb_sno,1,-1
c #RU   row    =       wnsno(n)     *roSNow(i,j,n)
c #RU   ros    = (1.d0-wnsno(n))    *roSNow(i,j,n)
c #RU   rowmin =       w0SNo*(ro_Ice-ros)
c #RU.                      /(roiwSN-w0SNo)
C +...  Minimum Water Content 
C +
c #RU   rownew =          rowmin + slwaSN(i,j)*max(zero,row-rowmin)
c #RU   rownew =  min(row,rownew)
C +
C +-- 10.9.1 Runoff Budget (Internal/Slope Effect)
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #RU   bmel   =  bmel  - (rownew-row)*dzSNow(i,j,n)/ro_Wat
C +
c #RU   bheat  =  bheat + (rownew-row)*dzSNow(i,j,n)
c #RU.                   *(Lf_H2O+csnow*tnsno(2,n))
C +
c #RU   roSNow(i,j,n)  =  rownew + ros
c #RU   wnsno     (n)  =  rownew / roSNow(i,j,n)
C +
c #RU  end do
C +
c #RU  end if
C +
C +
C +-- 10.10 Cumulative Snow-Melt/Snow-Freeze
C +   --------------------------------------
C +
c #SM  if (.not.diagno) then
c #sn   if(jhurGE.eq.0.and.minuGE.eq.0)
c #sn.  hmelSL(i,j)   =                1.d-3*wamel 
c #sn   do n=1,nb_sno
c #sn   hmelSL(i,j)   =  hmelSL(i,j) + 1.d-3*dqmel(n)
c #IB   wem_IB(i,j)   =  wem_IB(i,j) + 1.d-3*dqmel(n)
c #IB   if (dqmel(n).gt.0.0d0)wem_IB(i,j,1)=wem_IB(i,j,1)
c #IB.                                     +1.d-3*dqmel(n)
c #IB   if (dqmel(n).lt.0.0d0)wer_IB(i,j,1)=wer_IB(i,j,1)
c #IB.                                     +1.d-3*dqmel(n)
C +     dqmel < 0:  Freezing
C +     dqmel > 0:  Melting
C +...  Conversion [kg/m2] = [mmWE] :X 1.d-3 => [mWE]
C +
c #sn   end do
C +
c #SM  end if
C +
C +
C +-- 10.11 Water Mass Balance Verification
C +   -------------------------------------
C +
c #SW   qwater        =                    -ro_Wat        *bmel
c #SW   dwater        =  dwater + waSNru(i,j) + wasndi
c #SW  if    (nb_sno.ge.1) then
c #SW  do n=1,nb_sno
c #SW   qwater        =  qwater + dqmel(n)
c #SW   dwater        =  dwater + wnsno(n) *roSNow(i,j,n) *dzSNow(i,j,n)
c #SW  end do
c #SW  end if
c #SW  if (abs(qwater-dwater).gt.epsi) 
c #SW.  write(29,1206) jdaMAR,jhaMAR,jmmMAR,qwater,dwater
 1206   format(i4,':',i2,':',i2,5x,'Melt:',d15.6,5x,'Dwat:',d15.6)
C +
C +
C +-- 10.12 Sublimation (Impact on Energy and Mass Balances)
C +   ------------------------------------------------------
C +
c #IB    wes_IB(i,j,1)=    wes_IB(i,j,1) - subli
C +
c #sn   if         (nb_sno.ge.1) then
C +
c #sn    sheat           =
c #sn.              -  subli *ro_Wat / roSNow(i,j,nb_sno)
C +
c #sn    dzSNow(i,j,nb_sno) = dzSNow(i,j,nb_sno) + sheat
c #sn    sheat           =                         sheat
c #sn.              * (csnow *roSNow(i,j,nb_sno) * tnsno (2,nb_sno)
c #sn.                +Lf_H2O*roSNow(i,j,nb_sno) * wnsno   (nb_sno))
C +
C +
C +-- 11. Snow Cover Settling in Case of Melting (Impose a Density Minimum)
C +   =====================================================================
C +
c #DG    do n=nb_sno,1,-1
c #DG    if (wnmel(n).gt.0.d0) then
c #DG     sqrarg   = (dgsno(n)-1.6d-4)/1.1d-13
c #DG     rosnmi   =  sqrt(sqrt(sqrarg))
C +...    dgsno(n): Grain Size (Loth et al. 1993 JGR 98 D6 p.10454)
C +                       from  Anderson    1976
c #DG     rosnmi   =   max(roSNow(i,j,n),rosnmi)
c #DG     dzSNow(i,j,n) = (roSNow(i,j,n)/rosnmi)*dzSNow(i,j,n)
c #DG     roSNow(i,j,n) =                rosnmi
c #DG    end if
c #DG    end do
C +
c #sn   else
c #sn    sheat           = 0.d0
c #sn   end if
C +
C +
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c #WR  write(4,401)hsnoSL(i,j)*ro_Wat/r0sno,r0sno,waSNru(i,j)
c #WR  if (nb_sno.gt.0)
c #WR. write(4,402)(n,znSNo(n),     dzSNow(i,j,n),tnsno   (2,n),
c #WR.                              roSNow(i,j,n),wnsno     (n),
c #WR.  snwae(n),     agSNow(i,j,n),hhsno(n),1.d6*uwsno(n),
c #WR.                g1SNow(i,j,n),g2SNow(i,j,n),nhSNow(i,j,n),
c #WR.              n=nb_sno,1,-1)
c #WR  write(4,405)    tnsno(2  ,n),ro_SL0(i,j),1.d3*bmel
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +
C +
C +-- 12. Update
C +   ==========
C +
C +-- 12.1 Update of Snow Thickness
C +   -----------------------------
C +
c #sn  IF         (nb_sno.ge.1)                                   THEN
C +
c #sn        znSNo(nb_sno) = dzSNow(i,j,nb_sno)
c #sn        snwae(nb_sno) = roSNow(i,j,nb_sno)*dzSNow(i,j,nb_sno)*1.d3
c #sn.                     / ro_Wat
c #sn    IF       (nb_sno.gt.1)                                   THEN
c #sn      DO    n=nb_sno-1, 1,-1
c #sn        znSNo(n)      = dzSNow(i,j,n)     + znSNo(n+1)
c #sn        snwae(n)      = roSNow(i,j,n)     *dzSNow(i,j,n)     *1.d3
c #sn.                     / ro_Wat
c #sn.     + snwae(n+1)
c #sn      END DO
c #sn    END IF
C +
c +IB                        wet_IB(i,j)       = snwae(1)
C +
c #sn  ELSE
c #sn        znSNo(1)      = 0.d00
c #sn  END IF
C +
c #sn  IF    (mh    .ge.1)                                        THEN
c #sn    DO n=0,-mh1+1,-1
c #sn        znSNo(n)      = dzSNo     (n)     + znSNo(n+1)
c #sn    END DO
c #sn  END IF
C +
C +
C +-- 12.2 Update of Snow Temperature Profile
C +   ---------------------------------------
C +
c #sn  do n=-mh,nb_sno+1
c #sn   tnsno(1,n) = tnsno(2,n)
c #sn  end do
C +
C +  ===========================
C +--END   OF INTERNAL TIME LOOP-------------------------------------------
C +  ===========================
C +
c #sn end do
C +
c #sn  tisn_2        =(tiSNow(i,j,-mh)+tnsno(2,-mh))*0.5d0
c #sn do n=-mh,nb_sno+1
c #sn  tiSNow(i,j,n) =                 tnsno(2, n)
c #sn end do
c #sn   t2_SL(i,j)   =(t2_SL(i,j)*t2SLtn+tisn_2/cs2SL)
c #sn.               /            t2SLtd
C +...  cfr. Herve Giordani Fev. 1993, Note de travail du CNRM, p.4
C +
C +
C +-- 12.3 Update of Water Profile
C +   ----------------------------
C +
c #sn do n=1,nb_sno
c #sn  waSNow(i,j,n) = wnsno(n)
c #sn end do
C +
C +
C +-- 13. SNOW METAMORPHISM and MECHANICAL SETTLING
C +   =============================================
C +
c #sn if (nb_sno.gt.0)                 then
C +
c #sn  if(jmmMAR.eq.0.and.jssMAR.eq.0) then
C +
c #sn     slope    = slopGE(i,j)
c #sn   do n=1,nb_sno
c #sn     tiSNo(n) = tiSNow(i,j,n)
c #sn     dzSNo(n) = dzSNow(i,j,n)
c #sn     roSNo(n) = roSNow(i,j,n)
c #sn     waSNo(n) = waSNow(i,j,n)
c #sn     g1SNo(n) = g1SNow(i,j,n)
c #sn     g2SNo(n) = g2SNow(i,j,n)
c #sn     nhSNo(n) = nhSNow(i,j,n)
c #sn   end do
C +
C +       ***************
c #sn     call SRFmtm_sno(slope,nb_sno,nb_ice)
C +       ***************
C +
c #sn   do n=1,nb_sno
c #sn     tiSNow(i,j,n) = tiSNo(n)
c #sn     dzSNow(i,j,n) = dzSNo(n)
c #sn     roSNow(i,j,n) = roSNo(n)
c #sn     waSNow(i,j,n) = waSNo(n)
c #sn     g1SNow(i,j,n) = g1SNo(n)
c #sn     g2SNow(i,j,n) = g2SNo(n)
c #sn     nhSNow(i,j,n) = nhSNo(n)
c #sn   end do
C +
c #sn  end if
C +
C +
C +-- 14. Snow Cover new Discretization
C +   =================================
C +
C +    ***************
c #sn  call SRFstr_sic(nb_sno,nb_ice,iact)
C +    ***************
C +
C +--ROUTE
C +  ~~~~~
c #SE  if (iact.gt.0) then
c #SE                                nroute(29:29)  = 'L'
c #SE                  write(nroute(30:30),'(i1)')     nb_sno/10
c #SE                  write(nroute(31:31),'(i1)') mod(nb_sno,10)
c #SE  end if
C +
c #sn end if
C +
C +
C +-- 14.1 Denser Snow (10% Density Increase at most) 
C +        is included in the Snow Model
C +   -----------------------------------------------
C +
c #sn  IF (nb_sno.lt.mg1.and.
c #sn.     nb_sno.gt.  0.and.
c #sn.     nb_ice.eq.  0.and.isolSL(i,j).eq.-99)                   THEN
C +
C +        CAUTION: not use (isolSL(i,j).eq.-99)
C +          
c #sn        mm=nb_sno+1
c #sn       tiSNow(i,j,mm+1) = tiSNow(i,j,mm)
C +
c #sn     DO mm=nb_sno,1,-1
c #sn       dzSNow(i,j,mm+1) = dzSNow(i,j,mm)
c #sn       roSNow(i,j,mm+1) = roSNow(i,j,mm)
c #sn       tiSNow(i,j,mm+1) = tiSNow(i,j,mm)
c #sn       waSNow(i,j,mm+1) = waSNow(i,j,mm)
c #sn       agSNow(i,j,mm+1) = agSNow(i,j,mm)
c #sn       g1SNow(i,j,mm+1) = g1SNow(i,j,mm)
c #sn       g2SNow(i,j,mm+1) = g2SNow(i,j,mm)
c #sn       nhSNow(i,j,mm+1) = nhSNow(i,j,mm)
c #sn     END DO
C +
c #sn       nb_sno = nb_sno +1
c #sn       roSNow(i,j,1)    = roSNow(i,j, 2)*1.1d0
C +...      Density Increase :                 +10% 
C +
c #sn       roSNow(i,j,1)= min(roSNow(i,j, 1),ro_Ice) 
c #sn       tiSNow(i,j,1)    = tiSNow(i,j, 0)
c #sn       g1SNow(i,j,1)    = vg1SNo
c #sn       g2SNow(i,j,1)    = sph4SN
c #sn       nhSNow(i,j,1)    = nhSNo2
C +...      dzSNow, agSNow, waSNow: are implicitely  set 
C +                                 to lower layer value
C +
c #IB       dwe           = roSNow(i,j,1) *dzSNow(i,j,1) *1.d3/ro_Wat
c #b2       write(4,430)jdaMAR,jhaMAR,jmmMAR,jssMAR,i,j,dwe
 430        format(/,' Snow Model, after',i4,' Day ',3(i2,'.'),'Hr',
     .               ' at Pt',2i4,',',f15.6,' mmWE of Ice is added')
c #IB       do k = 1,mw
c #IB       wet_IB(i,j,k)   = wet_IB(i,j,k)  + dwe
c #IB       wei0IB(i,j)     = wei0IB(i,j  )  + dwe
c #IB       end do
C +
C +-- 14.1.1 ROUTE
C +   ~~~~~~~~~~~~
c #SE                                nroute(41:42)  = 'I+'
c #SE                  write(nroute(43:43),'(i1)')     nb_sno/10
c #SE                  write(nroute(44:44),'(i1)') mod(nb_sno,10)
C +
c #sn       iact  = iact  + 1
C +
c #Se       heat1 = heat1
c #Se.            + csnow *roSNow(i,j,1) *dzSNow(i,j,1) *tiSNow(i,j,1)
c #Se.            + Lf_H2O*roSNow(i,j,1) *dzSNow(i,j,1) *waSNow(i,j,1)  
C +
c #sn  END IF
C +
C +
C +-- 14.2 Update of Snow Thickness
C +   -----------------------------
C +
c #sn  IF         (nb_sno.gt.0.and.iact.gt.0)                     THEN
c #sn        znSNo(nb_sno) = dzSNow(i,j,nb_sno)
c #sn        snwae(nb_sno) = roSNow(i,j,nb_sno)*dzSNow(i,j,nb_sno)*1.d3
c #sn.                     / ro_Wat 
c #sn    IF       (nb_sno.gt.1)                                   THEN
c #sn      DO    n=nb_sno-1,1,-1
c #sn        znSNo(n)      = dzSNow(i,j,n)     + znSNo(n+1)
c #sn        snwae(n)      = roSNow(i,j,n)     *dzSNow(i,j,n)     *1.d3
c #sn.                     / ro_Wat
c #sn.     + snwae(n+1)
c #sn      END DO
c #sn    END IF
c #sn  END IF
C +
c #sn  IF         (mh    .gt.0.and.iact.gt.0)                     THEN
c #sn    DO   n=0,-mh1+1,-1
c #sn        znSNo(n)      = dzSNo     (n)     + znSNo(n+1)
c #sn    END DO
c #sn  END IF
C +
C +
C +-- 15. UPDATE of EXTERNAL VARIABLES
C +   ================================
C +
C +-- 15.1 Number of snow and ice layers
C +   ----------------------------------
C +
c #sn nsSNow(i,j) = nb_sno
c #sn niSNow(i,j) = nb_ice
C +
C +
C +-- 15.2 Analyse of Slush,Superimposed Ice 
C +        and Average Dens. and Water Content
C +   ----------------------------------------
C +
C +
C +   ************
c +sn call analyse(iterun, nb_sno,nb_ice,nb_superim,
c +sn.             nb_slush,superim,slush,avden,avwat)
C +   ************
C +
c +sn siiceSN(i,j) = superim
c +sn slushSN(i,j) = slush
c +sn avdenSN(i,j) = avden
c +sn avwatSN(i,j) = avwat
c +sn nsiiSN(i,j) = nb_superim
c +sn nsluSN(i,j) = nb_slush
c +sn if (nb_sno.ge.1) then
c +sn  if (iterun.eq.0) then 
c +sn   smbalSN0(i,j)    = snwae(1) - snwae(nb_ice+1)
c +sn  end if
c +GL  if (maskSN(i,j) .eq. 90) then 
c +sn   smbalSN(i,j)     = snwae(1) - smbalSN0(i,j)
c +sn   znSNow_snow(i,j) = znSNo(1) - znSNow0 (i,j)
c +GL  else
c +GL   smbalSN(i,j)     = snwae(nb_ice+1) 
c +GL   znSNow_snow(i,j) = znSNo(nb_ice+1) 
c +GL  endif
c +sn else
c +sn  smbalSN(i,j)      = 0.0d0
c +sn  znSNow_snow(i,j)  = 0.0d0
c +sn endif
C + 
C + 
c #sn znSNo(mg) = dzSNow(i,j,mg)
c #sn do n=mg1,1,-1
c #sn znSNo(n)  = dzSNow(i,j,n) + znSNo(n+1)
c #sn end do   
C +
C +
C +-- 15.3 Surface Temperature Increment
C +   ----------------------------------
C +
c #sn dtgSL(i,j,1) = (tiSNow(i,j,nb_sno+1) - tsrfSL(i,j,1))*dt/dtPhys
C +
C +
C +-- 15.4 Surface Specific Humidity
C +   ------------------------------
C +
c #sn                                                                lsf=0
c #sn qst        =  qsat0D(tiSNow(i,j,nb_sno),unun,pstDY(i,j),ptopDY,lsf)
c #sn qvapSL(i,j)=  qst
C +
C +
C +-- 15.5 Saltation Threshold
C +   ------------------------
C +
c #sn if  (           nb_sno .gt.     0) then
C +
c #sn  if (nhSNow(i,j,nb_sno).le.nhSNo1) then
c #sn       ro_SL(i,j) =      0.d0
C +...      ro_SL      : Pseudo-Surface Density (Roughness Length Parameter.)
C +
C +-- 15.5.1 CEN  Parameterization of the Saltation Threshold
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS    if (g1SNow(i,j,nb_sno).lt.0.d0) then
c #BS      SaltMo      = -0.750d-2 * g1SNow(i,j,nb_sno) 
c #BS.                   -0.500d-2 * g2SNow(i,j,nb_sno)+ 0.500d00
C +...     SaltMo      :  Guyomarc'h & Merindol, 1997, Ann. Glac.
C +             CAUTION:  Guyomarc'h & Merindol Dendricity Sign is +
C +             ^^^^^^^^                    MAR Dendricity Sign is -
c #BS    else
c #BS      SaltMo      = -0.833d-2 * g1SNow(i,j,nb_sno) 
c #BS.                   -0.583d-2 * g2SNow(i,j,nb_sno)+ 0.833d00
c #BS    end if
C +
c #BS    if (nhSNow(i,j,nb_sno).ge.nhSNo2)SaltMo = min(SaltMo,SaltMx)
C +
C +-- 15.5.2 Influence of Density on Shear Stress
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #BS      Por_BS      =  1.000d00    - roSNow(i,j,nb_sno)/ro_Ice
c #BS      ShearX      =                   Por_BS/(unun-Por_BS) 
C +...     ShearX ==> Arg(sqrt(shear)) with shear = max shear stress in snow:
C +        shear       =  3.420d00 * exp(-(Por_BS      +Por_BS)
C +  .                                   /(unun        -Por_BS))
C +                       see de Montmollin         (1978),
C +                       These Univ. Sci. Medic. Grenoble, Fig. 1 p. 124
C +
c #BS      SaltSU      =      (1.00d0+SaltMo)          *FacSBS
c #BS      ArgFac      =   max(zero  ,SheaBS-ShearX)
c #BS      Fac_Mo      =   exp(       ArgFac       )
C +
C +-- 15.5.3 Snow Drift Index
C +   ~~~~~~~~~~~~~~~~~~~~~~~
c #BS      SaltSU         =  max(epsi,SaltSU) 
c #BS      SaltSU         =  exp(Fac_Mo*log(SaltSU))
c #BS      ArguSi         =     -FacTBS                *ssvSL(i,j,mz)
c #BS      SaltSI(nb_sno) =     (SaltSU-exp(ArguSi))   *FacRBS  

c #BS      Salt_U         =     -Fac_Mo*log(SaltSU)    *FacUBs
C +...     Salt_U         :  Snow Drift Threshold Velocity            
C +                         (Guyomarc'h & Merindol, 1997, Ann. Glac.)
C +
c #BS      SaltSL(i,j) =     Salt_U  *  cdnSL(i,j,1)
C +
c #BY      SaltSL(i,j) =     Salt_U  /  26.5d00
C +...     Us(U10)     :    (Budd et al.            1966, Ant.Res.Ser. 9
C +                     (see Pomeroy & Gray 1995 NHRI Sci.Rep.7, (30) p. 62)
C +
C +-- 15.5.4 Densification of the eroded layer
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
C +  (See: Brun, Martin and Spiridonov 1997,J.Glaciol.)
C +
c #BM      ArguSi         = -8.5d-2                    *ssvSL(i,j,mz)
c #BM      SaltSI(nb_sno) = (SaltSU  -  exp(ArguSi))   *FacRBS
C +...     SaltSI         :  Snow Drift Index                         
C +                         (Guyomarc'h & Merindol, 1997, Ann. Glac.)
C +
c #BM       fro      =  dzSNow(i,j,nb_sno)*5.d00*(3.25d0-SaltSI(nb_sno))
c #BM       xro      =  max (zero ,SaltSI(nb_sno)*exp(-fro))
c #BM    if (roSNow(i,j,nb_sno).lt.roSNf)                           then
c #BM       dro      =  xro*(roSNf-roSNow(i,j,nb_sno))*dtPhys*5.787d-6
C +...                                    1/(2*86400s) --> 5.787d-6[s-1]
C +
c #BM        rosnew    =  min (roSNf,           dro +roSNow(i,j,nb_sno))
c #BM        dzSNow(i,j,nb_sno) = dzSNow(i,j,nb_sno)*roSNow(i,j,nb_sno)
c #BM.                                              /rosnew
c #BM        roSNow(i,j,nb_sno) =                    rosnew
c #BM    else
c #BM       dro        =  0.d0
c #BM    end if
c #BM    if (g1SNow(i,j,nb_sno).lt.0.d0) then
c #BM       dg1        = -g1SNow(i,j,nb_sno)*5.d-1 *xro *dtPhys*5.787d-6
c #BM       dg1        =  min (dg1 ,-g1SNow(i,j,nb_sno))
c #BM      g1SNow(i,j,nb_sno)= dg1  +g1SNow(i,j,nb_sno)
c #BM    end if
C +
C +-- 15.5.5 PBSM Parameterization of the Saltation Threshold
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #LP      tair_C      =  TairSL(i,j)-TfSnow
c #LP      tair2C      =  tair_C     *tair_C
c #LP      Salt_U      =  9.43d00 + 0.18d00*tair_C + 3.30d-3*tair2C
C +...     Salt_U      :  Li and Pomeroy 1997, JAM (3) p. 211
C +
c #LP      arg_Us      =  1.295d0 * log(abs(Salt_U))
c #LP      SaltSL(i,j) =                exp(arg_Us) /44.2d00
C +...     Us(U10)     :  Pomeroy 1988 
C +
C +-- 15.5.6 Additional Output 
C +   ~~~~~~~~~~~~~~~~~~~~~~~~
c #b2      ArguSi         = -0.085d00*ssvSL(i,j,mz)
c #b2      SaltSI(nb_sno) = (SaltSU  -  exp(ArguSi))      * 2.868d00
C +...     SaltSI         :  Snow Drift Index                         
C +                         (Guyomarc'h & Merindol, 1997, Ann. Glac.)
C +
c #b2      if (jmmMAR.eq.0)
c #b2.       write(6,6010)
 6010        format(14x,'V',6x,'Ta',5x,'Ts    u*   n',
     .              4x,'ro',4x,'G1',3x,'G2',' Th/Re Drift',
     .              4x,'DI',4x,'SI',4x,'Ut',3x,'u*t',
     .              ' qs_1_0[g/kg]   b*[mm]   h*[mm] z[mmWE]')
c #b2        write(6,6011)jdaMAR,jhaMAR,jmmMAR,
c #b2.                    ssvSL(i,j,mz),tairDY(i,j,mz),tsrfSL(i,j,1),
c #b2.                   SLuusl(i,j,1),
c #b2.                    nb_sno,roSNow(i,j,nb_sno),
c #b2.                           g1SNow(i,j,nb_sno), g2SNow(i,j,nb_sno),
c #b2.                    tdrift,rdrift,
c #b2.                    SaltMo,SaltSI(nb_sno),     Salt_U,SaltSL(i,j),
c #b2.                       (1.d3*qsHY(i,j,k),k=mz,mzz),
c #b2.               1.d3*bsnoEW,  1.d3*hsnoEW,      snwae(1)
 6011        format(3i3,f6.2,f8.2,f7.2,f6.3,i4,2f6.1,f5.1,4f6.3,f6.2,
     .              2f6.3,f7.3,2f9.6,f8.3)
C +
c #sn  else
c #sn       ro_SL(i,j) =      roSNow(i,j,nb_sno)
c #BS      SaltSL(i,j) =      1.d2
C +...     SaltSL: Here an impossible Value
C +               (Preclude Saltation)
c #sn  end if
C +
c #sn else
c #sn       ro_SL(i,j) =      ro_SL0(i,j)
c #BS      SaltSL(i,j) =      1.d2
C +...     SaltSL: Here an impossible Value
C +               (Preclude Saltation)
c #sn end if
C +
C +
C +-- 16. Snow Energy
C +   ===============
C +
C +-- 16.1 Snow Bottom  Energy and Water OUTPUT  
C +   -----------------------------------------
C +
c #sn fmel       =  bheat                                 /dtPhys
C +...fmel*dtPhys   =  BHeat:  Bottom       Heat 'Input' 
C +                        (In fact      Heat  Loss by Runoff)
C +
c #sn hwatSL(i,j) = hwatSL(i,j) +bmel
C +...hwatSL(i,j) : Melting Water available for the Ground [m]
C +
C +
C +-- 16.2 Snow Cover   Energy
C +   ------------------------
C +
c #Se  heat2 =(csnow     *tiSNow(i,j,nb_sno)+Lf_H2O)*(wasndi
c #Se.                                               +waSNru(i,j))
c #Se.        +d1_SL(i,j)*tiSNow(i,j,-mh)           / 3.72d0
C +...         Energy of          Soil      Layer
C +
c #Se if     (mh  .gt.0) then
c #Se  do n= -mh1+1,0
c #Se  heat2 = heat2
c #Se.       + cs_SV(n)                                 *tiSNow(i,j,n)
c #Se  end do
c #Se end if
C +
c #Se if   (nb_sno.ge.1) then
c #Se  do n=nb_sno,1,-1
c #Se  heat2 = heat2 
c #Se.       + csnow  *roSNow(i,j,n)      *dzSNow(i,j,n) *tiSNow(i,j,n)
c #Se.       + Lf_H2O *roSNow(i,j,n)      *dzSNow(i,j,n) *waSNow(i,j,n)
c #Se  end do
c #Se end if
C +
C +
C +-- 16.3 Snow Cover   Energy Balance
C +   --------------------------------
C +
c #Se dheat = heat2 -heat1 -aheat -wheat -sheat -bheat -hdeep
c #SE if (abs(dheat).gt.epSN1) then 
c #SE  write(29,1205) jdaMAR,jhaMAR,jmmMAR,heat2,heat1,
c #SE.             aheat,pheat,wheat,sheat,bheat,hdeep,dheat
c #SE.       ,nroute,        waSNru(i,j),    nb_sno,
c #SE.       (mroute(iroute),wwater(iroute),-iroute,iroute=9,1,-1)
 1205 format(/,1x,/,  i4,':',i2,':',i2,5x,
     .            /,'   (Heat2=',f13.1,') - (Heat1=',f13.1,')',
     .            /,' - (AHeat=',f13.1,') [-(*Heat=',f13.1,')]',
     .              ' - (.Heat=',f13.1,') - (SHeat=',f13.1,')',
     .            /,' - (BHeat=',f13.1,') - (hDeep=',f13.1,')',
     .             '  = (DHeat=',f13.1,')',
     .    //,'   Active  Processes: ',a44,5x,f9.3,' mmWE',5x,'iUp=',i2,
     .   9(/,'                      ',a44,5x,f9.3,' mmWE    (',i2,')'))
c #SE  write(29,401)hsnoSL(i,j)*ro_Wat/r0sno,r0sno,waSNru(i,j)
c #SE  if (nb_sno.gt.0)
c #SE. write(29,402)(n,znSNo(n),1.d3*dzSNow(i,j,n),tiSNow(i,j,n),
c #SE.                 roSNow(i,j,n),waSNow(i,j,n), cdsno(n),
c #SE.  snwae(n),      agSNow(i,j,n), hhsno(n),1.d6*uwsno(n),
c #SE.                 g1SNow(i,j,n),g2SNow(i,j,n),nhSNow(i,j,n),
c #SE.               n=nb_sno,1,-1)
c #SE  write(29,405)   tiSNow(i,j,n),ro_SL0(i,j),1.d3*bmel
c #SE end if
C +
C +
C +-- 17. OUTPUT on Listing if IO_loc .ge. 3
C +   ======================================
C +
c #sn if ((((IO_loc.ge.3.and.    jhurGE   .eq.0) .or. 
c #sn.      (IO_loc.ge.4.and.mod(jhurGE,3).eq.0) .or. 
c #sn.      (IO_loc.ge.5)                            )       ).or.
c #sn.       IO_loc.ge.7                                          ) then
C +
C +    ***********
c #sn  call TIMcor
C +    ***********
C +
       zeta = (gplvDY(i,j,mz)-gplvDY(i,j,mzz)) / (gravit*SLlmol(i,j,1))
C +
c #BS      ArguSI         = -0.085d00*ssvSL(i,j,mz)
c #BS  IF (nb_sno.GT.0)
c #BS.     SaltSI(nb_sno) = (SaltSU  -  exp(ArguSI))      * 2.868d00
C +...     SaltSI         :  Snow Drift Index                         
C +                         (Guyomarc'h & Merindol, 1997, Ann. Glac.)
C +
c #sn  write(4,400)jdplus,mmplus,jhlrGE(i,j),minuGE,i,j
 400   format(/,' Snow Model ',i2,'/',i2,1x,i2,'h',i2,'LT',
     .                           ' --    Grid Point (',i5,',',i5,')',
     .  /,' =======================================================')
C +
c #Se  write(4,410) heat2,heat1,
c #Se.              aheat,pheat,wheat,sheat,bheat,hdeep,dheat
 410   format(/,' Energy Balance',
     .        /,' ==============',
     .        /,'   (Heat2=',f13.1,') - (Heat1=',f13.1,')',
     .        /,' - (AHeat=',f13.1,') [-(*Heat=',f13.1,')]',
     .          ' - (.Heat=',f13.1,') - (SHeat=',f13.1,')',
     .        /,' - (BHeat=',f13.1,') - (hDeep=',f13.1,')',
     .         '  = (DHeat=',f13.1,')')
C +
c #sn  write(4,401)hsnoSL(i,j)*ro_Wat/r0sno,r0sno,waSNru(i,j)
 401   format(/,' Internal Characteristics',
     .        /,' ========================',
     .        /,'  n |  z    |  dz   |   T    | rho   |  W    |  Cd  |',
     .       ' z(WE) | Age   | Extin |  UW   | Dendr.| Spher.| Hist. |',
     .        /,'    | [m]   | [mm]  |  [K]   | kg/m3 | kg/kg | Wm/K |',
     .       '  [mm] | [d]   |       | mim/s | /Sphe.| /Size |       |',
     .        /,'----+-------+-------+--------+-------+-------+------+',
     .       '-------+-------+-------+-------+-------+-------+-------+',
     .        /,'    |       |',f6.1,' |        |',f6.1,' |',f5.2,'mm|',
     .                                                        '      |',
     .       '       |       |       |       |       |       |       |')
c #sn  if (nb_sno.gt.0)
c #sn. write(4,402)(n,znSNo(n),1.d3*dzSNow(i,j,n),tiSNow(i,j,n),
c #sn.                roSNow(i,j,n),waSNow(i,j,n), cdsno(n),
c #sn.  snwae(n),     agSNow(i,j,n), hhsno(n),1.d6*uwsno(n),
c #sn.                g1SNow(i,j,n),g2SNow(i,j,n),nhSNow(i,j,n),
c #sn.              n=nb_sno,1,-1)
 402   format((i3,' |',f6.2,' |',  f6.1,' |', f7.2,' |',  f6.1,' |',
     .       f6.3,' |',
     .       f5.1,' |',f7.0, '|',  f6.1,' |', f6.3,' |',  f6.2,' |',
     .     2(f6.1,' |'),i4,'   |'))
c #sn  if (mh    .gt.0) then
c #sn  write(4,403)
 403   format(/,'----+-------+-------+--------+-------+-------+------+',
     .       '-------+-------+-------+-------+-------+-------+-------+',
     .        /,'  n |  z    |  dz   |   T    |       |       |  Cd  |',
     .       '       |       |       |       |       |       |       |',
     .        /,'    | [m]   | [cm]  |  [K]   |       |       | Wm/K |',
     .       '       |       |       |       |       |       |       |',
     .        /,'----+-------+-------+--------+-------+-------+------+',
     .       '-------+-------+-------+-------+-------+-------+-------+')
c #sn  write(4,404)(n,znSNo(n),1.d2*dzSNo(n),tiSNow(i,j,n),
c #sn.                              cdsno(n),                  
c #sn.              n=0,-mh,-1)
 404   format((i3,' |',f6.2,' |',  f6.1,' |', f7.2,' |', 2(6x ,' |'),
     .       f5.1,' |', 7x , '|',   6x ,' |',  6x ,' |',   6x ,' |',
     .     2( 6x ,' |'),4x,'   |'))
c #sn  else
c #sn  write(4,405)   tiSNow(i,j,0),ro_SL0(i,j),1.d3*bmel
 405   format(('  0 |  0.00 |   0.0 |', f7.2,' |',  f6.1,' |',f7.4,'|',
     .       6x,   '|', 7x , '|',2( 6x ,' |'), 6x ,' |',2( 6x ,' |'),
     .       4x,'   |'))
c #sn  end if
C +
c #sn  write(4,440)
 440   format(/,' Surface  Characteristics',
     .        /,' ========================')
c #sn  write(4,441)  t2_SL(i,j),     tsrfSL(i,j,1),
c #sn.         1.d2*alb0SL(i,j),1.d2*albeSL(i,j)
c #sn  write(4,442) RAdsol(i,j),     sol_SL(i,j),
c #sn.              firmSL(i,j),     firdSL(i,j)
c #sn  write(4,443) uairDY(i,j,mz),  vairDY(i,j,mz),ssvSL(i,j,mz),zeta
c #sn  write(4,453) 1.d3*SL_z0(i,j,1),1.d3*SL_r0(i,j,1)
c #sn  write(4,444) cdhSL(i,j,1),
c #sn.             SLuusl(i,j,1),    SLutsl(i,j,1),1.d3*SLuqsl(i,j,1)
c #BS  write(4,454)SaltSL(i,j)  ,                  1.d3*uss_HY(i,j)
c #BS  write(4,455)SaltMo,                         1.d3*bsnoEW
c #BS  write(4,456)SaltSI(nb_sno),                 1.d3*hsnoEW
c #sn  write(4,445) 1.d2*relhum,qvapSL(i,j),hsenSL(i,j),hlatSL(i,j)
c #SM  write(4,446)                         fmelSL(i,j),freeSL(i,j)
c #sn  write(4,447) hbalSL(i,j),     dtgSL(i,j,1),roseSL(i,j),egdd
c #sn  write(4,448) fmel,1.d2*hmelSL(i,j),egpm
c #sn  write(4,449)     1.d-1*waSNru(i,j)
 441   format(' T2 (Deep)=', f8.2,4x,'   Tg(Snow)=',f7.2,2x,
     .        '   AlbedoB=',f7.2,2x,'   Albedo =',f8.2,2x)
 442   format(' RS (Dwn.)=', f8.2,4x,'   RS(Abs.)=',f7.2,2x,
     .        '   IR (Up)=',f7.2,2x,'   IR(Dwn)=',f8.2,2x)
 443   format(' u (S.Lay)=', f8.2,4x,'   v(S.Lay)=',f7.2,2x,
     .        '   | V |  =',f7.2,2x,'   zeta   =',f12.6)
 453   format(' SNOW     :',12x,     '   z0      =',f9.4,
     .        '   r0     =',f9.4,23x,'(X 1000)')
 444   format(' Comp.DRAG=',f12.6,   '    u *    =',f9.4,
     .        '   u th * =',f9.4,   '   u q *  =',f12.6,' g/kg m/s')
 454   format('           ', 12x,    '    u*_t   =',d9.3, 
     .        '           ', 9x,    '   u s *  =',f12.6,' g/kg m/s')
 455   format('           ', 12x,    '    Mobil I=',d9.3, 
     .        '           ', 9x,    '   h* Ero =',f12.6,' mm      ')
 456   format('           ', 12x,    '    Drift I=',d9.3, 
     .        '           ', 9x,    '   h* Dep =',f12.6,' mm      ')
 445   format(' Rela.Hum.=', f8.2,4x,'   q(Surf.)=',f9.4,
     .        '   H0     =',f7.2,2x,'   HL     =', f8.2)
 446   format('           ',  8x ,4x,'            ', 9x ,
     .        '   H_Melt =',f7.2,2x,'   H_Frz. =', f8.2)
 447   format(' Energ.B. =', f8.2,4x,'   d (Tg)  =',f9.4,
     .        '   Rime   =',f9.4,   '   eg(D.) =',f12.6)
 448   format(' Fmel     =', f8.2,4x,'   Cumul. Net Snowmelt H',
     .           ' (cmWE):',f8.3,  '    eg(P.) =',f12.6)
 449   format('           ',     12x,'   Surficial  Water    H',
     .           ' (cmWE):',f8.3)
C +
c #sn end if
C +
C +
C +-- 18. INTEGRATION of MELTING
C +   ==========================
C +
c #SM if (diagno) then
c #SM  if (jhurGE.eq.0.and.minuGE.eq.0) then
c #SM   hmelSL(i,j) = (fmelSL(i,j) + freeSL(i,j))*dtPhys/(ro_Wat*Lf_H2O)
c #SM  else
c #SM   hmelSL(i,j) =  hmelSL(i,j) 
c #SM.              + (fmelSL(i,j) + freeSL(i,j))*dtPhys/(ro_Wat*Lf_H2O)
C +...  hmelSL     :cumulative snowmelt thickness    (m water equivalent)
C +
c #SM  end if
c #SM end if
C +
C +-------------------------------------------------------------------------
C +--END OF SNOW MODEL------------------------------------------------------
C +-------------------------------------------------------------------------
C +
      return
      end   
      subroutine analyse(iterun,nb_sno,nb_ice,nb_superim,
     .                   nb_slush,superim,slush,avden,avwat)
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            03-12-2002  MAR |
C | subroutine analyse                                                     |
C | Analyse of Slush,Superimposed Ice and Average Dens. and Water Content  |
C +------------------------------------------------------------------------+     
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
      include 'MAR_DY.inc'
      include 'MAR_HY.inc'
      include 'MAR_RA.inc'
      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
      include 'MARsSN.inc'
      include 'MAR_IB.inc'
      include 'MAR_IO.inc'
C +
C +
C +--DATA
C +  ~~~~
      integer iterun,nb_sno,nb_ice,nb_superim,nb_slush
      integer ice_or_slush_found, n
C +
      real    height,slush,superim,avden,avwat
      real    sommas,somvol,somwa
C + 
      slush = 0.0
      superim= 0.0
C +
C +
C +---------Superimposed Ice(m) and Slush Height(m)--
C + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C    Hyphothese: 1) No Superimposed Ice  and No Slush
C                2)    Superimposed Ice  and No Slush
C                3)    Superimposed Ice  and    Slush
C                4) No Superimposed Ice  and    Slush
C + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +
        if (nb_sno.eq.nb_ice) then
           superim    = 0.0d0
           slush      = 0.0d0
           avden      = 0.0d0
           avwat      = 0.0d0
           nb_superim = nb_ice
           nb_slush   = nb_ice
           goto 666
        endif
C +
C + Recherche de SI-index (exclude ice lenses )
C + -------------------------------------------
C +
        nb_superim         = nb_ice
        ice_or_slush_found = 0
	do n=nb_ice+1,nb_sno
        if(roSNow(i,j,n) .gt. 900.0d0
     .  .and. waSNow(i,j,n) .eq. 0.00d0
     .                     .and. ice_or_slush_found.eq.0)then
              nb_superim=n
        else
              ice_or_slush_found=1
        endif
        enddo
C +
C + Recherche de Slush-index
C + ------------------------
       nb_slush           = nb_superim
      ice_or_slush_found = 0
      do n=nb_superim+1,nb_sno
       if ((roSNow(i,j,n) .gt. 900.0d0 .and.
     .  waSNow(i,j,n) .gt. 0.1d0).and. ice_or_slush_found .eq. 0)then 
        nb_slush=n
       else
        ice_or_slush_found=1
       endif
      enddo
C +
C + Superimposed Ice and Slush Height(m)
C + Note: Slush height does include superimposed-ice height 
C + ----------------------------------------------------------------
C +
C +...SI
C +=====
       if (nb_superim .eq. nb_ice) then
        superim = 0.0d0
       else
        height = 0.0
        do n=nb_ice+1, nb_superim
         height = dzSNow(i,j,n)+height
        enddo
        superim = height
      endif
C +
C +...SLUSH
C +========
      if (nb_slush   .eq. nb_superim) then
       slush = superim
      else
       height = superim
        do n=nb_superim+1,nb_slush
         height = dzSNow(i,j,n)+height
        enddo
       slush = height
      endif
C + 
C +--Average Density and Water Content(vol %), exluding slush/SI
C +  -------------------------------------------------------
C + 
      if (nb_slush .eq.nb_sno ) then
       avden   = 0.0d0
       avwat   = 0.0d0
       goto 666
      endif
C + 
      sommas = 0.0d0
      somvol = 0.0d0
      somwa =  0.0d0
      do n=nb_slush+1,nb_sno
       if (roSNow(i,j,n).ne.920.0d0) then
        sommas = sommas + (dzSNow(i,j,n)*roSNow(i,j,n))
        somvol = somvol + (dzSNow(i,j,n))
        somwa  = somwa  + (dzSNow(i,j,n)*roSNow(i,j,n)*waSNow(i,j,n))
       endif
      enddo
C + 
      somvol = max(epsi, somvol)
      sommas = max(epsi, sommas)
C + 
      avden  = sommas / somvol
      avwat  = (somwa /sommas) * avden / 10.0d0
c     ...maintenant, avwat est en % (1,2,3..)
C +
  666 continue
      return
      end   
      function SRFdtp_sno(pgra11,pgra21,pgra12,pgra22,
     .                    khist1,khist2,pro1  ,pro2  )
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   Function SRFdtp_sno                                                  |
C |            evaluates the difference between grain types of two layers  |
C |            and returns a value between 0. and 200.                     |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Brun et al.      1989, J. Glaciol 35 pp. 333--342           |
C |   ^^^^^^^^ Brun et al.      1992, J. Glaciol 38 pp.  13-- 22           |
C |            (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |                                                                        |
C |   INPUT : pgra11  1e variable descriptive des grains de la 1e strate   |
C |   ^^^^^^^ pgra21  2e variable descriptive des grains de la 1e strate   |
C |           pgra21  2e variable descriptive des grains de la 1e strate   |
C |           pgra12  1e variable descriptive des grains de la 2e strate   |
C |           pgra22  2e variable descriptive des grains de la 2e strate   |
C |           khist1     variable historique  des grains de la 1e strate   |
C |           khist2     variable historique  des grains de la 2e strate   |
C |           pro1       masse    volumique              de la 1e strate   |
C |           pro2       masse    volumique              de la 2e strate   |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   Methode                                                              |
C |   -------                                                              |
C |      cas de la neige dendritique:                                      |
C |         1ere variable descriptive des grains: dendricite.              |
C |         2eme variable descriptive des grains: sphericite.              |
C |      cas de la neige non dendritique:                                  |
C |         1ere variable descriptive des grains: sphericite.              |
C |         2eme variable descriptive des grains: diametre des grains.     |
C |         variable historique des grains.                                |
C |      poids de ces variables dans le calcul de la difference:           |
C |         sphericite: vdtysp (   .5 par defaut)                          |
C |         masse vol.: vdtyro (500.  par defaut)                          |
C |         diametre  : vdtydi ( 10.  par defaut)                          |
C |         historique: vdtyhi (100.  par defaut)                          |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      real     SRFdtp_sno
      real     pgra11,pgra21,pgra12,pgra22,pro1,pro2  
      real     SNtypx,vdtysp,vdtyro,vdtydi,vdtyhi
      integer  khist1,khist2
C +
C +
C +--DATA
C +  ====
C +
      data SNtypx/ 200.0e0/
C +...     SNtypx: Plage  pour Difference de Type de Grains  
C +
      data vdtysp/   0.5e0/
C +...     vdtysp: Poids de la Sphericite    dans le Calcul  
C +
      data vdtyro/ 500.0e3/
C +...     vdtyro: Poids de la Masse Volumique
C +
      data vdtydi/  10.0e0/
C +...     vdtydi: Poids du Diametre             des Grains  
C +
      data vdtyhi/ 100.0e0/
C +...     vdtyhi: Poids de l'Historique         des Grains  
C +
C +
C +-- Types: dendritique et non dendritique
C +   -------------------------------------
C +
      if     (pgra11*pgra12.lt.-epsi) then
        SRFdtp_sno=SNtypx
C +
C +
C +-- Les deux Strates sont a Grains de Type     dendritique
C +   ------------------------------------------------------
C +
      elseif (pgra11       .lt.-epsi) then
        SRFdtp_sno=abs(pgra11-pgra12)
     .            +abs(pgra21-pgra22)*vdtysp
     .            +abs(pro1  -pro2)  *vdtyro
      else
C +
C +
C +-- Les deux Strates sont a Grains de Type non dendritique
C +   ------------------------------------------------------
C +
        SRFdtp_sno=abs(pgra11-pgra12)
     .            +abs(pgra21-pgra22)*vdtydi
     .            +abs(pro1-pro2)    *vdtyro
      endif
C +
        SRFdtp_sno=min(SNtypx,SRFdtp_sno+abs(khist1-khist2)*vdtyhi)
C +
      return
      end
      subroutine SRFstr_sic(nb_sno,nb_ice,iact)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   SubRoutine SRFstr_sic optimizes the Snow Stratigraphy                |
C |                         aggregates or splits layer(s)                  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |  METHODE: L'AGREGATION se fait en fct de l'epaisseur de chaque couche. |
C |  ^^^^^^^^ L'epaisseur max est determinee     par Fonction SRFcri_agr   |
C |           Pour les couches internes, on aggrege une couche avec celle  |
C |           (du haut ou du bas)                                          |
C |           qui a les caracteristiques stratigraphiques les plus proches |
C |                                                                        |
C |           Conditions de dedoublement donnees par Fonction SRFcri_ded   |
C |                                      compte tenu substrat (isolSL)     |
C |                                                                        |
C |   METHOD: AGREGATION is determined by the thickness of each layer.     |
C |   ^^^^^^^ Maximum thickness is determined    by  Function SRFcri_agr   |
C |           Inside the snow mantle, a layer is aggregated with the layer |
C |           whose stratigraphic characteristics are similar              |
C |                                                                        |
C |           Conditions for splitting are given by  Function SRFcri_ded   |
C |                                      accounting  substrat (isolSL)     |
C |                                                                        |
C |   REFER. : (CROCUS & MAR, adapted to MAR at CEN by H.Gallee)           |
C |   ^^^^^^^^                                                             |
C |   UPDATE : (Filip Lefebre, 7-7-1999):                                  |
C |   ^^^^^^^^ (Lines marked by "c ###" are modified)                      |
C |           Thickness requirements for isolSL=3 are determined           |
C |                                  with SRFcri_agr /SRFcri_ded           |
C |           The old ice layers (n=1,nb_ice) are not considered           |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
C +
      logical  aggreg
C +
      real    vdd1,vdd2,sno_cm
      real    zdzmax,SRFcri_agr,zdtmax,zdamax,zsdty1,SRFdtp_sno
      real    zsdty2,zdzmin,SRFcri_ded
      integer nb_sno,nb_ice,iact,inst,jst,n,nn,isdag1,isdag2
C +
C +
C +--DATA
C +  ====
C +
      data vdd1  / 3.00e00/, vdd2  /  4.00e00/
C +
c #sn sno_cm     =  1.d2  * znSNo(nb_ice+1)
C +
C +
C +--Snow Layers Aggregation
C +  =======================
C +
 100  continue
      iact=0
C +
C +
C +--Conditions pour la strate de neige inferieure /bottom snow layer
C +  ----------------------------------------------------------------
C +
      IF(nb_sno-nb_ice.gt.1)                                       THEN
C +
        IF(isolSL(i,j).eq.3)                                       THEN
c ###     zdzmax=       max(SNmdz1,sno_cm/SNmdz2)
          zdzmax=SRFcri_agr(1     ,nb_sno-nb_ice)
        ELSE
C +
C +              **********
          zdzmax=SRFcri_agr(1,nb_sno)
C +              **********
C +
        END IF
C +
        IF(1.0d2*dzSNow(i,j,nb_ice+1).lt.zdzmax)                   THEN
C +
C +         ***************
            call SRFagr_sno(nb_ice+1,nb_sno)
C +         ***************
C +
          iact=iact+1
        END IF
C +
C +
C +--Conditions pour les Strates internes / internal Layers
C +  ------------------------------------------------------
C +
        IF(nb_sno-nb_ice.gt.2)                                     THEN
C +
C +--Criteres maximums autorisant l'Agregation
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 inst=  nb_sno
          DO jst=inst-1,nb_ice+2,-1
C +
           IF(isolSL(i,j).eq.3)                                    THEN
c ###       IF(jst.eq.2)                                           THEN
c ###         zdzmax=SNmdz3*max(SNmdz1,                sno_cm/SNmdz2) 
c ###         zdtmax=SNtyp1*   (SNtyp2-                   jst/SNtyp3)
c ###.                     *min(SNtyp4,max(SNtyp5,     sno_cm/SNtyp6))
c ###         zdamax=SNdag1*   (SNdag2-           SNdag3 *jst/SNdag4)
c ###.                     *max(SNdag5,                sno_cm/SNdag6)
c ###       ELSEIF (jst.lt.nb_sno-mg_SN1) then
c ###         zdzmax=          (SNmdz4-                   jst/SNmdz5)
c ###.                     *max(SNmdz1,                sno_cm/SNmdz6)
c ###         relden=nb_sno-mg_SN1
c ###         zdtmax=SNtyp1
c ###.              +SNtyp1*   (1.d00-                    jst/relden)
c ###.                     *min(SNtyp4,max(SNtyp5,     sno_cm/SNtyp6))
c ###         zdamax=SNdag1
c ###.              +SNdag1*   (1.d00-                    jst/relden)
c ###.                     *max(SNdag5,                sno_cm/SNdag6)
c ###       ELSEIF (jst.lt.nb_sno-mg_SN2) then
c ###         zdzmax=SNmdz7
c ###         relden=mg_SN2
c ###         if(nb_sno.gt.mg_SN3) zdzmax=zdzmax
c ###.                                +(nb_sno-mg_SN2-jst)   /relden
c ###.                     *   (SNmdz4-(nb_sno-mg_SN3-  1)   /SNmdz5)
c ###.                     *max(SNmdz1,                sno_cm/SNmdz6)
c ###         zdtmax=SNtyp1
c ###         zdamax=SNdag1
c ###       ELSE
c ###         zdzmax=SNmdz8
c ###         zdtmax=SNtyp1
c ###         zdamax=SNdag1
c ###       END IF
C +
c ###       IF(nb_sno.le.mg_SN2)                                    THEN
c ###         zdzmax=    0.5d0 *SNmdz8
c ###         zdzmax=max(zdzmax,zdzlim)
c ###       END IF
C +
C +                  **********
              zdzmax=SRFcri_agr(jst-nb_ice,nb_sno-nb_ice)
C +                  **********
C +
              zdtmax=SNtyp1
              zdamax=2.0d00
C +....       These 3 lines short-cut the former formulation for isolSL=3
C +                             which is no more valid with use of nb_ice !!!
C +
           ELSE
C +
C +                  **********
              zdzmax=SRFcri_agr(jst       ,nb_sno)
C +                  **********
C +
              zdtmax=SNtyp1
              zdamax=2.0d00
           END IF
C +
C +--Difference de Types de Grains
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           IF (1.d2*dzSNow(i,j,jst).le.zdzmax)                      THEN
C +
C +
C +                  **********
              zsdty1=SRFdtp_sno(g1SNow(i,j,jst  ),g2SNow(i,j,jst  ),
     .                          g1SNow(i,j,jst+1),g2SNow(i,j,jst+1),
     .                          nhSNow(i,j,jst  ),nhSNow(i,j,jst+1),
     .                          roSNow(i,j,jst  ),roSNow(i,j,jst+1))
C +                  **********
C +
C +
C +                  **********
              zsdty2=SRFdtp_sno(g1SNow(i,j,jst  ),g2SNow(i,j,jst  ),
     .                          g1SNow(i,j,jst-1),g2SNow(i,j,jst-1),
     .                          nhSNow(i,j,jst  ),nhSNow(i,j,jst-1),
     .                          roSNow(i,j,jst  ),roSNow(i,j,jst-1))
C +                  **********
C +
C +--Difference d'Age
C +  ~~~~~~~~~~~~~~~~
              isdag1=agSNow(i,j,jst)  -agSNow(i,j,jst+1)
              isdag2=agSNow(i,j,jst-1)-agSNow(i,j,jst)
C +
C +--Conditions sur les Types de Grain et l'Age
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             IF     (zsdty1.lt.zdtmax.and.isdag1.lt.zdamax)         THEN
               IF   (zsdty2.lt.zdtmax.and.isdag2.lt.zdamax)         THEN
                 IF (isdag2.lt.isdag1)                              THEN
C +
C +                 ***************
                    call SRFagr_sno(jst-1,nb_sno)
C +                 ***************
C +
                    iact=iact+1
                 ELSE
C +
C +                 ***************
                    call SRFagr_sno(jst,nb_sno)
C +                 ***************
C +
                    iact=iact+1
                 END IF
               ELSE
C +
C +                 ***************
                    call SRFagr_sno(jst,nb_sno)
C +                 ***************
C +
                    iact=iact+1
               END IF
c ###        ELSEIF (zsdty2.lt.zdtmax.and.isdag2.lt.zdamax)         THEN
             ELSEIF((zsdty2.lt.zdtmax.and.isdag2.lt.zdamax) .OR.
     .              (roSNow(i,j,jst-1).eq.ro_Ice  .AND.
     .               roSNow(i,j,jst  ).eq.ro_Ice          )     )   THEN
C +...               Allows aggregation in case of small ice layers 
C +                        (important during the melting season)
C +
C +                 ***************
                    call SRFagr_sno(jst-1,nb_sno)
C +                 ***************
C +
                    iact=iact+1
             END IF
           END IF
          END DO
        END IF
C +
C +
C +--Conditions pour la Strate de Surface /surface Layer
C +  ---------------------------------------------------
C +
        IF  (nb_sno-nb_ice .gt.1)                                   THEN
          IF(isolSL(i,j)   .eq.3)                                   THEN
c ###       zdzmax=SNmdz1*0.50d00
C +
C +                **********
            zdzmax=SRFcri_agr(nb_sno-nb_ice,nb_sno-nb_ice)
C +                **********
C +
          ELSE
C +
C +                **********
            zdzmax=SRFcri_agr(nb_sno       ,nb_sno)
C +                **********
C +
          END IF
          IF  (1.d2*dzSNow(i,j,nb_sno).lt.zdzmax)                   THEN
C +
C +                **********
              call SRFagr_sno(nb_sno-1,nb_sno)
C +                **********
C +
                   iact=iact+1
          END IF
        END IF
      END IF
C +
C +
C +--Aggregation | Desagregation Neiges Ventees
C +  ------------------------------------------
C +
c #BS   IF  (nb_sno-nb_ice            .gt.1)                        THEN
c #BS     nn=nb_sno+1
 120     continue
c #BS     nn=nn    -1
 121     continue
c #BS     IF (      dzSNow(i,j,nn    ).gt.1.d1*dzSNow(i,j,nn    -1))
c #BS.    THEN
C +
C +                **********
c #BS         call SRFagr_sno(nn    -1,nb_sno)
C +                **********
C +
c #BS     nn=nn    -1
c #BS     END IF
c #BS     if (nb_sno     .le.2.or.
c #BS.        nn         .le.2)
c #BS.    go to 122
c #BS     if (      dzSNow(i,j,nn    ).gt.1.d1*dzSNow(i,j,nn    -1))
c #BS.    go to 121
c #BS     if (nb_sno     .gt.2)
c #BS.    go to 120
 122     continue
c #BS   END IF
C +
C +
C +--Dedoublement eventuel de Strates /Splitting of Layers
C +  =====================================================
C +
 200  continue
C +
      do 203 jst=nb_sno,nb_ice+1,-1
        IF(nb_sno     .ge.mg1) goto 204
        IF(isolSL(i,j).eq.3 )                                       THEN
c ###     IF(jst.eq.1) then
c ###       zdzmin= vdd1*max(SNmdz1,sno_cm        /SNmdz2)
c ###     ELSEIF (jst.lt.nb_sno    -mg_SN1+1) then
c ###       zdzmin= vdd1*   (SNmdz4-  jst         /SNmdz5)
c ###.                  *max(SNmdz1,sno_cm        /SNmdz6)
c ###     ELSEIF  (jst.lt.nb_sno   -mg_SN2+1) then
c ###       zdzmin= vdd2
c ###       relden=mg_SN2
c ###       if           (nb_sno.gt.mg_SN3-1) 
c ###.      zdzmin=zdzmin
c ###.            + vdd1*(nb_sno   -mg_SN2+1-jst) /relden
c ###.          *(SNmdz4-(nb_sno   -mg_SN3)       /SNmdz5)
c ###.                  *max(SNmdz1,sno_cm        /SNmdz6)
c ###     ELSE
c ###       zdzmin= vdd1
c ###     END IF
C +
C +                **********
            zdzmin=SRFcri_ded(jst-nb_ice,nb_sno-nb_ice)
C +                **********
C +
        ELSE
C +
C +                **********
            zdzmin=SRFcri_ded(jst       ,nb_sno)
C +                **********
C +
        END IF
C +
        IF(1.d2*dzSNow(i,j,jst).gt.zdzmin)                          THEN
          iact  =iact  +1
          nb_sno=nb_sno+1
C +
               n=nb_sno+1
            tiSNow(i,j,n)=tiSNow(i,j,n-1)
C +
          DO   n=nb_sno,jst+2,-1
            roSNow(i,j,n)=roSNow(i,j,n-1)
            waSNow(i,j,n)=waSNow(i,j,n-1)
            tiSNow(i,j,n)=tiSNow(i,j,n-1)
            dzSNow(i,j,n)=dzSNow(i,j,n-1)
            g1SNow(i,j,n)=g1SNow(i,j,n-1)
            g2SNow(i,j,n)=g2SNow(i,j,n-1)
            nhSNow(i,j,n)=nhSNow(i,j,n-1)
            agSNow(i,j,n)=agSNow(i,j,n-1)
          END DO
C +
            roSNow(i,j,jst+1)=roSNow(i,j,jst)
            tiSNow(i,j,jst+1)=tiSNow(i,j,jst)
            waSNow(i,j,jst+1)=waSNow(i,j,jst)
            dzSNow(i,j,jst)  =dzSNow(i,j,jst) * 0.5d0
            dzSNow(i,j,jst+1)=dzSNow(i,j,jst)
            g1SNow(i,j,jst+1)=g1SNow(i,j,jst)
            g2SNow(i,j,jst+1)=g2SNow(i,j,jst)
            nhSNow(i,j,jst+1)=nhSNow(i,j,jst)
            agSNow(i,j,jst+1)=agSNow(i,j,jst)
        END IF
 203  continue
 204  continue
C +
c ### if(isolSL(i,j).eq.3.and.iact.gt.0.and.iact.le.mg-3) goto 100
      if(isolSL(i,j).eq.3.and.iact.gt.3.and.iact.le.mg-3) goto 100
C +
C +
C +--Aggregation of melting Snow Layers
C +  ==================================
C +
      IF   (nb_sno.gt.nb_ice+1)                                    THEN
C +
       DO n=nb_sno-1 ,nb_ice+1, -1
          IF (dzSNow(i,j,n).lt.0.005d0)                            THEN
C +
C +                **********
              call SRFagr_sno(n,nb_sno)
C +                **********
C +
          END IF
       END DO
      END IF
C +
C +
C +--Aggregation of old     Ice  Layers
C +  ==================================
C +
      IF (nb_ice .gt. 1)                                           THEN
                                                   aggreg = .false.
        DO n=1,nb_ice
            IF (dzSNow(i,j,n).lt.0.030d0 .and..not.aggreg)         THEN
C +
C +                  **********
                call SRFagr_ice(n-1,nb_sno,nb_ice)
C +                  **********
C +
                                                 aggreg = .true.
            END IF
        END DO
C +
C +
C +--Splitting   of old     Ice  Layers
C +  ==================================
C +
            n= nb_ice
          IF ((dzSNow(i,j,n) .gt. 0.03d0) .and.
     .        (nb_ice        .lt. mg0)                            ) THEN
C +
C +              **********
            call SRFspl_ice(n,nb_ice,nb_sno)
C +              **********
C +
          END IF
C +
        DO  n= nb_ice-1,1,-1
          IF ((dzSNow(i,j,n) .gt. 2.0d0*dzSNow(i,j,n+1)).and.
     .        (nb_ice        .lt. mg0)                            ) THEN
C +
C +              **********
            call SRFspl_ice(n,nb_ice,nb_sno)
C +              **********
C +
          END IF
        END DO
C +
      END IF
C +
      return
      end
      function   SRFcri_agr(kst,knst)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                             01-12-2001 MAR |
C |   Function   SRFcri_agr computes minimal thickness before aggregation  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT  :   *kst*   -  rang de la strate a examiner.                  |
C |   ^^^^^^^^   *knst*  -  nombre de strates du manteau neigeux.          |
C |                                                                        |
C |   REFER. : (CROCUS & MAR, adapted to MAR at CEN by H.Gallee)           |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      real    SRFcri_agr
      real    vdzag1,vdzag2,vdzag3,vdzag4,vdzag5,vdzag6,vdzag7,vdzag8
      integer nvnst4,nvnst6,nvnst5,nvnst7,kst,knst
C +
C +
C +--DATA
C +  ====
C +
      data vdzag1/ 1.00e00/, vdzag2/  0.50e00/
      data vdzag3/ 0.30e00/, vdzag4/  1.50e00/
      data vdzag5/ 4.00e00/, vdzag6/  0.05e00/
      data vdzag7/ 1.20e00/, vdzag8/  0.60e00/
C +
      data nvnst4/ 3      /, nvnst5/  2      /
C +...     Limite de nombre de strates internes au manteau neigeux
C +
      data nvnst6/10      /, nvnst7/  5      /
C +
C +
C +--Snow Layers Aggregation Criterion
C +  =================================
C +
C +--Strate sur le sol.
C +  ~~~~~~~~~~~~~~~~~
      if(kst.eq.1)then
        SRFcri_agr=vdzag1
C +
C +--Strate de surface.
C +  ~~~~~~~~~~~~~~~~~
      elseif(kst.eq.knst)then
        SRFcri_agr=vdzag2
C +
C +--Strates internes si au plus nvnst4.
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      elseif(knst.le.nvnst4+2)then
        SRFcri_agr=vdzag3
C +
C +--Strates internes si plus de nvnst4.
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      else
        if(kst.eq.nvnst5)then
          SRFcri_agr=vdzag4
        elseif(kst.lt.knst-nvnst6)then
          SRFcri_agr=vdzag5-kst*vdzag6
        elseif(kst.lt.knst-nvnst7)then
          SRFcri_agr=vdzag7
        else
          SRFcri_agr=vdzag8
        endif
      endif
C +
      return
      end
      function   SRFcri_ded(kst,knst)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   Function   SRFcri_ded computes minimal thickness before aggregation  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT  :   *kst*   -  rang de la strate a examiner.                  |
C |   ^^^^^^^^   *knst*  -  nombre de strates du manteau neigeux.          |
C |                                                                        |
C |   REFER. : (CROCUS & MAR, adapted to MAR at CEN by H.Gallee)           |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      real    SRFcri_ded
      real    vdzde1,vdzde2,vdzde3,vdzde4,vdzde5
      integer nvnst8,nvnst9,kst,knst  
C +
C +--DATA
C +  ====
C +
      data vdzde1/ 4.00e00/, vdzde2/ 12.00e00/
      data vdzde3/75.00e-3/, vdzde4/  4.00e00/
      data vdzde5/ 2.00e00/
C +
      data nvnst8/ 9      /, nvnst9/  4      /
C +
C +
C +--Snow Layers Aggregation Criterion
C +  =================================
C +
C +--Strate sur le Sol /bottom Layer.
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if(kst.eq.1)then
        SRFcri_ded=vdzde1
C +
C +--Autres Strates /other Cases.
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
      elseif(kst.lt.knst-nvnst8)then
         SRFcri_ded=vdzde2-kst*vdzde3
      elseif(kst.lt.knst-nvnst9)then
         SRFcri_ded=vdzde4
      else
         SRFcri_ded=vdzde5
      endif
C +
      return
      end
      subroutine SRFagr_sno(n,nb_sno)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   SubRoutine SRFagr_sno aggregates two contiguous snow layers          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : (CROCUS & MAR, adapted to MAR at CEN by H.Gallee)           |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
C +
      real     dz,dzro1,dzro0,dzro,ro,tn,wn,ag
      real     zdiamd,zdiamv,zdiamn
      real     zspherd,zspherv,zsphern,zdendr
      integer  n,nb_sno,ident,ivieu,mm
C +--Mean   Properties
C +  =================
C +
          dz      =  dzSNow(i,j,n+1)       + dzSNow(i,j,n)
          dzro1   =  roSNow(i,j,n+1)       * dzSNow(i,j,n+1)
          dzro0   =  roSNow(i,j,n)         * dzSNow(i,j,n)
          dzro    =  dzro1                 + dzro0
          ro      =  dzro                  / dz
          tn      = (dzro1*tiSNow(i,j,n+1) + dzro0*tiSNow(i,j,n)) /dzro
          wn      = (dzro1*waSNow(i,j,n+1) + dzro0*waSNow(i,j,n)) /dzro
          ag      = (dzro1*agSNow(i,j,n+1) + dzro0*agSNow(i,j,n)) /dzro
C +
C +-- 1.4 nouveaux Types de Grains /  new Grain Types
C +
C +-- 1.4.1. Meme  Type  de Neige  / same Grain Type
C +
        if ((g1SNow(i,j,n)         *  g1SNow(i,j,n+1)  .gt.0)  .or.
     .      (g1SNow(i,j,n  ).eq.0.and.g1SNow(i,j,n+1)  .ge.0)  .or.
     .      (g1SNow(i,j,n+1).eq.0.and.g1SNow(i,j,n)    .ge.0))      then
C +
             g1SNow(i,j,n)=
     .      (g1SNow(i,j,n)  *roSNow(i,j,n)  *dzSNow(i,j,n)+
     .       g1SNow(i,j,n+1)*roSNow(i,j,n+1)*dzSNow(i,j,n+1)  )
     .     / dzro 
             g2SNow(i,j,n)=
     .      (g2SNow(i,j,n)  *roSNow(i,j,n)  *dzSNow(i,j,n)+
     .       g2SNow(i,j,n+1)*roSNow(i,j,n+1)*dzSNow(i,j,n+1)  )
     .     / dzro 
        else
C +
C +-- 1.4.2 Types differents / differents Types
C +
          if(g1SNow(i,j,n).lt.0) then
            ident=n 
            ivieu=n+1     
          else
            ident=n+1     
            ivieu=n
          endif
C +
          zdiamd =-g1SNow(i,j,ident)*DiEtSN/vg1SNo
     .        +(1.+g1SNow(i,j,ident)       /vg1SNo)
     .           *(g2SNow(i,j,ident)*DiGfSN/vg1SNo
     .        +(1.-g2SNow(i,j,ident)       /vg1SNo)*DiFcSN)
          zspherd= g2SNow(i,j,ident)       /vg1SNo
          zdiamv = g2SNow(i,j,ivieu)
          zspherv= g1SNow(i,j,ivieu)       /vg1SNo
          zdiamn =(zdiamd *roSNow(i,j,ident)*dzSNow(i,j,ident)
     .            +zdiamv *roSNow(i,j,ivieu)*dzSNow(i,j,ivieu))/dzro
          zsphern=(zspherd*roSNow(i,j,ident)*dzSNow(i,j,ident)
     .            +zspherv*roSNow(i,j,ivieu)*dzSNow(i,j,ivieu))/dzro
C +
C +     le  type (dendritique ou non) depend de la comparaison
C +     avec le  diametre d'une neige recente avec      dendricite = 0  
C +     the type (dendritic or not depends on the comparaison
C +     with the optical diameter of a recent snow with dendricity = 0
C +
          if(zdiamn.lt.zsphern*DiGfSN+(1.d0-zsphern)*DiFcSN) then
             zdendr=(zdiamn-(zsphern*DiGfSN+(1.d0-zsphern)*DiFcSN))/
     .              (DiEtSN-(zsphern*DiGfSN+(1.d0-zsphern)*DiFcSN))
             g1SNow(i,j,n)=-vg1SNo*zdendr
             g2SNow(i,j,n)= vg1SNo*zsphern
          else
             g1SNow(i,j,n)= vg1SNo*zsphern
             g2SNow(i,j,n)= zdiamn
          endif
        endif
C +
C +
C +--Assignation to new Properties
C +  =============================
C +
          dzSNow(i,j,n) = dz
          roSNow(i,j,n) = ro
          tiSNow(i,j,n) = tn
          waSNow(i,j,n) = wn
          agSNow(i,j,n) = ag
C +
          if (nhSNow(i,j,n+1).ne.nhSNow(i,j,n)) 
     .                           nhSNow(i,j,n) = 0
C +
C +
C +--Rearrangment
C +  ============
C +
         if (n+1.le.nb_sno-1) then
          do mm=n+1,nb_sno-1
          dzSNow(i,j,mm)  = dzSNow(i,j,mm+1)
          roSNow(i,j,mm)  = roSNow(i,j,mm+1)
          tiSNow(i,j,mm)  = tiSNow(i,j,mm+1)
          waSNow(i,j,mm)  = waSNow(i,j,mm+1)
C +
          agSNow(i,j,mm)  = agSNow(i,j,mm+1)
          g1SNow(i,j,mm)  = g1SNow(i,j,mm+1)
          g2SNow(i,j,mm)  = g2SNow(i,j,mm+1)
          nhSNow(i,j,mm)  = nhSNow(i,j,mm+1)
          end do
         end if
C +
          dzSNow(i,j,nb_sno)   = 0.d0
          roSNow(i,j,nb_sno)   = 0.d0
          tiSNow(i,j,nb_sno)   = tiSNow(i,j,nb_sno+1)
          tiSNow(i,j,nb_sno+1) = 0.d0
          waSNow(i,j,nb_sno)   = 0.d0
C +
          agSNow(i,j,nb_sno)   = 0.d0
          g1SNow(i,j,nb_sno)   = 0.d0
          g2SNow(i,j,nb_sno)   = 0.d0
          nhSNow(i,j,nb_sno)   = 0
C +
          nb_sno = nb_sno-1
C +
      return
      end
      subroutine SRFagr_sic(n,nb_sno,nb_ice)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                             01-12-2001 MAR |
C |   SubRoutine SRFagr_sic aggregates the last snow layer                 |
C |                                 to the first ice layer                 |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
C +
      real    dz,dzro1,dzro0,dzro,ro,tn,wn,ag
      integer n,nb_sno,nb_ice
C +
C +--Mean   Properties
C +  =================
C +
          dz      =  dzSNow(i,j,n+1)       + dzSNow(i,j,n)
          dzro1   =  roSNow(i,j,n+1)       * dzSNow(i,j,n+1)
          dzro0   =  roSNow(i,j,n)         * dzSNow(i,j,n)     
          dzro    =  dzro1                 + dzro0
          ro      =  dzro                  / dz
          tn      = (dzro1*tiSNow(i,j,n+1) + dzro0*tiSNow(i,j,n)) /dzro
          wn      = (dzro1*waSNow(i,j,n+1) + dzro0*waSNow(i,j,n)) /dzro
          ag      = (dzro1*agSNow(i,j,n+1) + dzro0*agSNow(i,j,n)) /dzro
C +
C +
C +--Assignation to new Properties
C +  =============================
C +
          dzSNow(i,j,n) = dz
          roSNow(i,j,n) = ro
          tiSNow(i,j,n) = tn
          waSNow(i,j,n) = wn
          agSNow(i,j,n) = ag
C +
          if (nhSNow(i,j,n+1).ne.nhSNow(i,j,n))
     .                           nhSNow(i,j,n) = 0
C +
C +
C +
          dzSNow(i,j,nb_sno) = 0.d0
          roSNow(i,j,nb_sno) = 0.d0
          tiSNow(i,j,nb_sno) = 0.d0
          waSNow(i,j,nb_sno) = 0.d0
C +
          agSNow(i,j,nb_sno) = 0.d0
          g1SNow(i,j,nb_sno) = 0.d0
          g2SNow(i,j,nb_sno) = 0.d0
          nhSNow(i,j,nb_sno) = 0
C +
          nb_sno = nb_sno-1
C +
      return
      end
      subroutine SRFagr_ice(n,nb_sno,nb_ice)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                             01-12-2001 MAR |
C |   SubRoutine SRFagr_ice aggregates two contiguous ice  layers          |
C |   It aggregates the layer n with the layer n+1			   |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE 
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
C +
      real    dz,dzro1,dzro0,dzro,ro,tn,wn,ag
      integer n,nb_sno,nb_ice,mm
C +
C +--Mean   Properties
C +  =================
C +
          dz      =  dzSNow(i,j,n+1)       + dzSNow(i,j,n)
          dzro1   =  roSNow(i,j,n+1)       * dzSNow(i,j,n+1)
          dzro0   =  roSNow(i,j,n)         * dzSNow(i,j,n)
          dzro    =  dzro1                 + dzro0
          ro      =  dzro                  / dz
          tn      = (dzro1*tiSNow(i,j,n+1) + dzro0*tiSNow(i,j,n)) /dzro
          wn      = (dzro1*waSNow(i,j,n+1) + dzro0*waSNow(i,j,n)) /dzro
          ag      = (dzro1*agSNow(i,j,n+1) + dzro0*agSNow(i,j,n)) /dzro
C +
C +
C +--Assignation to new Properties
C +  =============================
C +
          dzSNow(i,j,n) = dz
          roSNow(i,j,n) = ro
          tiSNow(i,j,n) = tn
          waSNow(i,j,n) = wn
          agSNow(i,j,n) = ag
C +
          if (nhSNow(i,j,n+1).ne.nhSNow(i,j,n))
     .                           nhSNow(i,j,n) = 0
C +
C +
C +--Rearrangment
C +  ============
C +
         IF (n+1.le.nb_sno-1)                                       THEN
           DO mm=n+1,nb_sno-1
             dzSNow(i,j,mm)  = dzSNow(i,j,mm+1)
             roSNow(i,j,mm)  = roSNow(i,j,mm+1)
             tiSNow(i,j,mm)  = tiSNow(i,j,mm+1)
             waSNow(i,j,mm)  = waSNow(i,j,mm+1)
C +
             agSNow(i,j,mm)  = agSNow(i,j,mm+1)
             g1SNow(i,j,mm)  = g1SNow(i,j,mm+1)
             g2SNow(i,j,mm)  = g2SNow(i,j,mm+1)
             nhSNow(i,j,mm)  = nhSNow(i,j,mm+1)
           END DO
         END IF
C +
             dzSNow(i,j,nb_sno) = 0.d0
             roSNow(i,j,nb_sno) = 0.d0
             tiSNow(i,j,nb_sno) = 0.d0
             waSNow(i,j,nb_sno) = 0.d0
C +
             agSNow(i,j,nb_sno) = 0.d0
             g1SNow(i,j,nb_sno) = 0.d0
             g2SNow(i,j,nb_sno) = 0.d0
             nhSNow(i,j,nb_sno) = 0
C +
             nb_sno = nb_sno-1
             nb_ice = nb_ice-1 
C +
      return
      end
      subroutine SRFspl_ice(jst, nb_ice,nb_sno)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   SubRoutine SRFspl_ice splits ice layer(s)                            |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
C +
      integer jst, nb_ice,nb_sno,n
C +
C +--Dedoublement eventuel de Strates /Splitting of Layers
C +  =====================================================
C +
          nb_sno=nb_sno+1
          nb_ice=nb_ice+1
          DO n=nb_sno,jst+2,-1
            roSNow(i,j,n)=roSNow(i,j,n-1)
            waSNow(i,j,n)=waSNow(i,j,n-1)
            tiSNow(i,j,n)=tiSNow(i,j,n-1)
            dzSNow(i,j,n)=dzSNow(i,j,n-1)
            g1SNow(i,j,n)=g1SNow(i,j,n-1)
            g2SNow(i,j,n)=g2SNow(i,j,n-1)
            nhSNow(i,j,n)=nhSNow(i,j,n-1)
            agSNow(i,j,n)=agSNow(i,j,n-1)
          END DO
C +
            roSNow(i,j,jst+1)=roSNow(i,j,jst)
            tiSNow(i,j,jst+1)=tiSNow(i,j,jst)
            waSNow(i,j,jst+1)=waSNow(i,j,jst)
            dzSNow(i,j,jst)  =dzSNow(i,j,jst) * 0.5d0
            dzSNow(i,j,jst+1)=dzSNow(i,j,jst)
            g1SNow(i,j,jst+1)=g1SNow(i,j,jst)
            g2SNow(i,j,jst+1)=g2SNow(i,j,jst)
            nhSNow(i,j,jst+1)=nhSNow(i,j,jst)
            agSNow(i,j,jst+1)=agSNow(i,j,jst)
C +
      return
      end
      subroutine SRFmtm_sno(slope,nb_sno,nb_ice)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   SubRoutine SRFmtm_sno simulates SNOW Metamorphism                    |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Brun et al.      1989, J. Glaciol 35 pp. 333--342           |
C |   ^^^^^^^^ Brun et al.      1992, J. Glaciol 38 pp.  13-- 22           |
C |            (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |                                                                        |
C |   Formalisme adopte pour la Representation des Grains:                 |
C |   Formalism         for the Representation of  Grains:                 |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                 |
C |                                                                        |
C |                                                                        |
C |             1       - -1                 Neige Fraiche                 |
C |            / \      |                    -------------                 |
C |           /   \     |  Dendricite        decrite  par Dendricite       |
C |          /     \    |  Dendricity                  et Sphericite       |
C |         /       \   |                                                  |
C |        2---------3  -  0                 described by Dendricity       |
C |                                                   and Sphericity       |
C |        |---------|                                                     |
C |        0         1                                                     |
C |        Sphericite                                                      |
C |        Sphericity                                                      |
C |                                                                        |
C |        4---------5  -                                                  |
C |        |         |  |                                                  |
C |        |         |  |  Diametre (1/10eme de mm) (ou Taille)            |
C |        |         |  |  Diameter (1/10eme de mm) (or Size  )            |
C |        |         |  |                                                  |
C |        |         |  |                    Neige non dendritique         |
C |        6---------7  -                    ---------------------         |
C |                                          decrite  par Sphericite       |
C |                                                    et     Taille       |
C |                                          described by Sphericity       |
C |                                                   and       Size       |
C |                                                                        |
C |   Les Variables du Modele:                                             |
C |   Model         Variables:                                             |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^                                             |
C |     Cas Dendritique               Cas non Dendritique                  |
C |                                                                        |
C |     dtSNh         : Time Step                                          |
C |     g1SNo(n)      : Dendricite    g1SNo(n)      : Sphericite           |
C |     g2SNo(n)      : Sphericite    g2SNo(n)      : Taille (1/10e mm)    |
C |                                                   Size                 |
C |                                                                        |
C |                                                                        |
C |   Cas Dendritique/ Dendritic Case                                      |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                                      |
C |   Dendricite(Dendricity) g1SNow                                        |
C |            varie     de -vg1SNo (-99 par defaut / etoile)          a 0 |
C |            division par -vg1SNo pour obtenir des valeurs entre 1  et 0 |
C |            varies  from -vg1SNo (default -99    / fresh snow)     to 0 |
C |            division  by -vg1SNo to obtain values       between 1 and 0 |
C |                                                                        |
C |   Sphericite(Sphericity) g2SNow                                        |
C |            varie     de  0         (cas completement anguleux)         |
C |                       a  vg1SNo (99 par defaut, cas spherique)         |
C |            division par  vg1SNo pour obtenir des valeurs entre 0  et 1 |
C |            varies  from  0      (full faceted)               to vg1SNo |
C |                                                                        |
C |                                                                        |
C |   Cas non Dendritique / non Dendritic Case                             |
C |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                             |
C |   Sphericite(Sphericity) g1SNow                                        |
C |            varie     de  0         (cas completement anguleux)         |
C |                       a  vg1SNo (99 par defaut, cas spherique)         |
C |            division par  vg1SNo pour obtenir des valeurs entre 0  et 1 |
C |            varies  from  0      (full faceted)               to vg1SNo |
C |                                                                        |
C |   Taille    (Size)       g2SNow                                        |
C |            superieure a  vdiam1 (.4 mm) et ne fait que croitre         |
C |            greater than  vdiam1 (.4 mm) always increase                |
C |                                                                        |
C |                                                                        |
C |   Exemples: Points caracteristiques des Figures ci-dessus              |
C |   ^^^^^^^^^                                                            |
C |                                                                        |
C |               g1SNow    g2SNow     dendricite  sphericite  taille      |
C |                                    dendricity  sphericity  size        |
C |   ------------------------------------------------------------------   |
C |                                                            [1/10 mm]   |
C |     1        -vg1SNo    sph3SN          1           0.5                |
C |     2           0         0             0           0                  |
C |     3           0       vg1SNo          0           1                  |
C |     4           0       vdiam1                      0       4.         |
C |     5         vg1SNo    vdiam1-vsphe1               1       3.         |
C |     6           0         --                        0       --         |
C |     7         vg1SNo      --                        1       --         |
C |                                                                        |
C |   par defaut: vg1SNo=99.                                               |
C |                         sph3SN=50.                                     |
C |                         vdiam1= 4.                                     |
C |                                vsphe1=1.                               |
C |                                                                        |
C |                                                                        |
C |   Methode:                                                             |
C |   ^^^^^^^^                                                             |
C |   1. Evolution Types de Grains selon Lois de Brun et al. (1992):       |
C |      Grain metamorphism according to         Brun et al. (1992):       |
C |      Plusieurs Cas sont a distiguer  /  the different Cases are:       |
C |       1.1 Metamorphose Neige humide  /  wet Snow                       |
C |       1.2 Metamorphose Neige seche   /  dry Snow                       |
C |         1.2.1 Gradient faible        /  low      Temperature Gradient  |
C |         1.2.2 Gradient moyen         /  moderate Temperature Gradient  |
C |         1.2.3 Gradient fort          /  high     Temperature Gradient  |
C |      Dans chaque Cas on separe Neige Dendritique et non Dendritique    |
C |                           le Passage Dendritique -> non Dendritique    |
C |                           se fait lorsque  g1SNow devient > 0          |
C |      the Case of Dentritic or non Dendritic Snow is treated separately |
C |      the Limit   Dentritic -> non Dendritic is reached when g1SNow > 0 |
C |                                                                        |
C |   2. Tassement: Loi de Viscosite adaptee selon le Type de Grains       |
C |      Snow Settling:    Viscosity depends on the   Grain Type           |
C |                                                                        |
C |   3. Update Variables historiques (cas non dendritique seulement)      |
C |      nhSNow defaut                                                     |
C |               0     Cas normal                                         |
C |      nhsno1   1     Grains anguleux / faceted cristal                  |
C |      nhsno2   2     Grains ayant ete en presence d eau liquide         |
C |                     mais n'ayant pas eu de caractere anguleux    /     |
C |                     liquid water and no faceted cristals before        |
C |      nhsno3   3     Grains ayant ete en presence d eau liquide         |
C |                     ayant eu auparavant un caractere anguleux    /     |
C |                     liquid water and    faceted cristals before        |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
C +
C +
C +--Local   Variables
C +  =================
C +
      real    rdsno(mg),wgsno(mg)
      real    vdiam1,vdiam2,vdiam3,vdiam4,vsphe1,vsphe2,vsphe3,vsphe4
      real    vgran6,vtelv1,vdent1,slope ,vvap1 ,vvap2 
      real    husi_0,husi_1,husi_2
      real    husi_3,vtail1,vtail2,vgrat1,vgrat2,vfi
      real    vvisc1,vvisc2,vvisc3,vvisc4,vvisc5,vvisc6,vvisc7,vdz3
      real    zfracj,zgradt,ztelm ,ztelm1,zvdent,zdendr,zspher,zvap  
      real    zdiam 
      real    SRFang_sno   ,zzzdz ,zssmas,zsmas ,zsvisc
      real    dzsnew,rosnew,rosmax
C +
      integer nvdent1,nvdent2,nb_sno,nb_ice,jst
C +
C +
C +--DATA
C +  ====
C +
      data vdiam1/ 4.0e0/
C +...     vdiam1: Diametre (1/10mm) Minimum des Grains fins
C +
      data vdiam2/ 0.5e0/
C +...     vdiam2: Diametre     (mm) superieur pour Variation Sphericite
C +
      data vdiam3/ 3.0e0/
C +...     vdiam3: Diametre     (mm) caracter. pour Variation Sphericite
C +
      data vdiam4/ 2.0e0/
C +...     vdiam4: Diametre     (mm)           pour chgt Viscosite si TEL   
C +
      data vsphe1/ 1.0e0/
C +...     vsphe1: Sphericite        Maximum
C +
      data vsphe2/ 1.0e9/
C +...     vsphe2: Coeff pour Metamorphose
C +
      data vsphe3/ 0.5e0/
C +...     vsphe3: Sphericite limite pour gros Grains avec Cas historique=1
C +
      data vsphe4/ 0.1e0/
C +...     vsphe4: Seuils (/ 0/99)    pour mettre a Jour        Historique 
C +
      data vgran6/ 51.e0/
C +...     vgran6: Sphericite Maximum pour Augmentation Tassement
C +
      data vtelv1/ 5.e-1/
C +...     vtelv1: Seuil      Minimum pour mettre a Jour        Historique 
C +                                     et Densification  
C +
      data nvdent1/ 3   /
      data  vdent1/ 2.e8/
      data nvdent2/16   /
C +...     Coefficients Metamorphose Neige humide (pour la dendricite)
C +
      data   vvap1/-6.0e3/
C +...     Coefficient            pour Calcul Tension de Vapeur
C +
      data   vvap2/ 0.4e0/
C +...     Coefficient  Puissance pour Calcul Tension de Vapeur
C +
      data  husi_0/ 2.00000e1/
C +...      husi_0=   10  * 2
C +
      data  husi_1/ 0.23873e0/
C +...      husi_1= (3/4) /pi
C +
      data  husi_2/ 4.18880e0/
C +...      husi_2= pi *(4/3)
C +
      data  husi_3/ 0.33333e0/
C +...      husi_3= 1     / 3
C +
      data vtail1 /1.28e-08/
      data vtail2 /4.22e-10/
C +...     Cstes de metamorphose neige humide / non dendritique et spherique
C +
      data  vgrat1/0.05e+00/
C +...      vgrat1: Limite faible Gradient / moyen  Gradient
C +
      data  vgrat2/0.15e+00/
C +...      vgrat2: Limite moyen  Gradient / fort   Gradient
C +
      data  vfi   /0.09e+00/
C +...      vfi   : Fonction PHI             fort   Gradient
C +
      data  vvisc1/ 0.70e0 /
      data  vvisc2/ 1.11e5 /
      data  vvisc3/23.00e0 /
      data  vvisc4/ 0.10e0 /
C +...      vvisc1,2,3,4: Coeff       Viscosite
C +
      data  vvisc5/ 1.00e0 /
      data  vvisc6/ 2.00e0 /
      data  vvisc7/10.00e0 /
C +...      vvisc5,6,7:   Coeff modif Viscosite si Neige humide
C +
      data  vdz3  / 0.30e0 / 
C +...      vdz3:    Densification maximum des Couches
C +
C +
C +-- 1. Metamorphoses dans les Strates
C +      Metamorphism
C +      ==============================
C +
      zfracj=dtSNh/86400.d0      
C +...zfracj:Time Step (Units: Day Fraction)
C +
 100  continue
C +
C +
C +-- 1.1 Initialisation: teneur en eau liquide et gradient de temperature 
C +   ------------------  liquid water content and temperature gradient
C +
      do 134 jst=nb_ice+1,nb_sno
      rdsno(jst)=1.d-3                *roSNo(jst)     
     .                          *(1.d0-waSNo(jst)     )
C +...rdsno: Dry Density          (g         /cm3)
C +
      wgsno(jst)=1.d-1*dzSNo(jst)     *roSNo(jst)     
     .                          *      waSNo(jst)     
C +...wgsno: Liquid Water Content (g / layer /cm2)
C +
 134  continue
C +
      do 135 jst=nb_ice+1,nb_sno
C +
 110    continue
        if     (jst.gt.1.and.jst.eq.nb_sno) then
          zgradt=abs(    tiSNo     (nb_sno)-tiSNo     (nb_sno-1)
     .                  +tiSNo     (nb_sno)-tiSNo     (nb_sno-1)) *1.d-2
     .              /   (dzSNo     (nb_sno)+dzSNo     (nb_sno-1))
        elseif (jst.eq.1)      then
          zgradt=abs(    tiSNo     (2)     -tiSNo     (1)
     .                  +tiSNo     (2)     -tiSNo     (1))        *1.d-2
     .              /   (dzSNo     (1)     +dzSNo     (2))
        else
          zgradt=abs(    tiSNo     (jst+1) -tiSNo     (jst-1) 
     .                  +tiSNo     (jst+1) -tiSNo     (jst-1))    *1.d-2
     .              /   (dzSNo     (jst-1) +dzSNo     (jst+1)
     .                  +dzSNo     (jst)   +dzSNo     (jst)  )
        endif
C +...  Optimisation: Addition preferable to Multiplication
C +     Factor 1.d-2 for Conversion K/m --> K/cm
C +
C +
C +-- 1.2 Metamorphose humide 
C +       Wet Snow Metamorphism
C +       ---------------------
C +
        if (waSNo     (jst).gt.epsi) then
C +
 120      continue
C +
C +--     Vitesse de diminution de la dendricite
C +       Rate of the dendricity decrease
C +       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ztelm =1.d-1*roSNo     (jst)*waSNo     (jst)/rdsno(jst)
C +...    ztelm :Water Content [%]  
C +              1.d-1= 1.d2(1->%) * 1.d-3(roSNow*waSNow:kg/m3->g/cm3) 
C +
          ztelm1=    ztelm**nvdent1
          zvdent=max(ztelm1/nvdent2,vdent1*exp(vvap1/TfSnow))
C +
C +-- 1.2.1 Cas dendritique/dendritic Case
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(g1SNo     (jst).lt.-epsi)then
C +
121         continue
            zdendr=-g1SNo     (jst)/vg1SNo
            zspher= g2SNo     (jst)/vg1SNo
C +...      Variables descriptives de la dendricite et la sphericite.
C +
C +...      Calcul nouvelle dendricite et sphericite.
            zdendr= zdendr-zvdent*zfracj
            zspher= zspher+zvdent*zfracj
C +
C +...      Evolution de g1SNow et g2SNow et 
C +         Test Passage Dendritique -> non Dendritique.
            if(zdendr.le.epsi)then
              g1SNo     (jst)=min(vg1SNo,zspher*vg1SNo)
              g2SNo     (jst)=vdiam1-min(zspher,vsphe1)
            else
              g1SNo     (jst)=          -zdendr*vg1SNo
              g2SNo     (jst)=min(vg1SNo,zspher*vg1SNo)
            endif
C +
C +-- 1.2.2 Cas non dendritique non completement spherique
C +         Evolution de la Sphericite seulement.
C +         Non dendritic and not completely spheric Case
C +         Evolution of    Sphericity only (not size)
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          elseif(g1SNo     (jst).lt.vg1SNo-epsi)then
C +
 122        continue
            zspher=g1SNo     (jst)/vg1SNo
            zspher=                    zspher+zvdent*zfracj
                   g1SNo     (jst)=min(vg1SNo,zspher*vg1SNo)
C +
C +-- 1.2.3 Cas non dendritique et spherique / non dendritic and spheric
C +         Evolution de la Taille seulement / Evolution of Size only
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
C +
 123        continue
            g2SNo     (jst)=husi_0
     .      *(husi_1 *(husi_2 *(g2SNo     (jst)/husi_0)**3
     .                        +(vtail1+vtail2*ztelm1)*dtSNh ))**(husi_3)
          endif
        else
C +
C +
C +-- 1.3 Metamorposes seches / Dry Metamorphism
C +       --------------------------------------
C +
 130      continue
C +
C +-- 1.3.1 Calcul Metamorphose faible/low Gradient (0.00-0.05 deg/cm)
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          if(zgradt.lt.vgrat1)then
C +
 131        continue
            zvap=exp(vvap1/tiSNo     (jst))
C +
C +-- 1.3.1.1 Cas dendritique / dendritic Case
C +
            if(g1SNo     (jst).lt.-epsi)then
              zdendr=-g1SNo     (jst)/vg1SNo
              zspher= g2SNo     (jst)/vg1SNo
              zdendr= zdendr-vdent1*zvap*zfracj
              zspher= zspher+vsphe2*zvap*zfracj
C +
C +...        Evolution de g1SNow et g2SNow et 
C +           Test passage dendritique -> non dendritique
              if(zdendr.lt.epsi)then
                g1SNo     (jst)=min(vg1SNo,zspher*vg1SNo)
                g2SNo     (jst)=vdiam1-min(vsphe1,zspher)
              else
                g1SNo     (jst)=          -zdendr*vg1SNo
                g2SNo     (jst)=min(vg1SNo,zspher*vg1SNo)
              endif
            else
C +
C +-- 1.3.1.2 Cas non dendritique / non dendritic Case
C +
                zspher=g1SNo     (jst)/vg1SNo
                zdiam =g2SNo     (jst)*0.1d00
C +
              if(nhSNo     (jst).ne.nhSNo1.or.zdiam.lt.vdiam2)then
                zspher=zspher+vsphe2*zvap*zfracj
              else
C +
C +             Cas  historique=2 ou 3 et gros grains sphericite limitee
C +             Case history   =2 or 3 and big grains limited sphericity 
C +
                zspher=zspher+vsphe2*zvap*zfracj
     .                          *exp(min(zero,vdiam3-g2SNo     (jst)))
                zspher=   min(vsphe3,zspher)
              endif
C +
              g1SNo     (jst)=min(vg1SNo,zspher*vg1SNo)
C +
            endif
C +
C +-- 1.3.2 Calcul Metamorphose Gradient Moyen/Moderate (0.05-0.15)
C +         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          elseif (zgradt.lt.vgrat2) then
C +
 132        continue
            zvap=vdent1*exp(vvap1/tiSNo     (jst))*(zgradt*1.d2)**vvap2
C +
C +-- 1.3.2.1 cas dendritique / dendritic case.
C +
            if (g1SNo     (jst).lt.-epsi)then
C +
              zdendr=-g1SNo     (jst)/vg1SNo
              zspher= g2SNo     (jst)/vg1SNo
              zdendr= zdendr-zvap*zfracj
              zspher= zspher-zvap*zfracj
C +
C +           Evolution de g1SNow et g2SNow et 
C +           Test passage dendritique -> non dendritique.
              if(zdendr.lt.epsi) then
                g1SNo     (jst)=max(zero,zspher*vg1SNo)
                g2SNo     (jst)=vdiam1-max(zspher,zero)
              else
                g1SNo     (jst)=        -zdendr*vg1SNo
                g2SNo     (jst)=max(zero,zspher*vg1SNo)
              endif
C +
C +-- 1.3.2.2 Cas non dendritique / non dendritic Case
C +
            else
                zspher=g1SNo     (jst) / vg1SNo
                zspher=                  zspher-zvap*zfracj
                g1SNo     (jst)=max(zero,zspher*vg1SNo)
            endif
C +
C +-- 1.3.3 Calcul Metamorphose fort / high Gradient
C +   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          else
 133        continue
            zvap=vdent1*exp(vvap1/tiSNo     (jst))*(zgradt*1.d2)**vvap2
C +
C +-- 1.3.3.1 Cas dendritique / dendritic Case
C +
            if(g1SNo     (jst).lt.-epsi)then
              zdendr=-g1SNo     (jst)/vg1SNo
              zspher= g2SNo     (jst)/vg1SNo
              zdendr= zdendr-zvap*zfracj
C +
C +           Cas non dendritique et anguleux.
              zspher= zspher-zvap*zfracj
C +
C +           Evolution de g1SNow et g2SNow et 
C +           Test passage dendritique -> non dendritique.
              if(zdendr.lt.epsi)then
                g1SNo     (jst)=max(zero,zspher*vg1SNo)
                g2SNo     (jst)=vdiam1-max(zspher,zero)
              else
                g1SNo     (jst)=        -zdendr*vg1SNo
                g2SNo     (jst)=max(zero,zspher*vg1SNo)
              endif
C +
C +-- 1.3.3.2 Cas non dendritique non completement anguleux.
C +           non dendritic and spericity gt. 0
C +
            elseif(g1SNo     (jst).gt.epsi)then
                zspher=g1SNo     (jst) / vg1SNo
                zspher=                  zspher-zvap*zfracj
                g1SNo     (jst)=max(zero,zspher*vg1SNo)
            else
C +
C +-- 1.3.3.3 Cas non dendritique et anguleux
C +           dendritic and spericity = 0.
C +
                g2SNo     (jst)=g2SNo     (jst)
C +
C +                    **********
     .           +1.d2*SRFang_sno(tiSNo     (jst),rdsno(jst),zgradt)
C +                    **********
C +
     .                *vfi*zfracj
            endif
          endif
        endif
 135  continue
C +
C +
C +-- 2. Mise a Jour Variables Historiques (Cas non dendritique)
C +      Update of the historical Variables
C +      =======================================================
C +
 200  continue
C +
      do 201 jst=nb_ice+1,nb_sno
        if  (g1SNo     (jst).ge.0.)then
          if(g1SNo     (jst).lt.vsphe4.and.nhSNo     (jst).eq.0) then
                                           nhSNo     (jst)=nhSNo1
          elseif(vg1SNo-g1SNo     (jst).lt.vsphe4.and.
     .       wgsno(jst)/dzSNo     (jst).gt.vtelv1)               then
            if(nhSNo     (jst).eq.0)       nhSNo     (jst)=nhSNo2
            if(nhSNo     (jst).eq.nhSNo1)  nhSNo     (jst)=nhSNo3
          elseif(tiSNo     (jst).lt.TfSnow)                      then
            if(nhSNo     (jst).eq.nhSNo2)  nhSNo     (jst)=nhSNo4
            if(nhSNo     (jst).eq.nhSNo3)  nhSNo     (jst)=nhSNo5
          endif
        endif
 201  continue
C +
C +
C +-- 3. Tassement mecanique /mechanical Settlement
C +      ==========================================
C +
 300  continue
C +
        zzzdz =1.d2*dzSNo     (nb_sno)
        zssmas=0.d0
      do 301 jst=nb_sno,nb_ice+1,-1
        zsmas =1.d2*dzSNo     (jst)                   *rdsno(jst)
        zssmas=zssmas+0.5d0*zsmas
        zsvisc=vvisc1*vvisc2
     .        *exp(vvisc3                             *rdsno(jst)
     .            +vvisc4*abs(TfSnow-tiSNo     (jst)))*rdsno(jst)/rh11SN
C +
C +-- Changement de Viscosite si Teneur en Eau liquide
C +   Change of the Viscosity if liquid Water Content
C +   ------------------------------------------------
C +
        if(wgsno(jst).gt.epsi)
     .    zsvisc=zsvisc/(vvisc5+vvisc6*wgsno(jst)/dzSNo     (jst))
        if(g1SNo     (jst).lt.vgran6           .and.
     .                nhSNo     (jst).eq.nhSNo1)
     .    zsvisc=zsvisc*exp(min(vdiam1,g2SNo     (jst)-vdiam4))
        if(wgsno(jst)/dzSNo     (jst).le.vtelv1.and.
     .                nhSNo     (jst).ge.nhSNo2)
     .    zsvisc=zsvisc*vvisc7
C +
C +
C +-- Calcul nouvelle Epaisseur / new Thickness
C +   -----------------------------------------
C +
           dzsnew         =
     .     dzSNo     (jst) 
     .    *max(vdz3,
     .         (unun-dtSNh*max(zssmas*slope      ,unun)/zsvisc))
           rosnew         = roSNo     (jst) *dzSNo     (jst) /dzsnew
           rosmax         = 1.d0  / ( (1.d0 -waSNo     (jst))/ro_Ice
     .                                +      waSNo     (jst) /ro_Wat)
           rosnew         =                        min(rosnew,rosmax)
           dzSNo     (jst)= roSNo     (jst) *dzSNo     (jst) /rosnew
           roSNo     (jst)= rosnew
           rdsno(jst)     = roSNo     (jst)*(1.d0-waSNo     (jst))*1.d-3
C +...     rdsno: Dry Density (g/cm3)
C +
        zssmas=zssmas+zsmas*.5
301   continue
C +
C +
C +-- Mechanical Settling (Gallee and Duynkerke, 1997, JGR_G, 
C +   -------------------               over time step dtSNo)
C +
C +     stress       = 0.0d0
C +    do n=nb_sno,1,-1
C +     eta          = taSNo/(1.d0-tfSNo)
C +         *exp(teSNo *  roSNo     (n) /ro_Wat
C +             +epSN1 * (TfSnow-tiSNo     (n)))
C +     stress       = 0.5d0*(roSNo     (n)  *dzSNo     (n)
C +                          +roSNo     (n+1)*dzSNo     (n+1))+stress
C +     dzsnew       = dzSNo     (n)         *exp(-stress*dtSNo/eta)
C +     rosnew       = roSNo     (n)*dzSNo     (n)/dzsnew
C +     rosmax       = 1.d0 /( (1.d0-waSNo     (n))/ro_Ice
C +                            +     waSNo     (n) /ro_Wat)
C +     rosnew       = min(rosnew,rosmax)
C +     dzSNo     (n)= roSNo     (n)*dzSNo     (n)/rosnew
C +     roSNo     (n)= rosnew
C +    end do
C +
      return
      end
      function SRFang_sno(pst,psro,pgradt)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   Function SRFang_sno simulates                                        |
C |            growth rates for non dendritic grains with sphericity=0     |
C |            la croissance des grains non dendritiques et anguleux       |
C +------------------------------------------------------------------------+
C |   REFER. : Marbouty, D.     1980, J. Glaciol 26 pp. xxx--xxx           |
C |   ^^^^^^^^ (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |                                                                        |
C |    INPUT : pst    temperature     de                la strate de neige |
C |    ^^^^^^^ psro   masse volumique de                la strate de neige |
C |            pgradt gradient de temperature affectant la strate de neige |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--General Variables
C +  =================
C +
      include 'MARphy.inc'
C +
      real     SRFang_sno
      real     pst   ,psro  ,pgradt
      real     vtang1,vtang2,vtang3,vtang4,vtang5,vtang6,vtang7
      real     vtang8,vtang9,vtanga,vtangb,vtangc,vrang1,vrang2
      real     vgang1,vgang2,vgang3,vgang4,vgang5,vgang6,vgang7
      real     vgang8,vgang9,vganga,vgangb,vgangc
C +
C +
C +--DATA (Coefficient Fonction fort Gradient Marbouty)
C +  ==================================================
C +
      data  vtang1 /40.0e0/
      data  vtang2 / 6.0e0/
      data  vtang3 /22.0e0/
      data  vtang4 / 0.7e0/
      data  vtang5 / 0.3e0/
      data  vtang6 / 6.0e0/
      data  vtang7 / 1.0e0/
      data  vtang8 / 0.8e0/
      data  vtang9 /16.0e0/
      data  vtanga / 0.2e0/
      data  vtangb / 0.2e0/
      data  vtangc /18.0e0/
C +
      data  vrang1 / 0.40e0/
      data  vrang2 / 0.15e0/
C +
      data  vgang1 / 0.70e0/
      data  vgang2 / 0.25e0/
      data  vgang3 / 0.40e0/
      data  vgang4 / 0.50e0/
      data  vgang5 / 0.10e0/
      data  vgang6 / 0.15e0/
      data  vgang7 / 0.10e0/
      data  vgang8 / 0.55e0/
      data  vgang9 / 0.65e0/
      data  vganga / 0.20e0/
      data  vgangb / 0.85e0/
      data  vgangc / 0.15e0/
C +
C +
C +-- Influence de la Temperature /Temperature Influence
C +   ==================================================
C +
      if      (pst.ge.TfSnow-vtang1)                                then
        if    (pst.ge.TfSnow-vtang2)                                then
          SRFang_sno =vtang4+vtang5*(TfSnow       -pst)/vtang6
        elseif(pst.ge.TfSnow-vtang3)                                then
          SRFang_sno =vtang7-vtang8*(TfSnow-vtang2-pst)/vtang9
        else
          SRFang_sno =vtanga-vtangb*(TfSnow-vtang3-pst)/vtangc
        endif
C +
C +
C +-- Influence de la Masse Volumique /Density Influence
C +   ==================================================
C +
        if  (psro.le.vrang1)                                        then
          if(psro.gt.vrang2)
     .      SRFang_sno = SRFang_sno*(1.d0-(psro-vrang2)/(vrang1-vrang2))
C +
C +
C +-- Influence du Gradient de Temperature /Temperature Gradient Influence
C +   ====================================================================
C +
          if      (pgradt.le.vgang1)                                then
            if    (pgradt.le.vgang2)                                then
             SRFang_sno = SRFang_sno*vgang5*(pgradt-vgang6)
     .                                     /(vgang2-vgang6)
            elseif(pgradt.le.vgang3)                                then
             SRFang_sno = SRFang_sno*vgang7
     .                              +vgang8*(pgradt-vgang2)
     .                                     /(vgang3-vgang2)
            elseif(pgradt.le.vgang4)                                then
             SRFang_sno = SRFang_sno*vgang9
     .                              +vganga*(pgradt-vgang3)
     .                                     /(vgang4-vgang3)
            else
             SRFang_sno = SRFang_sno*vgangb
     .                              +vgangc*(pgradt-vgang4)
     .                                     /(vgang1-vgang4)
            endif
          endif
        else
             SRFang_sno = 0.d0
        endif
      else
             SRFang_sno = 0.d0
      endif
      return
      end
      function SRFdia_sno(pgran1,pgran2)
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   Function SRFdia_sno computes the optical Grain Size                  |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   METHOD: cette fonction rend le diametre optique des grains           |
C |   ^^^^^^^ dont le type est decrit par les deux variables descriptives  |
C |                continues sur la plage -99/+99 passees en appel.        |
C |           la taille optique (1/10mm) des etoiles,                      |
C |                                          grains fins et                |
C |                                          jeunes faces planes           |
C |           sert de base de calcul                                       |
C |                                                                        |
C |           this function gives the optical diameter of the grains       |
C |                         described with the CROCUS formalism            |
C |                         pgran1 / pgran2                                |
C |                                                                        |
C |   REFER. : Brun et al.      1992, J. Glaciol 38 pp.  13-- 22           |
C |   ^^^^^^^^ Eric Martin Sept.1996                                       |
C |            (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |                                                                        |
C |    INPUT : pgran1  Dendricity (<0)  or Sphericity (>0) of Snow layer   |
C |    ^^^^^^^ pgran2  Sphericity (>0)  os Size            of Snow layer   |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +-- General Variables
C +   =================
C +
      include 'MARdim.inc'
C +
      include 'MARphy.inc'
      include 'MAR_SV.inc'
      include 'MAR_SN.inc'
C +
      real     SRFdia_sno
      real     pgran1,pgran2
C +
C +
C +-- Anderson Formulation
C +   ====================
C +
C +    dsno     = 1.6d-4
C +  .          + 1.1d-13 *(roSNow(i,j,mg1)*roSNow(i,j,mg1)
C +  .                     *roSNow(i,j,mg1)*roSNow(i,j,mg1))
C +... dsno     : Grain Size (Loth et al. 1993 JGR 98 D6 p.10454)
C +                     from  Anderson    1976
C +
C +
C +-- Neige     dendritique
C +   =====================
C +
      if (pgran1.lt.-epsi)then
C +
         SRFdia_sno=-pgran1*DiEtSN/vg1SNo
     .        +(1.d0+pgran1       /vg1SNo)*
     .              (pgran2*DiGfSN/vg1SNo
     .        +(1.d0-pgran2       /vg1SNo)*DiFcSN)
C +
C +
C +-- Neige non dendritique
C +   =====================
C +
      else
C +
         SRFdia_sno= pgran2*pgran1/vg1SNo
     .          +max(DiFcSN,pgran2*demi)
     .        *(1.d0-pgran1       /vg1SNo)
C +
      endif
C +
C +
C +-- Unite S.I.
C +   ==========
C +
      SRFdia_sno=1.e-4 * SRFdia_sno
C +
      return
      end
      subroutine SRFalb_sno(alb_sno,alb1,alb2,alb3,
     .           dopsno,dsqr,rosnow,wasnow,agsnow,
     .           DirSola,DifSola,Cloudsa)     
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |   subroutine SRFalb_sno computes the spectral Snow Albedo              |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Brun et al.      1989, J. Glaciol 35 pp. 333--342           |
C |   ^^^^^^^^ Brun et al.      1992, J. Glaciol 38 pp.  13-- 22           |
C |            (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |   OPTION : #AG: Snow Aging Col de Porte                                |
C |   ^^^^^^^^ #WR: Ecriture   Composantes Albedo                          |
C |            #CP: Treatment of Direct and Diffuse Solar Radiation        |
C |                 (for Col de Porte Data)                                |
C |            #GL: Validation on ETH Camp                                 |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +-- General Variables
C +   =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
c #WR include 'MAR_GE.inc'
C +
c #WR integer               italoc
c #WR common/SRFalb_sno_loc/italoc
C +
      real    alb_sno,alb1 ,alb2  ,alb3  ,dopsno,dsqr  ,rosnow
      real    wasnow,agsnow,DirSola,DifSola,Cloudsa
      real    agsno ,alb1mn,doptmx,age   ,dopt
      real    s1SNva,s2SNva,s3SNva
c #CP real    s1SN1a,s1SN2a,s2SN1a,s2SN2a,s3SN1a,s3SN2a 
c #CP real    TotSola
C +
C +-- DATA
C +   ====
C +
      data    agsno  /60.0e0/
C +...        agsno:  Snow Age Maximum                                [day]
C +
      data    alb1mn /0.94e0/
C +...        alb1mn: albedo           minimum ds visible  (0.3--0.8micr.m)
C +
      data    doptmx /2.3e-3/
C +...        doptmx: diametre optique maximum pour pi * R**2 (m)
C +
C +CP data    s1SNva/0.590e00/,s2SNva/0.310e00/,s3SNva/0.100e00/
c #CP data    s1SN1a/0.950e00/,s2SN1a/0.050e00/,s3SN1a/0.000e00/
c #CP data    s1SN2a/0.660e00/,s2SN2a/0.270e00/,s3SN2a/0.070e00/
C +...        0.3--0.8micr.m  0.8--1.5micr.m  1.5--2.8micr.m
C +           Fractions of total solar irradiance in 3 spectral intervals
C +***        (see Eric Martin Sept. 1996, CROCUS, Subroutine METEO)
C +
      data    s1SNva/0.606e00/,s2SNva/0.301e00/,s3SNva/0.093e00/
C +...        0.3--0.8micr.m  0.8--1.5micr.m  1.5--2.8micr.m
C +           Fractions of total solar irradiance in 3 spectral intervals
C +***        (see Feagle and Businger 1981, Int.Geoph.Ser. 25, p.215-222)
C +
C +--Ice    Albedo
C +  =============
C +
      if (rosnow*(1.d0-wasnow).ge.850.d0) then
C +...    Density Ice Threshold:  850.d0 [kg/m3]
C +***    (see Eric Martin Sept. 1996, CROCUS, Subroutine PROPHY)
C +
       alb1        =   0.45d0
       alb2        =   0.30d0
       alb3        =   0.10d0   
C +
      else
       age         =                     min(agsnow,agsno)
       alb1        = 0.96d0       -1.580d0*dsqr
       alb1        = max(alb1,alb1mn)
c #AG.                              -0.175d0*age   /agsno
C +...                                    Aging Col de Porte (Impurities)
C +
       alb1        = max(alb1,zero)
       alb1        = min(alb1,unun)
C +
       alb2        = 0.95d0       -15.40d0*dsqr
       alb2        = max(alb2,zero)
       alb2        = min(alb2,unun)
C +
       dopt        = min(dopsno,doptmx)
       alb3        = 346.3d0*dopt -32.31d0*dsqr +0.88d0
       alb3        = max(alb3,zero)
       alb3        = min(alb3,unun)
      end if
C +
c #CP     TotSola = DirSola + DifSola
c #CP if (TotSola.gt.0.d0) then
c #CP  alb_sno  =((s1SNva*alb1+s2SNva*alb2+s3SNva*alb3) * DirSola
c #CP.           +(s1SN1a*alb1+s2SN1a*alb2+s3SN1a*alb3) * DifSola 
c #CP.           *(1.d0-Cloudsa)
c #CP.           +(s1SN2a*alb1+s2SN2a*alb2+s3SN2a*alb3) * DifSola 
c #CP.           * Cloudsa )
c #CP.           / TotSola
c #CP else
          alb_sno  =  s1SNva*alb1+s2SNva*alb2+s3SNva*alb3
c #CP end if
C +
C +...    alb_sno  :  Integrated background snow albedo,
C +                   adapted from Brun et al. 1991, J Glaciology
C +
c #WR if (mod(italoc,600).eq.0) write(6,6000)
 6000 format(8x,
     .       'dopsno    dsqr     age    alb1    alb2    alb3 alb_sno')
c #WR if (mod(italoc, 30).eq.0) write(6,6001)jdarGE,jhurGE,
c #WR.                                       1.d+4*dopsno,dsqr,agsnow,
c #WR.                                       alb1,alb2,alb3,alb_sno
 6001 format(2i3,f8.2,f8.4,f8.2,4f8.3)
c #WR italoc = italoc+1
C +
      return
      end
      subroutine SRFext_sno(ext_sno,ext1,ext2,ext3,
     .              dopsno,dsqr,rosnow,wasnow,
     .                    DirSole,DifSole,Cloudse)
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            01-12-2001  MAR |
C |  subroutine SRFext_sno computes the spectral Extinction Coeff. in Snow |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Brun et al.      1989, J. Glaciol 35 pp. 333--342           |
C |   ^^^^^^^^ Brun et al.      1992, J. Glaciol 38 pp.  13-- 22           |
C |            (CROCUS Model, adapted to MAR at CEN by H.Gallee)           |
C |                                                                        |
C |   OPTION : #WR: Ecriture   Composantes Extinction                      |
C |   ^^^^^^^^ #CP: Treatment of Direct and Diffuse Solar Radiation        |
C |                 (for Col de Porte Data)                                |                    
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +-- General Variables
C +   =================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
c #WR include 'MAR_GE.inc'
C +
c #WR integer               iteloc
c #WR common/SRFext_sno_loc/iteloc
C +
      real    ext_sno,ext1 ,ext2  ,ext3  ,dopsno,dsqr  ,rosnow
      real    wasnow,agsnow,DirSole ,DifSole,Cloudse
      real    s1SNve,s2SNve,s3SNve
      real    sbeta1,sbeta2,sbeta3,sbeta4,sbeta5,rdsno
c #CP real    s1SN1e,s1SN2e,s2SN1e,s2SN2e,s3SN1e,s3SN2e 
c #CP real    corr_1,corr_2,corr_3,  TotSole
C +
C +-- DATA
C +   ====
C +
c _CP data    s1SNve/0.590e00/,s2SNve/0.310e00/,s3SNve/0.100e00/
c #CP data    s1SN1e/0.950e00/,s2SN1e/0.050e00/,s3SN1e/0.000e00/
c #CP data    s1SN2e/0.660e00/,s2SN2e/0.270e00/,s3SN2e/0.070e00/
C +...        0.3--0.8micr.m  0.8--1.5micr.m  1.5--2.8micr.m
C +           Fractions of total solar irradiance in 3 spectral intervals
C +***        (see Eric Martin Sept. 1996, CROCUS, Subroutine METEO)
C +
      data    s1SNve/0.606e00/,s2SNve/0.301e00/,s3SNve/0.093e00/
C +...        0.3--0.8micr.m  0.8--1.5micr.m  1.5--2.8micr.m
C +           Fractions of total solar irradiance in 3 spectral intervals
C +***        (see Feagle and Businger 1981, Int.Geoph.Ser. 25, p.215-222)
C +
      data    sbeta1/0.0192e0/,sbeta2/0.4000e0/
      data    sbeta3/0.1098e0/,sbeta4/1.0000e0/,sbeta5/2.0000e1/
C +
C +--Ice    Albedo
C +  =============
C +
      if (rosnow*(1.d0-wasnow).ge.850.d0) then
C +...    Density Ice Threshold:  850.d0 [kg/m3]
C +***    (see Eric Martin Sept. 1996, CROCUS, Subroutine PROPHY)
C + 
       ext1   =     sbeta5
       ext2   =     sbeta5
       ext3   =     sbeta5
C +    
      else
       rdsno  = 1.d-3 *rosnow*(1.d0-wasnow)
       ext1   = 100d0*max(sbeta1*rdsno/dsqr,sbeta2) ! CROCUS param.
       ext2   = 100d0*max(sbeta3*rdsno/dsqr,sbeta4) ! (Brun et al, 1992)
C +    ext2   = 100d0*sbeta5    
       ext3   = 100d0*sbeta5
      end if
C +      
c #CP     TotSole   = DirSole + DifSole
c #CP if (TotSole.gt.0.d0) then
c #CP corr_1 =(S1SNve * DirSole +s1SN1e* DifSole *(1.d0-Cloudse)
c #CP.       + S1SN2e * DifSole * Cloudse)/(TotSole*s1SNve)
c #CP corr_2 =(S2SNve * DirSole +s2SN1e* DifSole *(1.d0-Cloudse)
c #CP.       + s2SN2e * DifSole * Cloudse)/(TotSole*s2SNve)
c #CP corr_3 =(S3SNve * DirSole +s3SN1e* DifSole *(1.d0-Cloudse)
c #CP.       + s3SN2e * DifSole * Cloudse)/(TotSole*s3SNve)
c #CP ext1   = ext1  * corr_1
c #CP ext2   = ext2  * corr_2
c #CP ext3   = ext3  * corr_3
c #CP end if
          ext_sno  =  s1SNve*ext1+s2SNve*ext2+s3SNve*ext3
C +
c #WR if (mod(iteloc,600).eq.0) write(6,6000)
 6000 format(8x,
     .       '                          ext1    ext2    ext3 ext_sno')
c #WR if (mod(iteloc, 30).eq.0) write(6,6001)jdarGE,jhurGE,
c #WR.                                       ext1,ext2,ext3,ext_sno
 6001 format(2i3, 8x , 8x , 8x ,4f8.3)
c #WR iteloc = iteloc+1
C +
      return
      end
      subroutine SRFfrm_soil
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            16-09-2001  MAR |
C |   SubRoutine SRFfrm_soil computes the surface energy balance over SOIL |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REFER. : Deardorff,       1978, JGR    83, pp.1889--1903             |
C |   ^^^^^^^^ Thom and Oliver, 1977, QJRMS 103, pp. 345-- 357             |
C |                                                                        |
C |   ASSUMPT. SRFfrm_soil is active every dtPhys and                      |
C |   ^^^^^^^^             gives a surface temperature increment over dt   |
C |                              for  next dtPhys period                   |
C |                                                                        |
C |   INPUT  : sol_SL(mx,my)  : Absorbed Solar Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ RAd_ir(mx,my)  : Downward    IR Flux (+ <=> Downward)(W/m2) |
C |            albeSL(mx,my)  : Surface Albedo                             |
C |            eps0SL(mx,my)  : Surface IR Emissivity                      |
C |            tsrfSL(mx,my,1): Surface   Temperature                  (K) |
C |            t2_SL (mx,my)  : Deep      Temperature                  (K) |
C |            d1_SL (mx,my)  : rhos * cs *(depth diurnal wave)   (J/m2/K) |
C |             ex.: SNOW: 330kg/m3 *2000J/kg/K *sqrt(0.27e-6m2/s *86400s) |
C |                                                                        |
C |   OUTPUT : firdSL(mx,my)  : Atmospheric IR Flux (+ <=> Downward)(W/m2) |
C |   ^^^^^^^^ firmSL(mx,my)  : Surface     IR Flux (+ <=>   Upward)(W/m2) |
C |            hsenSL(mx,my)  : Sensible  Heat Flux (+ <=> Downward)(W/m2) |
C |            hlatSL(mx,my)  : Latent    Heat Flux (+ <=> Downward)(W/m2) |
C |         => SLuqsl(i,j,1)  : Water Vapor Flux from Surface  (kg.m/kg/s) |
C |            hbalSL(mx,my)  : Sum Atmospher. Flux (+ <=>Surf.Loss)(W/m2) |
C |         =>  dtgSL(mx,my,1): Soil Surface Temperature Change over dt(K) |
C |         =>  t2_SL(mx,my)  : Deep         Temperature               (K) |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_RA.inc'
C +
      include 'MAR_SL.inc'
C +
      include 'MAR_IO.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      real     xf(2),yf(2)
C +
      real     radnet,pr10m ,rho10m,qst   ,qsa   ,relhum,pr    ,rhos  
      real     egdd  ,gamp  ,aqsat ,dqsat ,qs10  ,dnum  ,egpm  ,eg
      real     den   ,alpha ,fup0  ,fup1  ,fup2  ,tpx   ,zeta
c #WG real     wgwk  ,wgwx  ,cqq
C +
      real     apha  ,beta
      logical  qpm
C +
C +
C +--DATA
C +  ====
C +
      data     apha/.5e0/,beta/.5e0/
      data     qpm /.true./
C +
C +
C +--Water and Snow Accumulation
C +  ===========================
C +
      hwatSL(i,j) = hwatSL(i,j) + precSL(i,j)
      precSL(i,j) = zero
      hsnoSL(i,j) = hsnoSL(i,j) + snobSL(i,j) + snohSL(i,j)
      snobSL(i,j) = zero
      snohSL(i,j) = zero
C +
C +
C +--Surface Heat Fluxes
C +  ===================
C +
C +--Total Radiative Downward Heat Flux
C +  ----------------------------------
      RAdsol(i,j) = sol_SL(i,j)/(1.d0-albeSL(i,j))
      firdSL(i,j) = RAd_ir(i,j)*      eps0SL(i,j)
      radnet      = sol_SL(i,j)     + firdSL(i,j) 
     .            - eps0SL(i,j)*stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .                                *tsrfSL(i,j,1)*tsrfSL(i,j,1)
C +
C +
C +--Sensible Heat Flux
C +  ------------------
C +
      pr10m      = (pstDY(i,j)*sigma(mz)+ptopDY)*10.d0
C +...pr10m      : pressure      at first Sigma Level (hPa)
C +
      rho10m     = rolvDY(i,j,mz)*1000.d0
C +...rho10m     : specific mass at first Sigma Level (kg/m3)
C +
      hsenSL(i,j)=-rho10m*cp*SLutsl(i,j,1)
C +
C +
C +--Evaporation
C +  -----------
C +
      qst    = qvswDY(i,j,mzz)
C +...qst : saturation specific humidity, surface (kg/kg)
C +
      qsa    = qvswDY(i,j,mz)
      relhum = qvDY(i,j,mz) / qsa
C +
      pr     = (pstDY(i,j) +ptopDY)     * 1.d1
      rhos   =  pr/(RDryAi*TairSL(i,j)) * 1.d2
C +
C +--Water Vapor Flux at Soil-Atmosphere Interface (Deardorff, 1978)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #WG if (qsolSL)                                                 THEN
c #WG   wgwk =wg_SL(i,j)/wk_SL(i,j)
c #WG   alpha=min(unun,wgwk)
c #WG ELSE
        alpha=      1.d0
C +...  Particular Case: Bulk Aerodynamic Formula
C +
c #WG END IF
C +
      egdd= rho10m*cdhSL(i,j,1)*SLuusl(i,j,1) *alpha*(qst-qvDY(i,j,mz))
c _UQ egdd= rho10m*ch0SL(i,j  )* ssvSL(i,j,mz)*alpha*(qst-qvDY(i,j,mz))
C +...    : When   u q *  is computed using a precribed drag             
C +
C +--Water Vapor Flux at Soil-Atmosphere Interface (Thom & Oliver, 1977)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      gamp = 4.08d-04*(1.d0+rsurSL(i,j)/raerSL(i,j))
C +...rsurSL : `bulk' stomatal resistance (Thom & Oliver, 1977, p. 347)
C +...raerSL : aerodynamic resistance (computed in routine TURsbl)
C +
      aqsat= 1.d0/(237.3d0+tairDY(i,j,mz))
      dqsat= qst*4098.d0*aqsat*aqsat
      den  = dqsat+gamp
      qs10 = qvswDY(i,j,mz)
C +...qs10 : saturation specific humidity, 1st Sigma Level (kg/kg) 
C +
      dnum = (radnet*.9d0)*dqsat 
     .     + rhos*cp*(qs10-qvDY(i,j,mz))/raerSL(i,j)
      egpm =    alpha *dnum /den /Lv_H2O
C +...CAUTION : alpha included 
C +
      if (qpm) then
       eg = egpm
      else
       eg = egdd
      end if
C +
C +--Latent Heat Flux
C +  ~~~~~~~~~~~~~~~~
      SLuqsl(i,j,1) = - eg / rhos
      hlatSL(i,j)   =   eg * Lv_H2O
      roseSL(i,j)   =     roseSL(i,j) - eg * dtPhys / ro_Wat
      roseSL(i,j)   = max(roseSL(i,j),zero)
C +
C +
C +--Soil Humidity Model (Deardorff, 1978)
C +  =====================================
C +
c #WG IF (qsolSL)                                                 THEN
C +
c #WG   hwatSL(i,j) = hwatSL(i,j) * 1000.d0
C +...  Conversion [m] => [kg/m2]
C +
c #WG   w2_SL(i,j)=w2_SL(i,j)-(dtPhys*eg-hwatSL(i,j))/500.d0
C +...  w2_SL     : Vertical Averaged Value of Soil Moisture
C +
c #WG   w2_SL(i,j)=max(w2_SL(i,j),zero   )
c #WG   w2_SL(i,j)=min(w2_SL(i,j),wx_SL(i,j))
C +
c #WG   wgwx   =    wg_SL(i,j)/wx_SL(i,j)
c #WG   if(wgwx.ge.0.75d0)     cqq= 0.5d0
c #WG   if(wgwx.lt.0.75d0.and. 
c #WG.     wgwx.gt.0.15d0)     cqq=14.0d0-22.5d0*(wgwx-0.15d0)
c #WG   if(wgwx.le.0.15d0)     cqq=14.0d0
C +
c #WG   wg_SL(i,j)=wg_SL(i,j)-cqq*(dtPhys*eg-hwatSL(i,j)) /100.d0
c #WG.                      -0.9d0*dtPhys*(wg_SL(i,j)-w2_SL(i,j))/cs2SL
C +...  wg_SL     : Ground Surface Value of Soil Moisture
C +
c #WG   wg_SL(i,j)=max(wg_SL(i,j),zero      )
c #WG   wg_SL(i,j)=min(wg_SL(i,j),wx_SL(i,j))
C +
c #WG   hwatSL(i,j) = zero
C +
c #WG ELSE
c #WG    wg_SL(i,j) = wk_SL(i,j)
c #WG    w2_SL(i,j) = wx_SL(i,j)
c #WG END IF
C +
C +
C +--Soil Energy Balance Model (Deardorff(1978, JGR, p.1891)
C +  ========================= (Implicit Numerical Scheme) -
C +                           ============================= 
C +
      fup0= eps0SL(i,j)*stefan*tsrfSL(i,j,1)*tsrfSL(i,j,1)*tsrfSL(i,j,1)
      fup1=-3.d0*fup0                                     *tsrfSL(i,j,1)
      fup2= 4.d0*fup0                                    
C +...fup1+fup2*tsrfSL(t+dt) : 1st order Taylor Serie Expansion 
C +   of upward IR Flux (stefan * tsrfSL**4)
C +
      xf(1) = -3.72d0*(fup1 +hsenSL(i,j) +hlatSL(i,j) 
     .                      -sol_SL(i,j) -firdSL(i,j)) /d1_SL(i,j)
      yf(1) = -7.4d0 *(     - t2_SL(i,j)             ) /cs2SL
      xf(2) = -3.72d0*(fup2                          ) /d1_SL(i,j)
      yf(2) = -7.4d0                                   /cs2SL
      tpx   = (tsrfSL(i,j,1)*(1.d0+beta*(xf(2)+yf(2))*dtPhys)
     .                                 +(xf(1)+yf(1))*dtPhys)
     .      /                (1.d0-apha*(xf(2)+yf(2))*dtPhys)
C +
      firmSL(i,j)  = fup1 + (apha*tpx+beta*tsrfSL(i,j,1)) *fup2
      hbalSL(i,j)  = firmSL(i,j) + hsenSL(i,j) + hlatSL(i,j) 
     .             - sol_SL(i,j) - firdSL(i,j)
C +
       dtgSL(i,j,1)=(tpx - tsrfSL(i,j,1)) *dt /dtPhys
C +
C +
C +--Soil Deep Layer Temperature
C +  ---------------------------
C +
      t2_SL(i,j)=(t2_SL(i,j) *(1.d0+beta* xf(2)*0.0141*dtPhys)
     .                                  + xf(1)*0.0141*dtPhys)
     .          /             (1.d0-apha* xf(2)*0.0141*dtPhys)
C +***Deardorff 1978, (9) p.1891,    with 0.0141 = 1 / (3.72 * sqrt(365))
C +
C +
C +--`Surface' Specific Humidity
C +  ---------------------------
C +
       qvapSL(i,j) = min(qvapSL(i,j),qst)
C +
C +
C +--Output on Listing if IO_loc .ge. 3
C +  ==================================
C +
      if ((((IO_loc.ge.3.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.4.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.5)                            )       ).or.
     .       IO_loc.ge.7                                          ) then
C +
C +    ***********
       call TIMcor
C +    ***********
C +
       zeta = (gplvDY(i,j,mz)-gplvDY(i,j,mzz)) / (gravit*SLlmol(i,j,1))
C +
       write(4,980)jdplus,mmplus,jhlrGE(i,j),minuGE,i,j
 980   format(/,' Soil Model ',i2,'/',i2,1x,i2,'h',i2,'LT',
     .                           ' --    Grid Point (',i5,',',i5,')',
     .  /,' =======================================================')
C +
       write(4,988) t2_SL(i,j),tsrfSL(i,j,1),1.d2*albeSL(i,j),d1_SL(i,j)
c #WG  write(4,989) w2_SL(i,j), wg_SL(i,j),alpha
       write(4,984) RAdsol(i,j),sol_SL(i,j),firmSL(i,j),firdSL(i,j)
       write(4,982) uairDY(i,j,mz),vairDY(i,j,mz),ssvSL(i,j,mz),zeta
       write(4,985) 1.d3*SL_z0(i,j,1),1.d3*SL_r0(i,j,1)
       write(4,983)      cdhSL(i,j,1),
     .                  SLuusl(i,j,1),SLutsl(i,j,1),1.d3*SLuqsl(i,j,1)
       write(4,987) 1.d2*relhum,qvapSL(i,j),  hsenSL(i,j),hlatSL(i,j)
       write(4,991) hbalSL(i,j), dtgSL(i,j,1),roseSL(i,j),egdd
       write(4,992)                         precSL(i,j),egpm
 988   format(' T2 (Deep)=', f8.2,4x,'   Tg(Soil)=',f7.2,2x,
     .        '   Albedo =',f7.2,2x,'   r.c.d1 =  ',e14.4)
 989   format(' w2 (Deep)=', f8.2,4x,'   wg(Soil)=',f7.2,2x,
     .        '   Alpha  =',f7.2,2x)
 984   format(' RS (Dwn.)=', f8.2,4x,'   RS(Abs.)=',f7.2,2x,
     .        '   IR (Up)=',f7.2,2x,'   IR(Dwn)=',f8.2,2x)
 982   format(' u (S.Lay)=', f8.2,4x,'   v(S.Lay)=',f7.2,2x,
     .        '   | V |  =',f7.2,2x,'   zeta   =',f12.6)
 985   format(' SOIL     :',12x,     '   z0      =',f9.4,
     .        '   r0     =',f9.4,23x,'(X 1000)')
 983   format(' Comp.DRAG=',f12.6,   '    u *    =',f9.4,   
     .        '   u th * =',f9.4,   '   u q *  =',f12.6,'(X 1000)')
 987   format(' Rela.Hum.=', f8.2,4x,'   q(Surf.)=',f9.4,   
     .        '   H0     =',f7.2,2x,'   HL     =', f8.2)
 991   format(' Energ.B. =', f8.2,4x,'   d (Tg)  =',f9.4,   
     .        '   Dew    =',f9.4,   '   eg(D.) =',f12.6)
 992   format('           ',  8x ,4x,'   Precip. =',f8.3,  
     .        ' cmWE',16x,           '   eg(P.) =',f12.6)
C +
      end if
C +
      return
      end
c #SV block data SvaDAT
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            16-09-2001  MAR |
C |   Block Data SvaDAT     defines physical constants of SvaMAR           |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
c #SV implicit   none
C +
C +
C +--Global Variables
C +  ================
C +
c #SV INCLUDE   'MARdim.inc'
c #SV INCLUDE   'MAR_SV.inc'
c #SV INCLUDE   'MAR_TV.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
c #V1 integer    nv
c #V1 PARAMETER (nv=12)
c #V2 integer    nv
c #V2 PARAMETER (nv=18)
ci
ci*************************************************************************
ci*************************************************************************
ci******************* 1.INITIALIZATION ************************************
ci*************************************************************************
ci*************************************************************************
ci**                                                                     **
ci**  The initialization section consists of:                            **
ci**  (-) DATA statements                        (block data SvaDAT)     **
ci**  (-) An initialization part                                         **
ci**      that is set up during the first time 'svat.f' is executed.     **
ci**                                                                     **
ci**  Note that all the comment flags in the initialization section      **
ci**            are labeled 'ci', so you won't be lost easily.           **
ci**                                                                     **
ci*************************************************************************
ci*************************************************************************
ci
ci-------------------------------------------------------------------------
ci--- 1.0 MODEL CONTROL PARAMETERS (see block data SvaDAT) ----------------
ci-------------------------------------------------------------------------
ci
c #SV LOGICAL         svinit,etagNR,TsogNR
c #SV common/SvaMAR_L/svinit,etagNR,TsogNR
C +
c #SV DATA    etagNR/.true./
C +...        etagNR: Newton-Raphson Algorithm Switch on wtbalg
C +   WARNING etagNR=.false. ==> transient unstability
C +
c #SV DATA    TsogNR/.true./
C +...        TsogNR: Newton-Raphson Algorithm Switch on htbalg
C +   REMARK  TsogNR=.false. ==>             stability
C +
c #SV DATA    svinit/.true./
ci
ci-------------------------------------------------------------------------
ci--- 1.1 MODEL NUMERIC PARAMETERS (see block data SvaDAT) ----------------
ci-------------------------------------------------------------------------
ci
c #SV CHARACTER*14 FilNam
c #SV CHARACTER* 3 FilLab
c #SV common/SvaMAR_C/FilNam,FilLab
C +
c #SV DATA FilLab/'sv_'/
C +
C +
c #SV integer         itsvat,jNRmax,nunit
c #SV common/SvaMAR_I/itsvat,jNRmax,nunit(iptx,nvx)
C +
c #SV DATA itsvat/1/                  ! initial value internal counter
c #SV DATA jNRmax/20/                 ! max number Newton steps
C +
C +
c #SV real            depth
c #SV real            tvmin,tvmax,pvmin,pvmax,tgmin,tgmax,pgmin,pgmax
c #SV real            r_two,r_thr,r_ten
c #SV real            StefBo,Cp_Air,Vap_LH,RhoWat,RhoWCW,htcapv,StoRCr
c #SV real            rstmax,psicri,EpsVeg,EpsGro,EpsWat,conmin
c #SV common/SvaMAR_R/depth(4)
c #SV.               ,tvmin,tvmax,pvmin,pvmax,tgmin,tgmax,pgmin,pgmax
c #SV.               ,r_two,r_thr,r_ten
c #SV.               ,StefBo,Cp_Air,Vap_LH,RhoWat,RhoWCW,htcapv,StoRCr
c #SV.               ,rstmax,psicri,EpsVeg,EpsGro,EpsWat,conmin
C +
c #SV DATA depth/0.02,0.06,0.20,0.72/ ! soil layer depths
c #SV DATA tvmin,tvmax/1.0e+2,5.0e+2/ ! min max allowed Tv
c #SV DATA pvmin,pvmax/0.0e+0,1.0e+3/ ! min max allowed psivTV
c #SV DATA tgmin,tgmax/1.0e+2,5.0e+2/ ! min max allowed Tg
c #SV DATA pgmin,pgmax/9.0e-2,2.0e+5/ ! min max allowed psigTV
C +
c #SV DATA r_two/2.0e0/               ! for argument of intrinsic Functions
c #SV DATA r_thr/3.0e0/               ! for argument of intrinsic Functions
c #SV DATA r_ten/1.0e1/               ! for argument of intrinsic Functions
ci
ci-------------------------------------------------------------------------
ci--- 1.2 PHYSICAL CONSTANTS ----- (see block data SvaDAT) ----------------
ci-------------------------------------------------------------------------
ci
c #SV DATA StefBo/5.670e-8/ ! Stefan-Boltzmann Constant
c #SV DATA Cp_Air/1.005e+3/ ! Specific Heat of Air at constant Pressure
c #SV DATA Vap_LH/2.500e+6/ ! Latent   Heat of Condensation of Water
c #SV DATA RhoWat/1.000e+3/ ! Density                       of Water
c #SV DATA RhoWCW/4.180e+6/ ! Density * Specific Heat       of Water
c #SV DATA htcapv/2.000e+3/ ! Heat Capacity of Vegetation
c #SV DATA StoRCr/2.500e+1/ ! Critical Radiation Stomatal Resistance
c #SV DATA rstmax/5.000e+3/ ! Maximum            Stomatal Resistance
c #SV DATA psicri/0.250e+3/ ! Critical Leaf Water Potential
c #SV DATA EpsVeg/0.980e00/ ! Emissivity of Vegetation
c #SV DATA EpsGro/0.940e00/ ! Emissivity of Ground
c #SV DATA EpsWat/0.990e00/ ! Emissivity of Water
c #SV DATA conmin/0.172e00/ ! Minimum Soil Thermal Conductivity
ci
ci-------------------------------------------------------------------------
ci--- 1.3 SOIL HYDRAULIC PARAMETERS (USDA classification) -----------------
ci-------------------------------------------------------------------------
ci    etasat  .................... Water Content at Saturation (-)
ci    psisat  ............... Soil Water Suction at Saturation (-)
ci    aksat   ........... Hydraulic conductivity at Saturation (m/s)
ci    bclap   ........... Coefficient Clapp-Hornberger
ci-------------------------------------------------------------------------
ci
c #SV real            etasat    ,psisat    , aksat    ,bclap
c #SV real             csat1    , csat2    ,rhocsl
c #SV real            etgMin    ,etgMax    
c #SV common/SvaMAR_S/etasat(11),psisat(11), aksat(11),bclap(11),
c #SV.                 csat1(11), csat2(11),rhocsl(11),
c #SV.                etgMin(11),etgMax(11)
C +...Soil Parameters (depend on soil type)
C +
c #SV DATA
c #SV.(etasat(itx),psisat(itx),aksat(itx),bclap(itx),itx=1,11)
ci
ci     etasat .... psisat .... aksat .... bclap
ci
c #SV. /0.395,      0.121,  176.0e-6,      4.05, ! 1 SAND
c #SV.  0.410,      0.090,  156.3e-6,      4.38, ! 2 LOAMY      SAND
c #SV.  0.435,      0.218,   34.1e-6,      4.90, ! 3 SANDY      LOAM
c #SV.  0.485,      0.786,    7.2e-6,      5.30, ! 4 SILT       LOAM
c #SV.  0.451,      0.478,    7.0e-6,      5.39, ! 5            LOAM
c #SV.  0.420,      0.299,    6.3e-6,      7.12, ! 6 SANDY CLAY LOAM
c #SV.  0.477,      0.356,    1.7e-6,      7.75, ! 7 SILTY CLAY LOAM
c #SV.  0.476,      0.630,    2.5e-6,      8.52, ! 8       CLAY LOAM
c #SV.  0.426,      0.153,    2.2e-6,     10.40, ! 9 SANDY CLAY
c #SV.  0.492,      0.490,    1.0e-6,     10.40, !10 SILTY CLAY
c #SV.  0.482,      0.405,    1.3e-6,     11.40/ !11       CLAY
ci
ci-------------------------------------------------------------------------
ci--- 1.4 VEGETATION PARAMETERS (Structural/Transpiration) ----------------
ci-------------------------------------------------------------------------
ci    DisplH              Displacement      Height        (m)
ci    Z0mVeg              Roughness         Length        (m)
ci    StoRMn              Minimum  Stomatal Resistance    (s/m)
ci    RFr01m              Fraction of Roots in upper 0.1m (-)
ci    PlantR              Internal Plant    Resistance    (s)
ci-------------------------------------------------------------------------
ci
ci     Basic IGBP Classification
ci     =========================
ci
c #SV real            DisplH    ,Z0mVeg
c #SV real            StoRMn    ,RFr01m    ,PlantR
c #SV real            rhof      ,tauf      
c #SV common/SvaMAR_V/DisplH(nv),Z0mVeg(nv),
c #SV.                StoRMn(nv),RFr01m(nv),PlantR(nv),
c #SV.                rhof(nv,4),tauf(nv,4)
C +...Vegetation Parameters (depend on vegetation type)
C +
c #V1 DATA
c #V1.(DisplH(ivg),
c #V1.         Z0mVeg(ivg),
c #V1.                 StoRMn(ivg),
c #V1.                         RFr01m(ivg),
c #V1.                                 PlantR(ivg),ivg=1,nv)
ci
ci     DisplH  Z0mVeg  StoRMn  RFr01m  PlantR
ci     ------  ------  ------  ------  ------
c #V1. /0.07,   0.01,  0.5e2,  0.3e0,  0.5e+9,    ! 1 CROPS      LOW
c #V1.  0.21,   0.03,  0.5e2,  0.3e0,  0.5e+9,    ! 2 CROPS      MEDIUM
c #V1.  0.70,   0.10,  0.5e2,  0.3e0,  0.5e+9,    ! 3 CROPS      HIGH
c #V1.  0.07,   0.01,  0.5e2,  0.7e0,  0.5e+9,    ! 4 GRASS      LOW
c #V1.  0.21,   0.03,  0.5e2,  0.7e0,  0.5e+9,    ! 5 GRASS      MEDIUM
c #V1.  0.70,   0.10,  0.5e2,  0.7e0,  0.5e+9,    ! 6 GRASS      HIGH
c #V1.  1.40,   0.20,  1.0e2,  0.5e0,  1.0e+9,    ! 7 BROADLEAF  LOW
c #V1.  5.60,   0.80,  1.0e2,  0.5e0,  1.0e+9,    ! 8 BROADLEAF  MEDIUM
c #V1. 14.00,   2.00,  1.0e2,  0.5e0,  1.0e+9,    ! 9 BROADLEAF  HIGH
c #V1.  1.40,   0.20,  1.0e2,  0.5e0,  1.0e+9,    !10 NEEDLELEAF LOW
c #V1.  5.60,   0.80,  1.0e2,  0.5e0,  1.0e+9,    !11 NEEDLELEAF MEDIUM
c #V1. 14.00,   2.00,  1.0e2,  0.5e0,  1.0e+9/    !12 NEEDLELEAF HIGH
ci
ci
ci     MAR Classification (obtained from combili of Basic IGBP one)
ci     ============================================================
ci
c #V2 DATA
c #V2.(DisplH(ivg),
c #V2.        Z0mVeg(ivg),
c #V2.               StoRMn(ivg),
c #V2.                      RFr01m(ivg),
c #V2.                             PlantR(ivg),ivg=1,nv)
ci
ci     DisplH Z0mVeg StoRMn RFr01m PlantR
ci     -----  ------ ------ ------ ------
c #V2./14.00,  2.00, 100.0,  0.50, 1.0d+9, ! 1 EVERGREEN NEEDLELEAF FOREST
c #V2. 14.00,  2.00, 100.0,  0.50, 1.0d+9, ! 2 EVERGREEN BROADLEAF  FOREST
c #V2. 14.00,  2.00, 100.0,  0.50, 1.0d+9, ! 3 DECIDUOUS NEEDLELEAF FOREST
c #V2. 14.00,  2.00, 100.0,  0.50, 1.0d+9, ! 4 DECIDUOUS BROADLEAF  FOREST
c #V2.  0.00,  0.00,   0.0,  0.00, 0.0d+0, ! 5?MIXED                FOREST
c #V2.  0.00,  0.00,   0.0,  0.00, 0.0d+0, ! 6?CLOSED SHRUBLANDS
c #V2.  0.70,  0.10, 100.0,  0.50, 1.0d+9, ! 7 OPEN   SHRUBLANDS
c #V2.  3.50,  0.08,  75.0,  0.60, 7.5d+8, ! 8 WOODY SAVANNAS
c #V2.  3.50,  0.15,  75.0,  0.60, 7.5d+8, ! 9 SAVANNAS
c #V2.  0.70,  0.06,  50.0,  0.70, 0.5d+9, !10 GRASSLANDS
c #V2.  0.00,  0.00,   0.0,  0.00, 0.0d+0, !11?PERMANENT WETLANDS
c #V2.  0.07,  0.01,  50.0,  0.30, 0.5d+9, !12 CROPLANDS
c #V2. 10.00,  1.00, 990.0,  0.50, 1.0d+9, !13 URBAN AND BUILT-UP
c #V2.  0.70,  0.08,  50.0,  0.30, 0.5d+9, !14 CROPLAND / NAT.VEG.MOSAIC
c #V2.  3.00,  0.30, 990.0,  0.50, 1.0d+9, !15 SMALL CITY
c #V2.  0.10,  0.05, 990.0,  0.50, 1.0d+9, !16 BARREN OR SPARSELY VEGETATED
c #V2.  3.50,  0.50, 100.0,  0.50, 1.0d+9, !17 SAHELIAN TREES
c #V2.  0.35,  0.05,  50.0,  0.70, 0.5d+9/ !18 SAHELIAN GRASS
ci
ci-------------------------------------------------------------------------
ci--- 1.5 VEGETATION PARAMETERS (leaf optical parameters) -----------------
ci-------------------------------------------------------------------------
ci    rhovl    reflectivity   in the visible for live leaves
ci    rhonl    reflectivity   in the near IR for live leaves
ci    tauvl    transmissivity in the visible for live leaves
ci    taunl    transmissivity in the near IR for live leaves
ci    rhovd    reflectivity   in the visible for dead leaves
ci    rhond    reflectivity   in the near IR for dead leaves
ci    tauvd    transmissivity in the visible for dead leaves
ci    taund    transmissivity in the near IR for dead leaves
ci-------------------------------------------------------------------------
ci
ci     IGBP Classification
ci     ===================
ci
c #V1 DATA (rhof(ivg,1),rhof(ivg,2),tauf(ivg,1),tauf(ivg,2),
c #V1.      rhof(ivg,3),rhof(ivg,4),tauf(ivg,3),tauf(ivg,4),ivg=1,nv)
ci
ci    rhovl rhonl tauvl taunl rhovd rhond tauvd taund
ci    ----- ----- ----- ----- ----- ----- ----- -----
c #V1./0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,! 1 CROPS LOW
c #V1. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,! 2 CROPS MEDIUM
c #V1. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,! 3 CROPS HIGH
c #V1. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,! 4 GRASS LOW
c #V1. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,! 5 GRASS MEDIUM
c #V1. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,! 6 GRASS HIGH
c #V1. 0.10, 0.45, 0.05, 0.25, 0.16, 0.39, 0.01, 0.01,! 7 BROADL LOW
c #V1. 0.10, 0.45, 0.05, 0.25, 0.16, 0.39, 0.01, 0.01,! 8 BROADL MEDIUM
c #V1. 0.10, 0.45, 0.05, 0.25, 0.16, 0.39, 0.01, 0.01,! 9 BROADL HIGH
c #V1. 0.07, 0.35, 0.05, 0.10, 0.10, 0.39, 0.01, 0.01,!10 NEEDLE LOW
c #V1. 0.07, 0.35, 0.05, 0.10, 0.10, 0.39, 0.01, 0.01,!11 NEEDLE MEDIUM
c #V1. 0.07, 0.35, 0.05, 0.10, 0.10, 0.39, 0.01, 0.01/!12 NEEDLE HIGH
ci
ci
ci     MAR  Classification
ci     ===================
ci
c #V2 DATA (rhof(ivg,1),rhof(ivg,2),tauf(ivg,1),tauf(ivg,2),
c #V2.      rhof(ivg,3),rhof(ivg,4),tauf(ivg,3),tauf(ivg,4),ivg=1,nv)
ci
ci    rhovl rhonl tauvl taunl rhovd rhond tauvd taund
ci    ----- ----- ----- ----- ----- ----- ----- -----
c #V2./0.07, 0.35, 0.05, 0.10, 0.10, 0.39, 0.01, 0.01,! 1 EVERG. NEEDLEL.F.
c #V2. 0.10, 0.45, 0.05, 0.25, 0.16, 0.39, 0.01, 0.01,! 2 EVERG. BROADL. F.
c #V2. 0.07, 0.35, 0.05, 0.10, 0.10, 0.39, 0.01, 0.01,! 3 DECID. NEEDLEL.F.
c #V2. 0.10, 0.45, 0.05, 0.25, 0.16, 0.39, 0.01, 0.01,! 4 DECID. BROADL. F.
c #V2. 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,! 5?MIXED  FOREST
c #V2. 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,! 6?CLOSED SHRUBLANDS
c #V2. 0.10, 0.45, 0.05, 0.25, 0.16, 0.39, 0.01, 0.01,! 7 OPEN   SHRUBLANDS
c #V2. 0.11, 0.52, 0.06, 0.25, 0.26, 0.49, 0.12, 0.20,! 8 WOODY  SAVANNAS
c #V2. 0.11, 0.52, 0.06, 0.25, 0.26, 0.49, 0.12, 0.20,! 9 SAVANNAS
c #V2. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,!10 GRASSLANDS
c #V2. 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00,!11?PERMAN.WETLANDS
c #V2. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,!12 CROPLANDS
c #V2. 0.07, 0.35, 0.05, 0.10, 0.10, 0.39, 0.01, 0.01,!13 URBAN & BUILT-UP
c #V2. 0.11, 0.58, 0.07, 0.25, 0.36, 0.58, 0.22, 0.38,!14 CROPL./NAT.VEG.MOSA.
c #V2. 0.07, 0.35, 0.05, 0.10, 0.10, 0.39, 0.01, 0.01,!15 SMALL CITY
c #V2. 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01,!16 BARR.OR SPARS.VEGET.
c #V2. 0.10, 0.45, 0.05, 0.25, 0.10, 0.45, 0.05, 0.25,!17 SAHELIAN TREES
c #V2. 0.11, 0.58, 0.07, 0.25, 0.11, 0.58, 0.07, 0.25/!18 SAHELIAN GRASS
ci
C +
c #SV end
      subroutine svat
     .     (vVAir,vTAir,vQAir,vRadS,vRadL,vRain,cosZA,rhAir,vzAir,
     .      i    ,j    ,iprnt,vdt  ,
     .      vTsBr,vTsIR,vAlbS,vEmiS,vTa_S,vQa_S,vHS_S,vHL_S,vTauS)
C +
c**************************************************************************
c**************************************************************************
c**                                                                      **
c** Last Modifications:  9 December  1999, by Hubert Gallee              **
c**                     23 Januari   2000, by Hubert Gallee              **
c**                     21 October   2000, by Hubert Gallee              **
c**                     19 September 2001, by Hubert Gallee              **
c**                                                                      **
c** This routine computes the turbulent surface fluxes of                **
c**                       sensible and latent heat,   and                **
c**                       momentum,                                      **
c**              accounting for the interactions between                 **
c**                       soil, vegetation and atmosphere.               **
c** It           was developed at:                                       **
c**                                                                      **
c** Institut d'Astronomie et de Geophysique G. Lemaitre                  **
c** Universite Catholique de Louvain                                     **
c** 2, Chemin du Cyclotron                                               **
c** B-1348 Louvain-la-Neuve                                              **
c** BELGIUM                                                              **
c**                                                                      **
c**                                                                      **
c** REFERENCES:                                                          **
c** -----------                                                          **
c**                                                                      **
c** De Ridder, K., 1997: Radiation transfer in the IAGL land surface     **
c** model. Journ. Appl. Meteorol., 36, 12-21.  (> DR97)                  **
c**                                                                      **
c** De Ridder, K., and G. Schayes, 1997: The IAGL land surface model.    **
c** Journ. Appl. Meteorol., 36, 167-182.       (> DS97)                  **
c**                                                                      **
c**----------------------------------------------------------------------**
c**                                                                      **
c** Koen De Ridder                                                       **
c** VITO, Remote Sensing and Atmospheric Processes                       **
c** Boeretang 200, B-2400 Mol, BELGIUM                                   **
c** tel:   +32/14/33.68.40            email: dridderk@vito.be            **
c** fax:   +32/14/32.27.95            URL: http://www.vito.be            **
c**                                                                      **
c**                                                                      **
c**************************************************************************
c**                       INPUT                                          **
c**************************************************************************
c**                                                                      **
c** vVAir          : Norm Wind Speed  at 1st Model Level (m/s)           **
c** vTAir          : Temperature      at 1st Model Level (K)             **
c** vQAir          : Humidity         at 1st Model Level (kg/kg)         **
c** vRadS          : Solar Radiation incident at Surface (W/m**2)        **
c** vRadL          : IR    Radiation incident at Surface (W/m**2)        **
c** vRain          : rain intensity                      (kg/m**2/s)     **
c**                                                                      **
c** cosZA          : Cosine of Solar Zenith Angle        (-)             **
c** rhAir          : Air       Density                   (kg/m**3)       **
c** vzAir          : Height 1st Model (or Forcing) Level (m)             **
c**                                                                      **
c** imx            : number of gridpoints x-direction                    **
c** jmx            : number of gridpoints y-direction                    **
c** i              : gridpoint coordinate x-direction                    **
c** j              : gridpoint coordinate y-direction                    **
c** iprnt          : output print flag             Print (1)             **
c**                                             NO Print (0)             **
c** vdt            : SVAT Time Step                      (s)             **
c** itexpe         : re-start flag (.ge.1 ===> RESTART)                  **
c**                                                                      **
c**************************************************************************
c**                       OUTPUT                                         **
c**************************************************************************
c**                                                                      **
c** vTsBr          : surface brightness temperature      (K)             **
c** vTsIR          : surface temperature (radiative)     (K)             **
c** vAlbS          : surface albedo                      (-)             **
c** vEmiS          : surface emissivity                  (-)             **
c** vTa_S          : surface temperature (aerodynamic)   (K)             **
c** vQa_S          : surface specific humidity           (kg/kg)         **
c** vHS_S          : surface sensible heat flux          (W/m**2)        **
c** vHL_S          : surface latent   heat flux          (W/m**2)        **
c** vTauS          : surface stress                      (N/m**2)        **
c**                                                                      **
c**************************************************************************
c**************************************************************************
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      INCLUDE 'MARCTR.inc'
C +
      INCLUDE 'MARdim.inc'
      INCLUDE 'MARphy.inc'
      INCLUDE 'MAR_GE.inc'
      INCLUDE 'MAR_SV.inc'
      INCLUDE 'MAR_TV.inc'
C +
      real     vVAir,vTAir,vQAir,vRadS,vRadL,vRain,cosZA,rhAir,vzAir
      real     vTsBr,vTsIR,vAlbS,vEmiS,vTa_S,vQa_S,vHS_S,vHL_S,vTauS,vdt
      integer  i    ,j    ,iprnt
C +
C +
C +--Local  Variables
C +  ================
C +
      integer    nv
c #V1 PARAMETER (nv=12)
c #V2 PARAMETER (nv=18)
C +
      LOGICAL         svinit,etagNR,TsogNR
      common/SvaMAR_L/svinit,etagNR,TsogNR
C +
      integer         itsvat,jNRmax,nunit
      common/SvaMAR_I/itsvat,jNRmax,nunit(iptx,nvx)
C +
      CHARACTER*14    FilNam
      CHARACTER* 3    FilLab
      common/SvaMAR_C/FilNam,FilLab
C +
      real            depth(4),
     .                tvmin,tvmax,pvmin,pvmax,tgmin,tgmax,pgmin,pgmax,
     .                r_two,r_thr,r_ten,
     .                StefBo,Cp_Air,Vap_LH,RhoWat,RhoWCW,htcapv,StoRCr,
     .                rstmax,psicri,EpsVeg,EpsGro,EpsWat,conmin
      common/SvaMAR_R/depth,
     .                tvmin,tvmax,pvmin,pvmax,tgmin,tgmax,pgmin,pgmax,
     .                r_two,r_thr,r_ten,
     .                StefBo,Cp_Air,Vap_LH,RhoWat,RhoWCW,htcapv,StoRCr,
     .                rstmax,psicri,EpsVeg,EpsGro,EpsWat,conmin
C +
      real            etasat(11),psisat(11), aksat(11),bclap(11),
     .                 csat1(11), csat2(11),rhocsl(11),
     .                etgMin(11),etgMax(11)
      common/SvaMAR_S/etasat    ,psisat    , aksat    ,bclap    ,
     .                 csat1    , csat2    ,rhocsl    ,
     .                etgMin    ,etgMax
C +...Soil Parameters (depend on soil type)
C +
      real            DisplH(nv),Z0mVeg(nv),
     .                StoRMn(nv),RFr01m(nv),PlantR(nv),
     .                rhof(nv,4),tauf(nv,4)
      common/SvaMAR_V/DisplH    ,Z0mVeg    ,
     .                StoRMn    ,RFr01m    ,PlantR    ,
     .                rhof      ,tauf      
C +...Vegetation Parameters (depend on vegetation type)
C +
      real            omega(llx),rootf(nv,llx),
     .              eta_2(0:llx), gamat(0:llx),
     .              conh2(0:llx), gamah(0:llx),dptot,
     .                omwtr(llx),    fvtr(llx),alpha(llx),psi(llx)
      common/SvaMARs1/omega     ,rootf        ,
     .              eta_2       , gamat       ,
     .              conh2       , gamah       ,dptot,
     .                omwtr     ,    fvtr     ,alpha     ,psi
C +
      integer                  llxx
      parameter(               llxx=llx+1)
      real            Tsol_n(0:llxx),eta__n(0:llxx),
     .                Diag_A(   llx),Diag_B(   llx),
     .                Diag_C(   llx),Term_D(   llx),
     .                Term_P(   llx),Term_Q(   llx),Var__X(llx),
     .                implic        ,explic
      common/SvaMARs2/Tsol_n        ,eta__n        ,
     .                Diag_A        ,Diag_B        ,
     .                Diag_C        ,Term_D        ,
     .                Term_P        ,Term_Q        ,Var__X,
     .                implic        ,explic
C +...                For the diffusion numerical scheme
C +
      real            runoff(nvx),draing(nvx),
     .                      u0(2),     absv(2),   absg(2)
      common/SvaMARv1/runoff     ,draing     ,
     .                      u0   ,     absv   ,   absg
C +...Canopy     Radiative   Properties
C +
      real            wvmax(imx,jmx,nvx), sigt(imx,jmx,nvx),
     .               taudif(imx,jmx,nvx),beer0(imx,jmx,nvx)
      common/SvaMARv2/wvmax             , sigt             ,
     .               taudif             ,beer0
C +
      real            havg(imx,jmx),aleavg(imx,jmx), rnavg(imx,jmx),
     .              tbravg(imx,jmx),ustavg(imx,jmx),ggravg(imx,jmx),
     .               etavg(imx,jmx), Tsavg(imx,jmx)
      common/SvaMARen/havg         ,aleavg         , rnavg         ,
     .              tbravg         ,ustavg         ,ggravg         ,
     .               etavg         , Tsavg
C +
      integer  ilay  ,idp   ,isl   ,iin   ,jin   ,msc   ,iiw   ,naux
      integer  ksp   ,jcri  ,lpsi  ,jit1  ,jit2  ,jit3  ,jit4  ,jit
      integer  lostrt,jitmax,nflow ,kflow ,iwater,ix    ,LFlow ,itst  ,k
      real     vmulti,zdpth ,trm1  ,trm2  ,etag  ,frct
      real     tgavg ,qslavg,albavg,emavg ,eta1m ,eta2m ,eta3m ,eta4m
      real     T1m   ,T2m   ,T3m   ,T4m   ,SolAlb,SolEmi
      real     akrad ,bkrad ,expkL ,fmus  ,dlf   ,alcrit,ai0   ,d0
      real     xrhof ,xtauf ,rrad  ,trad  ,trad1 ,gamma ,exppgl,expmgl
      real     rrad0 ,trad0 ,anurad,anrad ,divrad,sigrad,cst1  ,cst2
      real     dl    ,alold ,argexp,anomcr,dencri,al_ver,aleff ,albedo
      real     absveg,absgrn,RnSo_g,rsv   
      real     xz0m  ,xz0h  ,alnm  ,alnh  ,cdm0  ,cdh0  ,bmstar,bhstar
      real     bmstab,bhstab,uamin ,ua    ,ra0m  ,ra0h  
      real     freta ,rst0  ,drip  ,argcth,conth1,conhyd,raingr
      real     tvpr  ,tgpr  ,pvpr  ,pgpr  ,xsigt ,xsigtc,xtaud ,xtaudc
      real     vTSurf,ribnom,rib   ,anoemh,stabh ,dstdri,raeroh,dradri
      real     dridtv,expon ,qsatv ,delta ,hv    ,f2stom,rst   ,etr
      real     edir  ,tvgn  ,rlv   ,alev  ,htbalv
      real     dradtv,dhvtv ,detrtv,dedrtv,dlevtv,drlvtv,dhvdtv
      real     htvlo ,tvhi  ,tvlo  ,htvhi ,denom ,fvtot ,wtbalv
      real     df2dpv,detrpv,dfvtot,auxdfv,dwvdpv
      real     wtvlo ,pvhi  ,wtvhi ,pvlo  ,dridtg
      real     hg    ,qsatg ,hu    ,tgrn  ,qgr   ,HLflug,RnIR_g,ggrg  
      real     htbalg,dradtg,dhgtg ,dlegtg,dggrtg,drlgtg,dhgdtg
      real     htglo ,tghi  ,htghi ,tglo  ,FcdH_g,DwnIRg,Up_IRg,eg    
      real     wtbalg,Fdif_g,F_gr_g,Fdg__g
      real     degpg ,dfgpg ,dwgdpg,wtglo ,pghi  ,wtghi ,pglo  
      real     anoemm,stabm ,raerom,ustr  ,stress
      real     xD1   ,FdgMax,detamx,dtmax ,dtwtr ,eta__g,watflw
      real     eta_g0,Fdg_gB,eta_g1,difh_g,bD_eta,AD_eta,conh_g
      real     B_gr_g,A_gr_g,exponT,qsat_g,aK_Atm,r_psig,rbpsig,r_humg
      real     B_Atmg,A_Atmg,A2_eta,A3_eta,B2_eta
      real     difh2 ,conh2f,conh2D,conh2A,conh2B,Elem_A,Elem_C
      real     deleta,Up_IRa,HSflua,Sum__A,Sum__B,FcdHgB,psi_2 ,argcon
      real     thcond,ha    ,alea  ,rnet  ,frac
ci
ci*************************************************************************
ci*************************************************************************
ci******************* 1.INITIALIZATION ************************************
ci*************************************************************************
ci*************************************************************************
ci**                                                                     **
ci**  The initialization section consists of:                            **
ci**  (-) DATA statements                   (cfr. block data SvaDAT)     **
ci**  (-) An initialization part                                         **
ci**      that is set up during the first time 'svat.f' is executed.     **
ci**                                                                     **
ci**  Note that all the comment flags in the initialization section      **
ci**            are labeled 'ci', so you won't be lost easily.           **
ci**                                                                     **
ci*************************************************************************
ci*************************************************************************
ci
ci-------------------------------------------------------------------------
ci--- 1.1 MODEL NUMERIC PARAMETERS ----------------------------------------
ci-------------------------------------------------------------------------
ci
ci
ci-------------------------------------------------------------------------
ci--- 1.2 PHYSICAL CONSTANTS ----------------------------------------------
ci-------------------------------------------------------------------------
ci
ci
ci-------------------------------------------------------------------------
ci--- 1.3 SOIL HYDRAULIC PARAMETERS (USDA classification) -----------------
ci-------------------------------------------------------------------------
ci
ci
ci-------------------------------------------------------------------------
ci--- 1.4 VEGETATION PARAMETERS (Structural/Transpiration) ----------------
ci-------------------------------------------------------------------------
ci
ci
ci-------------------------------------------------------------------------
ci--- 1.5 VEGETATION PARAMETERS (leaf optical parameters) -----------------
ci-------------------------------------------------------------------------
ci
ci
ci----------------------------------------------------------------------------
ci--- 1.6 FOLLOWING IF-LOOP IS ONLY ACTIVE AT FIRST CALL (svinit=.true.) -----
ci----------------------------------------------------------------------------
ci
      IF (svinit)                                                 THEN
C +
          svinit=.false.
ci
ci----------------------------------------------------------------------------
ci--- 1.7 AUXILIARY QUANTITIES -----------------------------------------------
ci----------------------------------------------------------------------------
ci
ci    1.7.0 numerical scheme parameters
ci    ---------------------------------
ci
        implic = 0.5d0
        explic = 1.0d0 - implic
C +...  Crank-Nicholson Scheme Parameters
C +
ci
ci
ci    1.7.1 soil layer depth-related quantities
ci    -----------------------------------------
ci
            deptTV(   0) = 0.00d0
        IF         (llx.le.4)                                     THEN
          DO ilay=1,llx
            deptTV(ilay) = depth(ilay)
          END DO
        ELSE
          DO ilay=1,  4
            deptTV(ilay) = depth(ilay)
          END DO
c #F        ratinv       = llx -1
c #F        vmulti       =(3.00d0/depth(1))**(unun/ratinv)
            vmulti       = 2.00d0
          DO ilay=5,llx
            deptTV(ilay) = deptTV(ilay-1)*vmulti
          END DO
        END IF
C +
            dptot        = 0.0d0
          DO ilay=0,llx-1
            dep2TV(ilay) =(deptTV(ilay)+deptTV(ilay+1))*0.5d0
            dptot        = dptot       +deptTV(ilay+1)
          END DO
C +
          DO ilay=1,llx
            omega(ilay)=vdt/deptTV(ilay)
          END DO
ci
ci
ci    1.7.2 root fraction per soil layer
ci    ----------------------------------
ci
        DO ivg=1,nv
                 zdpth=0.
          DO idp=1,llx
            IF  (zdpth+deptTV(idp).LE.0.1)                        THEN
                 rootf(ivg,idp)=       deptTV(idp)*RFr01m(ivg) /0.1
                 zdpth         = zdpth+deptTV(idp)
            ELSE
              IF(zdpth.LE.0.1)                                    THEN
                 trm1          =(0.1  -zdpth)     *RFr01m(ivg) /0.1
                 trm2          =(zdpth+deptTV(idp)-0.1)
     .                                        *(1.-RFr01m(ivg))/0.9
                 rootf(ivg,idp)=trm1+trm2
              ELSE
                 rootf(ivg,idp)=deptTV(idp)   *(1.-RFr01m(ivg))/0.9
              ENDIF
                 zdpth         =zdpth+deptTV(idp)
            ENDIF
          ENDDO
        ENDDO
ci
ci
ci    1.7.3 secondary soil parameters
ci    -------------------------------
ci
      DO       isl=1,11
        rhocsl(isl)=(1.-etasat(isl))*1.2E+6
         csat1(isl)=                  bclap(isl)*aksat(isl)*psisat(isl)
     .             /   (etasat(isl)**(bclap(isl)+r_thr))
         csat2(isl)=aksat(isl)
     .                /(etasat(isl)**(r_two*bclap(isl)+r_thr))
         etgMax(isl)= etasat(isl)*(psisat(isl)/pgmin)**(unun/bclap(isl))
         etgMin(isl)= etasat(isl)*(psisat(isl)/pgmax)**(unun/bclap(isl))
      ENDDO !  isl=1,11
ci
ci----------------------------------------------------------------------------
ci--- 1.8 INITIALIZATION GRIDPOINT DEPENDENT QUANTITIES ----------------------
ci----------------------------------------------------------------------------
ci
      DO jin=1,jmx
      DO iin=1,imx
ci
          isl=isolTV(iin,jin)
ci
ci      1.8.1 isolTV=0 (water) > no vegetation
ci      --------------------------------------
ci
        IF   (isolTV(iin,jin).EQ.0)      THEN ! entire Grid Element is Water
                          ivegTV(iin,jin,1)  =0
          DO msc=1,nvx
                          ifraTV(iin,jin,msc)=0
            IF (msc.EQ.1) ifraTV(iin,jin,msc)=100
          ENDDO
        ENDIF
C +
        DO msc=1,nvx
C +
          ivg=ivegTV(iin,jin,msc)
ci
ci        1.8.2 initialization Tv,Tg,psivTV,psigTV
ci        ----------------------------------------
ci
          IF   (itexpe.eq.0)                                      THEN
                TvegTV(iin,jin,msc)=TsolTV(iin,jin,msc,1)
                TgrdTV(iin,jin,msc)=TsolTV(iin,jin,msc,1)
                psivTV(iin,jin,msc)=0.
C +
            IF (isl.NE.0)                                         THEN
                etag=eta_TV(iin,jin,msc,1)
                frct=etasat(isl)/etag
                psigTV(iin,jin,msc)=psisat(isl)*frct**(bclap(isl))
            ELSE
                psigTV(iin,jin,msc)=0.
            ENDIF
          END IF
ci
ci        1.8.3 LAI dependent variables
ci        -----------------------------
ci
          IF (itexpe.EQ.0)        CaWaTV(iin,jin,msc)=0.
           wvmax(iin,jin,msc)=0.2*alaiTV(iin,jin,msc)
            sigt(iin,jin,msc)=1.0d0-exp(-0.5*alaiTV(iin,jin,msc))
          taudif(iin,jin,msc)=      exp(-    alaiTV(iin,jin,msc))
           beer0(iin,jin,msc)=1.0d0-sigt(iin,jin,msc)
ci
ci        1.8.4 open files detailed point output
ci        --------------------------------------
ci
                OPEN(unit=  51,file='SVATtroubles',status='unknown')
          DO iiw=1,iptx
            IF (iin.EQ.IOi_TV(iiw).AND.jin.EQ.IOj_TV(iiw))        THEN
              IF (ifraTV(iin,jin,msc).GT.0)                       THEN
                WRITE(FilNam,'(a3,2(i3.3,a1),i1)')
     .            FilLab,iin,FilLab(3:3),jin,FilLab(3:3),msc
                               nunit(iiw,msc) = 51+nvx*(iiw-1)+msc
                          naux=nunit(iiw,msc)
                OPEN(unit=naux,file=FilNam,status='unknown')
                WRITE(nunit(iiw,msc),1001)      iin,jin,msc,
     .               ifraTV(iin,jin,msc),isolTV(iin,jin),
     .                                   ivegTV(iin,jin,msc)
 1001           format(' Grid Point',2i4,'    Mosaic',i4,
     .                    '   FRAC',i4,' %    SolTyp',i4,
     .                                   '    VegTyp',i4,
     .               /,' ================================',
     .                  '=========================================')
              ENDIF
            ENDIF
          ENDDO
C +
        ENDDO ! msc=1,nvx
C +
      ENDDO ! iin=1,iim
      ENDDO ! jin=1,jjm
C +
      ENDIF ! (svinit)
C +
C +!!! Definieer hier qsat0D Function, en
C +    Gebruik die meteen om op te leggen dat vQAir < qsat0D(vTAir)
C +--  Initialization  >  for averaging over subgrid patches
C +    -----------------------------------------------------
C +
        havg(i,j)=0.
      aleavg(i,j)=0.
       rnavg(i,j)=0.
      ggravg(i,j)=0.
      tbravg(i,j)=0.
      ustavg(i,j)=0.
       tgavg     =0.
      qslavg     =0.
      albavg     =0.
       emavg     =0.
C +
       eta1m     =0.
       eta2m     =0.
       eta3m     =0.
       eta4m     =0.
         T1m     =0.
         T2m     =0.
         T3m     =0.
         T4m     =0.
c
c-----------------------------------------------------------------------------
c-----START SUBGRID LOOP (mosaic)---------------------------------------------
c-----------------------------------------------------------------------------
c
      DO msc=1,nvx
C +
        IF   (ifraTV(i,j,msc).NE.0)                               THEN
C +
          isl=isolTV(i,j)
          ivg=ivegTV(i,j,msc)
c
c-----------------------------------------------------------------------------
c-----SOIL ALBEDO (Pielke 1984) AND EMISSIVITY -------------------------------
c-----------------------------------------------------------------------------
c
          IF (isl.NE.0)                                           THEN
               etag =      etasat(isl)
     .                   *(psisat(isl)/psigTV(i,j,msc))**(1./bclap(isl))
            IF(etag.LE.0.5*etasat(isl))                           THEN
               SolAlb=AlbSTV(i,j)*(1.0d0-etag/etasat(isl))
            ELSE
               SolAlb=AlbSTV(i,j)* 0.5d0
            ENDIF
          ELSE
               SolAlb=0.06
          ENDIF
C +
          IF (ivg.NE.0)                                           THEN
               SolEmi=taudif(i,j,msc)*EpsGro+(1.-taudif(i,j,msc))*EpsVeg
          ELSE
            IF (isl.EQ.0)                                         THEN
               SolEmi=EpsWat
            ELSE
               SolEmi=EpsGro
            ENDIF
          ENDIF
c
c-----------------------------------------------------------------------------
c-----SOLAR RADIATION ABSORPTION AND EFFECTIVE LEAF AREA INDEX (DR97)---------
c-----------------------------------------------------------------------------
c     * if cosZA < 0. (= at night) >>> the radiation part is skipped
c     * chi_l (eqn49 DR97) is put to zero for all vegetation types
c     * radiation fluxes are normalized
c                        with respect to the incoming solar radiation (=I0+D0)
c-----------------------------------------------------------------------------
c
          IF (cosZA.GE.0.0001.AND.ivg.NE.0)                       THEN
              akrad=     0.5 /cosZA
              bkrad=     2.5 *cosZA
              expkL=     exp(-akrad*alaiTV(i,j,msc))
               fmus=1.d0-exp(-bkrad)
                dlf=1.d0-           glf_TV(i,j,msc)
             alcrit=2.d0
c
            DO    ksp=1,2                          ! ksp=1 > VIS ; ksp=2 > NIR
              IF (ksp.EQ.1) ai0=(0.25+0.697*fmus)
              IF (ksp.EQ.2) ai0=(0.80+0.185*fmus)
                    d0=1.d0-   ai0
                 xrhof=glf_TV(i,j,msc)*rhof(ivg,ksp)+dlf*rhof(ivg,ksp+2)
                 xtauf=glf_TV(i,j,msc)*tauf(ivg,ksp)+dlf*tauf(ivg,ksp+2)
                  rrad=(2.d0*xrhof+     xtauf) / 3.0d0
                  trad=(     xrhof+2.d0*xtauf) / 3.0d0
                 trad1= 1.d0-trad
                 gamma=sqrt(trad1*trad1-rrad*rrad)
                exppgl=exp( gamma*alaiTV(i,j,msc))
                expmgl=exp(-gamma*alaiTV(i,j,msc))
                 rrad0=.5*((xrhof+xtauf)*akrad+(xrhof-xtauf)/3.0d0)
                 trad0=.5*((xrhof+xtauf)*akrad-(xrhof-xtauf)/3.0d0)
                anurad=     trad1       -rrad*SolAlb
                 anrad=  gamma*(exppgl+expmgl)+anurad*(exppgl-expmgl)
                divrad=  gamma*gamma-       akrad*akrad
                if (abs(divrad).lt.1.d-6)  divrad=1.d-6
                sigrad=  (rrad*rrad0+trad0*(akrad+trad1))    /divrad
                  cst1=((gamma-anurad)*(d0-sigrad*ai0)*expmgl
     .                +((akrad-anurad)    *sigrad
     .                +  trad0+rrad*SolAlb)*ai0*expkl)/anrad
                  cst2=d0-cst1-sigrad*ai0
                    dl=   cst1*exppgl+cst2*expmgl+sigrad*ai0*expkl
               u0(ksp)=((gamma+trad1)*cst1-(gamma-trad1)*cst2
     .                -((akrad-trad1)*sigrad+trad0)*ai0)/rrad
             absg(ksp)= (1.d0-SolAlb)*(ai0*expkl+dl)
             absv(ksp)= (1.d0-u0(ksp))-absg(ksp)
C +
             IF (ksp.EQ.1.AND.d0*vRadS.GT.StoRCr)         THEN ! effective LAI
               DO jcri=1,10
                      alold=                      alcrit
                     argexp=  min(   argmax,gamma*alcrit)
                     anomcr=        cst1    *exp( argexp)
     .                             +cst2    *exp(-argexp)
     .                       +sigrad*ai0    *exp(-argexp)
     .                                       -2.*StoRCr/vRadS
                     dencri=gamma*  cst1    *exp( argexp)
     .                     -gamma*  cst2    *exp(-argexp)
     .                     -akrad*sigrad*ai0*exp(-argexp)
C +
                          al_ver=   alcrit         *dencri - anomcr
                 IF      (al_ver.lt.0.0d+0)                       THEN
                          alcrit=   0.0d+0
                 ELSE IF (al_ver.gt.alaiTV(i,j,msc)*dencri)       THEN
                          alcrit=   alaiTV(i,j,msc)
                 ELSE
                          alcrit=   al_ver         /dencri
                 END  IF
                 IF   (abs(alold-alcrit).LT.0.01)            GO TO 610
               END DO
             ELSE
                     alcrit=0.
             ENDIF
 610           aleff=alcrit+(exp(-akrad*alcrit)-expkl)/akrad
            END DO
              albedo=(  u0(1)+  u0(2))*0.5d0
              absveg=(absv(1)+absv(2))*0.5d0
              absgrn=(absg(1)+absg(2))*0.5d0
          ELSE                                            ! bare soil or water
              albedo=   SolAlb
              absveg=0.
              absgrn=1.-albedo
          ENDIF
c
          RnSo_g=absgrn*vRadS
          rsv   =absveg*vRadS
c
c-----------------------------------------------------------------------------
c-----AERODYNAMIC RESISTANCE (Garrat 1992)------------------------------------
c-----------------------------------------------------------------------------
c
c !!  onderstaande verkorten; tijdrovend om bij elke timestep
c                             opnieuw xz0m te moeten bepalen.
c                          ?? berekenen in de initializatie   ??
c    (xz0m(i,j))
c
          IF   (isl.NE.0)                                         THEN
            IF (ivg.EQ.0)                                         THEN
               xz0m=0.01
            ELSE
               xz0m=Z0mVeg(ivg)
            ENDIF
               xz0h=xz0m/7.4
          ELSE
               xz0m=0.0001
               xz0h=xz0m
          ENDIF
C +
               alnm=log(vzAir/xz0m)
               alnh=log(vzAir/xz0h)
               cdm0=.16/(alnm*alnm)
               cdh0=.16/(alnm*alnh)
C +...              .16: Square of the Von Karman Constant
C +
          IF   (isl.NE.0)                                         THEN
             bmstar=13.7-0.34/sqrt(cdm0)
             bhstar= 6.3-0.18/sqrt(cdm0)
          ELSE
             bmstar= 4.9
             bhstar= 2.6
          ENDIF
 
C +
             bmstab=1.d1*bmstar*cdm0*sqrt(vzAir/xz0m)
             bhstab=1.d1*bhstar*cdh0*sqrt(vzAir/xz0h)
c
c  !!        beter: ua        beperken tot 0.1 of zo en
c                   ua in Rib beperken tot waarde die afhangt van vzAir (bvb.)
c
              uamin=0.2*sqrt(vzAir)
              ua   =     MAX(vVAir,uamin)
              ra0m =1.0/(cdm0*ua)
              ra0h =1.0/(cdh0*ua)
c
c-----------------------------------------------------------------------------
c-----SOIL WATER POTENTIAL & STOMATAL RESISTANCE (no water stress)------------
c-----------------------------------------------------------------------------
c
c  ?? probeer aantal 'IF (isl.NE.0) THEN' en 'IF (ivg.NE.0) THEN'
c             te beperken (minder herhalen!!)
c
          IF   (isl.NE.0)                                         THEN
            DO lpsi=1,llx
              freta    =etasat(isl)/eta_TV(i,j,msc,lpsi)
              psi(lpsi)=psisat(isl)*freta**bclap(isl)
            END DO
            IF (ivg.NE.0)                                         THEN
              IF (glf_TV(i,j,msc).GT.0.01)                        THEN
                rst0=StoRMn(ivg)/glf_TV(i,j,msc)
              ELSE
                rst0=                    rstmax
              ENDIF
                rst0=rst0/max(aleff,rst0/rstmax)
            ENDIF
c
c ??? IF no soil but vegetation (e.g. MARSH) THEN DEFINE ELSE ... rst0 =
c
          ENDIF
c
c-----------------------------------------------------------------------------
c-----UPDATE CANOPY WATER CONTENT (fill)--------------------------------------
c-----------------------------------------------------------------------------
c
          IF (ivg.NE.0)                                           THEN
                    CaWaTV(i,j,msc)=CaWaTV(i,j,msc)
     .                             +  sigt(i,j,msc)*vRain*vdt
            IF     (CaWaTV(i,j,msc).gt.wvmax(i,j,msc))            THEN
              drip=(CaWaTV(i,j,msc)-wvmax(i,j,msc))/vdt
                    CaWaTV(i,j,msc)=wvmax(i,j,msc)
            ELSE
              drip=0.
            ENDIF
          ELSE
              drip=0.
          ENDIF
c
c-----------------------------------------------------------------------------
c-----THERMAL/HYDRAULIC CONDUCTIVITIES FIRST SOIL LAYER-----------------------
c-----------------------------------------------------------------------------
c
          IF   (isl.NE.0)                                         THEN
               argcth=   3.82d0*(psi(1))**(-0.4343)
               conth1=min(max(argcth,conmin),r_two)
               conhyd=aksat(isl)
     .             *(psisat(isl)/psi(1))**(2.+3./bclap(isl))
            IF (ivg.NE.0)                                         THEN
                raingr=beer0(i,j,msc)*vRain+drip
            ELSE
                raingr=               vRain
            ENDIF
            IF (raingr.GT.0.) psigTV(i,j,msc)=psisat(isl)
          ENDIF
c
c-----------------------------------------------------------------------------
c-----INITIALIZATION----------------------------------------------------------
c-----------------------------------------------------------------------------
c
            tvpr  =     TvegTV(i,j,msc)
            tgpr  =     TgrdTV(i,j,msc)
            pvpr  =     psivTV(i,j,msc)
            pgpr  =     psigTV(i,j,msc)
C +
          IF (ivg.NE.0)                                           THEN
            xsigt =       sigt(i,j,msc)
            xsigtc=  1.- xsigt
            xtaud =     taudif(i,j,msc)
            xtaudc=  1.-taudif(i,j,msc)
          ELSE
            xsigt =  0.
            xsigtc=  1.
            xtaud =  1.
            xtaudc=  0.
          ENDIF
c
c-----------------------------------------------------------------------------
c-----FLUX COMPUTATION--------------------------------------------------------
c-----------------------------------------------------------------------------
c     comments (solution method)
c-----------------------------------------------------------------------------
c
            jit1=0
            jit2=0
            jit3=0
            jit4=0
c
c-----------------------------------------------------------------------------
c-----CANOPY ENERGY FLUXES----------------------------------------------------
c-----------------------------------------------------------------------------
c
          IF (ivg.NE.0)                                           THEN
C +
            DO jit=1,100
C +
C +
C +--Computation of htbalv(Tv)
C +  -------------------------
C +
                  vTSurf=xsigt*TvegTV(i,j,msc)+xsigtc*tgpr
                  ribnom=    vTAir*ua*ua
                  rib   =9.8*vzAir*(vTAir-vTSurf)/ribnom
              IF (vTSurf .GT.  vTAir)                             THEN
                  anoemh=      1.0+bhstab*sqrt(-rib)-1.d1*rib
                   stabh=     (1.0+bhstab*sqrt(-rib))/ anoemh
                  dstdri= 5.0*(2.0+bhstab*sqrt(-rib))/(anoemh*anoemh)
              ELSE
                  argexp=      1.0+5.0   *      rib
                   stabh=      argexp*argexp
                  dstdri=10.0* argexp
              ENDIF
                  raeroh=ra0h* stabh
                  dradri=ra0h*dstdri
                  dridtv=-xsigt*9.8*vzAir/ribnom
                   expon=17.27*(TvegTV(i,j,msc)-273.16)
     .                        /(TvegTV(i,j,msc)-35.8)
                   qsatv=.0038*exp(expon)
              IF  (qsatv.LE.vQAir)                                THEN
                   delta=1.0 ! here condens.! leaves fraction convert by water
              ELSE                          ! (interecepted or condensed)
                   delta=     CaWaTV(i,j,msc)/wvmax(i,j,msc)
              ENDIF
                   hv=rhAir*Cp_Air*xsigt*(TvegTV(i,j,msc)-vTAir)/raeroh
              IF (pvpr.LT.248.)                                   THEN
                  f2stom=psicri/(psicri-pvpr)
              ELSE
                  f2stom=62.5*pvpr-15375.
              ENDIF
C +
                 rst=rst0*f2stom
                 etr=rhAir*xsigt*(1.-delta)*(qsatv-vQAir)
     .            /(raeroh+xsigt*rst)
                edir=rhAir*xsigt*    delta *(qsatv-vQAir)
     .            / raeroh
                tvgn=TvegTV(i,j,msc)
                 rlv=EpsVeg*xtaudc*(vRadL-2.*StefBo*tvgn*tvgn*tvgn*tvgn)
     .              +EpsGro*xtaudc*          StefBo*tgpr*tgpr*tgpr*tgpr
                alev=Vap_LH*(edir+etr)
              htbalv=rsv+rlv-hv-alev
C +
C +
C +--Evaluation of htbalv(Tv)
C +  ------------------------
C +
              IF (ABS(htbalv).LE.0.1)                        GO TO 101
C +
C +
C +--Computation update Tv
C +  ---------------------
C +
              IF (jit.LE.jNRmax)                          THEN ! Newton step
                  tvgn = TvegTV(i,j,msc)
                dradtv =      dradri *dridtv
                 dhvtv =     (Cp_Air *rhAir *xsigt / raeroh)
     .           *(1.0d0-       (tvgn-vTAir)*dradtv/ raeroh)
                detrtv= ((1.0-delta) *rhAir *xsigt /(raeroh+xsigt*rst))
     .          * (qsatv*4099.2/(tvgn-35.8)**2. -(qsatv-vQAir)
     .                                      *dradtv/(raeroh+xsigt*rst))
                dedrtv= (     delta  *rhAir *xsigt / raeroh)
     .          *((qsatv*4099.2/(tvgn-35.8)**2.)-(qsatv-vQAir)
     .                                      *dradtv/ raeroh)
                dlevtv=Vap_LH*(detrtv+dedrtv)
                drlvtv=-8.*EpsVeg*xtaudc*StefBo*tvgn*tvgn*tvgn
                dhvdtv=        drlvtv-dhvtv -dlevtv
C +
                    TvegTV(i,j,msc)  =        TvegTV(i,j,msc)-htbalv
     .                                                       /dhvdtv
                    TvegTV(i,j,msc)  =    max(TvegTV(i,j,msc),tvmin)
                    TvegTV(i,j,msc)  =    min(TvegTV(i,j,msc),tvmax)
C +
              ELSE                                               ! bisection
C +
                IF      (jit.EQ.jNRmax+1)                         THEN
                  IF    (htbalv.GE.0)                             THEN
                         htvlo           = htbalv
                         TvegTV(i,j,msc) = tvmax
                         tvhi            = tvmax
                         lostrt          = 1
                  ELSE
                         htvhi           = htbalv
                         TvegTV(i,j,msc) = tvmin
                         tvlo            = tvmin
                         lostrt          = 0
                  ENDIF
                ELSE IF (jit.EQ.jNRmax+2)                         THEN
                  IF    (lostrt.EQ.1)                             THEN
                         htvhi           = htbalv
                         TvegTV(i,j,msc) = tvmin
                         tvlo            = tvmin
                  ELSE
                         htvlo           = htbalv
                         TvegTV(i,j,msc) = tvmax
                         tvhi            = tvmax
                  ENDIF
                ELSE
                  IF    (htbalv*htvlo.GT.0)                       THEN
                         tvlo            = TvegTV(i,j,msc)
                         htvlo           = htbalv
                  ELSE
                         tvhi            = TvegTV(i,j,msc)
                         htvhi           = htbalv
                  ENDIF
                         TvegTV(i,j,msc) =(tvlo+tvhi)*0.5d0
                ENDIF
              ENDIF
            ENDDO
C +
 101        CONTINUE
C +...      Pas op! Gevaarlijk uit de do loop uit te gaan
C +
            jit1=jit
c
c-----------------------------------------------------------------------------
c-----CANOPY WATER FLUXES-----------------------------------------------------
c-----------------------------------------------------------------------------
c
                expon=17.27*(tvpr-273.16)/(tvpr-35.8)
                qsatv=.0038*exp(expon)
            IF (qsatv.LE.vQAir)                                   THEN
                delta=1.0
            ELSE
                delta=CaWaTV(i,j,msc)/wvmax(i,j,msc)
            ENDIF
C +
            IF (ABS(delta-1.).LT.1.E-06)                          THEN
C +
              DO jit=1,100
C +
C +
C +--Computation of wtbalv(psivTV)
C +  -----------------------------
C +
                IF (psivTV(i,j,msc).LT.248.)                      THEN
                    f2stom=psicri/(psicri-psivTV(i,j,msc))
                ELSE
                    f2stom=          62.5*psivTV(i,j,msc)-15375.
                ENDIF
                    rst   =              rst0*f2stom
                    denom = raeroh+xsigt* rst
                    etr   = rhAir *xsigt*(1.-delta)*(qsatv-vQAir)/denom
                    fvtot = 0.
                DO ilay=1,llx
                  IF (psivTV(i,j,msc).GT.DisplH(ivg)+psi(ilay))   THEN
                    fvtr(ilay)=RhoWat*rootf(ivg,ilay)
     .              *(psivTV(i,j,msc) - (DisplH(ivg)+psi(ilay)))
     .                                  /PlantR(ivg)
                    fvtot     =fvtot+fvtr(ilay)
                  ELSE
                    fvtr(ilay)=0.
                  ENDIF
                ENDDO
                    wtbalv    =fvtot-etr
C +
C +
C +--Evaluation of wtbalv(psivTV)
C +  ----------------------------
C +
                IF (Vap_LH*ABS(wtbalv).LE.0.1)               GO TO 102
C +
C +--Computation update psivTV
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
                IF     (jit.LE.jNRmax)                    THEN ! Newton step
                  IF   (psivTV(i,j,msc).LT.248.)                  THEN
                        df2dpv=psicri/(psicri-psivTV(i,j,msc))**2.
                  ELSE
                        df2dpv=62.5
                  ENDIF
                        detrpv=-etr*xsigt*rst0*df2dpv/(denom*denom)
                        dfvtot= 0.
                  DO ilay=1,llx
                    IF (psivTV(i,j,msc).GT.psi(ilay)+DisplH(ivg)) THEN
                        auxdfv=RhoWat*rootf(ivg,ilay)/PlantR(ivg)
                        dfvtot=dfvtot+auxdfv
                    ENDIF
                  ENDDO
                        dwvdpv=dfvtot-detrpv
                        psivTV(i,j,msc)=psivTV(i,j,msc)-wtbalv/dwvdpv
                  IF   (psivTV(i,j,msc).LE.pvmin) psivTV(i,j,msc)=pvmin
                  IF   (psivTV(i,j,msc).GE.pvmax) psivTV(i,j,msc)=pvmax
                ELSE                                             ! bisection
                  IF   (jit.EQ.jNRmax+1)                          THEN
                    IF (wtbalv.LE.0)                              THEN
                        wtvlo          = wtbalv
                        psivTV(i,j,msc)= pvmax
                        pvhi           = pvmax
                        lostrt         = 1
                    ELSE
                        wtvhi          = wtbalv
                        psivTV(i,j,msc)= pvmin
                        pvlo           = pvmin
                        lostrt         = 0
                    ENDIF
                  ELSE IF (jit.EQ.jNRmax+2)                       THEN
                    IF  (lostrt.EQ.1) THEN
                        wtvhi          = wtbalv
                        psivTV(i,j,msc)= pvmin
                        pvlo           = pvmin
                    ELSE
                        wtvlo          = wtbalv
                        psivTV(i,j,msc)= pvmax
                        pvhi           = pvmax
                    ENDIF
                  ELSE
                    IF (wtbalv*wtvlo.GT.0) THEN
                        pvlo           = psivTV(i,j,msc)
                        wtvlo          = wtbalv
                    ELSE
                        pvhi           = psivTV(i,j,msc)
                        wtvhi          = wtbalv
                    ENDIF
                        psivTV(i,j,msc)=(pvlo+pvhi)*0.5d0
                  ENDIF
                ENDIF
              ENDDO
C +
            ELSE                              ! IF (ABS(delta-1.).LT.1.E-06)
C +
              DO ilay=1,llx
                fvtr(ilay) = 0.
              ENDDO
C +
            ENDIF                             ! IF (ABS(delta-1.).LT.1.E-06)
C +
 102        CONTINUE
C +...      Pas op! Gevaarlijk uit de do loop uit te gaan
C +
            jit2=jit
C +
          ELSE                                                  ! (ivg.NE.0)
C +
                hv         = 0.
                alev       = 0.
                rsv        = 0.
                rlv        = 0.
              DO ilay=1,llx
                fvtr(ilay) = 0.
              ENDDO
C +
          ENDIF                                                 ! (ivg.NE.0)
c
c-----------------------------------------------------------------------------
c-----GROUND SURFACE ENERGY FLUXES--------------------------------------------
c-----------------------------------------------------------------------------
c
          IF (isl.EQ.0.OR. TsogNR)                           THEN ! (TsogNR)
C +
            DO jit=1,100
C +
C +
C +--Computation of htbalg(Tg)
C +  -------------------------
C +
                vTSurf=    xsigt*tvpr+xsigtc*TgrdTV(i,j,msc)
                ribnom=    vTAir*ua*ua
                rib   =9.8*vzAir*(vTAir-vTSurf)/ribnom
              IF (vTSurf.GT.vTAir)                                THEN
                anoemh=     1.+bhstab*sqrt(-rib) -10.*rib
                stabh =    (1.+bhstab*sqrt(-rib))/ anoemh
                dstdri= 5.*(2.+bhstab*sqrt(-rib))/(anoemh*anoemh)
              ELSE
                argexp=     1.0+5.0  *      rib
                stabh =     argexp*argexp
                dstdri=10.* argexp
              ENDIF
                raeroh= ra0h*stabh
                dradri= ra0h*dstdri
                dridtg=-xsigtc*9.8*vzAir/ribnom
                hg    = xsigtc* rhAir                   *Cp_Air
     .                        *(TgrdTV(i,j,msc)-vTAir ) /raeroh
                expon =17.27  *(TgrdTV(i,j,msc)-273.16)
     .                        /(TgrdTV(i,j,msc)-35.8)
                qsatg = 0.0038*exp(expon)
              IF (isl.EQ.0)                                       THEN
                hu    = 1.
              ELSE
                hu    =        exp(-7.2E-5*pgpr)
              ENDIF
                tgrn  = TgrdTV(i,j,msc)
                qgr   = hu    *qsatg
                HLflug= xsigtc*rhAir *Vap_LH*(qgr-vQAir)/raeroh
                RnIR_g= EpsGro*xtaud *vRadL
     .                 +EpsVeg*xtaudc*StefBo*tvpr*tvpr*tvpr*tvpr
     .                 -EpsGro       *StefBo*tgrn*tgrn*tgrn*tgrn
                ggrg  = conth1*2.*(TgrdTV(i,j,msc)
     .                            -TsolTV(i,j,msc,1))/deptTV(1)
                htbalg= RnSo_g+RnIR_g-hg-HLflug-ggrg
C +
C +
C +--Evaluation of htbalg(Tg)
C +  ------------------------
C +
              IF (isl.EQ.0) htbalg=0.
C +
              IF (ABS(htbalg).LE.0.1)                        GO TO 103
C +
C +--Computation update Tg
C +  ~~~~~~~~~~~~~~~~~~~~~
              IF (jit.LE.jNRmax)                          THEN ! Newton step
                  tgrn   = TgrdTV(i,j,msc)
                  dradtg = dradri*dridtg
                  dhgtg  =(rhAir*Cp_Air*xsigtc/raeroh)
     .            *(1.-(tgrn-vTAir)    *dradtg/raeroh)
                  dlegtg =(rhAir*Vap_LH*xsigtc/raeroh)
     .            *((qgr*4099.2/(tgrn-35.8)**2.)
     .            - (qgr-vQAir)        *dradtg/raeroh)
                  dggrtg= 2.*conth1/deptTV(1)
                  drlgtg=-4.*EpsGro*StefBo*tgrn*tgrn*tgrn
                  dhgdtg= drlgtg-dhgtg-dlegtg-dggrtg
C +
                  TgrdTV(i,j,msc)  =     TgrdTV(i,j,msc)-htbalg/dhgdtg
                  TgrdTV(i,j,msc)  = max(TgrdTV(i,j,msc),tgmin)
                  TgrdTV(i,j,msc)  = min(TgrdTV(i,j,msc),tgmax)
              ELSE                                               ! bisection
                IF (jit.EQ.jNRmax+1)                              THEN
                  IF                (htbalg.GE.0)                 THEN
                    htglo          = htbalg
                    TgrdTV(i,j,msc)= tgmax
                    tghi           = tgmax
                    lostrt=1
                  ELSE
                    htghi          = htbalg
                    TgrdTV(i,j,msc)= tgmin
                    tglo=tgmin
                    lostrt=0
                  ENDIF
                ELSE IF (jit.EQ.jNRmax+2)                         THEN
                  IF (lostrt.EQ.1) THEN
                    htghi          = htbalg
                    TgrdTV(i,j,msc)= tgmin
                    tglo           = tgmin
                  ELSE
                    htglo          = htbalg
                    TgrdTV(i,j,msc)= tgmax
                    tghi           = tgmax
                  ENDIF
                ELSE
                  IF (htbalg*htglo.GT.0)                          THEN
                    tglo           = TgrdTV(i,j,msc)
                    htglo          = htbalg
                  ELSE
                    tghi           = TgrdTV(i,j,msc)
                    htghi          = htbalg
                  ENDIF
                    TgrdTV(i,j,msc)=(tglo+tghi)*0.5d0
                ENDIF
              ENDIF
C +
            ENDDO
C +
 103      CONTINUE
C +...    Pas op! Gevaarlijk uit de do loop uit te gaan
C +
          jit3=jit
C +
C +
C +--Ground Heat Flux
C +  ----------------
C +
            IF (isl.NE.0)                                         THEN
              FcdH_g =ggrg
            ELSE
              FcdH_g =0.
            ENDIF
C +
C +
C +--Atmospheric Heat Fluxes
C +  -----------------------
C +
          ELSE                                                    ! (TsogNR)
                vTSurf=    xsigt*tvpr+xsigtc*TgrdTV(i,j,msc)
                ribnom=    vTAir*ua*ua
                rib   =9.8*vzAir*(vTAir-vTSurf)/ribnom
              IF (vTSurf.GT.vTAir)                                THEN
                anoemh=     1.+bhstab*sqrt(-rib) -10.*rib
                stabh =    (1.+bhstab*sqrt(-rib))/ anoemh
                dstdri= 5.*(2.+bhstab*sqrt(-rib))/(anoemh*anoemh)
              ELSE
                argexp=     1.0+5.0  *      rib
                stabh =     argexp*argexp
                dstdri=10.* argexp
              ENDIF
                raeroh= ra0h*stabh
                dradri= ra0h*dstdri
                dridtg=-xsigtc*9.8*vzAir/ribnom
C +
                expon =17.27  *(TgrdTV(i,j,msc)-273.16)
     .                        /(TgrdTV(i,j,msc)-35.8)
                qsatg = 0.0038*exp(expon)
              IF (isl.EQ.0)                                       THEN
                hu    = 1.
              ELSE
                hu    =        exp(-7.2E-5*pgpr)
              ENDIF
                tgrn  = TgrdTV(i,j,msc)
                qgr   = hu    *qsatg
                HLflug= xsigtc*rhAir *Vap_LH*(qgr-vQAir)/raeroh
                DwnIRg= EpsGro*xtaud *vRadL
     .                 +EpsVeg*xtaudc*StefBo*tvpr*tvpr*tvpr*tvpr
                Up_IRg=-EpsGro       *StefBo*tgrn*tgrn*tgrn*tgrn
                RnIR_g= DwnIRg+Up_IRg
                ggrg  = conth1*2.*(TgrdTV(i,j,msc)
     .                            -TsolTV(i,j,msc,1))/deptTV(1)
          ENDIF                                                   ! (TsogNR)
c
c-----------------------------------------------------------------------------
c-----GROUND SURFACE WATER FLUXES---------------------------------------------
c-----------------------------------------------------------------------------
c
          IF (isl.NE.0.AND.etagNR)                           THEN ! (etagNR)
C +
            DO jit=1,100
C +
C +
C +--Computation wtbalg(psigTV)
C +  --------------------------
C +
                expon =17.27  *(tgpr-273.16)/(tgpr-35.8)
                qsatg = 0.0038*exp(expon)
                hu    =        exp(-7.2E-5*psigTV(i,j,msc))
                qgr   =hu    *qsatg
                eg    =xsigtc*rhAir*(qgr-vQAir)/raeroh
              IF (raingr.GT.0.)                                   THEN
                wtbalg=0.
              ELSE
                Fdif_g= RhoWat*conhyd    *2.d0
     .                *(psi(1)     -psigTV(i,j,msc)) / deptTV(1)
                F_gr_g= RhoWat*aksat(isl)
     .                *(psisat(isl)/psigTV(i,j,msc))
     .               **(2.+(3./bclap(isl)))
                Fdg__g= Fdif_g     +F_gr_g
                wtbalg=-eg         -Fdg__g
              ENDIF
C +
C +
C +--Evaluation wtbalg(psigTV)
C +  -------------------------
C +
              IF (Vap_LH*ABS(wtbalg).LE.0.1)                 GO TO 104
C +
C +--Computation update psigTV
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
              IF   (jit.LE.jNRmax)                        THEN ! Newton step
                    degpg=-7.2d-5*(rhAir*xsigtc/raeroh)*qgr
                    dfgpg=-2.*RhoWat*conhyd/deptTV(1)
     .                                              -((2.+3./bclap(isl))
     .                /             psigTV(i,j,msc)) *aksat(isl) *RhoWat
     .                *(psisat(isl)/psigTV(i,j,msc))**(2.+3./bclap(isl))
                   dwgdpg=-degpg-dfgpg
C +
                    psigTV(i,j,msc)  =        psigTV(i,j,msc)
     .                                       -wtbalg/dwgdpg
                IF (psigTV(i,j,msc).LE.pgmin) psigTV(i,j,msc)=pgmin
                IF (psigTV(i,j,msc).GE.pgmax) psigTV(i,j,msc)=pgmax
              ELSE                                               ! bisection
                IF (jit.EQ.jNRmax+1)                              THEN
                  IF                 (wtbalg.LE.0)                THEN
                    wtglo           = wtbalg
                    psigTV(i,j,msc) = pgmax
                    pghi            = pgmax
                    lostrt          = 1
                  ELSE
                    wtghi           = wtbalg
                    psigTV(i,j,msc) = pgmin
                    pglo            = pgmin
                    lostrt          = 0
                  ENDIF
                ELSE IF (jit.EQ.jNRmax+2)                         THEN
                  IF (lostrt.EQ.1)                                THEN
                    wtghi           = wtbalg
                    psigTV(i,j,msc) = pgmin
                    pglo            = pgmin
                  ELSE
                    wtglo           = wtbalg
                    psigTV(i,j,msc) = pgmax
                    pghi            = pgmax
                  ENDIF
                ELSE
                  IF (wtbalg*wtglo.GT.0)                          THEN
                    pglo            = psigTV(i,j,msc)
                    wtglo           = wtbalg
                  ELSE
                    pghi            = psigTV(i,j,msc)
                    wtghi           = wtbalg
                  ENDIF
                    psigTV(i,j,msc) =(pglo+pghi)*0.5d0
                ENDIF
              ENDIF
            ENDDO
C +
 104      CONTINUE
C +...    Pas op! Gevaarlijk uit de do loop uit te gaan
C +
          jit4=jit
c
          ENDIF                                                   ! (etagNR)
c
c-----------------------------------------------------------------------------
c-----NEWTON-RAPHSON SCHEME STATISTICS----------------------------------------
c-----------------------------------------------------------------------------
c
          jitmax=MAX(jit1,jit2,jit3,jit4)
C +
          IF (jitmax.GE.90)                                       THEN
c #       IF (jitmax.GE.90.OR.(i.eq.64.and.j.eq.31.and.msc.eq.1)
c #  .                    .OR.(i.eq.28.and.j.eq.48.and.msc.eq.1)
c #  .                    .OR.(i.eq.60.and.j.eq.50.and.msc.eq.3)
c #  .                    .OR.(i.eq.65.and.j.eq.58.and.msc.eq.3)
c #  .                    .OR.(i.eq.60.and.j.eq.59.and.msc.eq.2)
c #  .                    .OR.(i.eq.60.and.j.eq.60.and.msc.eq.3)
c #  .                    .OR.(i.eq.90.and.j.eq.72.and.msc.eq.3)
c #  .                    .OR.(i.eq.22.and.j.eq.73.and.msc.eq.3)
c #  .                    .OR.(i.eq.81.and.j.eq.73.and.msc.eq.3)) THEN
            write(6,5999) itexpe,i,j,msc,jit1,jit2,jit3,jit4
 5999       format(/,' SVAmod (?)',2i6,2i4,i6,3i4)
            write(6,1002)
     .             jdarGE,           labmGE(mmarGE),iyrrGE,
     .             jhlrGE(i   ,j   ),minuGE        ,jsecGE,
     .             vVAir,vTAir,1000.*vQAir,vRadS,vRadL,3600.*vRain,
     .         msc,TvegTV(i,j,msc),psivTV(i,j,msc),rsv,rlv,hv,alev,
     .             TgrdTV(i,j,msc),psigTV(i,j,msc),
     .             RnSo_g,RnIR_g,hg,HLflug,
     .            (TsolTV(i,j,msc,ilay),
     .        1.d3*eta_TV(i,j,msc,ilay),ilay=1,llx)
          END IF
c
c-----------------------------------------------------------------------------
c-----FRICTION VELOCITY-------------------------------------------------------
c-----------------------------------------------------------------------------
c
            vTSurf=    xsigt*TvegTV(i,j,msc)+xsigtc*TgrdTV(i,j,msc)
            ribnom=    vTAir*ua*ua                ! slechts 1 keer berekenen
            rib   =9.8*vzAir*(vTAir-vTSurf)/ribnom
C +
          IF  (vTSurf.GT.vTAir)                                     THEN
            anoemm= 1.+bmstab*sqrt(-rib)-10.*rib
            stabm =(1.+bmstab*sqrt(-rib))/anoemm
          ELSE
            stabm =(1.+5.*rib)**2.
          ENDIF
C +
            raerom=     ra0m *stabm
            ustr  =sqrt(vVAir/raerom)
            stress=     rhAir*ustr*ustr
c
c-----------------------------------------------------------------------------
c-----UPDATE CANOPY WATER CONTENT (empty)-------------------------------------
c-----------------------------------------------------------------------------
c
          IF (ivg.NE.0)                                           THEN
                CaWaTV(i,j,msc)=CaWaTV(i,j,msc)-vdt*edir
            IF (CaWaTV(i,j,msc).LE.1.E-20)                        THEN
                CaWaTV(i,j,msc)=0.0
            ENDIF
          ENDIF
c
c-----------------------------------------------------------------------------
c-----UPDATE SOIL MOISTURE CONTENTS (Crank-Nicholson)-------------------------
c-----------------------------------------------------------------------------
c
          IF (isl.NE.0)                                           THEN
C +
C +
C +--Water overflow evaluation
C +  -------------------------
C +
            IF   (raingr.GT.0.)                                   THEN
              xD1   =csat1(isl)*eta_TV(i,j,msc,1)**(bclap(isl)+2.)
              FdgMax=RhoWat*xD1*2.
     .                     *(etasat(isl)-eta_TV(i,j,msc,1))/deptTV(1)
     .              +RhoWat*  aksat(isl)
              IF (raingr.GT.FdgMax) THEN ! complete previous test on raingr
                  Fdg__g =  FdgMax
              ELSE
                  Fdg__g =  raingr
              ENDIF
                  detamx =0.1*deptTV(1)*RhoWat*eta_TV(i,j,msc,1)
     .                                       /(bclap(isl)+2.)
                  dtmax  =     detamx/Fdg__g
                  dtmax  = MAX(dtmax ,r_ten)
              IF (dtmax.LT.vdt)                                   THEN
                  nflow  =AINT(vdt/dtmax) +1
                  dtwtr  =     vdt/nflow
              ELSE
                  nflow  =                 1
                  dtwtr  =     vdt
              ENDIF
C +
C +--Surface Humidity
C +  ~~~~~~~~~~~~~~~~
                  eta__g =  etasat(isl)
            ELSE
                  nflow  =                 1
                  dtwtr  =     vdt
C +
C +--Surface Humidity
C +  ~~~~~~~~~~~~~~~~
                  eta__g =  etasat(isl)
     .                    *(psisat(isl)/psigTV(i,j,msc))
     .               **(unun/bclap(isl))
            ENDIF
C +
            IF (iprnt.eq.1)                                       THEN
              DO iiw=1,iptx
                IF (i.EQ.IOi_TV(iiw).AND.j.EQ.IOj_TV(iiw).AND.
     .                   ifraTV(i,j,msc).gt.0                )    THEN
                  WRITE(nunit(iiw,msc),1003)
     .               jdarGE,           labmGE(mmarGE),iyrrGE,
     .               jhlrGE(i   ,j   ),minuGE        ,jsecGE,
     .               RainGr,Fdg__g,FdgMax,eta__g,etasat(isl)
 1003             FORMAT(/,i3,'-',a3,'-',i4,'/',i3,'.',i2,'.',i2,3x,
     .               ' RainGr',d15.6,' Fdg__g',d15.6,'  FdgMax',d15.6,
     .               /,47x,
     .               ' eta__g',d15.6,'  etasat',d15.6)
                ENDIF
              END DO
            END IF
C +
            DO ilay=1,llx
                  omwtr(ilay) = dtwtr/deptTV(ilay)
            ENDDO
C +
C +
C +--Start update
C +  ------------
C +
               kflow        = 0
C +
               watflw       = 0.0d+0
               runoff(msc)  = 0.0d+0
               draing(msc)  = 0.0d+0
C +
               eta_g0       = eta__g
            DO ilay=1,llx
               eta__n(ilay) = eta_TV(i,j,msc,ilay)
            END DO
               eta__n(llx+1)= eta__n(        llx)
C +...         zero gradient assumption
C +
 201        CONTINUE
C +
            DO iwater=1,nflow
C +
              xD1   =csat1(isl)*eta__n(        1)**(bclap(isl)+r_two)
              FdgMax=RhoWat*xD1*2.
     .                   *(etasat(isl)-eta__n(        1)) / deptTV(1)
     .              +RhoWat*aksat(isl)
C +
C +--Surface Humidity Contribution for     Saturation Conditions
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              IF   (raingr.GT.0.)                                 THEN
                IF (raingr.GT.FdgMax)                             THEN
                    Fdg__g =  FdgMax
                    watflw =  raingr-Fdg__g
                ELSE
                    Fdg__g =  raingr
                    watflw =  0.
                ENDIF
                    Fdg_gB =  0.
              ELSE
C +
C +--Surface Humidity Contribution for Non Saturation Conditions
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                IF (isl.NE.0.AND..NOT.etagNR)                     THEN
C +
C +--Water Diffusivity  Contribution
c #                 eta_g1 =(eta__g+eta__n(1)) * 0.5d0
                    eta_g1 =        eta__n(1)
                    difh_g = RhoWat
     .                      * csat1(isl)*eta_g1 ** (r_two+bclap(isl))
                    bD_eta = difh_g            * 2.0d0     /deptTV(1)
                    AD_eta = bD_eta
C +
C +--Water Conductivity Contribution
                    conh_g = csat2(isl)*eta__g  ** (r_two*bclap(isl)
     .                                             +r_thr)
                    B_gr_g = RhoWat *(1.0d0+bclap(isl))* 2.0d0 * conh_g
                    A_gr_g =-RhoWat *(2.0d0*bclap(isl) + 3.0d0)* conh_g
     .                     / eta__g
C +
C +--Atmospheric        Contribution
                    exponT =17.27  *(tgpr-273.16)/(tgpr-35.8)
                    qsat_g = 0.0038* exp(exponT)
                    aK_Atm = xsigtc* rhAir       /raeroh
                    r_psig = 7.2E-5* psigTV(i,j,msc)
                    rbpsig = r_psig* bclap(     isl)
                    r_humg =    exp(-r_psig)
                    B_Atmg = aK_Atm*(vQAir-qsat_g*r_humg*(1.d0-rbpsig))
                    A_Atmg =-aK_Atm*       qsat_g*r_humg*      rbpsig
     .                     / eta__g
C +
C +--Numerical Coefficients for SBC
                    A2_eta = AD_eta + A_gr_g
                    A3_eta = A_Atmg + A2_eta
                    B2_eta = B_Atmg + B_gr_g
C +
                    Fdg_gB = bD_eta *(A2_eta / A3_eta - 1.0d00)
                    Fdg__g =          A2_eta * B2_eta / A3_eta - B_gr_g
                ENDIF
C +
C +--Water Flow
                    watflw =  0.
              ENDIF
C +
C +--Soil    Humidity Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                conh2(0   ) = 0.0d+0
                gamah(0   ) = 0.0d+0
              DO ilay=1,llx-1
                eta_2(ilay) = 0.5d+0*(deptTV(ilay)  *eta__n(ilay+1)
     .                              + deptTV(ilay+1)*eta__n(ilay)  )
     .                              / dep2TV(ilay)
                difh2       =csat1(isl)*eta_2( ilay)**(r_two+bclap(isl))
                conh2(ilay) =csat2(isl)*eta__n(ilay)**(r_two*bclap(isl)
     .                                                +r_thr)
                gamah(ilay) =     difh2/dep2TV(ilay)
              END DO
                conh2(llx ) =iWaFTV(i,j)
     .                      *csat2(isl)*eta__n( llx)**(r_two*bclap(isl)
     .                                                +r_thr)
C +...                      (iWaFTV=0 > no flux;
C +                          iWaFTV=1 > free drainage)
C +
                gamah(llx ) =     0.0d0
C +
C +
C +--Set Up of the tridiagonal system
C +  ================================
C +
              DO k=1,llx
                conh2f        =  conh2(k) -conh2(k-1)
C +
C +--In Case of      explicit Resolution of the Conduction Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                conh2D        =  conh2f
                conh2A        =  0.0d+0
                conh2B        =  0.0d+0
C +
C +--In Case of semi-implicit Resolution of the Conduction Contribution
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #CI           conh2D        =  conh2D*(Explic
c #CI.                                  -Implic*2.0d0*(bclap(isl)+1.d0))
c #CI           conh2A        =-(conh2(k-1)/eta__n(k-1))
c #CI.                                  *Implic*(2.0d0*bclap(isl)+3.d0)
c #CI           conh2B        = (conh2(k)  /eta__n(k)  )
c #CI.                                  *Implic*(2.0d0*bclap(isl)+3.d0)
C +...WARNING:  unstable !
C +
C +--Matrix Coefficients
C +  ~~~~~~~~~~~~~~~~~~~
                Elem_A        =  omwtr(k) *gamah(k-1)
                Elem_C        =  omwtr(k) *gamah(k)
                Diag_A(k)     = -Elem_A   *Implic
     .                          +omwtr(k) *conh2A 
                Diag_C(k)     = -Elem_C   *Implic 
                Diag_B(k)     =  1.0d+0   -Diag_A(k) -Diag_C(k) 
     .                          +omwtr(k) *conh2B
                Term_D(k)     =  Explic  *(Elem_A    *eta__n(k-1)
     .                                    +Elem_C    *eta__n(k+1))
     .                 +(1.0d+0 -Explic  *(Elem_A
     .                                    +Elem_C))  *eta__n(k)
     .                          -omwtr(k)*(conh2D
     .                                    +fvtr(  k) /RhoWat)
              END DO
C +
                Diag_B(1)     = Diag_B(1)
     .                          -omwtr(1) *Fdg_gB    /RhoWat
                Term_D(1)     = Term_D(1)
     .                          +omwtr(1) *Fdg__g    /RhoWat
C +
C +
C +--Solve     the tridiagonal system
C +  ================================
C +
C +
C +           *********
              CALL tlat(Diag_A,Diag_B,Diag_C,Term_D,
     .                  Term_P,Term_Q,llx,llx,Var__X)
C +           *********
C +
C +..To be generalized in case of implicit prediction
C +                    of the skin surface humidity    (i.e., to k=0)
C +
              DO k=1,llx
                eta__n(        k) = Var__X(k)
              END DO
              IF (isl.NE.0.AND..NOT.etagNR)                       THEN
                eta__g =(eta__n(1) * bD_eta + B2_eta)/A3_eta
                eta__g = min(eta__g,etgMax(isl))
                eta__g = max(eta__g,etgMin(isl))
                psigTV(i,j,msc) = psisat(isl)
     .                          *(etasat(isl)/eta__g)**bclap(isl)
              END IF
C +
C +
C +--Runoff from overflow soil layers
C +  --------------------------------
C +
              DO itst=llx,1,-1
                IF    (eta__n(itst).GT.etasat(isl))               THEN
                  IF  (itst.NE.1)                                 THEN
                    deleta=                        deptTV(itst)
     .               *(eta__n(itst) - etasat(isl))/deptTV(itst-1)
                       eta__n(itst-1)=
     .                 eta__n(itst-1)+deleta
                  ELSE
                    watflw=watflw    +RhoWat      *deptTV(itst)
     .               *(eta__n(itst) - etasat(isl))/vdt
                  ENDIF
                       eta__n(itst) = etasat(isl)
                ENDIF
              ENDDO
C +
              runoff(msc) = runoff(msc)+watflw           /nflow
              draing(msc) = draing(msc)+RhoWat*conh2(llx)/nflow
C +
                                           LFlow =  0
              DO ilay=1,llx
               IF (eta__n(ilay).lt.0.d0)   LFlow = -1
              END DO
C +
              IF (iprnt.eq.1)                                     THEN
                DO iiw=1,iptx
                  IF (i.EQ.IOi_TV(iiw).AND.j.EQ.IOj_TV(iiw).AND.
     .                     ifraTV(i,j,msc).gt.0                )  THEN
                    WRITE(nunit(iiw,msc),1004)
     .                 jdarGE,           labmGE(mmarGE),iyrrGE,
     .                 jhlrGE(i   ,j   ),minuGE        ,jsecGE,
     .                 runoff(msc),draing(msc),watflw,
     .                 iwater,     kflow,      lflow,
     .                 eta__g,(eta__n(ilay),ilay=1,llx)
 1004               FORMAT(/,i3,'-',a3,'-',i4,'/',i3,'.',i2,'.',i2,3x,
     .                 ' runoff',d15.6,' draing',d15.6,' watflw',d15.6,
     .                 /,47x,
     .                 ' iwater',i15  ,'  kflow',i15  ,'  lflow',i15,
     .                 /,47x,
     .                 ' eta   ',10f7.4)
                  ENDIF
                END DO
              END IF
C +
C +--Integration RESET in case of negative Soil Humidity
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              IF  (LFlow.lt.0)                                    THEN
C +
                   write(51,510)itexpe,i,j,msc,nflow,
     .                         (eta__n(ilay),ilay=1,llx)
 510               format(2i6,2i4,'  (',i2,')   0 > eta =',10f7.4)
C +
                   kflow =  1 + kflow
                   nflow =  1 + nflow
                   dtwtr =  vdt/nflow
C +
                   eta__g       = eta_g0
                DO ilay=1,llx
                   omwtr( ilay) = dtwtr / deptTV(ilay)
                   eta__n(ilay) = eta_TV(i,j,msc,ilay)
                END DO
                   eta__n(llx+1)= eta__n(        llx)
C +...             zero gradient assumption
C +
                   watflw       = 0.0d+0
                   runoff(msc)  = 0.0d+0
                   draing(msc)  = 0.0d+0
C +
              END IF
              IF  (LFlow.lt.0)                               GO TO 201
C +
            ENDDO                                           ! iwater=1,nflow
C +
C +
C +--END UPDATE
C +  ----------
C +
            DO ilay=1,llx
               eta_TV(i,j,msc,ilay) =  eta__n(ilay)
            END DO
C +
C +
C +--Latent Heat Flux
C +  ----------------
C +
               expon =17.27  *(TgrdTV(i,j,msc)-273.16)
     .                       /(TgrdTV(i,j,msc)-35.8)
               qsatg = 0.0038*exp(expon)
            IF (isl.EQ.0)                                         THEN
               hu    = 1.
            ELSE
               hu    =        exp(-7.2E-5*psigTV(i,j,msc))
            ENDIF
               qgr   = hu    *qsatg
               HLflug= xsigtc*rhAir *Vap_LH*(qgr-vQAir)/raeroh
c
c-----------------------------------------------------------------------------
c-----UPDATE SOIL TEMPERATURES (Crank-Nicholson)------------------------------
c-----------------------------------------------------------------------------
c
C +
C +
C +--Surface Temperature Implicit Contribution
C +  =========================================
C +
            IF (.NOT.TsogNR)                                      THEN
                Up_IRa = EpsGro * StefBo
     .                  *TgrdTV(i,j,msc)*TgrdTV(i,j,msc)*TgrdTV(i,j,msc)
                HSflua = xsigtc * rhAir  * Cp_Air/raeroh
                conh_g = conth1          * 2.0d+0/deptTV(1)
                Sum__A = RnSO_g + DwnIRg + 3.0d+0*Up_IRa*TgrdTV(i,j,msc)
     .                  -HLflug          +        HSflua* vTAir
                Sum__B = conh_g          + 4.0d+0*Up_IRa+HSflua
C +
                FcdH_g = conh_g * Sum__A/Sum__B
                FcdHgB = conh_g *(conh_g/Sum__B - 1.0d+0)
            ELSE
                FcdHgB = 0.0d+0
            END IF
C +
              gamat(   0) = 0.0d+0
            DO ilay=1,llx-1
              eta_2(ilay) = 0.5*(deptTV(ilay)  *eta_TV(i,j,msc,ilay+1)
     .                          +deptTV(ilay+1)*eta_TV(i,j,msc,ilay)  )
     .                          /dep2TV(ilay)
              psi_2       =      psisat(isl)
     .                         *(etasat(isl)/eta_2(ilay))**bclap(isl)
              argcon      =      3.82d0    *(psi_2)     **(-0.4343d0)
              thcond   = min(max(argcon,conmin),r_two)
              gamat(ilay) =      thcond     /dep2TV(ilay)
              alpha(ilay)= omega(ilay)/(rhocsl(isl)
     .                                 +RhoWCW*eta_TV(i,j,msc,ilay))
            END DO
              gamat( llx) = 0.0d+0
              alpha( llx)= omega( llx)/(rhocsl(isl)
     .                                 +RhoWCW*eta_TV(i,j,msc, llx))
C +
C +
C +--Set Up of the tridiagonal system
C +  ================================
C +
              Tsol_n(0)     = TsolTV(i,j,msc,1)
            DO k=1,llx
              Tsol_n(k)     = TsolTV(i,j,msc,k)
            END DO
              Tsol_n(llx+1) = TsolTV(i,j,msc,llx)
C +...        zero gradient assumption
C +
            DO k=1,llx
              Elem_A        =  alpha(k)*gamat(k-1)
              Elem_C        =  alpha(k)*gamat(k)
              Diag_A(k)     = -Elem_A  *Implic
              Diag_C(k)     = -Elem_C  *Implic
              Diag_B(k)     =  1.0d+0  -Diag_A(k) -Diag_C(k)
              Term_D(k)     =  Explic *(Elem_A    *Tsol_n(k-1)
     .                                 +Elem_C    *Tsol_n(k+1))
     .               +(1.0d+0 -Explic *(Elem_A
     .                                 +Elem_C))  *Tsol_n(k)
            END DO
              Diag_B(1)     =  Diag_B(1)-alpha(1) *FcdHgB
              Term_D(1)     =  Term_D(1)+alpha(1) *FcdH_g
C +
C +
C +--Solve     the tridiagonal system
C +  ================================
C +
C +         *********
            CALL tlat(Diag_A,Diag_B,Diag_C,Term_D,
     .                Term_P,Term_Q,llx,llx,Var__X)
C +         *********
C +
C +..To be generalized in case of implicit prediction
C +                    of the skin surface temperature (i.e., to k=0)
C +
            DO k=1,llx
              TsolTV(i,j,msc,k) = Var__X(k)
            END DO
C +
            IF (.NOT.TsogNR)                                        THEN
              TgrdTV(i,j,msc)   =(Sum__A+conh_g*TsolTV(i,j,msc,1))
     .                           /Sum__B
            END IF
C +
          ENDIF                                                 ! (isl.NE.0)
c
c-----------------------------------------------------------------------------
c-----WRITE TO OUTPUT FILES (point data)--------------------------------------
c-----------------------------------------------------------------------------
c
c #       IF (iprnt.EQ.1)                                         THEN
            DO iiw=1,iptx
              IF (i.EQ.IOi_TV(iiw).AND.j.EQ.IOj_TV(iiw).AND.
     .                 ifraTV(i,j,msc).gt.0                )      THEN
                WRITE(nunit(iiw,msc),1002)
     .             jdarGE,           labmGE(mmarGE),iyrrGE,
     .             jhlrGE(i   ,j   ),minuGE        ,jsecGE,
     .             vVAir,vTAir,1000.*vQAir,vRadS,vRadL,3600.*vRain,
     .                        msc,
     .             TvegTV(i,j,msc),psivTV(i,j,msc),rsv,rlv,hv,alev,
     .             TgrdTV(i,j,msc),psigTV(i,j,msc),
     .             RnSO_g,RnIR_g,hg,HLflug,
     .            (TsolTV(i,j,msc,ilay),
     .             eta_TV(i,j,msc,ilay)*1.d3,ilay=1,llx)
 1002           FORMAT(/,i3,'-',a3,'-',i4,'/',i3,'.',i2,'.',i2,3x,
     .                    '  vVAir',f9.2,'   vTAir', f9.2,
     .                   '   vQAir',f9.2,'   vRadS', f9.2,
     .                   '   vRadL',f9.2,'   vRain', f9.2,
     .                 /,21x,                                  i3,
     .                   '    TVeg',f9.2,'    psiV', f9.2,
     .                   '    rsV ',f9.2,'    rlV ', f9.2,
     .                   '    hV  ',f9.2,'    aleV', f9.2,
     .                 /,21x,                                  3x,
     .                   '    TGrd',f9.2,'    psiG', f9.2,
     .                   '    rsG ',f9.2,'    rlG ', f9.2,
     .                   '    hG  ',f9.2,'    aleG', f9.2,
     .                 /,21x,                                  3x,
     .                   '    TSol',f9.2,'    etaS', f9.2,
     .                /,(21x,                                  3x,
     .                   '        ',f9.2,'        ', f9.2))
              ENDIF
            END DO
c #       ENDIF
c
c-----------------------------------------------------------------------------
c-----TOTAL SURFACE FLUXES----------------------------------------------------
c-----------------------------------------------------------------------------
c
            ha  =hv  +hg
            alea=alev+HLflug
            rnet=rsv +RnSO_g +rlv +RnIR_g
c
c
c-----------------------------------------------------------------------------
c-----AVERAGING OVER SUBGRID PATCHES (mosaic)---------------------------------
c-----------------------------------------------------------------------------
c
          frac       =ifraTV(i,j,msc)/100.
            havg(i,j)=  havg(i,j)+frac*ha
          aleavg(i,j)=aleavg(i,j)+frac*alea
           rnavg(i,j)= rnavg(i,j)+frac*rnet
          ggravg(i,j)=ggravg(i,j)+frac*FcdH_g
          ustavg(i,j)=ustavg(i,j)+frac*ustr**2.
          tbravg(i,j)=tbravg(i,j)+frac
     .              *(xtaudc*EpsVeg*TvegTV(i,j,msc)**4
     .               +xtaud *EpsGro*TgrdTV(i,j,msc)**4) ! pas op voor water !!
           tgavg     =tgavg +frac*vTSurf
          qslavg     =qslavg+frac*(vQAir+alea*raeroh/(rhAir*Vap_LH))
          albavg     =albavg+frac*albedo
           emavg     =emavg +frac*SolEmi
C +
          eta1m=eta1m+frac*eta_TV(i,j,msc,1)
          eta2m=eta2m+frac*eta_TV(i,j,msc,2)
          eta3m=eta3m+frac*eta_TV(i,j,msc,3)
          eta4m=eta4m+frac*eta_TV(i,j,msc,4)
C +
          T1m  =T1m  +frac*TsolTV(i,j,msc,1)
          T2m  =T2m  +frac*TsolTV(i,j,msc,2)
          T3m  =T3m  +frac*TsolTV(i,j,msc,3)
          T4m  =T4m  +frac*TsolTV(i,j,msc,4)
C +
          runoTV(i,j)= runoTV(i,j) + frac*runoff(msc)*vdt
          draiTV(i,j)= draiTV(i,j) + frac*draing(msc)*vdt
C +
        ENDIF                                      ! points with ifraTV NE 0
      ENDDO                                ! end of DO-loop over all subgrid
c
c-----------------------------------------------------------------------------
c-----AVERAGE FIELDS ---------------------------------------------------------
c-----------------------------------------------------------------------------
c
      tbravg(i,j)=tbravg(i,j)**0.25
      ustavg(i,j)=sqrt(ustavg(i,j))
       etavg(i,j)=(eta1m*depth(1)+eta2m*depth(2)
     .            +eta3m*depth(3)+eta4m*depth(4))/dptot
       Tsavg(i,j)=(T1m  *depth(1)+T2m  *depth(2)
     .            +T3m  *depth(3)+T4m  *depth(4))/dptot
c
c-----------------------------------------------------------------------------
c-----OUTPUT TO ATMOSPHERIC MODEL---------------------------------------------
c-----------------------------------------------------------------------------
c
      vTsBr=      tbravg(i,j)
      vTsIR= vTsBr/emavg**(0.25)
      vAlbS=      albavg
      vEmiS=       emavg
      vTa_S=       tgavg
      vQa_S=      qslavg
      vHS_S=        havg(i,j)
      vHL_S=      aleavg(i,j)
      vTauS=rhAir*ustavg(i,j)**2.
C +
C +
      return
      end


      subroutine SVAsav(Ordr)

C +------------------------------------------------------------------------+
C | MAR OUTPUT                                         Sun 14-06-2009  MAR |
C |   SubRoutine SVAsav is used to save the main SVAT  Variables           |
C |                                                                        |
C | # OPTIONS:   #OA: Ocean Albedo is prescribed                           |
C | # ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'

      include 'MARdim.inc'

      include 'MARgrd.inc'
      include 'MAR_GE.inc'

c #TV include 'MAR_LB.inc'

      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
      include 'MAR_TV.inc'
      include 'MAR_VB.inc'
c #SN include 'MARsSN.inc'
      include 'MAR_BS.inc'
c #IB include 'MAR_IB.inc'

      character*4 Ordr


C +--Local  Variables
C +  ================

      character*6 vartyp
      integer     n1    ,n2    ,iteSVA,iyrSVA,mmaSVA,jdaSVA,jhuSVA,n
      integer     i50   ,j50   ,iim   ,jjm   ,msc

      logical     iniWRI

      DATA        iniWRI/.true./

      real mskSNo2(mx,my)


C +--READ
C +  ====

      IF (Ordr.eq.'read')                                         THEN


C +--Open File
C +  ---------

          OPEN (unit=11,status='old'    ,form='unformatted',
     .                                   file='MARsvt.DAT')


C +--Read DATA
C +  ---------

            READ(11) iteSVA
            READ(11) iyrSVA,mmaSVA,jdaSVA,jhuSVA
          IF   (itexpe.eq.0)                                      THEN
            IF (iteSVA.ne.itexpe.or.
     .          iyrSVA.ne.iyr0GE.or.
     .          mmaSVA.ne.mma0GE.or.
     .          jdaSVA.ne.jda0GE.or.
     .          jhuSVA.ne.jhu0GE)
     .        write(6,600)itexpe,iyrSVA,mmaSVA,jdaSVA,jhuSVA,
     .                           iyr0GE,mma0GE,jda0GE,jhu0GE
 600          format(' ++WARNING++ MARsvt improperly specified ',
     .             /,'          iyr    mma    jda    jhu',
     .             /,i6,4i7,' Old',/,6x,4i7,' Current')
          ELSE
            IF (iteSVA.ne.itexpe.or.
     .          iyrSVA.ne.iyrrGE.or.
     .          mmaSVA.ne.mmarGE.or.
     .          jdaSVA.ne.jdarGE.or.
     .          jhuSVA.ne.jhurGE)
     .        write(6,600)itexpe,iyrSVA,mmaSVA,jdaSVA,jhuSVA,
     .                           iyrrGE,mmarGE,jdarGE,jhurGE
          END IF

            READ(11) IOi_TV  ! IO i Index
            READ(11) IOj_TV  ! IO j Index
            READ(11) isolTV  ! Soil       Type Index
            READ(11) iWaFTV  ! =0 ==> no Water Flux
                             ! =1 ==> free Drainage
            READ(11) AlbSTV  ! Dry Soil       Albedo
            READ(11) ivegTV  ! Vegetation Type Index
            READ(11) ifraTV  ! Vegetation Class Coverage
            READ(11) alaiTV  !       Leaf Area Index                [-]
            READ(11) glf_TV  ! Green Leaf Fraction                  [-]
            READ(11) TsolTV  ! Soil Temperature                     [K]
            READ(11) eta_TV  ! Soil Moisture                    [m3/m3]


C +--If Simulation   start, THEN initialize further
C +  ----------------------------------------------

        IF (itexpe.eq.0)                                          THEN
          DO j=1,my
          DO i=1,mx
            IF (isolSL(i,j).eq. 1)                                THEN
c #TV           ifraTV(i,j,1) = 100
c #TV           ivegTV(i,j,1) = 0
c #TV           isolTV(i,j)   = 0
c #OA           AlbSTV(i,j)   = 0.15
            END IF
            IF (isolSL(i,j).eq. 5)                                THEN
                tsrfSL(i,j,1) = 0.0d+0
              DO n=1,nvx
                tsrfSL(i,j,1) = tsrfSL(i,j,1) 
     .                        + TsolTV(i,j,n,1)*ifraTV(i,j,n)
              END DO
                tsrfSL(i,j,1) = tsrfSL(i,j,1)  *1.0d-2
                albsSL(i,j)   = AlbSTV(i,j)
                alb0SL(i,j)   = albsSL(i,j)
                albeSL(i,j)   = albsSL(i,j)
              IF (tsrfSL(i,j,1).lt.200.)
     .            write(6,6000) i,j
 6000             format(' WARNING: undefined Surface Temperature',
     .                   ' (i j) = (',2i4,')')

            END IF

C +--Set of SISVAT Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #TV       IF      (VSISVAT)                                     THEN
c #TV         IF    (isolSL(i,j).le.2)                            THEN
c #TV                ifraTV(i,j,1)   = 100
c #TV                ivegTV(i,j,1)   = 0
c #TV                isolTV(i,j)     = 0
c #TV           IF  (reaVAR.AND.reaLBC)                           THEN
c #TV             DO n= 1,       nvx
c #TV                TvegTV(i,j,n)   = sst_LB(i,j)
c #TV             DO k= 1,       llx
c #TV                TsolTV(i,j,n,k) = sst_LB(i,j)
c #TV                eta_TV(i,j,n,k) = 1.
c #TV             END DO
c #TV             END DO
c #TV           ELSE
c #TV             DO n= 1,       nvx
c #TV                TvegTV(i,j,n)   = SST_SL
c #TV             DO k= 1,       llx
c #TV                TsolTV(i,j,n,k) = SST_SL
c #TV                eta_TV(i,j,n,k) = 1.
c #TV             END DO
c #TV             END DO
c #TV           END IF

c #TV         ELSE
c #TV           IF (.not.reaLBC)                                  THEN
c #TV             DO n= 1,       nvx
c #TV                TvegTV(i,j,n)   = SST_SL
c #TV             END DO
c #TV           ELSE
c #TV             DO n= 1,       nvx
c #TV                TvegTV(i,j,n)   = TairSL(i,j)
c #TV             END DO
c #TV           END IF
c #TV         END IF
c #TV       END IF

c #TV         DO n= 1, max(mw,nvx)
c #TV                      n1   = min(n,mw)
c #TV                      n2   = min(n,nvx)
c #TV           tsrfSL(i,j,n1)  = TsolTV(i,j,n2,1)
c #TV         END DO

          END DO
          END DO

          IF (iniWRI)                                             THEN
                                  n = 123
                                                 i50 = min(mx,66)
                                                 j50 = min(my,66)
                           vartyp =  'isolTV'
              write(4,4001)vartyp,n,((isolTV(i,j  ),i=1,i50),j=j50,1,-1)
 4001        format(/,' --- SVAsav --- ',a6,' ---',i4,' ---',/,(66i2))
 4002        format(/,' --- SVAsav --- ',a6,' ---',i4,' ---',/,(66f6.2))

                           vartyp =  'iWaFTV'
              write(4,4001)vartyp,n,((iWaFTV(i,j  ),i=1,i50),j=j50,1,-1)
            DO                    n =            1,nvx
                           vartyp =  'ifraTV'
              write(4,4002)vartyp,n,((ifraTV(i,j,n),i=1,i50),j=j50,1,-1)
                           vartyp =  'ivegTV'
              write(4,4001)vartyp,n,((ivegTV(i,j,n),i=1,i50),j=j50,1,-1)
            END DO

              iniWRI = .false.
          END IF
        END IF

C +--If SISVAT is set up
C +  ~~~~~~~~~~~~~~~~~~~
        IF (VSISVAT.AND..NOT.reaVAR)                              THEN
          DO j=1,my
          DO i=1,mx
            sst_LB(i,j) = SST_SL
            sst1LB(i,j) = SST_SL
            sst2LB(i,j) = SST_SL
          END DO
          END DO
        END IF


C +--If Simulation   start, THEN set        to zero
C +  ----------------------------------------------

        IF (itexpe.eq.0)                                          THEN
            DO msc=1,nvx
            DO jjm=1,jmx
            DO iim=1,imx
                     CaSnTV(iim,jjm,msc) =  0.0
                     CaWaTV(iim,jjm,msc) =  0.0
c #SN                WEq_SN(iim,jjm,msc) =  0.0
            ENDDO
            ENDDO
            ENDDO
c #SN       DO msc=1,nsx
c #SN       DO jjm=1,jmx
c #SN       DO iim=1,imx
c #SN                snohSN(iim,jjm,msc) =  0.0
c #SN       ENDDO
c #SN       ENDDO
c #SN       ENDDO
        END IF


C +--If Simulation restart, THEN read       further
C +  ----------------------------------------------

        IF (itexpe.ne.0.and.reaVAR)                               THEN

            READ(11) CaSnTV  ! Canopy Intercepted Snow  Content[m w.e.]
            READ(11) CaWaTV  ! Canopy Intercepted Water Content [kg/m2]
            READ(11) psivTV  ! Vegetation   Hydraulic Potential     [m]
            READ(11) psigTV  ! Ground       Hydraulic Potential     [m]
            READ(11) TvegTV  ! Skin      Vegetation Temperature     [K]
            READ(11) TgrdTV  ! Skin            Soil Temperature     [K]

            DO msc=1,nvx
            DO jjm=1,jmx
            DO iim=1,imx
                 IF (CaWaTV(iim,jjm,msc).LE.1.d-20) 
     .               CaWaTV(iim,jjm,msc) =  0.d+00
            ENDDO
            ENDDO
            ENDDO

            READ(11) evapTV  ! Total Evapotranspiration [mm w.e.]
            READ(11) draiTV  ! Drainage            Flow    [mm/s]
            READ(11) runoTV  ! Integrated Drainage Flow      [mm]


C +--Snow Pack Characteristics
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
C #SN     IF (SnoMod)                                             THEN
c #SN       if(mw.ne.5) then
c #SN       READ(11) mskSNo2 ! Snow/Ice Type Index            [-]
c #SN       do i=1,mx ; do j=1,my
c #SN       mskSNo(i,j,1)=mskSNo2(i,j)
c #SN       enddo     ; enddo
c #SN       else
c #SN       READ(11) mskSNo  ! Snow/Ice Type Index            [-]    
c #SN       endif
c #SN       READ(11) nssSNo  ! Nb Snow and     Ice Layers
c #SN       READ(11) issSNo  ! Nb Superimposed Ice Layers
c #SN       READ(11) nisSNo  ! Nb              Ice Layers
c #SN       READ(11) nhsSNo  ! Snow History                   [-]
c #SN       READ(11) dzsSNo  ! Snow Layers  Thickness         [m]
c #SN       READ(11) rosSNo  ! Snow Volumic Mass          [kg/m3]
c #SN       READ(11) wasSNo  ! Snow Water   Content       [kg/kg]
c #SN       READ(11) tisSNo  ! Snow Temperature               [K]
c #SN       READ(11) g1sSNo  ! Snow Dendricity / Sphericity   [-]
c #SN       READ(11) g2sSNo  ! Snow Sphericity / Size         [-] [0.0001 m]
c #SN       READ(11) agsSNo  ! Snow Age                     [day]
c #SN       READ(11) snohSN  ! Snow Buffer Layer    [kg/m2], [mm]
c #SN       READ(11) BrosSN  ! Snow Buffer Layer Density  [kg/m3]
c #SN       READ(11) BG1sSN  ! Snow Buffer Layer Dendri/Spher.[-]
c #SN       READ(11) BG2sSN  ! Snow Buffer Layer Spheri/Size  [-] [0.0001 m]
c #SN       READ(11) SWaSNo  ! Snow Surficial Water           [m]
c #SN       READ(11) zWE0SN  ! Initial      Snow Thickn.[mm w.e.]
c #SN       READ(11) zWE_SN  ! Current      Snow Thickn.[mm w.e.]
c #SN       READ(11) zWEcSN  ! Non-erodible Snow Thickn.[mm w.e.]
c #SN       READ(11) SaltSN  ! u*_th                        [m/s]
c #SN       READ(11) SLussl  ! u*_s*                  [kg/kg.m/s]
c #SN       READ(11) blowSN  ! NEW  MAX Erosion           [kg/m2]
c #SN       READ(11) WEq_SN  ! Added Snow Amount         [m w.e.]
c #ZM       READ(11) SLn_z0  ! Z0_momentum    (instantaneous) [m]
c #ZM       READ(11) SLn_r0  ! Z0_scalar      (instantaneous) [m]
c #BS       READ(11) SLn_b0  ! Z0_erosion     (instantaneous) [m]
c #ZA       READ(11) ua_0BS  !  Wind ,  x-component (t-dt)  [m/s]
c #ZA       READ(11) va_0BS  !  Wind ,  y-component (t-dt)  [m/s]
c #ZA       READ(11) VVs_BS  ! (wind ,  Sastrugi) Relevance [m/s]
c #ZA       READ(11) RRs_BS  ! (wind ,  Sastrugi) Counter     [-]
c #ZA       READ(11) DDs_BS  ! (wind ,  Sastrugi) Angle      [dg]
c #SZ       READ(11) Z0SaBS  ! Z0      (Sastrugi Height)      [m]
c #IB       READ(11) wes_IB  ! Snow/ice Sublimation     [mm w.e.]
c #IB       READ(11) wee_IB  ! Evapotranspiration       [mm w.e.]
c #IB       READ(11) wem_IB  ! Snow/ice Melting         [mm w.e.]
c #IB       READ(11) wer_IB  ! Snow/ice Refreezing      [mm w.e.]
c #IB       READ(11) wei0IB  ! Bottom Snow/ice added    [mm w.e.]
c #IB       READ(11) weu_IB  ! Run-off                  [mm w.e.]
c #IB       READ(11) zn0IB   ! Initial Snow Height            [m]
c #IB       READ(11) mb0IB   ! Initial Mass Balance        [mmWE]
            if (mw .eq. 5) then
            READ(11) gradTM !*CL* Local temp. gradient  [C/m]
            READ(11) gradQM !*CL* Local hum. gradient   [g/kg/m]
            endif
C #SN     END IF

        ELSE IF (itexpe.EQ.0)                                     THEN
            DO j=1,my
            DO i=1,mx
                         evapTV(i,j)= 0.0
c #ZA                    VVs_BS(i,j)=10.0
c #ZA                    RRs_BS(i,j)= 1.0
c #ZA                    DDs_BS(i,j)= 0.0
            END DO
            END DO
        ENDIF

          CLOSE(unit=11)


C +--SVAT Prescribed Evolutive VBC (Vegetation Boundary  Condition)
C +                                (i.e.,      Green Leaf Fraction)
C +  --------------------------------------------------------------

          tim1VB=ou2sGE(iyrSVA,mmaSVA,jdaSVA,jhuSVA,0,0)
          tim2VB=   tim1VB

          DO n=1,nvx
          DO j=1,my
          DO i=1,mx
c #LN       LAI1VB(i,j,n) = alaiTV(i,j,n)
c #LN       LAI2VB(i,j,n) = alaiTV(i,j,n)
            glf1VB(i,j,n) = glf_TV(i,j,n)
            glf2VB(i,j,n) = glf_TV(i,j,n)
          END DO
          END DO
          END DO

c         MAR-GRISLI coupling
c #GL     call ice_sheet_model_coupling

      END IF


C +--WRITE
C +  =====

      IF (Ordr.eq.'writ')                                         THEN

        OPEN(unit=11,status='unknown',form='unformatted',
     .                                file='MARsvt.DAT')
           WRITE(11) itexpe
           WRITE(11) iyrrGE,mmarGE,jdarGE,jhurGE

           WRITE(11) IOi_TV  ! IO i Index
           WRITE(11) IOj_TV  ! IO j Index
           WRITE(11) isolTV  ! Soil       Type Index
           WRITE(11) iWaFTV  ! =0 ==> no Water Flux
                             ! =1 ==> free Drainage
           WRITE(11) AlbSTV  ! Dry Soil       Albedo
           WRITE(11) ivegTV  ! Vegetation Type Index
           WRITE(11) ifraTV  ! Vegetation Class Coverage
           WRITE(11) alaiTV  !       Leaf Area Index                [-]
           WRITE(11) glf_TV  ! Green Leaf Fraction                  [-]
           WRITE(11) TsolTV  ! Soil Temperature                     [K]
           WRITE(11) eta_TV  ! Soil Moisture                    [m3/m3]

           WRITE(11) CaSnTV  ! Canopy Intercepted Snow  Content[m w.e.]
           WRITE(11) CaWaTV  ! Canopy Intercepted Water Content [kg/m2]
           WRITE(11) psivTV  ! Vegetation   Hydraulic Potential     [m]
           WRITE(11) psigTV  ! Ground       Hydraulic Potential     [m]
           WRITE(11) TvegTV  ! Skin      Vegetation Temperature     [K]
           WRITE(11) TgrdTV  ! Skin            Soil Temperature     [K]

           WRITE(11) evapTV  ! Total Evapotranspiration       [mm w.e.]
           WRITE(11) draiTV  ! Drainage            Flow          [mm/s]
           WRITE(11) runoTV  ! Integrated Drainage Flow            [mm]

           do i=1,mx ; do j=1,my
             mskSNo2(i,j)=mskSNo(i,j,1)
           enddo     ; enddo

C +--Snow Pack Characteristics
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
C #SN    IF (SnoMod)                                              THEN

c #SN      if(mw.ne.5) then
c #SN      WRITE(11) mskSNo2 ! Snow/Ice Type Index               [-]
c #SN      else
c #SN      WRITE(11) mskSNo  ! Snow/Ice Type Index               [-]    
c #SN      endif
c #SN      WRITE(11) nssSNo  ! Nb Snow and     Ice Layers
c #SN      WRITE(11) issSNo  ! Nb Superimposed Ice Layers
c #SN      WRITE(11) nisSNo  ! Nb              Ice Layers
c #SN      WRITE(11) nhsSNo  ! Snow History                      [-]
c #SN      WRITE(11) dzsSNo  ! Snow Layers  Thickness            [m]
c #SN      WRITE(11) rosSNo  ! Snow Volumic Mass             [kg/m3]
c #SN      WRITE(11) wasSNo  ! Snow Water   Content          [m3/m3]
c #SN      WRITE(11) tisSNo  ! Snow Temperature                  [K]
c #SN      WRITE(11) g1sSNo  ! Snow Dendricity / Sphericity      [-]
c #SN      WRITE(11) g2sSNo  ! Snow Sphericity / Size            [-] [0.0001 m]
c #SN      WRITE(11) agsSNo  ! Snow Age                        [day]
c #SN      WRITE(11) snohSN  ! Snow Buffer    Layer [kg/m2],    [mm]
c #SN      WRITE(11) BrosSN  ! Snow Buffer Layer Density  [kg/m3]
c #SN      WRITE(11) BG1sSN  ! Snow Buffer Layer Dendri/Spher.   [-]
c #SN      WRITE(11) BG2sSN  ! Snow Buffer Layer Spheri/Size     [-] [0.0001 m]
c #SN      WRITE(11) SWaSNo  ! Snow Surficial Water              [m]
c #SN      WRITE(11) zWE0SN  ! Initial      Snow Thickness [mm w.e.]
c #SN      WRITE(11) zWE_SN  ! Current      Snow Thickness [mm w.e.]
c #SN      WRITE(11) zWEcSN  ! Non-erodible Snow Thickness [mm w.e.]
c #SN      WRITE(11) SaltSN  ! u*_th                           [m/s]
c #SN      WRITE(11) SLussl  ! u*_s*                     [kg/kg.m/s]
c #SN      WRITE(11) blowSN  ! NEW  MAX Erosion              [kg/m2]
c #SN      WRITE(11) WEq_SN  ! Added Snow Amount            [m w.e.]
c #ZM      WRITE(11) SLn_z0  ! Z0_momentum    (instantaneous)    [m]
c #ZM      WRITE(11) SLn_r0  ! Z0_scalar      (instantaneous)    [m]
c #BS      WRITE(11) SLn_b0  ! Z0_erosion     (instantaneous)    [m]
c #ZA      WRITE(11) ua_0BS  !  Wind ,  x-component (t-dt)     [m/s]
c #ZA      WRITE(11) va_0BS  !  Wind ,  y-component (t-dt)     [m/s]
c #ZA      WRITE(11) VVs_BS  ! (wind ,  Sastrugi) Relevance    [m/s]
c #ZA      WRITE(11) RRs_BS  ! (wind ,  Sastrugi) Counter        [-]
c #ZA      WRITE(11) DDs_BS  ! (wind ,  Sastrugi) Angle         [dg]
c #SZ      WRITE(11) Z0SaBS  ! Z0      (Sastrugi Height)         [m]
c #IB      WRITE(11) wes_IB  ! Snow/ice Sublimation     [mm w.e.]
c #IB      WRITE(11) wee_IB  ! Evapotranspiration       [mm w.e.]
c #IB      WRITE(11) wem_IB  ! Snow/ice Melting         [mm w.e.]
c #IB      WRITE(11) wer_IB  ! Snow/ice Refreezing      [mm w.e.]
c #IB      WRITE(11) wei0IB  ! Bottom Snow/ice added    [mm w.e.]
c #IB      WRITE(11) weu_IB  ! Run-off                  [mm w.e.]
c #IB      WRITE(11) zn0IB   ! Initial Snow Height            [m]
c #IB      WRITE(11) mb0IB   ! Initial Mass Balance        [mmWE]
           if (mw .eq. 5) then
           WRITE(11) gradTM !*CL* Local temp. gradient  [C/m]
           WRITE(11) gradQM !*CL* Local hum. gradient   [g/kg/m]
           endif
cXF
C #SN    END IF

        CLOSE(unit=11)

      END IF

      return
      end


      subroutine INIglf(ihamr_glf,nhamr_glf,newglfINI)
C +
C +------------------------------------------------------------------------+
C | MAR INPUT      SVAT                                     7-06-2002  MAR |
C |   SubRoutine INIglf is used to initialize MAR Green Leaf Fractions     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  ihamr_glf: Time Digital Filter Status                        |
C |   ^^^^^   nhamr_glf: Time Digital Filter Set Up                        |
C |                                                                        |
C |   OUTPUT: newglfINI: (0,1) ==> (NO new glf , new glf)                  |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   OUTPUT: alaiTV: Current                     Leaf  Area Index    (LAI)|
C |   ^^^^^^^ LAI1VB: Previous Nesting Time Step  Leaf  Area Index         |
C |           LAI2VB: Next     Nesting Time Step  Leaf  Area Index         |
C |           glf_TV: Current                     Green Leaf Fraction (GLF)|
C |           glf1VB: Previous Nesting Time Step  Green Leaf Fraction      |
C |           glf2VB: Next     Nesting Time Step  Green Leaf Fraction      |
C |           tim1VB,tim2VB:   Times  n, n+1  of  LAI and GLF              |
C |                                                                        |
C |   CAUTION: It is assumed that tim1VB and tim2VB do not change when the |
C |   ^^^^^^^^ Variables are reassigned after the dynamical Initialization |
C |            (Reassignation => itexpe := nham => timar := timar-nham*dt) |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
      include 'MAR_TV.inc'
      include 'MAR_VB.inc'
C +
      integer  ihamr_glf,nhamr_glf
      integer  newglfINI
C +
C +
C +--Local  Variables
C +  ================
C +
cXF
      integer*8  itisva,iv_glf
! int*8 is needed for making future projections!!!!
      real       rate
C +
C +
C +--Current Time
C +  ============
C +
          itisva=ou2sGE(iyrrGE,mmarGE,jdarGE,jhurGE,minuGE,jsecGE)
c #HF.           + (ihamr_glf+nhamr_glf)                           * idt
C +
C +
C +--Reinitialization of the Leaf Area Index and the Green Leaf Fraction
C +  -------------------------------------------------------------------
C +
      IF (iterun.eq.0)                                            THEN
          jdh_VB = 1
          iyr_VB = iyrrGE
          mma_VB = mmarGE
          jda_VB = jdarGE
          jhu_VB = jhurGE
          tim1VB = itisva
          tim2VB = itisva
       DO iv_glf=1,nvx
         DO j=1,my
         DO i=1,mx
c #LN      LAI1VB(i,j,iv_glf) = alaiTV(i,j,iv_glf)
c #LN      LAI2VB(i,j,iv_glf) = alaiTV(i,j,iv_glf)
           glf1VB(i,j,iv_glf) = glf_TV(i,j,iv_glf)
           glf2VB(i,j,iv_glf) = glf_TV(i,j,iv_glf)
         END DO
         END DO
       END DO
C +
      END IF
C +
C +
C +--New VBC
C +  =======
C +
      IF (itisva.gt.   tim2VB)                                    THEN
C +
          tim1VB =     tim2VB
C +
          write(6,6001)jda_VB,labmGE(mma_VB),iyr_VB,
     .                 jhu_VB,                      tim1VB,
     .                 jdarGE,labmGE(mmarGE),iyrrGE,
     .                 jhurGE,minuGE,        jsecGE,itisva
 6001     format(/, '  1st VBC /',i3,'-',a3,'-',i4,i3,' ',2x,'/',2x,
     .              '   t =',i12,'s A.P.',
     .           /, '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12)
C +
       IF (jdh_VB.eq.0)jdh_VB = -1
       open (unit=11,status='old',form='unformatted',file='MARglf.DAT')
       rewind     11
 11    CONTINUE
       IF (jdh_VB.le.0)                                       GO TO 10
C +
C +
C +--VBC at nesting time step n
C +  --------------------------
C +
       DO iv_glf=1,nvx
         DO j=1,my
         DO i=1,mx
c #LN      LAI1VB(i,j,iv_glf) = LAI2VB(i,j,iv_glf)
           glf1VB(i,j,iv_glf) = glf2VB(i,j,iv_glf)
c #LN      LAI2VB(i,j,iv_glf) = 0.d0
           glf2VB(i,j,iv_glf) = 0.d0
         END DO
         END DO
       END DO
C +
C +
C +--VBC at nesting time step n+1
C +  ----------------------------
C +
       read      (11) iyr_VB,mma_VB,jda_VB,jhu_VB,jdh_VB
       read      (11) glf2VB
c #LN  read      (11) LAI2VB
C +
       tim2VB=ou2sGE(iyr_VB,mma_VB,jda_VB,jhu_VB,0,0)
C +
       IF(itisva.gt.tim2VB)                                   GO TO 11
C +
          write(6,6002)jda_VB,labmGE(mma_VB),iyr_VB,
     .                 jhu_VB,jdh_VB,               tim2VB
 6002     format(   '  2nd VBC /',i3,'-',a3,'-',i4,i3,' ',2x,'/(',i1,
     .              ')  t =',i12,/,1x)
C +
 10    CONTINUE
       close(unit=11)
C +
      ELSE
c #WR     write(6,6003)jdarGE,labmGE(mmarGE),iyrrGE,
c #WR.                 jhurGE,minuGE,        jsecGE,itisva
 6003     format(   '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12,'s A.P.')
      END IF
C +
C +
C +--Time Interpolation
C +  ==================
C +
      IF            (itisva.le.tim2VB  .and.   tim1VB.lt.tim2VB)  THEN
C +
        rate = float(itisva  - tim1VB) / float(tim2VB  - tim1VB)
        DO iv_glf=1,nvx
          DO j=1,my
          DO i=1,mx
c #LN       alaiTV(i,j,iv_glf)=LAI1VB(i,j,iv_glf) +
c #LN.     (LAI2VB(i,j,iv_glf)-LAI1VB(i,j,iv_glf))*rate
            glf_TV(i,j,iv_glf)=glf1VB(i,j,iv_glf) +
     .     (glf2VB(i,j,iv_glf)-glf1VB(i,j,iv_glf))*rate
          END DO
          END DO
        END DO
C +
        newglfINI = 1
C +
      ELSE
        newglfINI = 0
      END IF
C +
      return
      end
      subroutine INIsic(ihamr_sic,nhamr_sic,newsicINI)

C +------------------------------------------------------------------------+
C | MAR INPUT    Sea-Ice                                   03-03-2004  MAR |
C |   SubRoutine INIsic is used to initialize MAR Sea-Ice    Fractions     |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT:  ihamr_sic: Time Digital Filter Status                        |
C |   ^^^^^   nhamr_sic: Time Digital Filter Set Up                        |
C |                                                                        |
C |   OUTPUT: newsicINI: (0,1) ==> (NO new sic , new sic)                  |
C |   ^^^^^^^                                                              |
C |                                                                        |
C |   OUTPUT: sicsIB: Current                     Sea-Ice    Fraction      |
C |   ^^^^^^^ sic1sI: Previous Nesting Time Step  Sea-Ice    Fraction      |
C |           sic2sI: Next     Nesting Time Step  Sea-Ice    Fraction      |
C |           tim1sI,tim2sI:   Times  n, n+1  of  Sea-Ice    Fraction      |
C |                                                                        |
C |   CAUTION: It is assumed that tim1sI and tim2sI do not change when the |
C |   ^^^^^^^^ Variables are reassigned after the dynamical Initialization |
C |            (Reassignation => itexpe := nham => timar := timar-nham*dt) |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
      include 'MAR_TV.inc'
      include 'MARsIB.inc'

      integer  ihamr_sic,nhamr_sic
      integer  newsicINI


C +--Local  Variables
C +  ================

cXF
      integer*8  itisIB
      real       rate


C +--Current Time
C +  ============

          itisIB=ou2sGE(iyrrGE,mmarGE,jdarGE,jhurGE,minuGE,jsecGE)
c #HF.          + (ihamr_sic+nhamr_sic)                           * idt


C +--Reinitialization of the Sea-Ice Fraction
C +  ----------------------------------------

      IF (iterun.eq.0)                                            THEN
          jdh_sI = 1
          iyr_sI = iyrrGE
          mma_sI = mmarGE
          jda_sI = jdarGE
          jhu_sI = jhurGE
          tim1sI = itisIB
          tim2sI = itisIB
       DO j=1,my
       DO i=1,mx
         sic1sI(i,j) = sicsIB(i,j)
         sic2sI(i,j) = sicsIB(i,j)
       END DO
       END DO

      END IF


C +--New sIB
C +  =======

      IF (itisIB.gt.   tim2sI)                                    THEN

          tim1sI =     tim2sI

          write(6,6001)jda_sI,labmGE(mma_sI),iyr_sI,
     .                 jhu_sI,                      tim1sI,
     .                 jdarGE,labmGE(mmarGE),iyrrGE,
     .                 jhurGE,minuGE,        jsecGE,itisIB
 6001     format(/, '  1st sIB /',i3,'-',a3,'-',i4,i3,' ',2x,'/',2x,
     .              '   t =',i12,'s A.P.',
     .           /, '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12)
C +
       IF (jdh_sI.eq.0)jdh_sI = -1
       open (unit=11,status='old',form='unformatted',file='MARsic.DAT')
       rewind     11
 11    CONTINUE
       IF (jdh_sI.le.0)                                       GO TO 10


C +--sIB at nesting time step n
C +  --------------------------

       DO j=1,my
       DO i=1,mx
         sic1sI(i,j) = sic2sI(i,j)
         sic2sI(i,j) = 0.d0
       END DO
       END DO


C +--sIB at nesting time step n+1
C +  ----------------------------

       read      (11) iyr_sI,mma_sI,jda_sI,jhu_sI,jdh_sI
       read      (11) sic2sI

          tim2sI=ou2sGE(iyr_sI,mma_sI,jda_sI,jhu_sI,0,0)

       IF(itisIB.gt.tim2sI)                                   GO TO 11

          write(6,6002)jda_sI,labmGE(mma_sI),iyr_sI,
     .                 jhu_sI,jdh_sI,               tim2sI
 6002     format(   '  2nd sIB /',i3,'-',a3,'-',i4,i3,' ',2x,'/(',i1,
     .              ')  t =',i12)

 10    CONTINUE
       close(unit=11)

      ELSE
c #WR     write(6,6003)jdarGE,labmGE(mmarGE),iyrrGE,
c #WR.                 jhurGE,minuGE,        jsecGE,itisIB
 6003     format(   '  Current /',i3,'-',a3,'-',i4,i3,':',i2,':',i2,
     .              '   t =',i12,'s A.P.')
      END IF


C +--Time Interpolation
C +  ==================

      IF            (itisIB.le.tim2sI  .and.   tim1sI.lt.tim2sI)  THEN

        rate = float(itisIB  - tim1sI) / float(tim2sI  - tim1sI)
        DO j=1,my
        DO i=1,mx
c #AO       sic1sI(i,j)=sicsIB(i,j)
c #AO       sic2sI(i,j)=sicsIB(i,j)
            sicsIB(i,j)=sic1sI(i,j) +
     .     (sic2sI(i,j)-sic1sI(i,j))*rate
        END DO
        END DO

        newsicINI = 1

      ELSE
        newsicINI = 0
      END IF

      return
      end


      subroutine OASIS_2_MAR

C +--------------------------------------------------------------------------+
C |                                                                1-12-2006 |
C |   subroutine OASIS_2_MAR transfers OASIS variables to MAR                |
C |                                                                          |
C |                                                                          |
C |      A chaque pas de temps, fromcpl est appele ;                         |
C |      si il_time_secs est egal a un multiple de la periode de couplage    |
C |      alors son action est effective        (via prism_get),              |
C |         et MAR recupere les champs de NEMO  via getfld (oasis)           |
C |                                                                          |
C |                                                                          |
C |      cf mar_module.f90                                                   |
C |      cf OASIS-3 user guide (december 2004)                               |
C +--------------------------------------------------------------------------+

      USE mod_prism_proto !
      USE mar_module      !TANGO modules
      USE flincom         !

      IMPLICIT NONE

C +--MAR    Variables
C +  ----------------

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_LB.inc'

      include 'MAR_SL.inc'
      include 'MAR_AO.inc'

      integer n

C +--cpl : GET FIELDS FROM OASIS
C +  ===========================

      IF (tocken_AO.eq.1) THEN
        tocken_AO=0      !fromcpl a deja ete appele pour ce pas de temps
      ELSE
           il_time_secs = iterun*idt 
C +...                    temps du run en sec. au pas de temps precedant
           write(*,*) '     CALL fromcpl, itexpe =', itexpe

C +             *******
           CALL fromcpl(il_time_secs, srftAO(:,:,1), sicsAO,
     .                  albAO(:,:,2), srftAO(:,:,2), hicAO,
     .                  hsnoAO      , UoceAO       , VoceAO )
C +             *******

          !cpl----those oceanic fields from oasis are used along the code--

C +--open water albedo (same parametrisation as in NEMO, 
c +  -----------------  but  with a real zenith angle)

                       ! see Briegleb & Ramanathan, JAM, 1982
          DO i=1,mx
          DO j=1,my
          albAO(i,j,1)=( 0.05/(1.1*czenGE(i,j)**1.4+0.15) )*cld_SL(i,j)
     .                +  0.06                        *  (1.-cld_SL(i,j))
                                  !czenGE=cos(zenith angle),cld_SL=cloud cover
          sst_LB(i,j) =            srftAO(i,j,1)
          sicsIB(i,j) =            sicsAO(i,j)
          ENDDO
          ENDDO
                                  !hicAO et hsnoAO pas utilises dans MAR 
                                  !                             pour le moment

      END IF

      return
      end


      subroutine MAR_2_OASIS

C +--------------------------------------------------------------------------+
C |                                                                1-12-2006 |
C |   subroutine MAR_2_OASIS transfers MAR variables to OASIS                |
C |                                                                          |
C |                                                                          |
C |      A chaque pas de tps, apres fromcpl, intocpl est appele ici;         |
C |      si il_time_secs correspond au pas de temps precedant le couplage,   |
C |      alors son action est effective        (via prism_put),              |
C |         et MAR envoie ses champs            via givfld (oasis)           |
C |                       a NEMO au pas de temps du couplage.                |
C |      L'appel a chaque pas de temps sert au moins au calcul de moyennes   |
C |                                            (cf AVERAGE dans namcouple)   |
C |                                                                          |
C |      cf mar_module.f90                                                   |
C |      cf OASIS-3 user guide (december 2004)                               |
C +--------------------------------------------------------------------------+

      USE mod_prism_proto !
      USE mar_module      !TANGO modules
      USE flincom         !

      IMPLICIT NONE

C +--MAR    Variables
C +  ----------------

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'

c #HY include 'MAR_HY.inc'
      include 'MAR_RA.inc'

      include 'MAR_SL.inc'
c #AO include 'MAR_AO.inc'

      include 'MAR_WK.inc'

      integer n


C +--cpl-1 Let's extract or calculate the usefull fields
C +  ===================================================

        IF (itexpe.eq.0)                                            THEN
            write(6,*) ' MAR first time step :  itexpe = ',itexpe
            DO i=1,mx
            DO j=1,my
              lprecipAO_t2(i,j)=0
              sprecipAO_t2(i,j)=0
            ENDDO
            ENDDO
        END IF

        DO i=1,mx
        DO j=1,my            
            lprecipAO_t1(i,j)=lprecipAO_t2(i,j)                         
C +...                        total liq. precip since itexpe=0 (at itexpe-1) 
            lprecipAO_t2(i,j)=rainHY(i,j)                               
C +...                        total liq. precip since itexpe=0 (at itexpe)
            lprecipAO(i,j)   =lprecipAO_t2(i,j)-lprecipAO_t1(i,j)       
C +...                        liquid precip             in a time step (mm.w.e)
            sprecipAO_t1(i,j)=sprecipAO_t2(i,j)                         
C +...                        total sol. precip since itexpe=0 (at itexpe-1)
            sprecipAO_t2(i,j)=snowHY(i,j)+crysHY(i,j)                   
C +...                        total sol. precip since itexpe=0 (at itexpe)
            sprecipAO(i,j)   =sprecipAO_t2(i,j)-sprecipAO_t1(i,j)       
C +...                        solid  precip/upward snow in a time step (mm.w.e)

            IF (sprecipAO(i,j).ge.0.)                               THEN
                 upsnowAO(i,j) =  0.
            ELSE
                 upsnowAO(i,j) = -sprecipAO(i,j)
                sprecipAO(i,j) =  0.
            END IF

                   evapAO(i,j) = -   SLuqsl(i,j,1) *rolvDY(i,j,mz) *1.e3 
C +...                           evaporation over ocean (negative, kg.m-2.s-1)

                 normdUAO      = sqrt((UairDY(i,j,mz) - UoceAO(i,j))**2
     .                               +(VairDY(i,j,mz) - VoceAO(i,j))**2)

            DO n=1,2
                   cpa        = cp*(1+qvswDY(i,j,mz)*(2-n)*(cpvir)
     .                               +qvsiDY(i,j,mz)*(n-1)*(cpvir))
C +...                           moist air heat capacity

              radsolAO(i,j,n) = RAdsol(i,j)  * ( 1.0 - albAO(i,j,n) )     
C +...                           downward solar                        (W.m-2)
               radirAO(i,j,n) = RAd_ir(i,j) 
     .                        - epsAO*stefan *        srftAO(i,j,n)**4   
C +...                           downward IR                      (net, W.m-2)
                hsenAO(i,j,n) = SLutsl(i,j,n)*cpa*rolvDY(i,j,mz)*1.e3    
C +...                           downward sensible                     (W.m-2)
                hlatAO(i,j,n) = SLuqsl(i,j,n)    *rolvDY(i,j,mz)*1.e3        
     .                        * ( (2-n)*Lv_H2O + (n-1)*Ls_H2O )
C +...                           downward latent                       (W.m-2)
              radtotAO(i,j,n) = radirAO(i,j,n)
     .                        +  hsenAO(i,j,n) + hlatAO(i,j,n)  
C +...                           downward non solar                    (W.m-2)
                 DFlAO(i,j,n) = -rolvDY(i,j,mz)*SLuusl(i,j,n)
     .                        *  cdhSL(i,j,n)*R_Rv*1.e3
     .                        * ( (2-n)*Lv_H2O + (n-1)*Ls_H2O )**2
     .                        * ( (2-n)*qvswDY(i,j,33)
     .                                  + (n-1)*qvsiDY(i,j,33))
     .                        / (       RDryAi *       srftAO(i,j,n)**2)
C +...                           latent flux derivative/T
C +...                          (Clausius-Clapeyron for Dqsat/DT)
                 DFsAO(i,j,n) = -rolvDY(i,j,mz)*cpa*1.e+3                   
     .                        *   cdhSL(i,j,n) *SLuusl(i,j,n)        
C +...                           sensible flux derivative/T
                 DFiAO(i,j,n) = -4*epsAO*stefan*srftAO(i,j,n)**3            
C +...                           IR flux derivative/T
               DFtotAO(i,j,n) =  DFlAO(i,j,n)+DFsAO(i,j,n)+DFiAO(i,j,n)   
C +...                           total         derivative/T

               TauxtAO(i,j,n) =cdmSL(i,j,n)**2 *normdUAO*rolvDY(i,j,mz)
     .                       *(UairDY(i,j,mz)-UoceAO(i,j)*(2-n)) *1.e3
C +...                           wind stress on T grid                 (N.m-2)
               TauytAO(i,j,n) =cdmSL(i,j,n)**2 *normdUAO*rolvDY(i,j,mz)   
     .                       *(VairDY(i,j,mz)-VoceAO(i,j)*(2-n)) *1.e3
            ENDDO 
        ENDDO
        ENDDO


        DO n=1,2
          DO i=1,mx-1
          DO j=1,my-1
            TauxuAO(i,j,n)= 0.5*(TauxtAO(i,j,n) + TauxtAO(i+1,j,n)) ! U grid
            TauyuAO(i,j,n)= 0.5*(TauytAO(i,j,n) + TauytAO(i+1,j,n)) ! U grid
            TauxvAO(i,j,n)= 0.5*(TauxtAO(i,j,n) + TauxtAO(i,j+1,n)) ! V grid
            TauyvAO(i,j,n)= 0.5*(TauytAO(i,j,n) + TauytAO(i,j+1,n)) ! V grid
          ENDDO
          ENDDO
          DO i=1,mx
            TauxvAO(i,my,n)=     TauxtAO(i,my,n)
            TauyvAO(i,my,n)=     TauxtAO(i,my,n)
          ENDDO        
          DO j=1,my
            TauxuAO(mx,j,n)=     TauxtAO(mx,j,n)
            TauyuAO(mx,j,n)=     TauxtAO(mx,j,n)
          ENDDO
        ENDDO


C +--cpl-2 Now let's give the fields to oasis
C +  ========================================

          il_time_secs = iterun*idt
C +...                   temps en sec depuis le debut du run, au pas precedant
          write(*,*) '     CALL intocpl, itexpe =', itexpe

C +            *******
          CALL intocpl(il_time_secs,   radsolAO(:,:,2),radsolAO(:,:,1),
     .                 radtotAO(:,:,2),radtotAO(:,:,1), DFtotAO(:,:,2),
     .                   evapAO       ,lprecipAO,     sprecipAO       , 
     .                 upsnowAO,  
     .                  TauxuAO(:,:,1), TauxuAO(:,:,2),                 
     .                  TauyuAO(:,:,1), TauyuAO(:,:,2),                 
     .                  TauxvAO(:,:,1), TauxvAO(:,:,2),                 
     .                  TauyvAO(:,:,1), TauyvAO(:,:,2))
C +            *******


      return
      end


      subroutine SRFini_pol
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            18-09-2001  MAR |
C |   SubRoutine SRFini_pol initializes the Polynya Model                  |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |    INPUT: fxlead           : Minimum Open-Water Fraction               |
C |    ^^^^^^ hic0             : Standard Sea-Ice Thickness            [m] |
C |                                                                        |
C |   OUTPUT: POLYNYA   VARIABLES                                          |
C |   ^^^^^^^ ^^^^^^^^^^^^^^^^^^^                                          |
C |           aPOlyn(mx,my)    : Initial Open-Water Fraction in a Grid Box |
C |                             (Input from MARdom.dat)                    |
C |           SLsrfl(mx,my,2)  : Initial Open-Water Fraction in a Grid Box |
C |           hicePO(mx,my)    : Initial  Sea-Ice Thickness            [m] |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
C +
      include 'MAR_SL.inc'
c #PO include 'MAR_PO.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      integer  ipol  ,jpol  ,ntot  ,iwpd  ,jwpd  ,npol  ,itot ,jtot
C +
C +
C +--Time Step
C +  =========
C +
c #PO   dtPO = dt
C +
C +
C +--Ice Characteristics 
C +  ===================
C +
c #PO silfPO = 1024.d0 * 333.9d3 *
c #PO.                           (1.d0 -1.d-3 *si00PO
c #PO.       - (si00PO /sw00PO) *(1.d0 -1.d-3 *sw00PO) )
C +...silfPO : Sea-Ice Latent Heat of Melting [J.m-3]
C +
c #PO  DO j=1,my
c #PO  DO i=1,mx
c #PO          hfraPO(i,j) =  0.d0
c #PO          vgriPO(i,j) =  0.d0
c #PO          swsaPO(i,j) =  sw00PO
c #PO  END DO
c #PO  END DO
C +
C +
C +--Area Initialisation
C +  ===================
C +
c #PO  DO j=1,my
c #PO  DO i=1,mx
c #PO    IF     (isolSL(i,j).le.2)                                THEN
c #PO      IF   (isolSL(i,j).eq.1)                                THEN
c #PO            aicePO(i,j)   =     0.d0
c #PO            hicePO(i,j)   =     0.d0
c #PO            nSLsrf(i,j)   =     1
c #PO            tsrfSL(i,j,1) = max(tfrwat,tsrfSL(i,j,1))
c #PO            tsrfSL(i,j,2) =     0.d0
c #PO            SLsrfl(i,j,2) =     0.d0
c #PO      END IF
c #PO      IF   (isolSL(i,j).eq.2)                                THEN
c #PO            aPOlyn(i,j)   = max(fxlead,aPOlyn(i,j))
c #PO            SLsrfl(i,j,2) =            aPOlyn(i,j)
c #PO            aicePO(i,j)   =     1.d0 - aPOlyn(i,j)
c #PO            hicePO(i,j)   =     hic0
c #PO        IF (aPOlyn(i,j).gt.zero)                             THEN
c #PO            nSLsrf(i,j)   =     2
c #PO            tsrfSL(i,j,2) = max(tfrwat,tsrfSL(i,j,2))
c #PO        END IF
c #PO      END IF
c #PO            SLsrfl(i,j,1) =     1.d0 - SLsrfl(i,j,2)
c #PO    END IF
c #PO  END DO
c #PO  END DO
C +
C +
C +--Polynia Output Zone
C +  ===================
C +
       ipol =        imez+1
       jpol =        jmez+1
       ntot =        0
C +
C +
C +--Search the most coastal confluence zone
C +  ---------------------------------------
C +
C +--Coastal Grid Point
C +  ~~~~~~~~~~~~~~~~~~
       DO j=1,my
       DO i=1,mx
         IF ( isolSL(    i ,    j ).le.2     .and.
     .       (isolSL(ip1(i),    j ).gt.2.or.
     .        isolSL(    i ,jp1(j)).gt.2.or.
     .        isolSL(im1(i),    j ).gt.2.or.
     .        isolSL(    i ,jm1(j)).gt.2    )      )              THEN
C +
              ipol =  i
              jpol =  j
C +
c #PO         iPO1 =  max( 1,ipol-16)
c #PO         iwpd =  iPO1 - ipol+16
c #PO         iPO2 =  min(mx,ipol+16+iwpd)
C +
c #PO         jPO1 =  max( 1,jpol-16)
c #PO         jwpd =  jPO1 - jpol+16
c #PO         jPO2 =  min(my,jpol+16+jwpd)
C +
              npol =  0
c #PO      DO jpol =  jPO1,jPO2
c #PO      DO ipol =  iPO1,iPO2
c #PO         npol =  npol+isolSL(ipol,jpol)
c #PO      END DO
c #PO      END DO
           IF(npol.gt.ntot)                                       THEN
              ntot =  npol
              itot =  ipol
              jtot =  jpol
           END IF
C +
         END IF
       END DO
       END DO
C +
C +--Polynya Grid
C +  ~~~~~~~~~~~~
              ipol =  itot
              jpol =  jtot
C +
c #PO  iPO1 = max( 1,ipol-16)
c #PO  iwpd = iPO1 - ipol+16
c #PO  iPO2 = min(mx,ipol+16+iwpd)
C +
c #PO  jPO1 = max( 1,jpol-16)
c #PO  jwpd = jPO1 - jpol+16
c #PO  jPO2 = min(my,jpol+16+jwpd)
C +
c #PO  iPO3 = iPO1 +     12
c #PO  iwpd = max(0, 1-iPO3)
c #PO  iPO3 = iPO3 +   iwpd
c #PO  iPO4 = iPO3 +      5
c #PO  iwpd = min(0,mx-iPO4)
c #PO  iPO3 = iPO3 +   iwpd
c #PO  iPO4 = iPO4 +   iwpd
C +
c #PO  jPO3 = jPO1 +     14
c #PO  jwpd = max(0, 1-jPO3)
c #PO  jPO3 = jPO3 +   jwpd
c #PO  jPO4 = jPO3 +      6
c #PO  jwpd = min(0,my-jPO4)
c #PO  jPO3 = jPO3 +   jwpd
c #PO  jPO4 = jPO4 +   jwpd
C +
c #PO  iPO1 = min(iPO1,mx)
c #PO  iPO2 = min(iPO2,mx)
c #PO  iPO3 = min(iPO3,mx)
c #PO  iPO4 = min(iPO4,mx)
C +
c #PO  jPO1 = min(jPO1,my)
c #PO  jPO2 = min(jPO2,my)
c #PO  jPO3 = min(jPO3,my)
c #PO  jPO4 = min(jPO4,my)
C +
      return
      end
      block data SRFdat_pol
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            16-09-2001  MAR |
C |   Block Data SRFdat_pol defines physical constants of POLYNYA  MODEL   |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARdim.inc'
C +
      include 'MAR_PO.inc'
C +
C +
C +--DATA
C +  ====
C +
      data sw00PO/35.e0/
      data si00PO/10.e0/
C +...     sw00PO and si00PO are water and sea-ice salinities in
C +        Terra Nova Bay (Bromwich and Kurtz,   1984, JGR, p.3568;
C +             see also   Cavalieri and Martin, 1985,      p. 248)
C +
      end 


      subroutine SRFmod_pol
C +
C +------------------------------------------------------------------------+
C | MAR SURFACE                                            18-09-2001  MAR |
C |   SubRoutine SRFmod_pol determines the polynya opening / closing       |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   Assumptions: 1. SEA ICE DYNAMICS are included                        |
C |   ~~~~~~~~~~~~    but possibility exists for making the                |
C |                   FREE DRIFT Assumption                                |
C |                   (NO internal stresses NOR local variation in time;   |
C |                    e.g. McPhee, 1980:                    Option #FD)   |
C |                   LATERAL ACCRETION in LEADS determined through        |
C |                    frazil collection process of Ou (1988, JPO,p.585)   |
C |                                                                        |
C |                2. A Redistribution Function for Sea Ice is assumed     |
C |                   (Shinohara 1990, JGR 95, p.13431 A8) ------> #DD     |
C |                                                                        |
C |                3. Grease Ice is free to ridge                          |
C |                                                                        |
C |                4. Sea Water Properties depends on Salt Rejection       |
C |                   (i.e. Salinity, Freezing Point, Temperature,         |
C |                         Latent Heat of Solidification, Heat Capacity)  |
C |                                                                        |
C |                5. Cloudiness (cfr. variable cld_SL(i,j))               |
C |                   used for the Water Albedo Computation                |
C |                   is specified only in SubRoutine PHYrad_sol           |
C |                                                                        |
C |                6. r0 = 0.01 * z0 when surface type changes             |
C |                   (cfr. SubRoutine TURsbl)                             |
C |                                                                        |
C |                7. Sea-Ice Thermodynamics are included in tice          |
C |                   (cfr. SubRoutine tice)                               |
C |                                                                        |
C |                                                                        |
C |   Numerics: Arakawa C grid is used for sea ice                         |
C |   ~~~~~~~~~                                                            |
C |                     +----------------+----------------+                |
C |                     |                |vicePO(i,j+1)   |                |
C |                     |                |                |                |
C |                     |                |                |                |
C |                     |                |                |                |
C |                     |                |SLuusl(i,j,1)   |                |
C |                     |                |uairDY(i,j,mz)  |                |
C |                     |                |vairDY(i,j,mz)  |                |
C |                     |                |ssvSL(i,j,mz)   |                |
C |                     +----------------+----------------+                |
C |                     |uicePO(i,j)     |aicePO(i,j)     |uicePO(i+1,j)   |
C |                     |WKxy3(i,j)      |hicePO(i,j)     |                |
C |                     |:=d/dx(sig)     |epsixx          |                |
C |                     |                |epsiyy          |                |
C |                     |                |WKxy1(i,j)      |                |
C |                     |                |:=sig_x+sig_y   |                |
C |                     |                |(=sig)          |                |
C |                     |                |                |                |
C |                     +----------------+----------------+                |
C |                                       vicePO(i,j)                      |
C |                                       WKxy3(i,j)                       |
C |                                       :=d/dy(sig)                      |
C |                                                                        |
C |                                                                        |
C |   Domain of Validity: As plastic response to shear is not included,    |
C |   ~~~~~~~~~~~~~~~~~~  dx must be .ge. 10 km                            |
C |                      (Overland and Pease 1988, JGR p.15632 and Fig.9)  |
C |                                                                        |
C | # OPTIONS: #IF Update Sea Ice Latent Heat of Freezing                  |
C | # ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_RA.inc'
C +
      include 'MAR_SL.inc'
      include 'MAR_PO.inc'
C +
      include 'MAR_WK.inc'
C +
      include 'MAR_IO.inc'
C +
C +
C +--Local  Variables
C +  ================
C +
      logical  freeri,fulwri
C +
      real     uwa  (mx,my)
      real     vwa  (mx,my)
C +...         (uwa,vwa): Frazil Velocity Vector used in Frazil Advection
C +                       corrected (:= 0 if open water fraction < fraadv)
C +
      real     hsst (mx,my)
      real     swlf (mx,my)
      real     psice(mx,my)
C +...         psice: Redistribution Function for Sea Ice 
C +                   (Shinohara 1990, JGR 95, p.13431 A8)
C +
      real     vecx1(mx)
      real     vecx2(mx)
      real     vecx3(mx)
      real     vecx4(mx)
      real     vecx5(mx)
C +
      integer  modrun,jmx   ,ntsi  ,ntfr
      real     advfra,dxdy  ,cc1m  ,dduuxx,dduuyy,ddvvxx,ddvvyy
      real     epsixx,epsixy,epsiyx,epsiyy,pppp  ,aeps  ,zeta  ,facrad
      real     duio  ,dvio  ,dssv  ,himi  ,rihi  ,brak  ,argi  
      real     cosi  ,sini  ,uuxm  ,uuym  ,vvxm  ,vvym  
      real     uu    ,vv    ,cflui ,cflvi ,dtsi  ,vice
      real     agri  ,agrin ,dagri ,firupp
      real     dhw   ,dsw   ,swsa2 ,tsswc ,tssw0 ,argt0 ,cwsw0
      real     dtfr  ,cfluw ,cflvw ,vfraz ,auw   ,avw   
      real     tannum,tanden,ssvw  ,tana  ,sina  ,cosa  
      real     srf1  ,rr11  ,srf2  ,rr22  ,srf3  ,rr33  ,srf   
      real     rrrr  ,ddrr  ,aicen ,dvice ,daice ,flead ,aicenh
      real     frlead,compte,rjd   ,rjh
C +
c #CN integer  itsi  ,itfr
c #CN real     cflmax,cfl   ,uwvwmx,uwvw
C +
c #VR integer      ivr   ,jvr
c #VR character*15 route
C +
      real     epstmn,zcoemx,zetamn,him   ,hwl   ,tcompa,fraadv
C +
C +
C +--DATA
C +  ====
C +
      data freeri/.true./
C +...     freeri=.true. ==> Parameterization Grease Ice Free Ridging ON
C +
      data fulwri/.true./
C +...     fulwri=.true. ==> Additional Output
C +
      data epstmn/2.0e-09/
C +...Minimum Strain Rate, as in Hibler 1979, JPO 9, p.819 (10)
C +
      data zcoemx/5.0e+08/
C +...Maximum value of the Ice Strength Coefficient in the Relation on the 
C +                        Bulk Viscosity Coefficient [s], 
C +                        as in Hibler 1979, JPO 9, p.819 (10)
C +
      data zetamn/4.0e+08/
C +...Minimum value of the bulk viscosity [kg/s], 
C +                        as in Hibler 1979, JPO 9, p.823, 2e col, 2e para
C +
      data him /  0.400e0/
C +...     him : Minimum Ice Thickness for Active Lateral Stresses
C +              Usually chosen equal to the Frazil Collection Thickness
C +
      data hwl /  0.400e0/
C +   data hwl /  0.220e0/
C +...     hwl : Frazil Collection Thickness
C +            (standard is 10 cm, Pease 1987, JGR 92, p.7051 Table 1.)
C +            (In Terra Nova Bay, 22 cm is acceptable,
C +             following  Bromwich and Kurtz,   1984, JGR, p.3568;
C +             see also   Smith et al.,         1990, JGR, p.9465)
      data tcompa/345600.e0/
C +...     tcompa: grease ice solidification time scale 
C +               (uncertain parameter, as wind must impact solidification)
C +               (a 4-days / 4 X 86400s e-folding time is chosen, 
C +                corresponding roughly to the cyclones frequency)
C +
      data fraadv/0.001e0/
C +...     fraadv:Minimum frazil concentration allowing advection
C +
C +
C +--Initialisation
C +  ==============
C +
      advfra = 1.d0 - fraadv
C +
c #IF silfPO = 1024.d0 * 333.9d3 *
c #IF.                           (1.d0 -1.d-3 *si00PO 
c #IF.       - (si00PO /sw00PO) *(1.d0 -1.d-3 *sw00PO) )
C +...silfPO : Sea-Ice Latent Heat of Melting [J.m-3]
C +
      dxdy = dx * dy
C +...dxdy : Grid Mesh Surface
C +
      cc1m = 15.d0 * (1.d0-epsi)
C +
C +--Output for Verification 
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #VR ivr = 66  
c #VR jvr = 43  
c #VR route = ' BEG SRFmod_pol'
c #VR write(6,6601)   itexpe,route,
c #VR.              ((aicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6601 format(i6,a15,' aicePO:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6603) ((hicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6611) ((uicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6612) ((vicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6605) ((vgriPO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
C +
C +
C +--FULL SEA-ICE DYNAMICS
C +  =====================
C +
C +...Individual Acceleration is included, as in Hakkinen, 1986, JGR, p.820
C +
      do 10 j=1,my
      do 10 i=1,mx
      WKxy1(i,j) = 0.d0
      WKxy2(i,j) = 0.d0
      WKxy3(i,j) = 0.d0
      WKxy4(i,j) = 0.d0
      WKxy5(i,j) = 0.d0
 10   continue
C +
      do 101 j=1,my
      do 101 i=1,mx
      if (aicePO(i,j).le.zero) then
          uicePO(i,j) = 0.d0
          vicePO(i,j) = 0.d0
      else
       if (freeri) then
           WKxy5(i,j) = aicePO(i,j) 
       else
           WKxy5(i,j) = aicePO(i,j) - vgriPO(i,j)/hicePO(i,j)
C +...     Unconsolidated Sea-Ice Fraction not included in Evaluation
C +                    of Strain Rate Tensor and Internal Ice Stress
C +
       end if
           WKxy5(i,j) = max(WKxy5(i,j),zero)
C +
      end if
 101  continue
C +
C +
C +--Strain Rate Tensor
C +  ------------------
C +
      do 111 j=jp11,my1
      do 111 i=ip11,mx1
C +
       dduuxx=         (uicePO(ip1(i),j     )-uicePO(i     ,j     )) /dx
       dduuyy= 0.25d0*((uicePO(i     ,jp1(j))-uicePO(i     ,jm1(j))) 
     .                +(uicePO(ip1(i),jp1(j))-uicePO(ip1(i),jm1(j))))/dy
       ddvvxx= 
     .         0.25d0*((vicePO(ip1(i),j     )-vicePO(im1(i),j     ))
     .                +(vicePO(ip1(i),jp1(j))-vicePO(im1(i),jp1(j))))/dx
       ddvvyy=         (vicePO(i     ,jp1(j))-vicePO(i     ,j     )) /dy
C +
       epsixx=          dduuxx
       epsixy= 0.50d0 *(dduuyy+ddvvxx)
       epsiyx=          epsixy      
       epsiyy=          ddvvyy
C +
       WKxy3(i,j)  = epsixx + epsiyy     
C +... WKxy3(i,j): Trace of the Strain Rate Tensor
C +
       WKxy4(i,j)  = 15.0d0 *(1.d0      - WKxy5(i,j))
c #HI  WKxy4(i,j)  = 20.0d0 *(1.d0      - WKxy5(i,j))
 111   continue
C +
      do 112 j=jp11,my1
      do 112 i=ip11,mx1
      if (WKxy4(i,j).lt.cc1m .and.  hicePO(i,j).gt.hwl) then
       psice(i,j)  = exp(-WKxy4(i,j))
C +... psice(i,j)  : Redistribution Function for the Cavitating Fluid
C +                  (Shinohara 1990, JGR 95, p.13431 A7)
C +
       pppp        = 1.40d3 * hicePO(i,j) * WKxy5(i,j) * psice(i,j)
C +        (Overland and Pease  1988 JGR 93 C12, p.15623 (16), 
C +                                              p.15625, 2e col 2e para) 
C +    P_0: Flato    and Hibler 1992 JPO 22   6, p.  632 (17)  
C +
c #HI  pppp        = 27.5d3 * hicePO(i,j) * WKxy5(i,j) * psice(i,j)
C +... P_*         = P_0    X Hice        X Aice       X exp(-C X(1-Aice))
C +    P_* Dependance of Ice Strength on Ice Thickness and Compactness
C +        (Hibler              1979 JPO  9 (16) p.  822)
C +
       aeps        =    -WKxy3(i,j)
C +... compaction  =>    WKxy3(i,j) < 0
C +
      else
       psice(i,j)  = 0.d0
       pppp        = 0.d0
      end if
C +
       psice(i,j)  =     psice(i,j)*WKxy3(i,j)
       psice(i,j)  = min(psice(i,j),zero)
C +
       aeps        = max(epstmn,aeps)
       zeta        = 0.5d0*pppp/aeps
C +??? zeta        = max(zetamn,zeta)
C +... zeta       := max(zetamn,zeta) => Floating Overflow
C +
C +
C +--Internal Ice Stress (Semtner, 1987, JPO)
C +  ----------------------------------------
C +
C +- Compaction
C +  ~~~~~~~~~~
      if (WKxy3(i,j) .lt. 0.d0) then 
      WKxy1(i,j)  = WKxy3(i,j) * zeta - 0.5*pppp
C +
C +- Divergence   =>  0
C +  ~~~~~~~~~~
      else
      WKxy1(i,j)  =   0.d0
      end if
 112  continue
C +
C +- Lateral Boundaries
C +  ~~~~~~~~~~~~~~~~~~
      do 1121 j=1,my
      WKxy1( 1, j) = WKxy1(ip11,     j)
      WKxy1(mx, j) = WKxy1(mx1,     j)
 1121 continue
C +
      do 1122 i=1,mx
      WKxy1( i, 1) = WKxy1(     i,jp11)
      WKxy1( i,my) = WKxy1(     i,my1)
 1122 continue
C +
C +--Reset
C +  ~~~~~
      do 1120 j=1,my
      do 1120 i=1,mx
      WKxy3(i,j)  =   0.d0
      WKxy4(i,j)  =   0.d0
 1120 continue
C +
C +
C +--Stress Force
C +  ------------
C + 
      do 113 j=jp11,my
      do 113 i=ip11,mx
       facrad        =  WKxy5(i,j)*hicePO (i,  j) *dx *910.d0
       facrad        =  max(facrad                ,dx)
       WKxy3 (i,j)   = (WKxy1(i,j)-WKxy1(im1(i),j))/facrad
       WKxy4 (i,j)   = (WKxy1(i,j)-WKxy1(i,jm1(j)))/facrad
       WKxyz1(i,j,1) =  WKxy3(i,j)
       WKxyz1(i,j,2) =  WKxy4(i,j)
 113  continue
C +
C +
C +--Contribution from Lateral and Internal Stresses 
C +  -----------------------------------------------
C +
      do 114 j=jp11,my1
      do 114 i=ip11,mx1
       duio    = uicePO(i,j)- uocnPO(i,j)  
       dvio    = vicePO(i,j)- vocnPO(i,j)
       dssv    = sqrt(duio*duio +dvio*dvio)
       himi    =  max(him,    hicePO(i,j))
       rihi    = 1820.d0    * himi
C +... rihi    = 2 X ro_Ice X hicePO / rho_air, where rho_air assumed:=1
C +
       brak    = maskSL(i,j) *dtPO * 1.2d-3 *dssv          /himi
C +... brak    : Sea-Ice/Water Friction Implicit Coefficient
C +              Here it is assumed that the ratio ro_Ice / ro_Wat = 1 
C +
       uicePO(i,j) = uicePO(i,j) + maskSL(i,j) *dtPO 
     .  * ((SLuusl(i  ,j,1)*SLuusl(i  ,j,1)*uairDY(i,j  ,mz)
     .                                      /ssvSL(i,j  ,mz)        
     .     +SLuusl(i+1,j,1)*SLuusl(i+1,j,1)*uairDY(i+1,j,mz)
     .                                      /ssvSL(i+1,j,mz))      
     .                                                     /rihi 
     .    + WKxy3(i,j)                                                 )
C +
       uicePO(i,j) =(uicePO(i,j) + brak *uocnPO(i,j))
     .             /(1.0d+0      + brak             )
C +
       vicePO(i,j) = vicePO(i,j) + maskSL(i,j) *dtPO 
     .  * ((SLuusl(i  ,j,1)*SLuusl(i  ,j,1)*vairDY(i,j  ,mz)
     .                                      /ssvSL(i,j  ,mz)        
     .     +SLuusl(i+1,j,1)*SLuusl(i+1,j,1)*vairDY(i+1,j,mz)
     .                                      /ssvSL(i+1,j,mz))       
     .                                                     /rihi 
     .    + WKxy4(i,j)                                                 )
C +
       vicePO(i,j) =(vicePO(i,j) + brak *vocnPO(i,j))
     .             /(1.0d+0      + brak             )
C +
       WKxyz2(i,j,1) =             maskSL(i,j)
     .  *  (SLuusl(i  ,j,1)*SLuusl(i  ,j,1)*uairDY(i,j  ,mz)
     .                                      /ssvSL(i,j  ,mz)        
     .     +SLuusl(i+1,j,1)*SLuusl(i+1,j,1)*uairDY(i+1,j,mz)
     .                                      /ssvSL(i+1,j,mz))       
     .                                                     /rihi 
       WKxyz2(i,j,2) =             maskSL(i,j)
     .  *  (SLuusl(i  ,j,1)*SLuusl(i  ,j,1)*vairDY(i,j  ,mz)
     .                                      /ssvSL(i,j  ,mz)        
     .     +SLuusl(i+1,j,1)*SLuusl(i+1,j,1)*vairDY(i+1,j,mz)
     .                                      /ssvSL(i+1,j,mz))       
     .                                                     /rihi 
       WKxyz3(i,j,1) =
     .    - 1.2d-3*dssv *duio    * maskSL(i,j)             /himi
       WKxyz3(i,j,2) =
     .    - 1.2d-3*dssv *dvio    * maskSL(i,j)             /himi
 114  continue
C +
C +--Output for Verification 
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #VR route = ' END Stresses  '
c #VR write(6,6602)          route,
c #VR.              ((aicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6603) ((hicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6604) (( psice(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6606) (( WKxy1(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6606 format(6x,15x,'  WKxy1:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6607) (( WKxy3(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6607 format(6x,15x,'  WKxy3:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6608) (( WKxy4(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6608 format(6x,15x,'  WKxy4:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6609) (( ssvSL(i,j,mz),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6609 format(6x,15x,'  ssvSL:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6611) ((uicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6612) ((vicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6605) ((vgriPO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
C +
C +
C +--Contribution from Coriolis Force (C Grid !)
C +  -------------------------------------------
C +
      modrun = mod(itexpe,2) + 1
      go to (1141,1142) modrun
 1141 continue
        DO j=1,my
        DO i=1,mx
          uicePO(i,j) =     uicePO(i,j)  + 0.25d0*fcorDY(i,j)*dtPO
     .                    *(vicePO(im1(i),j     )-vocnPO(im1(i),j     )
     .                     +vicePO(im1(i),jp1(j))-vocnPO(im1(i),jp1(j)) 
     .                     +vicePO(i     ,j     )-vocnPO(i     ,j     )  
     .                     +vicePO(i     ,jp1(j))-vocnPO(i     ,jp1(j)))
        END DO
        END DO
C +
        DO j=1,my
        DO i=1,mx
          vicePO(i,j) =     vicePO(i,j)  - 0.25d0*fcorDY(i,j)*dtPO
     .                    *(uicePO(ip1(i),j     )-uocnPO(ip1(i),j     )
     .                     +uicePO(ip1(i),jm1(j))-uocnPO(ip1(i),jm1(j))
     .                     +uicePO(i     ,j     )-uocnPO(i     ,j     )
     .                     +uicePO(i     ,jm1(j))-uocnPO(i     ,jm1(j)))
        END DO
        END DO
C +
      go to  1143
 1142 continue
        DO j=1,my
        DO i=1,mx
          vicePO(i,j) =     vicePO(i,j)  - 0.25d0*fcorDY(i,j)*dtPO 
     .                    *(uicePO(ip1(i),j     )-uocnPO(ip1(i),j     )
     .                     +uicePO(ip1(i),jm1(j))-uocnPO(ip1(i),jm1(j))
     .                     +uicePO(i     ,j     )-uocnPO(i     ,j     )
     .                     +uicePO(i     ,jm1(j))-uocnPO(i     ,jm1(j)))
        END DO
        END DO
C +
        DO j=1,my
        DO i=1,mx
          uicePO(i,j) =     uicePO(i,j)  + 0.25d0*fcorDY(i,j)*dtPO 
     .                    *(vicePO(im1(i),j     )-vocnPO(im1(i),j     )
     .                     +vicePO(im1(i),jp1(j))-vocnPO(im1(i),jp1(j))  
     .                     +vicePO(i     ,j     )-vocnPO(i     ,j     )  
     .                     +vicePO(i     ,jp1(j))-vocnPO(i     ,jp1(j)))
        END DO
        END DO
      go to  1143
 1143 continue
C +
        DO j=1,my
        DO i=1,mx
          IF (isolSL(i,j).gt.2)                                   THEN
              uicePO(i,j) = 0.0d+0
              vicePO(i,j) = 0.0d+0
          END IF
        END DO
        END DO
C +
C +--Output for Verification 
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #VR route = ' END Coriolis  '
c #VR write(6,6602)          route,
c #VR.              ((aicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6603) ((hicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6611) ((uicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6612) ((vicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
C +
C +
C +--Contribution from Advection (First Order Upwind Scheme is used)
C +  ---------------------------
C +
      do 115 j=1,my
      do 115 i=1,mx
      WKxy1 (i,j)    = 0.d0
      WKxy2 (i,j)    = 0.d0
      WKxy3 (i,j)    = 0.d0
      WKxy4 (i,j)    = 0.d0
      WKxyz1(i,j,mz) = 0.d0
      WKxyz2(i,j,mz) = 0.d0
 115  continue
      do 1150 j=jp11,my
      do 1150 i=ip11,mx
      WKxy1(i,j) = dtPO * (uicePO(i,j)-uicePO(im1(i),j     )) / dx
      WKxy2(i,j) = dtPO * (uicePO(i,j)-uicePO(i     ,jm1(j))) / dy
      WKxy3(i,j) = dtPO * (vicePO(i,j)-vicePO(im1(i),j     )) / dx
      WKxy4(i,j) = dtPO * (vicePO(i,j)-vicePO(i     ,jm1(j))) / dy
 1150 continue
C +
              j=1
      do 1151 i=ip11,mx
      WKxy1(i,j) = dtPO * (uicePO(i,j)-uicePO(im1(i),j)) / dx
      WKxy3(i,j) = dtPO * (vicePO(i,j)-vicePO(im1(i),j)) / dx
 1151 continue
C +
              i=1
      do 1152 j=jp11,my
      WKxy2(i,j) = dtPO * (uicePO(i,j)-uicePO(i,jm1(j))) / dy
      WKxy4(i,j) = dtPO * (vicePO(i,j)-vicePO(i,jm1(j))) / dy
 1152 continue
C +
      do 1153 j=1,my
      do 1153 i=1,mx
      if (isolSL(i,j).le.2)    then
       if(uicePO(i,j).gt.0.d0) then
        if (i.gt. 1) then
C +...  Free Lateral Boundary Conditions
C +
          WKxyz1(i,j,mz) = uicePO(i,j)- uicePO(i,j) *WKxy1(i  ,j)
          WKxyz2(i,j,mz) = vicePO(i,j)- uicePO(i,j) *WKxy3(i  ,j)
        end if
       else
        if (i.lt.mx) then
          WKxyz1(i,j,mz) = uicePO(i,j)- uicePO(i,j) *WKxy1(i+1,j)
          WKxyz2(i,j,mz) = vicePO(i,j)- uicePO(i,j) *WKxy3(i+1,j)
        end if
       end if
C +
       if(vicePO(i,j).gt.0.d0) then
        if (j.gt. 1) then
          WKxyz1(i,j,mz) = WKxyz1(i,j,mz) - vicePO(i,j) *WKxy2(i,j  )
          WKxyz2(i,j,mz) = WKxyz2(i,j,mz) - vicePO(i,j) *WKxy4(i,j  )
        end if
       else
        if (j.lt.my) then
          WKxyz1(i,j,mz) = WKxyz1(i,j,mz) - vicePO(i,j) *WKxy2(i,jp1(j))
          WKxyz2(i,j,mz) = WKxyz2(i,j,mz) - vicePO(i,j) *WKxy4(i,jp1(j))
        end if
       end if
      end if
 1153 continue
C +
      do 1154 j=1,my
      do 1154 i=1,mx
      if (isolSL(i,j).le.2)    then
          uicePO(i,j)    = WKxyz1(i,j,mz)
          vicePO(i,j)    = WKxyz2(i,j,mz)
      end if
 1154 continue
C +
C +
C +--FREE-DRIFT MODEL
C +  ================
C +
      if (fcorDY(imez,jmez).gt.0.d0) then
       argi =-pi * 20.d0 / 180.d0
      else
       argi = pi * 20.d0 / 180.d0
C +... argi : Angle between 10m-height Wind Vector and Sea-Ice/Frazil Drift
C +          (Angle results from equilibrium between lateral (wind) Stress 
C +                                          and     Coriolis Force       )
C +           D.Martinson, Personal Communication, 1 Nov 1992
C +
      end if
C +
       cosi = cos(argi)
       sini = sin(argi)
C +
      jmx   = 2
      jmx   = min(jmx,my)
C +
      do 120 j=jmx,my
      do 120 i=  1,mx
C +
      uuxm    = 0.50d0 * (uairDY(i,j,mz)+uairDY(im1(i),j     ,mz))
      uuym    = 0.50d0 * (uairDY(i,j,mz)+uairDY(i     ,jm1(j),mz))
      vvxm    = 0.50d0 * (vairDY(i,j,mz)+vairDY(im1(i),j     ,mz))
      vvym    = 0.50d0 * (vairDY(i,j,mz)+vairDY(i     ,jm1(j),mz))
      uu      = uuxm * cosi - vvxm * sini
      vv      = uuym * sini + vvym * cosi
C +
C +
C +--Frazil  Velocity (Free Drift Assumption)
C +  ----------------------------------------
C +
      ufraPO(i,j) = uu * 0.040d0
      vfraPO(i,j) = vv * 0.040d0
C +... 0.040: Fact. between 10m-height Wind Norm   and         Frazil Drift
C +           D.Martinson, Personal Communication, 1 Nov 1992
C +
C +
C +--Sea-Ice Velocity (Free Drift Assumption)
C +  ----------------------------------------
C +
c #FD uicePO(i,j) = uu * 0.024d0
c #FD vicePO(i,j) = vv * 0.024d0
C +... 0.024: Fact. between 10m-height Wind Norm   and Sea-Ice        Drift
C +           D.Martinson, Personal Communication, 1 Nov 1992
 120  continue
C +
C +
C +
C +--SEA-ICE CONSERVATION 
C +  ====================
C +
C +... First Order Accurate Conservative Positive Definite Advection Scheme 
C +    [see Bott (1989) MWR, 117, 1007 (3)-(4)]
C +    Free Lateral Boundary Conditions are used
C +
      do 130  j=1,my
      do 130  i=1,mx
      WKxy1 (i,j)    = 0.0d0 
      WKxy2 (i,j)    = 0.0d0 
      WKxy3 (i,j)    = 0.0d0 
      WKxy4 (i,j)    = 0.0d0 
 130  continue
C +
C +- Courant Mumber and Limitation of a Local Time Step
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #CN cflmax     = 0.d0
      do 1301 j=1,my
      do 1301 i=1,mx1
      cflui      = dtPO      * uicePO(ip1(i),j)   / dx
c #CN cfl        =         abs(cflui)
c #CN cflmax     =         max(cfl,cflmax)
      WKxy1(i,j) =     0.5d0 *(cflui +abs(cflui))
      WKxy2(i,j) =    -0.5d0 *(cflui -abs(cflui))
 1301 continue
C +
      if (mmy.gt.1) then
      do 1302 j=1,my1
      do 1302 i=1,mx
      cflvi      = dtPO      * vicePO(i,jp1(j))   / dy
c #CN cfl        =         abs(cflvi)
c #CN cflmax     =         max(cfl,cflmax)
      WKxy3(i,j) =     0.5d0 *(cflvi +abs(cflvi))
      WKxy4(i,j) =    -0.5d0 *(cflvi -abs(cflvi))
 1302 continue
      end if
C +
c #CN ntsi  = cflmax * 1.5d0
C +...                 1.5: Security Factor
C +
      ntsi  = max(1,ntsi)
      dtsi  = dtPO /ntsi
C +
c #CN do 1303 j=1,my
c #CN do 1303 i=1,mx1
c #CN WKxy1(i,j) = WKxy1(i,j) / ntsi
c #CN WKxy2(i,j) = WKxy2(i,j) / ntsi
 1303 continue
C +
c #CN if (mmy.gt.1) then
c #CN do 1304 j=1,my1
c #CN do 1304 i=1,mx
c #CN WKxy3(i,j) = WKxy3(i,j) / ntsi
c #CN WKxy4(i,j) = WKxy4(i,j) / ntsi
 1304 continue
c #CN end if
C +
C +--Local Iterations of Advection
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c #CN do 131  itsi=1,ntsi
      do 1310 j=1,my
      do 1310 i=1,mx
        WKxyz1(i,j,mz)   = 0.0d0
        WKxyz2(i,j,mz)   = 0.0d0
        WKxyz1(i,j,mmz1) = unun - aicePO(i,j)
C +...  WKxyz1(i,j,mmz1) : open ocean fraction
C +
        WKxyz1(i,j,mmz2) =        aicePO(i,j)
C +...  WKxyz1(i,j,mmz2) : sea-ice    fraction
C +
 1310 continue
C +
      do 1315 j=1,my
      do 1313 i=ip11,mx1
      WKxyz1( i,j,mz) = aicePO( i,j) 
     .+maskSL(i,j)*( WKxy2(i     ,j)                 *aicePO(ip1(i),j) 
     .             + WKxy1(im1(i),j)                 *aicePO(im1(i),j) 
     .             -(WKxy1(i     ,j)+WKxy2(im1(i),j))*aicePO(i     ,j))
      WKxyz2( i,j,mz) = hicePO( i,j)
     .+maskSL(i,j)*( WKxy2(i     ,j)                 *hicePO(ip1(i),j) 
     .             + WKxy1(im1(i),j)                 *hicePO(im1(i),j) 
     .             -(WKxy1(i     ,j)+WKxy2(im1(i),j))*hicePO(i     ,j))
 1313 continue
      WKxyz1( 1,j,mz) = aicePO( 1,j)
     .+maskSL(1,j)*( WKxy2(1     ,j)                 *aicePO(ip11,j) 
     .             - WKxy1(1     ,j)                 *aicePO(1      ,j))
      WKxyz2( 1,j,mz) = hicePO( 1,j)
     .+maskSL(1,j)*( WKxy2(1     ,j)                 *hicePO(ip11,j) 
     .             - WKxy1(1     ,j)                 *hicePO(1      ,j))
      WKxyz1(mx,j,mz) = aicePO(mx,j)
     .+maskSL(mx,j)*(WKxy1(mx1,j)                *aicePO(mx1,j) 
     .             -                WKxy2(mx1,j) *aicePO(mx ,j))
      WKxyz2(mx,j,mz) = hicePO(mx,j)
     .+maskSL(mx,j)*(WKxy1(mx1,j)                *hicePO(mx1,j) 
     .             -                WKxy2(mx1,j) *hicePO(mx ,j))
 1315 continue
C +
C +--Output for Verification 
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #VR route = ' END Advection '
c #VR write(6,6602)          route,
c #VR.              ((aicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6603) ((hicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6604) (( psice(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6611) ((uicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6612) ((vicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6605) ((vgriPO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
C +
      if (mmy.gt.1) then
      do 1316 i=1,mx
      do 1314 j=jp11,my1
      WKxyz1(i, j,mz) = WKxyz1(i, j,mz)
     .+maskSL(i,j)*( WKxy4(i,j     )                 *aicePO(i,jp1(j)) 
     .             + WKxy3(i,jm1(j))                 *aicePO(i,jm1(j)) 
     .             -(WKxy3(i,j     )+WKxy4(i,jm1(j)))*aicePO(i,j  ))
      WKxyz2(i, j,mz) = WKxyz2(i, j,mz)
     .+maskSL(i,j)*( WKxy4(i,j     )                 *hicePO(i,jp1(j)) 
     .             + WKxy3(i,jm1(j))                 *hicePO(i,jm1(j)) 
     .             -(WKxy3(i,j     )+WKxy4(i,jm1(j)))*hicePO(i,j    ))
 1314 continue
      WKxyz1(i, 1,mz) = WKxyz1(i, 1,mz)
     .+maskSL(i,1)*( WKxy4(i,1     )                 *aicePO(i,jp11) 
     .             - WKxy3(i,1     )                 *aicePO(i,1     ))
      WKxyz2(i, 1,mz) = WKxyz2(i, 1,mz)
     .+maskSL(i,1)*( WKxy4(i,1     )                 *hicePO(i,jp11) 
     .             - WKxy3(i,1     )                 *hicePO(i,1     ))
      WKxyz1(i,my,mz) = WKxyz1(i,my,mz)
     .+maskSL(i,my)*(WKxy3(i,my1)                *aicePO(i,my1) 
     .             -                 WKxy4(i,my1)*aicePO(i,    my))
      WKxyz2(i,my,mz) = WKxyz2(i,my,mz)
     .+maskSL(i,my)*(WKxy3(i,my1)                *hicePO(i,my1) 
     .             -                 WKxy4(i,my1)*hicePO(i,    my))
 1316 continue
      end if
C +
      do 132  j=1,my
      do 132  i=1,mx
      WKxy1 (i,j)    = 0.0d0 
      WKxy2 (i,j)    = 0.0d0 
      WKxy3 (i,j)    = 0.0d0 
      WKxy4 (i,j)    = 0.0d0 
      aicePO(i,j)    = WKxyz1(i,j,mz)
     .                                + psice (i,j)    * dtsi
C +...Redistribution Function of Shinohara 1990 JGR 95, p.13426 (24) 
C +   
      hicePO(i,j)    = WKxyz2(i,j,mz) 
     .               * WKxyz1(i,j,mz) / max(epsi,aicePO(i,j))
      WKxyz1(i,j,mz) = 0.0d0
      WKxyz2(i,j,mz) = 0.0d0
 132  continue
C +
      do 133  j=1,my
      do 133  i=1,mx
C +
C +
C +--Sea-Ice Fraction and Thickness must be positive
C +  -----------------------------------------------
C +
      if (aicePO(i,j).le.zero.or.
     .    hicePO(i,j).le.zero) then
          aicePO(i,j) =  zero
          hicePO(i,j) =  zero
      end if
C +
C +
C +--Sea-Ice Fraction must be smaller than or equal to 1
C +  ---------------------------------------------------
C +
      if (aicePO(i,j).gt.unun) then
          hicePO(i,j) =  hicePO(i,j) * aicePO(i,j)
          aicePO(i,j) =  unun
      end if
C +
C +
C +--Convergence ==> Free Grease Ice Piling up / Compaction 
C +  ------------------------------------------------------
C +
      IF (freeri                                   .and.
     .    hicePO(i,j).gt.                    zero  .and.
     .    aicePO(i,j).gt.WKxyz1(i,j,mmz2)          .and.
C +...    aicePO(i,j).gt.WKxyz1(i,j,mmz2) <== Convergence
C +
     .                   WKxyz1(i,j,mmz2).gt.epsi)                THEN
          vgriPO(i,j) = vgriPO(i,j)  * aicePO(i,j)/WKxyz1(i,j,mmz2)
C +...    Grease Ice Volume Increases as Ice Fraction aicePO
C +
          vice        =          aicePO(i,j) * hicePO(i,j)
          vgriPO(i,j) = min(vice,vgriPO(i,j))
          agri        =          vgriPO(i,j) / hicePO(i,j)
          agrin       = max(zero,agri -aicePO(i,j)+WKxyz1(i,j,mmz2))
          dagri       =          agrin-agri
C +...    Grease Ice Fraction Variation is negative here
C +
          dagri       = max(    dagri,-aicePO(i,j))
C +...    Grease Ice Fraction Flux Limitor
C +
          agrin       = agri        + dagri
          aicePO(i,j) = aicePO(i,j) + dagri
          hicePO(i,j) = vice        / aicePO(i,j)
          vgriPO(i,j) = agrin       * hicePO(i,j)
      END IF
 133  continue
C +
C +--Output for Verification 
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #VR route = ' END Grease Ice'
c #VR write(6,6602)          route,
c #VR.              ((aicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6603) ((hicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
C +
 131  continue
C +
C +
C +--FRAZIL  CONSERVATION
C +  ====================
C +
C +--Frazil Production
C +  -----------------
C +
      do 140 j=1,my
      do 140 i=1,mx
       firupp = stefan *tsrfSL(i,j,2) *tsrfSL(i,j,2) 
     .                 *tsrfSL(i,j,2) *tsrfSL(i,j,2)
C +... FirUpP : Upward IR over Ice-free Water
C +
       albwPO(i,j) = .07d0                          *       cld_SL(i,j)
     .  +(.05d0 / (1.1d0*czenGE(i,j)**1.4d0 +.15d0))* (1.d0-cld_SL(i,j))
C +
       hatmPO(i,j) =  abs(nSLsrf(i,j)-iun)*
     .  ( sol_SL(i,j)*(1.d0-albwPO(i,j))/(1.d0-albeSL(i,j))
C +...    Absorbed Solar Heat Flux
C +
     .  +(RAd_ir(i,j) - firupp)*eps0SL(i,j)
C +...    Net I.R.       Heat Flux
C +
     .  + SLutsl(i,j,2) * rolvDY(i,j,mz) *1000.d0*cp
C +...    Sensible       Heat Flux
C +
     .  + SLuqsl(i,j,2) * rolvDY(i,j,mz) *1000.d0*Lv_H2O ) 
C +...    Latent         Heat Flux
C +
     .           +max(0,2-isolSL(i,j))*
     .  ( sol_SL(i,j)*(1.d0-albwPO(i,j))/(1.d0-albeSL(i,j))
C +...    Absorbed Solar Heat Flux
C +
     .  +(RAd_ir(i,j) - firupp)*eps0SL(i,j)
C +...    Net I.R.       Heat Flux
C +
     .  + SLutsl(i,j,1) * rolvDY(i,j,mz) *1000.d0*cp
C +...    Sensible       Heat Flux
C +
     .  + SLuqsl(i,j,1) * rolvDY(i,j,mz) *1000.d0*Lv_H2O )
C +...    Latent         Heat Flux
C +
c #HA  hatmPO(i,j) =  abs(nSLsrf(i,j)-iun)*
c #HA.  (-2000.d0*ssvSL(i,j,mz)/20.d0)
c #HA.           +max(0,2-isolSL(i,j))*
c #HA.  (-2000.d0*ssvSL(i,j,mz)/20.d0)
C +
       dhw        = 
     . - dtPO *(                   hatmPO(i,j) 
     .          - fracoh *min(zero,hatmPO(i,j)) 
C +...            fracoh           = 0.25
C +*** Hibler (1984), ANTARCTIC Ocean: 25% of cooling => Oceanic Heat Flux
C +    (Hansen and Takahashi Eds) 
C +    Geophys. Monogr. 29, M. Ewing Vol. 5, AGU, p. 241
     .                                          ) / silfPO
       hfraPO(i,j)  = hfraPO (i,j) + dhw
C +
C +
C +--Variation of Sea Water Properties
C +  ---------------------------------
C +
       dsw         = (swsaPO(i,j)-si00PO) * SLsrfl(i,j,2) * dhw / 400.d0
C +... dsw : salinity variation (diluted over Terra Nova 400m oceanic depth)
C +
       WKxy1(i,j)  = cwswPO(i,j)
       WKxy2(i,j)  = tsswPO(i,j)
C +... Old Values
C +
       swsaPO(i,j) = swsaPO(i,j) + dsw 
       swsa2       = swsaPO(i,j) * swsaPO(i,j)
       tsswPO(i,j) = TfSnow - 1.d-3*(3.d0+53.75*swsaPO(i,j)
     .                                   +4.d-2*swsa2
     .                                   +4.d-6*swsa2*swsaPO(i,j))
       tsswc       = tsswPO (i,j) - TfSnow
       tssw0       = tsswc      + 7.0d-1 *swsaPO(i,j) + 1.75d-2*swsa2
C +... assume SST  = tsswc     
       argt0       =-4.8d-2*tssw0
       cwsw0       = 4178.4d0 + (8.46d0+26.19d0*exp(argt0))
     .                  *1.d-3*(tssw0 -33.67d0)
       cwswPO(i,j) = cwsw0 - 5.075 *swsaPO(i,j) -1.4d-2*swsa2
C +... cwswPO      : Sea Water Heat Capacity 
C +
 140   continue
C +
      if (iterun.gt.0) then
       do 141 j=1,my
       do 141 i=1,mx
       hsst(i,j) =( WKxy1(i,j) * WKxy2(i,j) 
     .           - cwswPO(i,j) *tsswPO(i,j)) *400.d3 /dtPO
C +... hsst      : because of the Solification Temperature Increase, an
C +                 Additional Cooling Rate is necessary over 400.d3 kg/m2
       swlf(i,j) = 1024.d0 *333.9d3 
     .           *(1.d0-1.d-3*si00PO-
     .            (1.d0-1.d-3*swsaPO(i,j))*si00PO/swsaPO(i,j))
C +... swlf      : Sea Water Latent Heat of Solidification [J.m-3]
C +
 141   continue
      end if
C +
C +
C +--Frazil  Velocity (Correction for small Frazil Concentration)
C +  ------------------------------------------------------------
C +
      jmx   = 2
      jmx   = min(jmx,my)
C +
      do 142 j=jmx,my
      do 142 i=  1,mx
      uwa(i,j) = ufraPO(i,j)
      vwa(i,j) = vfraPO(i,j)
      if (aicePO(i     ,j     ).ge.advfra.or.
     .    aicePO(im1(i),j     ).ge.advfra) uwa(i,j) = 0.d0
      if (aicePO(i     ,j     ).ge.advfra.or.
     .    aicePO(i     ,jm1(j)).ge.advfra) vwa(i,j) = 0.d0
 142  continue
C +
C +
C +--Frazil Advection (1st order accurate Upstream Scheme)
C +  -----------------------------------------------------
C +
C +... First Order Accurate Conservative Positive Definite Advection Scheme 
C +    [see Bott (1989) MWR, 117, 1007 (3)-(4)]
C +    Free Lateral Boundary Conditions are used
C +
c #CN uwvwmx = epsi
      do 143 j=1,my
      do 143 i=1,mx
c #CN uwvw   = abs(uwa(i,j))
c #CN uwvwmx = max(uwvw,uwvwmx)
c #CN uwvw   = abs(vwa(i,j))
c #CN uwvwmx = max(uwvw,uwvwmx)
      WKxyz1(i,j,mmz1)  = 1.d0 -aicePO(i,j)
C +...WKxyz1(i,j,mmz1)  : Frazil Ice Concentration
C +
 143  continue
C +
c #CN dtfr = 0.9d0*dx/uwvwmx
c #CN ntfr = dtPO/dtfr
      ntfr =  max(ntfr,1)
      dtfr = dtPO/ntfr
C +
c #CN do 1439 itfr=1,ntfr
      do 1430 j=1,my
      do 1430 i=1,mx
      WKxyz1(i,j,mmz2) = WKxyz1(i,j,mmz1) * hfraPO(i,j)
C +...WKxyz1(i,j,mmz2) : Frazil Ice Volume
C +
 1430 continue
C +
C +- Frazil Ice Fluxes
C +  ~~~~~~~~~~~~~~~~~
      do 1431 j=1,my
      do 1431 i=1,mx1
      cfluw      =dtfr*0.5d0 * uwa(ip1(i),j)
     .                *(WKxyz1(ip1(i),j,mmz2)+WKxyz1(i,j,mmz2)) / dx
      WKxy1(i,j) =     0.5d0 *(cfluw    +abs(cfluw))
      WKxy2(i,j) =    -0.5d0 *(cfluw    -abs(cfluw))
 1431 continue
C +
      if (mmy.gt.1) then
      do 1432 j=1,my1
      do 1432 i=1,mx
      cflvw      =dtfr*0.5d0 * vwa(i,jp1(j))
     .                *(WKxyz1(i,jp1(j),mmz2)+WKxyz1(i,j,mmz2)) / dy
      WKxy3(i,j) =     0.5d0 *(cflvw    +abs(cflvw))
      WKxy4(i,j) =    -0.5d0 *(cflvw    -abs(cflvw))
 1432 continue
      end if
C +
      do 1434 j=1,my
      do 1433 i=ip11,mx1
      WKxyz1( i,j,mz) = WKxyz1(i,j,mmz2) +  maskSL(i,j)
     . *(  WKxy2(i     ,j)                 *WKxyz1(ip1(i),j,mmz1) 
     .  +  WKxy1(im1(i),j)                 *WKxyz1(im1(i),j,mmz1) 
     .  - (WKxy1(i     ,j)+WKxy2(im1(i),j))*WKxyz1(i     ,j,mmz1))
C +...WKxyz1( i,j,mz) : New Frazil Ice Volume
C +
 1433  continue
      WKxyz1( 1,j,mz) = WKxyz1( 1,j,mmz2) + maskSL(1,j)
     . *( WKxy2(1      ,j)                 *WKxyz1(ip11 ,j,mmz1) 
     .  - WKxy1(1      ,j)                 *WKxyz1(1      ,j,mmz1))
      WKxyz1(mx,j,mz) = WKxyz1(mx,j,mmz2)+  maskSL(    mx ,j)
     . *( WKxy1(mx1,j)                 *WKxyz1(mx1,j,mmz1) 
     .  -                 WKxy2(mx1,j) *WKxyz1(    mx ,j,mmz1))
 1434  continue
C +
      if (mmy.gt.1) then
      do 1436 i=1,mx
      do 1435 j=jp11,my1
      WKxyz1(i, j,mz) = WKxyz1(i, j,mz)  + maskSL(i,j)
     . *( WKxy4(i,j     )                 *WKxyz1(i,jp1(j),mmz1) 
     .  + WKxy3(i,jm1(j))                 *WKxyz1(i,jm1(j),mmz1) 
     .  -(WKxy3(i,j     )+WKxy4(i,jm1(j)))*WKxyz1(i,j     ,mmz1))
 1435  continue
      WKxyz1(i, 1,mz) = WKxyz1(i, 1,mz)  + maskSL(i, 1)
     . *( WKxy4(i,1     )                 *WKxyz1(i,jp11,mmz1) 
     .  - WKxy3(i,1     )                 *WKxyz1(i,1      ,mmz1))
      WKxyz1(i,my,mz) = WKxyz1(i,my,mz) +  maskSL(i,my)
     . *( WKxy3(i,my1)                *WKxyz1(i,my1,mmz1) 
     .  -                 WKxy4(i,my1)*WKxyz1(i,    my ,mmz1))
 1436  continue
      end if
C +
      do 1437  j=1,my
      do 1437  i=1,mx
      if (WKxyz1(i,j,mmz1).gt.fraadv) then 
          hfraPO(i,j)    = WKxyz1(i,j,mz) / WKxyz1(i,j,mmz1)
      end if
C +
C +- Working Variables are reset to Zero
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      do 1437 k=mmz2,mz,2
      WKxyz1(i,j, k) = 0.0d0
 1437 continue
C +
      do 1438  j=1,my
      do 1438  i=1,mx
      WKxy1 (i,j)    = 0.0d0 
      WKxy2 (i,j)    = 0.0d0 
      WKxy3 (i,j)    = 0.0d0 
      WKxy4 (i,j)    = 0.0d0 
 1438 continue
 1439 continue
C +
C +
C +--LATERAL ACCRETION in POLYNYA and LEADS
C +  ======================================
C +
      DO j=1,my
      DO i=1,mx
C +
C +
C +--Turning "on" Frazil Collection Process
C +  --------------------------------------
C +
        IF   (isolSL(i,j).eq.2   .and.aicePO(i,j).lt.unun)        THEN
C +...    Lateral Accretion is computed where ocean is ice free
C +       and using Ou (1988, JPO) Model
C +...    In Principle, Numerical Diffusion in the Positive Definite
C +       Advection Scheme precludes  aicePO .le. 0.d0
C +       so that the case            aicePO .lt. 0.d0 is not considered
C +
              vfraz        =  (unun - aicePO(i,j)) * hfraPO(i,j)
              vice         =          aicePO(i,j)  * hicePO(i,j)
C +
          IF (hfraPO(i,j).gt.0.d0.and.hfraPO(i,j).lt.hwl)         THEN
C +
C +- Normalized Length and Surfaces
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    auw    = abs(ufraPO(i,j))
                    avw    = abs(vfraPO(i,j))
                    tannum = min(auw,avw)
                    tanden = max(auw,avw)
                    ssvw   = sqrt(auw*auw+avw*avw)
C +...              ssvw   : Frazil Speed Scale
C +
            IF     (tanden.gt.epsi)                               THEN
                    tana   = tannum / tanden
                    sina   = tannum / ssvw  
                    cosa   = tanden / ssvw  
                    srf1   = 0.5d00 * tana
                    rr11   = sina
                    srf2   = 1.0d00 - tana
                    rr22   = cosa   - sina
                    srf3   = srf1
                    rr33   = sina
                    srf    = aicePO(i,j)
C +
C +- Sea Ice     Normalized Length
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              IF   (srf.lt.srf1)                                  THEN
                    rrrr   =  2.d0 * srf * cosa 
              ELSE
                IF (srf.lt.(srf1+srf2))                           THEN
                    rrrr =  sina +(cosa-sina)*(srf  -0.5d0*tana)
     .                                       /(1.0d0-      tana)
                ELSE
                    rrrr =  cosa *(1.d0+2.d0 *(srf  -1.0d0+tana*0.5d0))
                END IF
              END IF
                    ddrr =  dtPO *hfraPO(i,j) *ssvw 
     .                   /((hwl  -hfraPO(i,j))*dx  )
C +...              ddrr :  Frazil collected Extent (Ou 1988 JPO p.585)
C +                         (normalized by dx) 
C +
C +- Sea Ice new Normalized Surface
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    rrrr =   rrrr+ddrr 
              IF   (rrrr.gt.(rr11+rr22+rr33))                     THEN
                    aicen=   unun  
              ELSE
                IF (rrrr.gt.(rr11+rr22))                          THEN
                    aicen=   0.5d0*(1.d0-tana+rrrr/cosa)
                ELSE
                 IF(rrrr.gt. rr11)                                THEN
                    aicen=   0.5d0* tana
     .                       +(1.d0-tana)*(rrrr-sina)/(cosa-sina)
                 ELSE
                    aicen=   0.5d0* rrrr/ cosa
                 END IF
                END IF
              END IF
C +
            ELSE
                    aicen=  aicePO(i,j)
            END IF 
C +
          ELSE
C +
C +- Freezing if Frazil Thickness .ge. Frazil Collection Thickness 
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            IF (hfraPO(i,j).gt.0.d0)                              THEN
                    aicen=  unun
C +
C +- NO          Frazil is available
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ELSE
                    aicen=  aicePO(i,j)
                    dvice=  zero
            END IF
          END IF
C +
C +
C +--Ensure Frazil Volume and Consolidated Ice Volume Conservation 
C +  -------------------------------------------------------------
C +
          IF   (hfraPO(i,j).gt.0.d0)                              THEN
                    daice       =  aicen - aicePO(i,j)
C +...              daice       :  Positive Definite Value
C +
                    dvice       =  daice * hwl
                    dvice       =  min (vfraz,dvice)
C +...                             Flux Limitor on Frazil Collection
C +
                    daice       =  dvice / hwl
                    aicen       =  daice + aicePO(i,j)
C +
             IF    (aicen.lt.unun)                                THEN
                    flead       =  unun   - aicen
                    hfraPO(i,j) = (vfraz  - dvice) / flead
             ELSE
                    hfraPO(i,j) =  zero
             END IF
C +
             IF                   (aicen.gt.0.d0)                 THEN
                    aicePO(i,j) =  aicen
                    hicePO(i,j) = (vice   + dvice) / aicen
             END IF
          END IF
C +
C +
C +--Grease Ice Variation
C +  --------------------
C +
          IF (freeri) then
                    vgriPO(i,j) =  vgriPO(i,j) + dvice
C +...              vgriPO      :  is increased by Frazil Collection
C +
                    vgriPO(i,j) =  vgriPO(i,j) * exp(-dtPO/tcompa)
C +...              vgriPO      :  exponential Decay by progressive Compaction
C +
          END IF
        END IF
C +
      END DO
      END DO
C +
C +--Output for Verification 
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #VR route = ' BEFORE UPDATE '
c #VR write(6,6602)          route,
c #VR.              ((aicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
c #VR write(6,6603) ((hicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
C +
C +
C +--SURFACES UPDATE
C +  ===============
C +
      do 160 j=1,my
      do 160 i=1,mx
C +
C +
C +--New Open Ocean Grid Points
C +  --------------------------
C +
        IF(isolSL(i,j).eq.2.and.
     .    (hicePO(i,j) .le. epsi   .or. aicePO(i,j) .le. epsi  )) THEN
           isolSL(i,j)   =  1
           hfraPO(i,j)   =  hfraPO(i,j)+aicePO(i,j)*hicePO(i,j)
           hicePO(i,j)   =  0.0d+0
           aicePO(i,j)   =  0.0d+0
           nSLsrf(i,j)   =  1
           tsrfSL(i,j,1) =  tsrfSL(i,j,2)
           tsrfSL(i,j,2) =  0.0d+0
            dtgSL(i,j,1) =  0.0d+0
            dtgSL(i,j,2) =  0.0d+0
        END IF
C +
C +
C +--New Sea-Ice    Grid Points
C +  --------------------------
C +
        IF  (  isolSL(i,j)  .eq.1                                .and.
     .       ((tsrfSL(i,j,1).le.tfrwat.and.hbalSL(i,j).gt.0.0d+0).or.
     .        (aicePO(i,j)  .gt.epsi                            )    ))
     .                                                            THEN
               aicenh        =      hbalSL(i,j) * dtPO /  silfPO
C +...         aicePO *hwl *silfPO= hbalSL      X dtPO
C +
     .                       +      hfraPO(i,j) *(1.d0 -  aicePO(i,j))
     .                       +      hicePO(i,j) *         aicePO(i,j)
               aicen         =      aicenh             /  hwl
               aicen         =  min(aicen,unun)
C +
           IF (aicen.gt.1.d-2)                                    THEN
               isolSL(i,j)   =      2
               aicePO(i,j)   =      aicen
            IF(aicen.lt.1.d+0)                                    THEN
               aicenh        =      aicenh -(1.d0-aicen) *hfraPO(i,j)
            ELSE
               hfraPO(i,j)   =      0.d+0
            END IF
               hicePO(i,j)   =      aicenh             /  aicen
C +
               nSLsrf(i,j)   =      2
               tsrfSL(i,j,2) =      tfrwat
                d1_SL(i,j)   =      1.05d5
                dtgSL(i,j,2) =       dtgSL(i,j,1)
           ELSE
               aicePO(i,j)   =      0.d+0
               hicePO(i,j)   =      0.d+0
               hfraPO(i,j)   =      aicenh
           END IF
C +
        END IF
C +
C +
C +-- Grid Boxes containing Leads
C +   ---------------------------
C +
      if  (isolSL(i,j) .ne.2.or.aicePO(i,j).ge.1.d0) then
           nSLsrf(i,j)  =1
      else
           nSLsrf(i,j)  =2
      end if
C +
       if (isolSL(i,j) .eq. 2) then
           SLsrfl(i,j,2)=1.d0       -   aicePO(i,j)
       else
           SLsrfl(i,j,2)=0.d0
       end if
           SLsrfl(i,j,1)=1.d0       - SLsrfl(i,j,2)
C +
       if (nSLsrf(i,j).eq.1) then
           tgirSL(i,j)  =tsrfSL(i,j,1)
       else
           tgirSL(i,j)  =sqrt(sqrt(
     .     SLsrfl(i,j,1)*tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .                  *tsrfSL(i,j,1)*tsrfSL(i,j,1)
     .    +SLsrfl(i,j,2)*tsrfSL(i,j,2)*tsrfSL(i,j,2)
     .                  *tsrfSL(i,j,2)*tsrfSL(i,j,2)))
       end if
C +
C +
C +-- Mean ``Sea-Ice'' Thickness
C +   --------------------------
C +
          hiavPO(i,j) = 
     .  (SLsrfl(i,j,1)*hicePO (i,j)+SLsrfl(i,j,2)*hfraPO(i,j)) 
     . /(SLsrfl(i,j,1)             +SLsrfl(i,j,2))
C +
 160  continue
C +
C +
C +--LATERAL BOUNDARY CONDITIONS
C +  ===========================
C +
       DO j=1,my
         isolSL( 1,j)  = isolSL(ip11,j)
         isolSL(mx,j)  = isolSL(mx1,j)
         SLsrfl( 1,j,1)= SLsrfl(ip11,j,1)
         SLsrfl( 1,j,2)= SLsrfl(ip11,j,2)
         SLsrfl(mx,j,1)= SLsrfl(mx1,j,1)
         SLsrfl(mx,j,2)= SLsrfl(mx1,j,2)
         aicePO( 1,j)  = aicePO(  2,j)
         hicePO( 1,j)  = hicePO(  2,j)
         hfraPO( 1,j)  = hfraPO(  2,j)
         aicePO(mx,j)  = aicePO(mx1,j)
         hicePO(mx,j)  = hicePO(mx1,j)
         hfraPO(mx,j)  = hfraPO(mx1,j)
       END DO
C +
       DO i=1,mx
         isolSL(i, 1)  = isolSL(i,jp11)
         isolSL(i,my)  = isolSL(i,my1)
         SLsrfl(i, 1,1)= SLsrfl(i,jp11,1)
         SLsrfl(i, 1,2)= SLsrfl(i,jp11,2)
         SLsrfl(i,my,1)= SLsrfl(i,my1,1)
         SLsrfl(i,my,2)= SLsrfl(i,my1,2)
         aicePO(i, 1)  = aicePO(i,jp11)
         hicePO(i, 1)  = hicePO(i,jp11)
         hfraPO(i, 1)  = hfraPO(i,jp11)
         aicePO(i,my)  = aicePO(i,my1)
         hicePO(i,my)  = hicePO(i,my1)
         hfraPO(i,my)  = hfraPO(i,my1)
       END DO
C +
C +
C +--Maximum Polynya Extent
C +  ======================
C +
       DO j=1,my
       DO i=1,mx
         awmxPO(i,j) = max(awmxPO(i,j),SLsrfl(i,j,2))
       END DO
       END DO
C +
C +
C +--Lead Averaged Fraction
C +  ----------------------
C +
             frlead = 0.0d+0
             compte = 0.0d+0
       DO j = 1,jPO4
       DO i = 1,iPO1
         IF (isolSL(i,j).le.2)                                    THEN
             compte = compte + 1.0d+0
             frlead = frlead + SLsrfl(i,j,2)
         END IF
       END DO
       END DO
             compte =      max(unun,compte)
             frlead = frlead * 1.d2/compte
C +
C +
C +--Output
C +  ======
C +
      if ((  jmmMAR.eq.0.and.    jssMAR   .eq.0         .and.
     .     ((IO_loc.ge.2.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.3.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.4)                            )       ).or.
     .       IO_loc.ge.7                                          ) then
        write(4,30) jhurGE,jdarGE,mmarGE,iPO1,iPO2,jPO1,jPO2,frlead
c #VR  if (mmy.gt.1) 
c #VR.  write(6,30) jhurGE,jdarGE,mmarGE,iPO1,iPO2,jPO1,jPO2,frlead
 30     format(/,i3,' UT  ',i3,'/',i3,' POLYNYA EXTENT  i = ',
     .           i3,' -> ',i3,' j = ',i3,' -> ',i3,
     .          '   /   Fraction Lead :',e12.4,
     .         /,1x,60('^'))
C +
       if (fulwri) then
        write(4,360)((isolSL(i,j)
     .           -abs(nSLsrf(i,j)-iun),i=iPO1,iPO2),j=jPO2,jPO1,-1)
 360    format(33i4)
        write(4,361)
 361    format(  /,'  Ui [m/s] :',/,'  ----------')
        write(4,36 )((   uicePO (i,j),i=iPO1,iPO2),j=jPO2,jPO1,-1)
        write(4,362)
 362    format(  /,'  Vi [m/s] :',/,'  ----------')
        write(4,36 )((   vicePO (i,j),i=iPO1,iPO2),j=jPO2,jPO1,-1)
 36     format(33f4.1)
        write(4,363)
 363    format( /,'  SrfWat:',/,'  -------')
        rjd = jdarGE
        rjh = jhurGE
        write(4,364)((1.d+1*SLsrfl(i,j,2), i=iPO1,iPO2),j=jPO2,jPO1,-1)
c #VR  if (mmy.eq.1) 
c #VR.  write(6,364) rjd,rjh,
c #VR.              ((1.d+1*SLsrfl(i,j,2), i=iPO1+2
c #VR.                                      ,iPO2),j=jPO2,jPO1,-1)
 364    format(33f4.1)
        write(4,365)
 365    format( /,'  HA[kW/m2]:',/,'  ----------')
        write(4,364)((1.d-3*hatmPO(i,j), i=iPO1,iPO2),j=jPO2,jPO1,-1)
c #WR   write(4,366)
 366    format( /,'  H+ [W/m2]:',/,'  ----------')
c #WR   write(4,364)((     hsst(i,j), i=iPO1,iPO2),j=jPO2,jPO1,-1)
        write(4,367)
 367    format( /,'  hFra [cm]:',/,'  ----------')
        write(4,364)((1.d+2*hfraPO(i,j), i=iPO1,iPO2),j=jPO2,jPO1,-1)
        write(4,368)
 368    format( /,'  hi[cm]:',   /,'  -------')
        write(4,369)((1.d+2*hiavPO(i,j), i=iPO1,iPO2),j=jPO2,jPO1,-1)
 369    format(33f4.0)
       end if
      end if
C +
C +
C +--Local Output
C +  ------------
C +
      if ((  jmmMAR.eq.0.and.    jssMAR   .eq.0         .and.
     .     ((IO_loc.ge.2.and.    jhurGE   .eq.0) .or. 
     .      (IO_loc.ge.2.and.mod(jhurGE,3).eq.0) .or. 
     .      (IO_loc.ge.3)                            )       ).or.
     .       IO_loc.ge.7                                          ) then
        write(4,39) jhurGE,minuGE,jdarGE,mmarGE,iPO3,iPO4,jPO3,jPO4,
     .              frlead
 39     format(/,i3,'UT',i2,i6,'/',i3,' POLYNYA EXTENT  i = ',
     .           i3,' -> ',i3,' j = ',i3,' -> ',i3,
     .          '   /   Fraction Lead :',e12.4)
       if (mmy.gt.1) then
        write(4,391)
 391    format(/,'  OPEN OCEAN (LOCAL)    ',' | ',
     .           '  Ui [m/s]              ',' | ',
     .           '  Vi [m/s]              ',' | ',
     .           '  HA [kW/m2]            ',' | ',
     .           '  hFr[cm]               ',
     .         /,4(24('-'),'-+-'),24('-'))
        write(4,392)(( isolSL(i,j)
     .            -abs(  nSLsrf(i,j)-iun),i=iPO3,iPO4),
     .                (  uicePO(i,j),     i=iPO3,iPO4),
     .                (  vicePO(i,j),     i=iPO3,iPO4),
     .             (.001*hatmPO(i,j),     i=iPO3,iPO4),
     .             (100.*hfraPO(i,j),     i=iPO3,iPO4),
     .                                           j=jPO4,jPO3,-1)
 392    format((6i4,' | ',3(6f4.1,' | '),6f4.1))
        write(4,395)
 395    format(/,'  Isop                  ',' | ',
     .           '  Uw [m/s]              ',' | ',
     .           '  Vw [m/s]              ',' | ',
     .           '  Srf WATER             ',' | ',
     .           '  Srf WATER (MAXIMUM)   ',
     .         /,4(24('-'),'-+-'),24('-'))
        write(4,392)( (     nSLsrf(i,j)-iun,i=iPO3,iPO4),
     .                (     ufraPO(i,j),    i=iPO3,iPO4),
     .                (     vfraPO(i,j),    i=iPO3,iPO4),
     .                ( 10.*SLsrfl(i,j,2),  i=iPO3,iPO4),
     .                ( 10.*awmxPO(i,j),    i=iPO3,iPO4),
     .                                                  j=jPO4,jPO3,-1)
        write(4,393)
 393    format(/,'  MaskSL                ',' | ',
     .           '  Int.Stress x [.1mm/s2]',' | ',
     .           '  Int.Stress y [.1mm/s2]',' | ',
     .           '  TOP Stress x   [cm/s2]',' | ',
     .           '  TOP Stress y   [cm/s2]',
     .         /,4(24('-'),'-+-'),24('-'))
        write(4,392)( (      maskSL(i,j),  i=iPO3,iPO4),
     .                ( 1.d4*WKxyz1(i,j,1),i=iPO3,iPO4),
     .                ( 1.d4*WKxyz1(i,j,2),i=iPO3,iPO4),
     .                ( 1.d2*WKxyz2(i,j,1),i=iPO3,iPO4),
     .                ( 1.d2*WKxyz2(i,j,2),i=iPO3,iPO4),
     .                                                  j=jPO4,jPO3,-1)
       end if
      end if
C +
      do 399 k=1,2
      do 399 j=1,my
      do 399 i=1,mx
      WKxyz1(i,j,k) = 0.d0
      WKxyz2(i,j,k) = 0.d0
      WKxyz3(i,j,k) = 0.d0
 399  continue
C +
C +--Output for Verification 
C +  ~~~~~~~~~~~~~~~~~~~~~~~
c #VR route = ' END SRFmod_pol'
c #VR write(6,6602)          route,
c #VR.              ((aicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6602 format(6x,a15,' aicePO:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6603) ((hicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6603 format(6x,15x,' hicePO:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6604) (( psice(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6604 format(6x,15x,'  psice:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6611) ((uicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6611 format(6x,15x,' uicePO:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6612) ((vicePO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6612 format(6x,15x,' vicePO:',5d12.4,/,(29x,5d12.4))
c #VR write(6,6605) ((vgriPO(i,j),i=ivr-2,ivr+2),j=jvr+2,jvr-2,-1)
 6605 format(6x,15x,' vgriPO:',5d12.4,/,(29x,5d12.4))
C +
      return
C +
      end


      subroutine OUTsav

C +------------------------------------------------------------------------+
C | MAR OUTPUT                                        Mon 23-May-2011  MAR |
C |   SubRoutine OUTsav is used to save the main Model Variables           |
C |                                                                        |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
c #NH include 'MAR_NH.inc'

      include 'MAR_LB.inc'
      include 'MAR_UB.inc'
      include 'MARsIB.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'

      include 'MAR_RA.inc'

c #HY include 'MAR_HY.inc'
c #CA include 'MAR_CA.inc'
c #PB include 'MAR_PB.inc'
c #TC include 'MAR_TC.inc'

      include 'MAR_SL.inc'
c #PO include 'MAR_PO.inc'
c #SN include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'
      include 'MAR_BS.inc'

      include 'MAR_IO.inc'


C +--    Hydrostatic Dynamics
C +  ========================
C +
          open (unit=11,status='unknown',form='unformatted',
     .                                   file='MARdyn.DAT')
          rewind     11
          write     (11) itexpe,jdh_LB
          write     (11) iyrrGE,mmarGE,jdarGE,jhurGE
C +...    Time    Parameters

          write     (11) imez,jmez
          write     (11) GElat0,GElon0
C +...    Spatial Parameters

          write     (11) sigma,ptopDY,dx,dy
C +...    Discretisation

          write     (11) uairDY
          write     (11) vairDY
          write     (11) pktaDY
          write     (11) pstDY
          write     (11) qvDY
C +...    Dynamics

          write     (11) sh
          write     (11) pstDY1

          write     (11) iyr_LB,mma_LB,jda_LB,jhu_LB,jdh_LB
          write     (11) vaxgLB,vaxdLB,vayiLB,vaysLB
C +...    Lateral Boundary Conditions

          write     (11) sst_LB

          write     (11) uairUB,vairUB,pktaUB
C +...    Upper   Sponge   Reference State

          write     (11) pstDYn
          write     (11) RAd_ir
          write     (11) IRsoil
          write     (11)  virDY
          write     (11) tim1LB,v1xgLB,v1xdLB,v1yiLB,v1ysLB
          write     (11) tim2LB,v2xgLB,v2xdLB,v2yiLB,v2ysLB
          write     (11) sst1LB,sst2LB
          write     (11) ua1_UB,ua2_UB
          write     (11) va1_UB,va2_UB
          write     (11) pkt1UB,pkt2UB
C +
          IF (my.EQ.1)                                            THEN
            write   (11) ugeoDY
            write   (11) vgeoDY
          END IF
C +
          close(unit=11)
C +
C +
C +--Non-Hydrostatic Dynamics
C +  ========================
C +
c #NH     open (unit=11,status='unknown',form='unformatted',
c #NH.                                   file='MARonh.DAT')
c #NH     rewind     11
c #NH     write     (11) itexpe
c #NH     write     (11) iyrrGE,mmarGE,jdarGE,jhurGE
C +...    Time    Parameters
C +
c #NH     write     (11) ua0_NH
c #NH     write     (11) va0_NH
c #NH     write     (11) wa0_NH
c #NH     write     (11) wairNH
c #NH     write     (11) pairNH
C +...    Dynamics
C +
c #NH     close(unit=11)


C +--Mass Flux convective Scheme
C +  ===========================

c #CA   IF (convec)                                               THEN
c #CA     open (unit=11,status='unknown',form='unformatted',
c #CA.                                   file='MARcva.DAT')
c #CA     rewind     11
c #CA     write     (11) itexpe
c #CA     write     (11) iyrrGE,mmarGE,jdarGE,jhurGE
C +...    Time    Parameters

c #CA     write     (11) adj_CA
c #CA     write     (11) int_CA
c #CA     write     (11) dpktCA
c #CA     write     (11) dqv_CA
c #CA     write     (11) dqw_CA
c #CA     write     (11) dqi_CA
c #CA     write     (11) drr_CA
c #CA     write     (11) dss_CA
c #CA     write     (11) dsn_CA
c #CA     write     (11) rainCA
c #CA     write     (11) snowCA
c #CA     write     (11) tau_CA

c #PB     write     (11) Kstep1
c #PB     write     (11) K_CbT1
c #PB     write     (11) K_CbB1
c #PB     write     (11) P_CH_0
c #PB     write     (11) PdCH_1
c #PB     write     (11) PdTa_1
c #PB     write     (11) PdQa_1
c #PB     write     (11) PdQw_1
c #PB     write     (11) PdQi_1
c #PB     write     (11) Pdrr_1
c #PB     write     (11) Pdss_1
c #PB     write     (11) PuMF_1
c #PB     write     (11) PdMF_1
c #PB     write     (11) Pfrr_1
c #PB     write     (11) Pfss_1
c #PB     write     (11) Pcape1

c #CA   END IF


C +--Microphysics
C +  ============

c #HY   IF (micphy)                                               THEN

c #HY     open (unit=11,status='unknown',form='unformatted',
c #HY.                                   file='MARcld.DAT')
c #HY     rewind     11
c #HY     write     (11) itexpe
c #HY     write     (11) iyrrGE,mmarGE,jdarGE,jhurGE

c #HY     write     (11) turnHY
c #HY     write     (11) ccniHY
c #HY     write     (11) qiHY
c #HY     write     (11) qsHY
! #qg     write     (11) qgHY
c #HY     write     (11) qwHY
c #HY     write     (11) qrHY
c #HY     write     (11) rainHY,rai0HY
c #HY     write     (11) snowHY,sno0HY,sfa0HY
c #HY     write     (11) crysHY
c #CA     write     (11) rainCA
c #BS     write     (11) uss_HY

c #HY     close(unit=11)

c #HY   END IF


C +--Atmospheric Tracers
C +  ===================

c #TC     open (unit=11,status='unknown',form='unformatted',
c #TC.                                   file='MARtca.DAT')
c #TC     rewind     11
c #TC     write     (11) itexpe
c #TC     write     (11) iyrrGE,mmarGE,jdarGE,jhurGE
c #TC     write     (11) dt_ODE,dt2ODE,nt_ODE,jt_ODE
C +
c #TC     write     (11) qxTC
c #TC     write     (11) qsTC
c #TC     write     (11) uqTC
C +
c #TC     close(unit=11)
C +
C +
C +--Polynya Model
C +  =============
C +
c #PO   IF (polmod)                                               THEN
C +
c #PO     open (unit=11,status='unknown',form='unformatted',
c #PO.                                   file='MARpol.DAT')
c #PO     rewind     11
c #PO     write     (11) itexpe
c #PO     write     (11) iyrrGE,mmarGE,jdarGE,jhurGE
C +
c #PO     write     (11) isolSL
c #PO     write     (11) iPO1,iPO2,jPO1,jPO2,iPO3,iPO4,jPO3,jPO4
c #PO     write     (11) hfraPO,vgriPO,uocnPO,vocnPO,swsaPO,focnPO
c #PO     write     (11) silfPO,hicePO,aicePO,uicePO,vicePO,dtPO
C +
c #PO     close(unit=11)
C +
c #PO   END IF
C +
C +
C +--Snow Model
C +  ==========
C +
c #SN   IF (snomod.AND..NOT.VSISVAT)                              THEN
C +
c #SN     open (unit=11,status='unknown',form='unformatted',
c #SN.                                   file='MARsno.DAT')
c #SN     rewind     11
c #sn     write     (11) itexpe,ntSNo ,ntwaSN
c #sn     write     (11)        dtSNo ,dtwaSN
c #sn     write     (11) iyrrGE,mmarGE,jdarGE,jhurGE
C +
c #sn     write     (11) agSNow
c #sn     write     (11) tiSNow
c #sn     write     (11) waSNow
c #sn     write     (11) roSNow
c #sn     write     (11) dzSNow
c #sn     write     (11) g1SNow
c #sn     write     (11) g2SNow
c #sn     write     (11) nhSNow
c #sn     write     (11) nsSNow
c #sn     write     (11) niSNow
c #sn     write     (11) smbalSN0
c #sn     write     (11) znSNow0
c #sn     write     (11) maskSN
c #sn     write     (11) slopSN
c #sn     write     (11) waSNru
c #BS     write     (11) FacRBS,FacSBS,FacTBS,FacUBS,
c #BS.                   g1__BS,g2__BS,sheaBS
C +
c #SN     close(unit=11)
C +
c #SN   END IF


C +--Soil Model
C +  ==========

          open (unit=11,status='unknown',form='unformatted',
     .                                   file='MARsol.DAT')
          rewind     11
          write     (11) itexpe
          write     (11) iyrrGE,mmarGE,jdarGE,jhurGE

          write     (11) nSLsrf
          write     (11) SLsrfl
          write     (11) TairSL
          write     (11) tsrfSL
          write     (11) alb0SL,eps0SL
          write     (11) SaltSL
          write     (11) ro_SL0
          write     (11) ro_SL
          write     (11) d1_SL
          write     (11) t2_SL
          write     (11) w2_SL,wg_SL
          write     (11) roseSL
          write     (11) qvapSL
          write     (11) hsnoSL
          write     (11) hmelSL

          write     (11) SLuusl,SL_z0
          write     (11) SLutsl,SL_r0

          write     (11) pktaSL
          write     (11) sicsIB
          write     (11) sic1sI,sic2sI
          write     (11) albeSL
          write     (11) SLuus ,SLuts
          write     (11) SLuqs ,SLuqsl
          write     (11) duusSL
          write     (11) dutsSL
          write     (11) cdmSL ,cdhSL
c #AW     write     (11) V_0aSL
c #AH     write     (11) dT0aSL
c #AM     write     (11) u_0aSL
c #AT     write     (11) uT0aSL
c #AS     write     (11) us0aSL
c #VX     write     (11) WV__SL
          write     (11) SLlmo ,SLlmol
c #BV     write     (11)  virSL

          close(unit=11)


C +--SVAT Model
C +  ==========

c #TV   IF (vegmod)                                               THEN

C +       ***********
c #TV     call SVAsav('writ')
C +       ***********

c #TV   END IF


C +--Turbulence
C +  ==========
C +
          open (unit=11,status='unknown',form='unformatted',
     .                                   file='MARtur.DAT')
          rewind     11
          write     (11) itexpe
          write     (11) iyrrGE,mmarGE,jdarGE,jhurGE
C +
          write     (11) ect_TE
          write     (11) eps_TE
          write     (11) tranTE
C +...    TURBULENT KINETIC ENERGY (TKE) and DISSIPATION (e)
C +
          write     (11) TUkvm 
          write     (11) TUkvh 
C +...    TURBULENT DIFFUSION COEFFICIENT
C +
          close(unit=11)
C +
      return
      end


      subroutine OUTgks
C +
C +------------------------------------------------------------------------+
C | MAR OUTPUT                                             19-09-2001  MAR |
C |   SubRoutine OUTgks is used to write the main Model Variables          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   OUTPUT: on asci file si_ddhhmm.LAB (Atmospheric Dynamics, Surface)   |
C |   ^^^^^^               cl_ddhhmm.LAB (Microphysics)                    |
C |                                                                        |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MARSND.inc'
C +
      include 'MAR_DY.inc'
c #OL include 'MAR_OL.inc'
C +
      include 'MAR_TE.inc'
      include 'MAR_TU.inc'
C +
c #HY include 'MAR_HY.inc'
C +
      include 'MAR_SL.inc'
c #PO include 'MAR_PO.inc'
c #SN include 'MAR_SV.inc'
c #sn include 'MAR_SN.inc'
C +
      include 'MAR_IO.inc'
C +
c #HP external zext
c #HP integer  zext
C +
C +
C +--Local  Variables
C +  ================
C +
      real     fac_sh
      integer  jmmd  ,jm10  ,jh10  ,jh1   ,jd10  ,jd1
C +
C +
C +--Linear Mountain Waves Characteristics
C +  =====================================
C +
c #OL do 10 k=1,mz
c #OL do 10 j=1,my
c #OL do 10 i=1,mx
c #OL  urefOL(i,j,k) = uairDY(i,j,k)
c #OL  uairDY(i,j,k) =(uairDY(i,j,k)-ugeoDY(i,j,k)) *1000.d0
c #OL  trefOL(i,j,k) = tairDY(i,j,k)
c #OL  tairDY(i,j,k) =(tairDY(i,j,k)-tSND  (1,1)  ) *1000.d0 
c #OL.                +tSND  (1,1)
c #OL  gplvOL(i,j,k) = gplvDY(i,j,k)
c #OL  gplvDY(i,j,k) =(gplvDY(i,j,k)-gp00OL(i,j,k)) *1000.d0 
c #OL.                +gp00OL(i,j,k)
 10   continue
      fac_sh = 1.d0
c #OL fac_sh = 1.d3
C +
C +
C +--Output File Label
C +  =================
C +
      fnam( 1: 3) = 'si_'
      jmmd     = 1 + mod(minuGE,10)
      jm10     = 1 +     minuGE/10
      jh10     = 1 +     jhaMAR/10
      jh1      = 1 + mod(jhaMAR,10)
      jd10     = 1 +     jdaMAR/10
      jd1      = 1 + mod(jdaMAR,10)
      if (jd10.gt.10) then 
      fnam( 3: 3) =   '+'
      jd10        =  mod(jd10  ,10)
      end if
      fnam( 4: 4) = labnum(jd10)
      fnam( 5: 5) = labnum(jd1)
      fnam( 6: 6) = labnum(jh10)
      fnam( 7: 7) = labnum(jh1)
      fnam( 8: 8) = labnum(jm10)
      fnam( 9: 9) = labnum(jmmd)
      fnam(10:10) = '.'
      fnam(11:13) = explIO
      fnam(14:16) = '   '
C +
C +
C +--File si_ddhhmm.LAB (Atmospheric Dynamics, Surface)
C +  ==================================================
C +
      open(unit=13,status='unknown',file=fnam)
      rewind    13
C +
      write(13,613)itexpe,iterun,imez,jmez
  613 format(4i12)
      write(13,611) qsolSL
  611 format(l2,'  qsolSL')
      write(13,614)((fac_sh*sh(i,j),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO)
  614 format(10e12.5,' sh')
      write(13,615)GElat0,GElon0,itizGE(imez,jmez),fcorDY(imez,jmez),
     .             0.1d0*pSND(1,1),pstSND,
     .             GEddxx,zs_SL,zn_SL,zl_SL,dt,dx,ptopDY
  615 format(6e12.5)
      write(13,616)( sigma(k),    k=mzw1IO,mzw2IO,izw_IO)
  616 format(8f12.8,'  s')
      write(13,617)(ugeoDY(1,1,k),k=mzw1IO,mzw2IO,izw_IO)
  617 format(8e12.5,'  ug')
      write(13,618)(vgeoDY(1,1,k),k=mzw1IO,mzw2IO,izw_IO)
  618 format(8e12.5,'  vg')
C +
      write(13,619)itexpe*dt,jdaMAR,jhaMAR,
     .             mmarGE,jdarGE,jhurGE,minuGE,jsecGE
  619 format(e12.5,2i12,'  time - jdaMAR - jhaMAR',
     .              i5,'/',i2,i3,'h',i2,'m',i2,'s')
      write(13,620)(((uairDY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  620 format(10f12.6,'  u')
      write(13,621)(((vairDY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  621 format(10f12.6,'  v')
      write(13,622)(((wairDY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  622 format(10e12.5,'  w')
      write(13,623)(((tairDY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  623 format(10f12.6,'  T')
      write(13,624)(((gplvDY(i,j,k)*grvinv,
     .                              i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  624 format(10f12.4,'  GPlev')
      write(13,625)(((  qvDY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  625 format(10e12.5,'  qv  ')
      write(13,627) ((hmelSL(i,j  ),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO)
  627 format(10e12.5,'  hmel')
      write(13,628) (( pstDY(i,j  ),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO)
  628 format(10f12.6,'  pstar')
      write(13,629) ((tsrfSL(i,j,1),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO)
  629 format(10f12.6,'  tsrfSL')
      write(13,630)((( TUkvm(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  630 format(10f12.6,'  TUkvm')
      write(13,631)((( TUkvh(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  631 format(10f12.6,'  TUkvh')
      write(13,632) ((   SLuus(i,j),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO)
  632 format(10f12.6,'  SLuus')
      write(13,633) ((   SLuts(i,j),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO)
  633 format(10f12.6,'  SLuts')
      write(13,634) ((   SLuqs(i,j),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO)
  634 format(10f12.9,'  SLuqs')
C +
      write(13,636)(((ect_TE(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
     .                              j=myw1IO,myw2IO,iyw_IO),
     .                              k=mzw1IO,mzw2IO,izw_IO)
  636 format(10e12.5,'  ect_TE')
C +
c #PO write(13,6370)((hatmPO(i,j),  i=mxw1IO,mxw2IO,ixw_IO),
c #PO.                              j=myw1IO,myw2IO,iyw_IO)
 6370 format(10f12.2,' H(atm) ')
c #PO write(13,637) ((hfraPO(i,j),  i=mxw1IO,mxw2IO,ixw_IO),
c #PO.                              j=myw1IO,myw2IO,iyw_IO)
  637 format(10f12.6,' Frazil')
c #PO write(13,6380)((SLsrfl(i,j,2),i=mxw1IO,mxw2IO,ixw_IO),
c #PO.                              j=myw1IO,myw2IO,iyw_IO)
 6380 format(10f12.6,' Srf Wa ')
c #PO write(13,6381)((aicePO(i,j),  i=mxw1IO,mxw2IO,ixw_IO),
c #PO.                              j=myw1IO,myw2IO,iyw_IO)
 6381 format(10f12.6,' A(ice) ')
c #PO write(13,6382)((hicePO(i,j),  i=mxw1IO,mxw2IO,ixw_IO),
c #PO.                              j=myw1IO,myw2IO,iyw_IO)
 6382 format(10f12.6,' h(ice) ')
c #PO write(13,6383)((hiavPO(i,j),  i=mxw1IO,mxw2IO,ixw_IO),
c #PO.                              j=myw1IO,myw2IO,iyw_IO)
 6383 format(10f12.6,' Hi avr.')
C + 
      close(unit=13)
C +
C +
C +--File cl_ddhhmm.LAB (Microphysics)       
C +  =================================
C +
c #HY fnam( 1: 2) = 'cl'
c #HY open(unit=14,status='unknown',file=fnam)
c #HY rewind    14
C +
c #HY write(14,641)-zext(turnHY),  itexpe,  jdarGE,  jhurGE
  641 format(4i12,    '  turnHY  - itexpe - jdarGE - jhurGE')
c #HY write(14,642)(((  qwHY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
c #HY.                              j=myw1IO,myw2IO,iyw_IO),
c #HY.                              k=mzw1IO,mzw2IO,izw_IO)
  642 format(10e12.5,'  qw')
c #HY write(14,643)(((  qiHY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
c #HY.                              j=myw1IO,myw2IO,iyw_IO),
c #HY.                              k=mzw1IO,mzw2IO,izw_IO)
  643 format(10e12.5,'  qi')
c #HY write(14,644)(((  qrHY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
c #HY.                              j=myw1IO,myw2IO,iyw_IO),
c #HY.                              k=mzw1IO,mzw2IO,izw_IO)
  644 format(10e12.5,'  qr')
c #HY write(14,645)(((  qsHY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
c #HY.                              j=myw1IO,myw2IO,iyw_IO),
c #HY.                              k=mzw1IO,mzw2IO,izw_IO)
  645 format(10e12.5,'  qs')
c #HY write(14,646) ((rainHY(i,j  ),i=mxw1IO,mxw2IO,ixw_IO),
c #HY.                              j=myw1IO,myw2IO,iyw_IO)
  646 format(10e12.5,'  rain')
c #HY write(14,647) ((snowHY(i,j  ),i=mxw1IO,mxw2IO,ixw_IO),
c #HY.                              j=myw1IO,myw2IO,iyw_IO)
  647 format(10e12.5,'  snow')
c #HY write(14,648)(((hlatHY(i,j,k),i=mxw1IO,mxw2IO,ixw_IO),
c #HY.                              j=myw1IO,myw2IO,iyw_IO),
c #HY.                              k=mzw1IO,mzw2IO,izw_IO)
  648 format(10e12.5,'  hlat')
C +
c #HY close(unit=14)
C +
C +
C +--RESET
C +  =====
C +
c #OL do 20 k=1,mz
c #OL do 20 j=1,my
c #OL do 20 i=1,mx
c #OL  uairDY(i,j,k) = urefOL(i,j,k)
c #OL  tairDY(i,j,k) = trefOL(i,j,k)
c #OL  gplvDY(i,j,k) = gplvOL(i,j,k)
 20   continue
C +
      return
      end


      subroutine OUT_nc

C +------------------------------------------------------------------------+
C | MAR OUTPUT                                        Fri 20-Jan-2012  MAR |
C |   SubRoutine OUT_nc is used to write the main Model Variables          |
C |                                      on  a NetCDF file                 |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   INPUT: ipr_nc: Current time step    number                           |
C |   ^^^^^^         (starting from ipr_nc=1, which => new file creation)  |
C |                                                                        |
C |   OUTPUT: NetCDF File adapted to IDL Graphic Software                  |
C |   ^^^^^^                                                               |
C |                                                                        |
C |   CAUTION:    This Routine requires the usual NetCDF library,          |
C |   ^^^^^^^^    and the complementary access library  'libUN.a'          |
C |                                                                        |
C |   MODIF.  4 Nov 2009   : OUTPUT of Map Scaling Factor SFm_DY           |
C |   ^^^^^                                                                |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
c #NH include 'MAR_NH.inc'
c #OL include 'MAR_OL.inc'

      include 'MAR_TE.inc'
      include 'MAR_TU.inc'

c #CA include 'MAR_CA.inc'
c #HY include 'MAR_HY.inc'
c #WB include 'MAR_WB.inc'
c #BS include 'MAR_BS.inc'
      include 'MAR_RA.inc'
c #TC include 'MAR_TC.inc'

      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
c #TV include 'MARdSV.inc'
c #TV include 'MAR_TV.inc'
c #SN include 'MARsSN.inc'
c #PO include 'MAR_PO.inc'

      include 'MAR_WK.inc'
c #DY include 'MARvec.inc'

      include 'MAR_IO.inc'

      real              Soilz(mz)
      common/OUT_nc_rea/Soilz

      integer   nsnomz,         kk
      parameter(nsnomz=min(nsno,mz))
    
      integer           kOUTnc,nOUTnc
c #SN integer           ijSNOW(mx,my)
      common/OUT_nc_int/kOUTnc,nOUTnc
c #SN.                 ,ijSNOW


C +--Local  Variables
C +  ================

c #IZ logical           noZOOM
      logical           LastIO
      real              end_YR

      integer    Lfnam,     Ltit,     Luni,     Lnam,     Llnam
      PARAMETER (Lfnam= 40, Ltit= 90, Luni= 31, Lnam= 13, Llnam=50)
C +...Length of char strings 

      CHARACTER*(Lfnam)  fnamNC
      common/OUT_nc_loc/ fnamNC
C +...                   fnamNC: To retain file name.

      integer    NdimNC
      PARAMETER (NdimNC = 5)
C +...Number of defined spatial dimensions (exact)

      integer    MXdim
      PARAMETER (MXdim = 86401)
C +...Maximum Number of all dims: recorded Time Steps
C +   and also maximum of spatial grid points for each direction. 

      integer    MX_var
      PARAMETER (MX_var = 120)
C +...Maximum Number of Variables 

      integer    NattNC
      PARAMETER (NattNC = 2)
C +...Number of real attributes given to all variables

      INTEGER           RCODE

      integer           njmo
      integer           jourNC(MXdim)
      integer           moisNC(MXdim)
      real              yearNC(MXdim)
      real              dateNC(MXdim)
      common/OUT_nc_r/  yearNC,dateNC
      real              timeNC(MXdim)
      real              VALdim(MXdim,0:NdimNC)
      integer           nDFdim(      0:NdimNC)
      common/OUT_nc_i/  nDFdim
      integer           NvatNC(NattNC)
      CHARACTER*(Lnam)  NAMdim(      0:NdimNC)
      CHARACTER*(Luni)  UNIdim(      0:NdimNC)
      CHARACTER*(Lnam)  SdimNC(4,MX_var)       
      CHARACTER*(Luni)  unitNC(MX_var)
      CHARACTER*(Lnam)  nameNC(MX_var)
      CHARACTER*(Llnam) lnamNC(MX_var)
      CHARACTER*(Ltit ) tit_NC
      CHARACTER*(Lnam)  NAMrat(NattNC)
c #TC CHARACTER*9   labelc
      CHARACTER*120 tmpINP

      integer  n1000 ,n100a ,n100  ,n10_a ,n10   ,n1    ,m10
      integer  n     ,l     ,              jd10  ,jd1   ,MMXstp
      integer  it    ,mois  ,mill  ,iu    ,itotNC,NtotNC,ID__nc
c #TC integer  itot
      real     starti,starta(1),DayLen,rhodzk

c #SN character*1  chn
c #SN character*7  lab__z,lab_dz,lab_ro,lab_wa,lab_g1,lab_g2,lab_Ti

c #SN data lab__z/'z_mmWE '/
c #SN data lab_dz/'dzSNOW '/
c #SN data lab_ro/'roSNOW '/
c #SN data lab_wa/'waSNOW '/
c #SN data lab_g1/'g1SNOW '/
c #SN data lab_g2/'g2SNOW '/
c #SN data lab_Ti/'TiSNOW '/

c #IZ data     noZOOM/.FALSE./


C +--NetCDF File Initialization
C +  ==========================

      IF (ipr_nc.eq.1)                                              THEN


C +--Nb of OUTPUT per File (Option #SO for splitting the MAR*.nc file)
C +  ---------------------

            nOUTnc =      npr_nc
c #SO       nOUTnc = (2.0 /0.09)*(161.*161.*34.)/(mx*my*mzz)
c #SO       kOUTnc =  86400.1                   /(dt*nboucl)
c #SO       nOUTnc =             nOUTnc         /    kOUTnc
c #SO       nOUTnc =             nOUTnc         *    kOUTnc
c #SO       nOUTnc =  min(       nOUTnc,
c #SO.                           kOUTnc*(365+max(0,1-mod(iyrrGE,4))))
c #SO   IF (npr_nc.EQ.nprint+1)                                     THEN
c #SO       nOUTnc =             nOUTnc         +         1
c #SO   ENDIF
c #SO       nOUTnc =  min(npr_nc,nOUTnc)
            npr_nc =      npr_nc-nOUTnc


          n1000 = 1 +     iyrrGE/1000
          n100a =     mod(iyrrGE,1000)
          n100  = 1 +     n100a /100
          n10_a =     mod(n100a ,100)
          n10   = 1 +     n10_a /10
          n1    = 1 + mod(n10_a ,10)
          m10   = 1 +     mmarGE/10
          m1    = 1 + mod(mmarGE,10)
          jd10  = 1 +     jdarGE/10
          jd1   = 1 + mod(jdarGE,10)


C +--Output File Label
C +  -----------------

       fnamNC = 'MAR.'
     .        // labnum(n1000) // labnum(n100)
     .        // labnum(  n10) // labnum(  n1)
     .        // labnum(  m10) // labnum(  m1)
     .        // labnum( jd10) // labnum( jd1)
     .        // '.' // explIO
     .        // '.nc    '

c #SO     write(6,6000) fnamNC,nOUTnc,npr_nc,kOUTnc
 6000     format(/,'++++++++++++++++++++++++++++++++++++++++++++++',
     .           /,'OUT_nc: Nb of OUTPUT: ',a19,            ':',i4,
     .           /,'                      After  present File:',i4,
     .           /,'                      Per            Day :',i4,
     .           /,'++++++++++++++++++++++++++++++++++++++++++++++')


C +--Output Title
C +  ------------

       tit_NC = 'MAR'
     .        // ' - Exp: ' // explIO
     .        // ' - '
     .        // labnum(n1000) // labnum(n100)
     .        // labnum(  n10) // labnum(  n1)
     .        // labnum(  m10) // labnum(  m1)
     .        // labnum( jd10) // labnum( jd1)


C +--Create File / Write Constants
C +  -----------------------------

       MMXstp = MXdim
C +...To check array bounds... silently

C +--Time Variable (hour)
C +  ~~~~~~~~~~~~~~~~~~~~

C +...  To define a NetCDF dimension (size, name, unit):
        nDFdim(0)= nOUTnc
c #UL   nDFdim(0)= 0
        NAMdim(0)= 'time'
        UNIdim(0)= 'HOURS since 1901-01-15 00:00:00'

C +...  Check temporary arrays: large enough ?
        IF (nOUTnc.gt.MMXstp)
     &  STOP '*** OUT_nc - ERROR : MXdim to low ***'

              starti = jhurGE + minuGE/60.d0 + jsecGE/3600.d0
C +...        starti : Starting Time (= current time in the day)

              starta(1) = (351+(iyrrGE  -1902) *365    ! Nb Days before iyrrGE
     .                        +(iyrrGE  -1901) /  4    ! Nb Leap Years
     .                        + njyrGE(mmarGE)         ! Nb Days before mmarGE
     .                        + njybGE(mmarGE)         ! (including Leap Day)
     .                    *max(0,1-mod(iyrrGE,4))      !
     .                        + jdarGE     -1   )*  24 !
     .                    +jhurGE                      !
     .                  + (minuGE *60 +jsecGE   )/3600.!

        DO it = 1,nOUTnc
              timeNC(it)   = starti    + (it-1) * nboucl  *dt / 3600.
C +...                                         nboucl: #iter between output

              VALdim(it,0) = starta(1) + (it-1) * nboucl  *dt / 3600.
C +...        VALdim(  ,0) : values of the dimension # 0 (time) 

C +--Time Variable (date)
C +  ~~~~~~~~~~~~~~~~~~~~
                  dateNC(it) =           timeNC(it)
                  jourNC(it) =  jdarGE + timeNC(it) / 24.
        END DO
                  mois       =  mmarGE
                  mill       =  iyrrGE
        DO it = 1,nOUTnc
          IF     (mois      .eq.2           .AND.
     .        mod(mill,4)   .eq.0           )                     THEN
                  njmo       =  njmoGE(mois) + 1
          ELSE
                  njmo       =  njmoGE(mois)
          END IF
          IF     (jourNC(it).gt.njmo        )                     THEN
            DO iu=it,nOUTnc
                  jourNC(iu) =  jourNC(iu) - njmo
            END DO
                  mois       =  mois + 1
              IF (mois.gt.12)                                     THEN
                  mois       =         1
                  mill       =  mill + 1
              END IF
          END IF
                  moisNC(it) =  mois
                  yearNC(it) =  mill

          IF     (dateNC(it).gt.24.-epsi)                         THEN
                  DayLen     =  24.
            DO iu=it,nOUTnc
                  dateNC(iu) = mod(dateNC(iu),DayLen)
            END DO
          END IF
        END DO

        DO it = 1,nOUTnc
              dateNC(it) =  dateNC(it)
     .             + 1.d+2 *jourNC(it) 
     .             + 1.d+4 *moisNC(it) 
        END DO


C +--Define horizontal spatial dimensions :    
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +...Check temporary arrays: large enough ?
      IF (    mx .gt.MMXstp.or.my.gt.MMXstp
     &    .or.mzz.gt.MMXstp.or.mw.gt.MMXstp)
     &  STOP '*** OUT_nc - ERROR : MXdim to low ***'

C +...To define NetCDF dimensions (size, name, unit):

      DO i = 1, mx
        VALdim(i,1) = xxkm(i)
      END DO
      nDFdim(1)= mx
      NAMdim(1)= 'x'
      UNIdim(1)= 'km'

      DO j = 1, my
        VALdim(j,2) = yykm(j)
      END DO
      nDFdim(2)= my
      NAMdim(2)= 'y'
      UNIdim(2)= 'km'

      do k = 1, mz
        VALdim(k,3) = sigma(k)
      enddo
      nDFdim(3)= mz
      NAMdim(3)= 'level'
      UNIdim(3)= 'sigma_level'
C +... For levels k

      do k = 1, mz
        VALdim(k,4) = sigmid(k+1)
      enddo
      nDFdim(4)= mz
      NAMdim(4)= 'level2'
      UNIdim(4)= 'sigma_level'
C +... For levels k+1/2

      do k = 1, mw
        VALdim(k,5) = k 
      enddo
      nDFdim(5)= mw
      NAMdim(5)= 'sector'
      UNIdim(5)= 'level'
C +... For Surface Sectors 

C +--Variable's Choice (Table MARvou.dat)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        OPEN(unit=10,status='unknown',file='MARvou.dat')

        itotNC = 0
 980    CONTINUE
          READ (10,'(A120)',end=990) tmpINP
          IF (tmpINP(1:4).eq.'    ')                                THEN 
            itotNC = itotNC + 1
            READ (tmpINP,'(4x,5A9,A12,A50)')
     &          nameNC(itotNC)  ,SdimNC(1,itotNC),SdimNC(2,itotNC),
     &          SdimNC(3,itotNC),SdimNC(4,itotNC),
     &          unitNC(itotNC)  ,lnamNC(itotNC)
C +...          nameNC: Name
C +             SdimNC: Names of Selected Dimensions (max.4/variable) 
C +             unitNC: Units
C +             lnamNC: Long_name, a description of the variable

c #TC       IF (nameNC(itotNC).eq.'qxTC     '.and.nkWri.ge.1)       THEN
c #TC           nameNC(itotNC) =  namTC(1)
c #TC        IF                                  (nkWri.gt.1)       THEN
c #TC           itot = itotNC
c #TC         DO  n=2,nkWri
c #TC           itot = itot    +  1
c #TC           nameNC(itot)   =  namTC(n)
c #TC          DO m=1,4
c #TC           SdimNC(m,itot) = SdimNC(m,itotNC)
c #TC          END DO
c #TC           unitNC(itot)   = unitNC(itotNC)
c #TC           lnamNC(itot)   = lnamNC(itotNC)
c #TC         END DO
c #TC           itotNC         = itot
c #TC        ENDIF
c #TC       ENDIF

          ENDIF
        GOTO 980
 990    CONTINUE

        CLOSE(unit=10)

        NtotNC = itotNC 
C +...  NtotNC : Total number of variables writen in NetCDF file.

C +--List of NetCDF attributes given to all variables:
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C +... The "actual_range" is the (min,max)
C +    of all data for each variable:
      NAMrat(1) = 'actual_range'
      NvatNC(1) = 2

C +... The "[var]_range" is NOT of attribute type,
C +    it is a true variable containing the (min,max) for
C +    each level, for 4D (space+time) variables only
C +    (automatic handling by UN library;
C +     must be the LAST attribute)
      NAMrat(NattNC) = '[var]_range'
      NvatNC(NattNC) = 2

C +--Automatic Generation of the NetCDF File Structure
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C +     **************
        CALL UNscreate (fnamNC,tit_NC,
     &                  NdimNC, nDFdim, MXdim , NAMdim, UNIdim, VALdim,
     &                  MX_var, NtotNC, nameNC, SdimNC, unitNC, lnamNC,
     &                  NattNC, NAMrat, NvatNC,
     &                  ID__nc) 
C +     **************


C +--Write Time - Constants
C +  ~~~~~~~~~~~~~~~~~~~~~~
        DO j=1,my
        DO i=1,mx
          WKxy1(i,j) =  GElonh(i,j) * 15.
C +...    Conversion: Hour->degrees

          WKxy2(i,j) =  GElatr(i,j) / degrad
C +...    Conversion: rad ->degrees

          WKxy3(i,j) =  isolSL(i,j)
C +...    Conversion to REAL type (integer not allowed)

          WKxy4(i,j) =  isolTV(i,j)
C +...    Conversion to REAL type (integer not allowed)

        END DO
        END DO


c #TV   DO l=1,llx
c #TV     Soilz(l) =-deptTV(l  )
c #TV   END DO
c #TV   DO l=  llx+1,mz
c #TV     Soilz(l) =-deptTV(llx) -1.e-6*(l-llx)
c #TV   END DO


C +       ************
          CALL UNwrite (ID__nc, 'lon   ', 1  , mx    , my, 1 , WKxy1)
          CALL UNwrite (ID__nc, 'lat   ', 1  , mx    , my, 1 , WKxy2)
          CALL UNwrite (ID__nc, 'MapSC ', 1  , mx    , my, 1 , SFm_DY)
          CALL UNwrite (ID__nc, 'sh    ', 1  , mx    , my, 1 , sh)
          CALL UNwrite (ID__nc, 'isol  ', 1  , mx    , my, 1 , WKxy3)
          CALL UNwrite (ID__nc, 'TEX   ', 1  , mx    , my, 1 , WKxy4)
c #TV     CALL UNwrite (ID__nc, 'DepthS ', ipr_nc, mz,  1, 1 , Soilz)
C +       ************


C +--Snow Mosa?c for OUTPUT
C +  ======================

c #SN   DO j=1,my
c #SN   DO i=1,mx
c #SN     ijSNOW(i,j)   =      1 + maskSL(i,j)
c #SN   ENDDO
c #SN   ENDDO


C +--Re-Open file if already created.
C +  ================================

      ELSE

C +     ************
        CALL UNwopen (fnamNC,ID__nc)
C +     ************

      END IF


C +--Write Time-dependent variables:
C +  ===============================

C +--UNLIMITED Time Dimension
C +  ------------------------

      IF (nDFdim(0).eq.0)                         THEN !
          starta(1) =  (351+(iyrrGE  -1902) *365       ! Nb Days before iyrrGE
     .                     +(iyrrGE  -1901) /  4       ! Nb Leap Years
     .                     + njyrGE(mmarGE)            ! Nb Days before mmarGE
     .                     + njybGE(mmarGE)            ! (including Leap Day)
     .                 *max(0,1-mod(iyrrGE,4))         !
     .                     + jdarGE     -1      )*  24 !
     .                 +jhurGE                         !
     .               + (minuGE *60 +jsecGE      )/3600.!

C +     ************
        CALL UNwrite (ID__nc, 'time   ',ipr_nc, 1, 1, 1, starta(1))
C +     ************

      END IF


C +     ************
        CALL UNwrite (ID__nc, 'date   ',ipr_nc, 1, 1, 1, dateNC(ipr_nc))
        CALL UNwrite (ID__nc, 'year   ',ipr_nc, 1, 1, 1, yearNC(ipr_nc))
C +     ************


C +--Geopotential Height, Saturation Specific Humidity
C +  -------------------------------------------------

      do k=1,mz
      do j=1,my
      do i=1,mx
        WKxyz1(i,j,k) = gplvDY(i,j,k)*   grvinv
        WKxyz2(i,j,k) = qvswDY(i,j,k)
c #NH   WKxyz3(i,j,k) = pairNH(i,j,k)*   pstDYn(i,j) * sigma(k)
c #TV   WKxyz4(i,j,k) = 0.0
      enddo
      enddo
      enddo


C +--Surface Humidity and Green Leaf Fraction [%]
C +  --------------------------------------------

c #TV DO j=1,my
c #TV DO i=1,mx
c #TV       WKxy1(i,j)    = 0.0
c #TV       WKxy2(i,j)    = 0.0
c #TV       WKxy3(i,j)    = 0.0
c #vV END DO
c #vV END DO

c #TV DO n=1,nvx
c #vV DO j=1,my
c #vV DO i=1,mx
c #TV       WKxy1(i,j)    =  WKxy1(i,j)
c #TV.                    + eta_TV(i,j,n,1)               *SLsrfl(i,j,n)
c #TV       WKxy2(i,j)    =  WKxy2(i,j)
c #TV.                    + glf_TV(i,j,n)   *alaiTV(i,j,n)*SLsrfl(i,j,n)
c #TV END DO
c #TV END DO
c #TV END DO

c #TV DO l=1,llx
c #TV DO n=1,nvx
c #TV DO j=1,my
c #TV DO i=1,mx
c #TV       WKxyz4(i,j,l) = WKxyz4(i,j,  l)
c #TV.                    + eta_TV(i,j,n,l)               *SLsrfl(i,j,n)
c #TV END DO
c #TV END DO
c #TV END DO
c #TV END DO

c #TV DO l=1,llx
c #TV DO j=1,my
c #TV DO i=1,mx
c #TV       WKxy3(i,j)    =  WKxy3(i,j)
c #TV.                    + WKxyz4(i,j,l)   *dz_dSV(1-l)
c #TV END DO
c #TV END DO
c #TV END DO

C +   ************
      CALL UNwrite (ID__nc, 'uairDY ', ipr_nc, mx, my, mz, uairDY)
      CALL UNwrite (ID__nc, 'vairDY ', ipr_nc, mx, my, mz, vairDY)
      CALL UNwrite (ID__nc, 'wairDY ', ipr_nc, mx, my, mz, wairDY)
      CALL UNwrite (ID__nc, 'tairDY ', ipr_nc, mx, my, mz, tairDY)
c #NH CALL UNwrite (ID__nc, 'wairNH ', ipr_nc, mx, my, mz, wairNH)
c #NH CALL UNwrite (ID__nc, 'pairNH ', ipr_nc, mx, my, mz, WKxyz3)
      CALL UNwrite (ID__nc, 'qvDY   ', ipr_nc, mx, my, mz, qvDY  )
      CALL UNwrite (ID__nc, 'zzDY   ', ipr_nc, mx, my, mz, WKxyz1)
      CALL UNwrite (ID__nc, 'qsatDY ', ipr_nc, mx, my, mz, WKxyz2)
      CALL UNwrite (ID__nc, 'pstar  ', ipr_nc, mx, my, 1 , pstDY )
      CALL UNwrite (ID__nc, 'RadOLR ', ipr_nc, mx, my, 1 , RAdOLR)
      CALL UNwrite (ID__nc, 'RadSol ', ipr_nc, mx, my, 1 , RAdsol)
      CALL UNwrite (ID__nc, 'Rad_IR ', ipr_nc, mx, my, 1 , RAD_ir)
      CALL UNwrite (ID__nc, 'hmelSL ', ipr_nc, mx, my, 1 , hmelSL)
      CALL UNwrite (ID__nc, 'tairSL ', ipr_nc, mx, my, 1 , TairSL)
      CALL UNwrite (ID__nc, 'tsrfSL ', ipr_nc, mx, my, mw, tsrfSL)
c #T2 CALL UNwrite (ID__nc, 'Ta2mSL ', ipr_nc, mx, my, mw, Ta2mSL)
c #T2 CALL UNwrite (ID__nc, 'TminSL ', ipr_nc, mx, my, mw, TminSL)
c #T2 CALL UNwrite (ID__nc, 'TmaxSL ', ipr_nc, mx, my, mw, TmaxSL)
c #T2 CALL UNwrite (ID__nc, 'Ta3mSL ', ipr_nc, mx, my, mw, Ta3mSL)
c #T2 CALL UNwrite (ID__nc, 'V03mSL ', ipr_nc, mx, my, mw, V03mSL)
c #T2 CALL UNwrite (ID__nc, 'V10mSL ', ipr_nc, mx, my, mw, V10mSL)
      CALL UNwrite (ID__nc, 'albxSL ', ipr_nc, mx, my, mw, albxSL)
      CALL UNwrite (ID__nc, 'hsenSL ', ipr_nc, mx, my, 1 , hsenSL)
      CALL UNwrite (ID__nc, 'hlatSL ', ipr_nc, mx, my, 1 , hlatSL)
      CALL UNwrite (ID__nc, 'ect_TE ', ipr_nc, mx, my, mz, ect_TE)
      CALL UNwrite (ID__nc, 'eps_TE ', ipr_nc, mx, my, mz, eps_TE)
      CALL UNwrite (ID__nc, 'TUkvm  ', ipr_nc, mx, my, mz, TUkvm )
      CALL UNwrite (ID__nc, 'TUkvh  ', ipr_nc, mx, my, mz, TUkvh )
      CALL UNwrite (ID__nc, 'SL_z0  ', ipr_nc, mx, my, mw, SL_z0 )
      CALL UNwrite (ID__nc, 'SL_r0  ', ipr_nc, mx, my, mw, SL_r0 )
c #BS CALL UNwrite (ID__nc, 'ustart ', ipr_nc, mx, my, mw, SaltSN)
c #BS CALL UNwrite (ID__nc, 'z0emBS ', ipr_nc, mx, my, mw, Z0emBS)
c #BS CALL UNwrite (ID__nc, 'z0SaBS ', ipr_nc, mx, my, mw, Z0SaBS)
      CALL UNwrite (ID__nc, 'SLsrfl ', ipr_nc, mx, my, mw, SLsrfl)
      CALL UNwrite (ID__nc, 'SLuusl ', ipr_nc, mx, my, mw, SLuusl)
      CALL UNwrite (ID__nc, 'SLutsl ', ipr_nc, mx, my, mw, SLutsl)
      CALL UNwrite (ID__nc, 'SLuqsl ', ipr_nc, mx, my, mw, SLuqsl)
      CALL UNwrite (ID__nc, 'SLussl ', ipr_nc, mx, my, mw, SLussl)
      CALL UNwrite (ID__nc, 'albeSL ', ipr_nc, mx, my, 1 , albeSL)
      CALL UNwrite (ID__nc, 'Clouds ', ipr_nc, mx, my, 1 , cld_SL)
C +   ************

C +   ************
c #TV CALL UNwrite (ID__nc, 'HumSol ', ipr_nc, mx, my, 1 , WKxy1)
c #TV CALL UNwrite (ID__nc, 'GreenL ', ipr_nc, mx, my, 1 , WKxy2)
c #TV CALL UNwrite (ID__nc, 'WatSol ', ipr_nc, mx, my, 1 , WKxy3)
c #TV CALL UNwrite (ID__nc, 'EvapoT ', ipr_nc, mx, my, 1 , evapTV)
c #TV CALL UNwrite (ID__nc, 'Draing ', ipr_nc, mx, my, 1 , draiTV)
c #TV CALL UNwrite (ID__nc, 'RunOFF ', ipr_nc, mx, my, 1 , runoTV)
c #TV CALL UNwrite (ID__nc, 'H2OSol ', ipr_nc, mx, my, mz, WKxyz4)
C +   ************


C +--Dynamical Budget
C +  ----------------

c #IZ IF (noZOOM)                                                   THEN

c #DY   do k=1,mz
c #DY   do j=1,my
c #DY   do i=1,mx
c #DY     dumy3D(i,j,k) = 0.
c #DY   enddo
c #DY   enddo
c #DY   enddo

C +          ******
c #DY   call dynbil(7,1,ipr_nc,ID__nc,0.,0.,0.,0.,dumy3D)
C +          ******

c #IZ END IF


C +--Cloud Microphysics, Mass Flux convective Scheme
C +  -----------------------------------------------

c #HY do k=1,mz
c #HY do j=1,my
c #HY do i=1,mx
c #HY   WKxyz1(i,j,k) =   qwHY(i,j,k)  +   qiHY(i,j,k)
c #HY   WKxyz2(i,j,k) =   qrHY(i,j,k)  +   qsHY(i,j,k)
c #CA   WKxyz3(i,j,k) = dqv_CA(i,j,k)*   Lv_H2O/cp
c #CA.             *min(adj_CA(i,j),iun)*86400./dt_Loc
c #CA   WKxyz4(i,j,k) =(dpktCA(i,j,k)
c #CA.                *(ptopDY+sigma(k) *pstDY(i,j))**cap)
c #CA.             *min(adj_CA(i,j),iun)*86400./dt_Loc
c #HY enddo
c #HY enddo
c #HY enddo

c #HY do j=1,my
c #HY do i=1,mx
c #HY        zcd_HY(i,j)  = zcd_HY(i,j) / max(eps9,Hcd_HY(i,j)) / gravit
c #HY        Tcd_HY(i,j)  = Tcd_HY(i,j) / max(eps9,Hcd_HY(i,j))
c #HY        zsb_HY(i,j)  = zsb_HY(i,j) / max(eps9,Hsb_HY(i,j)) / gravit
c #HY        Tsb_HY(i,j)  = Tsb_HY(i,j) / max(eps9,Hsb_HY(i,j))
c #HY        Hcd_HY(i,j)  = Hcd_HY(i,j) / max(   1,icntHY     )
c #HY        Hsb_HY(i,j)  = Hsb_HY(i,j) / max(   1,icntHY     )
c #HY enddo
c #HY enddo

C +   ************
c #HY CALL UNwrite (ID__nc, 'QwQi   ', ipr_nc, mx, my, mz, WKxyz1)
c #HY CALL UNwrite (ID__nc, 'QrQs   ', ipr_nc, mx, my, mz, WKxyz2)
c #HY CALL UNwrite (ID__nc, 'ccniHY ', ipr_nc, mx, my, mz, ccniHY)
c #HY CALL UNwrite (ID__nc, 'qiHY   ', ipr_nc, mx, my, mz, qiHY  )
c #HY CALL UNwrite (ID__nc, 'qwHY   ', ipr_nc, mx, my, mz, qwHY  )
c #HY CALL UNwrite (ID__nc, 'qsHY   ', ipr_nc, mx, my, mz, qsHY  )
c #HY CALL UNwrite (ID__nc, 'qrHY   ', ipr_nc, mx, my, mz, qrHY  )
c #HY CALL UNwrite (ID__nc, 'hlatHY ', ipr_nc, mx, my, mz, hlatHY)
c #HY CALL UNwrite (ID__nc, 'HLCond ', ipr_nc, mx, my, 1 , Hcd_HY)
c #HY CALL UNwrite (ID__nc, 'TaCond ', ipr_nc, mx, my, 1 , Tcd_HY)
c #HY CALL UNwrite (ID__nc, 'z_Cond ', ipr_nc, mx, my, 1 , zcd_HY)
c #HY CALL UNwrite (ID__nc, 'HLSubl ', ipr_nc, mx, my, 1 , Hsb_HY)
c #HY CALL UNwrite (ID__nc, 'TaSubl ', ipr_nc, mx, my, 1 , Tsb_HY)
c #HY CALL UNwrite (ID__nc, 'z_Subl ', ipr_nc, mx, my, 1 , zsb_HY)
c #HY CALL UNwrite (ID__nc, 'rainHY ', ipr_nc, mx, my, 1 , rainHY)
c #HY CALL UNwrite (ID__nc, 'snowHY ', ipr_nc, mx, my, 1 , snowHY)
c #HY CALL UNwrite (ID__nc, 'crysHY ', ipr_nc, mx, my, 1 , crysHY)
C +   ************

c #HY        icntHY       =     0
c #HY do j=1,my
c #HY do i=1,mx
c #HY        Hcd_HY(i,j)  =     0.
c #HY        Tcd_HY(i,j)  =     0.
c #HY        zcd_HY(i,j)  =     0.
c #HY        Hsb_HY(i,j)  =     0.
c #HY        Tsb_HY(i,j)  =     0.
c #HY        zsb_HY(i,j)  =     0.
c #HY enddo
c #HY enddo

C +   ************
c #CA CALL UNwrite (ID__nc, 'CAPE   ', ipr_nc, mx, my, 1 , capeCA)
c #CA CALL UNwrite (ID__nc, 'rainCA ', ipr_nc, mx, my, 1 , rainCA)
c #CA CALL UNwrite (ID__nc, 'snowCA ', ipr_nc, mx, my, 1 , snowCA)
c #CA CALL UNwrite (ID__nc, 'dqv_CA ', ipr_nc, mx, my, mz, WKxyz3)
c #CA CALL UNwrite (ID__nc, 'dpktCA ', ipr_nc, mx, my, mz, WKxyz4)
C +   ************


C +--Water Budget
C +  ------------

C +        ******
c #WB call H2O_WB(-1, 0.,0.,.FALSE.,.TRUE.)
C +        ******

c #WB DO j=1,my
c #WB DO i=1,mx
c #WB   WKxy1(i,j) = dq__WB(i,j,1)
c #WB   WKxy2(i,j) = dq__WB(i,j,2)
c #WB   WKxy3(i,j) = dq__WB(i,j,3)
c #WB   WKxy4(i,j) = dq__WB(i,j,4)
c #WB   WKxy5(i,j) = dq__WB(i,j,5)
c #WB   WKxy6(i,j) = dq__WB(i,j,6)
c #WB ENDDO
c #WB ENDDO

C +        *******
c #WB CALL UNwrite (ID__nc, 'H2O_ADV', ipr_nc, mx, my,  1 , WKxy1)
c #WB CALL UNwrite (ID__nc, 'H2OdifH', ipr_nc, mx, my,  1 , WKxy2)
c #WB CALL UNwrite (ID__nc, 'H2O_CVA', ipr_nc, mx, my,  1 , WKxy3)
c #WB CALL UNwrite (ID__nc, 'H2OdifV', ipr_nc, mx, my,  1 , WKxy4)
c #WB CALL UNwrite (ID__nc, 'H2O_mic', ipr_nc, mx, my,  1 , WKxy5)
c #WB CALL UNwrite (ID__nc, 'H2Ofltr', ipr_nc, mx, my,  1 , WKxy6)
c #WB CALL UNwrite (ID__nc, 'H2OsrfT', ipr_nc, mx, my,  1 , uq__WB)
c #WB CALL UNwrite (ID__nc, 'H2OsrfA', ipr_nc, mx, my,  1 , wq__WB)
c #WB CALL UNwrite (ID__nc, 'H2Oflux', ipr_nc, mx, my,  1 , upq_WB)
c #WB CALL UNwrite (ID__nc, 'H2Ofluy', ipr_nc, mx, my,  1 , vpq_WB)
c #WB CALL UNwrite (ID__nc, 'H2Omean', ipr_nc, mx, my,  1 , cpq_WB)
c #WB CALL UNwrite (ID__nc, 'Snoflux', ipr_nc, mx, my,  1 , ups_WB)
c #WB CALL UNwrite (ID__nc, 'Snofluy', ipr_nc, mx, my,  1 , vps_WB)
c #WB CALL UNwrite (ID__nc, 'Snomean', ipr_nc, mx, my,  1 , cps_WB)
c #WB CALL UNwrite (ID__nc, 'Vap_Liq', ipr_nc, mx, my, mz , dqwHY)
c #WB CALL UNwrite (ID__nc, 'Vap_Ice', ipr_nc, mx, my, mz , dqiHY)
C +        *******

C +        ******
c #WB call H2O_WB(-1, 0.,0.,.TRUE.,.FALSE.)
C +        ******


C +--Cloud Optical Depth
C +  -------------------

c #OD DO j=1,my
c #OD DO i=1,mx
c #OD      WKxy1(i,j)  = 0.
C +...     WKxy1(i,j)  : liquid water path (kg/m2) (droplets)

c #OD      WKxy2(i,j)  = 0.
c +...     WKxy2(i,j)  : liquid water path (kg/m2) (crystals)
c #vO ENDDO
c #vO ENDDO

c #OD DO k = mzabso+1,mz
c #vO DO j=1,my
c #vO DO i=1,mx
c #OD      rhodzk = (    pstDY(i,j)  * sigma(k)+ptopDY)
c #OD.            / (ra*tairDY(i,j,k)*(1.+.608   *qvDY(i,j,k)))
c #OD.            * (   gpmiDY(i,j,k)-          gpmiDY(i,j,k+1))
C +...     rhodzk : (rho / 1000) * (dz * gravit)

c #OD      WKxy1(i,j)  = WKxy1(i,j) + rhodzk * qwHY(i,j,k)
c #OD      WKxy2(i,j)  = WKxy2(i,j) + rhodzk * qiHY(i,j,k)
c #OD END DO
c #vO END DO
c #vO END DO

c #vO DO j=1,my
c #vO DO i=1,mx
c #OD      WKxy3(i,j)  = 1.5 * ( WKxy1(i,j) / 20.d-6
c #OD.                         + WKxy2(i,j) / 40.d-6 ) *grvinv
c #OD END DO
c #OD END DO

C +   ************
c #OD CALL UNwrite (ID__nc, 'OptDep ', ipr_nc, mx, my, 1 , WKxy3 )
c #EE CALL UNwrite (ID__nc, 'OptDep ', ipr_nc, mx, my, 1 ,RAcdtO )
C +   ************


C +--Snow Pack
C +  ---------

c #SN IF (SnoMod.AND.VSISVAT)                                       THEN

c #SN   DO k=1,mw
c #SN   DO j=1,my
c #SN   DO i=1,mx
c #SN     WRKxys(i,j,k) = zWE_SN(i,j,k) - zWE0SN(i,j,k)
c #SN   END DO
c #SN   END DO
c #SN   END DO

c #SN   DO n=1,mw

c #SN   IF (n.GT.1)                                                 THEN
c #SN                lab__z(5:5) = '_'
c #SN                lab_dz(5:5) = '_'
c #SN                lab_ro(5:5) = '_'
c #SN                lab_wa(5:5) = '_'
c #SN                lab_g1(5:5) = '_'
c #SN                lab_g2(5:5) = '_'
c #SN                lab_Ti(5:5) = '_'
c #SN                write(chn,'(i1)') n
c #SN                lab__z(6:6) = chn
c #SN                lab_dz(6:6) = chn
c #SN                lab_ro(6:6) = chn
c #SN                lab_wa(6:6) = chn
c #SN                lab_g1(6:6) = chn
c #SN                lab_g2(6:6) = chn
c #SN                lab_Ti(6:6) = chn
c #SN   ELSE
c #SN                lab__z(5:6) = 'WE'
c #SN                lab_dz(5:6) = 'OW'
c #SN                lab_ro(5:6) = 'OW'
c #SN                lab_wa(5:6) = 'OW'
c #SN                lab_g1(5:6) = 'OW'
c #SN                lab_g2(5:6) = 'OW'
c #SN                lab_Ti(5:6) = 'OW'
c #SN   END IF

c #SN   DO k=1,mz
c #SN   DO j=1,my
c #SN   DO i=1,mx
c #SN     WKxyz1(i,j,k) = 0.
c #SN     WKxyz2(i,j,k) = 0.
c #SN     WKxyz3(i,j,k) = 0.
c #SN     WKxyz4(i,j,k) = 0.
c #SN   END DO
c #SN   END DO
c #SN   END DO

c #SN   DO k=1,nsnomz
c #SN   DO j=1,my
c #SN   DO i=1,mx
! #SN     n             =         ijSNOW(i,j)             ! 1: Land  /  2:Ocean
c #SN     WKxyz4(i,j,k) = min(max(nssSNo(i,j,n)-k+1,0),1) ! 0: outside SnowPack
c #vS   END DO
c #vS   END DO
c #vS   END DO

c #vS   DO k=1,nsnomz
c #vS   DO j=1,my
c #vS   DO i=1,mx
! #vS     n             =         ijSNOW(i,j)             ! 1: Land  /  2:Ocean
c #SN     kk            =     max(nssSNo(i,j,n)-k+1,1)    ! 1: 1st lev SnowPack

c #SN     WKxyz1(i,j,k) = dzsSNo(i,j,n,kk) * WKxyz4(i,j,k) 
c #SN.                  +   epsi       * (1.-WKxyz4(i,j,k))
c #SN     WKxyz2(i,j,k) = rosSNo(i,j,n,kk) * WKxyz4(i,j,k)
c #SN     WKxyz3(i,j,k) = wasSNo(i,j,n,kk) * WKxyz4(i,j,k)
c #SN   END DO
c #SN   END DO
c #SN   END DO

C +     ************
! #SN   CALL UNwrite (ID__nc, lab__z , ipr_nc, mx, my, mw, WRKxys)
c #SN   CALL UNwrite (ID__nc, lab_dz , ipr_nc, mx, my, mz, WKxyz1)
c #SN   CALL UNwrite (ID__nc, lab_ro , ipr_nc, mx, my, mz, WKxyz2)
c #SN   CALL UNwrite (ID__nc, lab_wa , ipr_nc, mx, my, mz, WKxyz3)
C +     ************

c #SN   DO k=1,mz
c #SN   DO j=1,my
c #SN   DO i=1,mx
c #SN     WKxyz1(i,j,k) = 0.
c #SN     WKxyz2(i,j,k) = 0.
c #SN     WKxyz3(i,j,k) = 0.
c #SN     WKxyz4(i,j,k) = 0.
c #SN   END DO
c #SN   END DO
c #SN   END DO

c #SN   DO k=1,nsnomz
c #SN   DO j=1,my
c #SN   DO i=1,mx
! #SN     n             =         ijSNOW(i,j)             ! 1: Land  /  2:Ocean
c #SN     kk            =     max(nssSNo(i,j,n)-k+1,1)    ! 1: 1st lev SnowPack

c #SN     WKxyz1(i,j,k) = g1sSNo(i,j,n,kk) * WKxyz4(i,j,k)
c #SN     WKxyz2(i,j,k) = g2sSNo(i,j,n,kk) * WKxyz4(i,j,k)
c #SN     WKxyz3(i,j,k) = tisSNo(i,j,n,kk) * WKxyz4(i,j,k)
c #SN   END DO
c #SN   END DO
c #SN   END DO

C +     ************
c #SN   CALL UNwrite (ID__nc, lab_g1 , ipr_nc, mx, my, mz, WKxyz1)
c #SN   CALL UNwrite (ID__nc, lab_g2 , ipr_nc, mx, my, mz, WKxyz2)
c #SN   CALL UNwrite (ID__nc, lab_Ti , ipr_nc, mx, my, mz, WKxyz3)
C +     ************

c #SN   END DO

c #SN END IF


C +--Polynya
C +  -------

C +   ************
c #PO CALL UNwrite (ID__nc, 'hatmPO ', ipr_nc, mx, my, 1 , hatmPO)
c #PO CALL UNwrite (ID__nc, 'hfraPO ', ipr_nc, mx, my, 1 , hfraPO)
c #PO CALL UNwrite (ID__nc, 'aicePO ', ipr_nc, mx, my, 1 , aicePO)
c #PO CALL UNwrite (ID__nc, 'hicePO ', ipr_nc, mx, my, 1 , hicePO)
c #PO CALL UNwrite (ID__nc, 'hiavPO ', ipr_nc, mx, my, 1 , hiavPO)
C +   ************


C +--Chemical Species
C +  ----------------

c #TC IF      (nkWri.gt.0)                                          THEN
c #TC   DO n=1,nkWri

c #TC       labelc       = namTC(      ikTC(n))
c #TC     DO k=1,mz
c #TC     DO j=1,my
c #TC     DO i=1,mx
c #TC       WKxyz1(i,j,k)=  qxTC(i,j,k,ikTC(n))  * 1.000d+09
C +...      Conversion [kg/kg] ------------------> [micro-g/kg]

c #CH.                                           * rolvDY(i,j,k) 
c #CH.                                           * 0.392D-19 / Unity
C +...      Conversion [mcm]   ------------------> [ppb]        if requested 
C +       =>Conversion [kg/kg] ------------------> [micro-g/kg]   eliminated
C +                                            ==> 0.392D-19 = 392D-10/1.d+9

c #TC     END DO
c #TC     END DO
c #TC     END DO

C +       ************
c #TC     CALL UNwrite (ID__nc,labelc(1:7),ipr_nc, mx, my, mz, WKxyz1)
C +       ************

c #TC   END DO

c #TC END IF


C +--That 's all, folks: NetCDF File Closure
C +  =======================================

C +   ************
      CALL UNclose (ID__nc)
C +   ************


C +--Work Arrays Reset
C +  =================

      do j=1,my
      do i=1,mx
        WKxy1(i,j)   =0.0
        WKxy2(i,j)   =0.0
        WKxy3(i,j)   =0.0
        WKxy4(i,j)   =0.0
      enddo
      enddo

      do k=1,mz
      do j=1,my
      do i=1,mx
        WKxyz1(i,j,k)=0.0
        WKxyz2(i,j,k)=0.0
        WKxyz3(i,j,k)=0.0
        WKxyz4(i,j,k)=0.0
      enddo
      enddo
      enddo

      IF   (mmarGE.EQ.12.AND.jdarGE.EQ.31)                          THEN
            end_YR = real(24-jhurGE)*3599.9- dt * nboucl
        IF (end_YR.LT.0.)                                           THEN
                             LastIO =             .TRUE.
        ELSE
                             LastIO =             .FALSE.
        END IF
      ELSE
        IF (mmarGE.EQ. 1.AND.jdarGE.EQ. 1.AND.    jhurGE.EQ.0.AND.
     .      iyrrGE      .GT. iyr0GE      .AND.
     .      iterun.GE.nboucl*nprint)                                THEN
                             LastIO =             .TRUE.
        ELSE
                             LastIO =             .FALSE.
        END IF
      END IF
 
C +   +++++++++++
C +   IF (LastIO) ipr_nc = 0        ! ipr_nc:=0 => NEW MAR*.nc     created
C +   +++++++++++                   !              at the next OUT_nc call

      return
      end


      subroutine OUTlmw

C +------------------------------------------------------------------------+
C | MAR OUTPUT                                             08-03-2004  MAR |
C |   SubRoutine OUTlmw computes the Root Mean Square Error undergone      |
C |                     by MAR when simulating Linear Mountain Waves       |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARCTR.inc'
      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MARSND.inc'

      include 'MAR_DY.inc'
c #OL include 'MAR_OL.inc'

      include 'MAR_SL.inc'


      integer           jplan
      common/LiMtWa_int/jplan
      real              ua_ANA(mx,mz),Ta_ANA(mx,mz)
      common/LiMtWa_rea/ua_ANA       ,Ta_ANA


C +--Local  Variables
C +  ================

      integer  mx4

      real     uuu(mz),ttt(mz)
      real     eru(mz),ert(mz)
      real     pcu(mz),pct(mz)

      character* 1 labgra
      character* 8 forme,formi
      character*16 fout

      integer  immtu ,immtt ,immeu ,immet ,immeu4,immet4
      integer  imstu ,imstt ,imseu ,imset ,imseu4,imset4
      integer  nofen ,ngra  ,month ,isg   ,mrk   ,k2000
      real     rmmtu ,rmmtt ,rmmeu ,rmmet ,rmmeu4,rmmet4
      real     rmstu ,rmstt ,rmseu ,rmset ,rmseu4,rmset4
      real     fac   ,cst   ,h2000 ,d2000 ,e2000 ,heure

      real     zz    ,yrmse ,yrmse2,aam   ,hhm


C +--DATA
C +  ====

      data yrmse /10000.e0/
      data yrmse2/ 5000.e0/

      include 'OUTlmw.inc'

      if (mmy.ne.1) 
     .stop'++++++++ my is improperly specified ++++++++++++++++++++++++'
       jplan   = 1


C +--Initialisation
C +  ==============

C +--Small Domain over which the Errors are computed
C +  -----------------------------------------------
      mx4=aam*5/dx
      mx4=min(mx/4,mx4)


C +--Initialization of the Errors Counters
C +  -------------------------------------

C +--Mean Error
C +  ~~~~~~~~~~
       immtu   = 0
       immtt   = 0
       rmmtu   = 0.
       rmmtt   = 0.

       immeu   = 0
       immet   = 0
       rmmeu   = 0.
       rmmet   = 0.

       immeu4  = 0
       immet4  = 0
       rmmeu4  = 0.
       rmmet4  = 0.

C +--RMSE (Root Mean Square Error, e.g. Pielke, 1984, p.350)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       imstu   = 0
       imstt   = 0
       rmstu   = 0.
       rmstt   = 0.

       imseu   = 0
       imset   = 0
       rmseu   = 0.
       rmset   = 0.

       imseu4  = 0
       imset4  = 0
       rmseu4  = 0.
       rmset4  = 0.


C +--MAR Variables are stored
C +  ------------------------

c #OL DO k=1,mz
c #OL DO j=1,my
c #OL DO i=1,mx
c #OL   urefOL(i,j,k) = uairDY(i,j,k)
c #OL   uairDY(i,j,k) =(uairDY(i,j,k)-ugeoDY(i,j,k)) *1000.
c #OL   trefOL(i,j,k) = tairDY(i,j,k)
c #OL   tairDY(i,j,k) =(tairDY(i,j,k)-tSND  (1,1)  ) *1000. 
c #OL.                 +tSND  (1,1)
c #OL   gplvOL(i,j,k) = gplvDY(i,j,k)
c #OL   gplvDY(i,j,k) =(gplvDY(i,j,k)-gp00OL(i,j,k)) *1000. 
c #OL.                 +gp00OL(i,j,k)
c #OL ENDDO
c #OL ENDDO
c #OL ENDDO


C +--ANALYTICAL SOLUTION
C +  ===================

C +        ******
      call ANAlmw
C +        ******


C +--ERROR
C +  =====

      DO k=1,mz
      DO i=1,mx
          zz      =               gplvDY(i,jplan,k) * grvinv

        IF (i.eq.imez)                                              THEN
          uuu(k) =                uairDY(i,jplan,k)
          eru(k) = ua_ANA(i,k)  - uairDY(i,jplan,k)
          pcu(k) = 100.*abs(eru(k))/abs(ua_ANA(i,k))
          ttt(k) =                tairDY(i,jplan,k)
          ert(k) = Ta_ANA(i,k)  - tairDY(i,jplan,k)
          pct(k) = 100.*abs(ert(k))/abs(Ta_ANA(i,k))
        END IF

          immtu  = immtu  + 1
          immtt  = immtu  + 1
          rmmtu  = rmmtu  + ua_ANA(i,k) - uairDY(i,jplan,k)
          rmmtt  = rmmtt  + Ta_ANA(i,k) - tairDY(i,jplan,k)

          imstu  = imstu  + 1
          imstt  = imstu  + 1
          rmstu  = rmstu  +(ua_ANA(i,k) - uairDY(i,jplan,k))**2
          rmstt  = rmstt  +(Ta_ANA(i,k) - tairDY(i,jplan,k))**2

        IF (zz.le.yrmse)                                            THEN
          immeu  = immeu  + 1
          immet  = immeu  + 1
          rmmeu  = rmmeu  + ua_ANA(i,k) - uairDY(i,jplan,k)
          rmmet  = rmmet  + Ta_ANA(i,k) - tairDY(i,jplan,k)

          imseu  = imseu  + 1
          imset  = imseu  + 1
          rmseu  = rmseu  +(ua_ANA(i,k) - uairDY(i,jplan,k))**2
          rmset  = rmset  +(Ta_ANA(i,k) - tairDY(i,jplan,k))**2
        END IF

        IF (zz.le.yrmse2.and.(i.gt.mx4.and.i.le.mx-mx4))            THEN
          immeu4 = immeu4 + 1
          immet4 = immeu4 + 1
          rmmeu4 = rmmeu4 + ua_ANA(i,k) - uairDY(i,jplan,k)
          rmmet4 = rmmet4 + Ta_ANA(i,k) - tairDY(i,jplan,k)

          imseu4 = imseu4 + 1
          imset4 = imseu4 + 1
          rmseu4 = rmseu4 +(ua_ANA(i,k) - uairDY(i,jplan,k))**2
          rmset4 = rmset4 +(Ta_ANA(i,k) - tairDY(i,jplan,k))**2
        END IF

      ENDDO
      ENDDO


C +--Mean Errors 
C +  -----------

          rmmtu  =      rmmtu /immtu
          rmmtt  =      rmmtt /immtt

          rmmeu  =      rmmeu /immeu
          rmmet  =      rmmet /immet

          rmmeu4 =      rmmeu4/immeu4
          rmmet4 =      rmmet4/immet4


C +--RMSE (Root Mean Square Error, e.g. Pielke, 1984, p.350)
C +  -------------------------------------------------------

          rmstu  = sqrt(rmstu /imstu)
          rmstt  = sqrt(rmstt /imstt)

          rmseu  = sqrt(rmseu /imseu)
          rmset  = sqrt(rmset /imset)

          rmseu4 = sqrt(rmseu4/imseu4)
          rmset4 = sqrt(rmset4/imset4)


C +--OUTPUT
C +  ------

      IF (iterun.eq.1)                                              THEN

        fout      =  fnam
        fout(1:9) = 'RMSE__V_t'
        open (unit=41,status='unknown',file=fout)
        rewind     41
        nofen  =  0
        labgra = 'H'
        ngra   =  4
        forme = '(5f12.6)'
        formi = '(5i12  )'
C +...  forme,formi : output format -> graphic file 

        month =  0
C +...  month :  X axis parameter   -> graphic file 

        fac   =  1.
        cst   =  0.
        isg   =  1
        mrk   = -3
C +...  Graphic Caracteristics 

         h2000 = 2000.  
         d2000 = 2000.  
        DO k=1,mz
         e2000 = abs(h2000-gplvDY(imez,jplan,k)*grvinv)
        if (e2000.lt.d2000) then
         d2000 =     e2000
         k2000 =     k
        end if
        ENDDO
C +...  Indice du niveau le plus pres de 2000 m 

        write(41,2001)nofen,labgra,k2000
 2001   format('LINEAR MOUNTAIN WAVES',20x,i1,1x,a1,6x,'k2000 =',i3,
     .       /,'    1 --- read x|y, y|x, x,y (1,2,3)')
C +...  TITRE

        write(41,2002) nterun,ngra,forme,formi
 2002   format(     i5,' --- number of data',
     .       /,'  ',i3,' --- number of curves',
     .       /,'  ',a8,
     .       /,'  ',a8)

      END IF


        heure = itexpe * dt / 3600.
        write(41,2003) heure,rmseu4,rmseu,pcu(k2000),
     .              0.001d0 *gplvDY(imez,jplan,k2000)*grvinv
 2003   format(5f12.6)

      IF (iterun.eq.nterun)                                         THEN

        write(41,2003) fac,fac,fac,fac,fac
        write(41,2003) cst,cst,cst,cst,cst
        write(41,2004) isg,isg,isg,isg,isg
        write(41,2004) mrk,mrk,mrk,mrk,mrk
 2004   format(5i12  )

        write(41,2005)  month
 2005   format(
     .       '    0 --- axe x logarithmique :        (oui,non) = (1,0)',
     .     /,'    0 --- axe y logarithmique :        (oui,non) = (1,0)',
     ./,'    ',i1,' --- label axe inferieur : mois : (oui,non) = (1,0)',
     .     /,'              Time [Hour]              $',
     .     /,'    RMS Error on Wind Speed [m.s-1]    $',
     .     /,'        Error on Wind Speed [%]        $')
        write(41,2006)
 2006   format(40x)
        write(41,2007) labgra,nofen,fnam,mx,mz,0.001*dx 
 2007   format(
     .       '    n ',a1,1x,i1,' --- Fichier Suivant / Type Graphe',
     .     /,'    ',a16,
     .     /,'    LINEAR MOUNTAIN WAVE (mx,mz=',i3,',',i3,')',
     .     /,'    Grid Size :',f8.1,' km')
        write(41,2006)
        write(41,2006)
        write(41,2006)
        write(41,2006)
        write(41,2006)
        close(unit=41)

      END IF

      IF (jmmMAR.eq.0.and.jssMAR.eq.0)                              THEN

        fout      = fnam
        fout(1:2) ='ER'
        open (unit=42,status='unknown',file=fout)
        rewind     42
        write(42,307)fnam(11:13),fnam(6:7),
     .               mx,mz,           immtu, rmmtu, rmmtt, rmstu, rmstt,
     .                    .001*yrmse, immeu, rmmeu, rmmet, rmseu, rmset,
     .                    .001*yrmse2,immeu4,rmmeu4,rmmet4,rmseu4,rmset4
 307    format(' Experiment ',a3,3x,a2,'h',3x,i3,' Grid Points  X ',
     .                                        i3,' Vert.Levels'
     .   /,'                     DATA      Mean Error    R.M.S. Error',
     .   /,'                                u       T       u       T',
     .   /,' Full Domain      : '    ,i5,4f8.4,
     .   /,' All x, z=0,',f4.0,'km: ',i5,4f8.4,
     .   /,' 1/2 x, z=0,',f4.0,'km: ',i5,4f8.4)
        write(42,308)imez,sh(imez,jplan)
c #WR   write (6,308)imez,sh(imez,jplan)
 308    format(/,' Grid Point',i3,3x,' z(Srf) = ',f8.0,
     .   /,'      z       u          Error(u)  ',
     .             '       T         Error(T)',
     .   /,'     [m]    [m/s]    [m/s]      [%]',
     .             '      [K]      [K]      [%]')
        write(42,309)(gplvDY(imez,jplan,k)*grvinv,uuu(k),eru(k),pcu(k),
     .                                     ttt(k),ert(k),pct(k),k=1,mz)
c #WR   write (6,309)(gplvDY(imez,jplan,k)*grvinv,uuu(k),eru(k),pcu(k),
c #WR.                                     ttt(k),ert(k),pct(k),k=1,mz)
 309    format(f8.0,f9.2,f9.3,f9.2,f9.2,f9.3,f9.2)
c #WR   write (6,307)fnam(11:13),fnam(6:7),
c #WR.               mx,mz,           immtu, rmmtu, rmmtt, rmstu, rmstt,
c #WR.                    .001*yrmse, immeu, rmmeu, rmmet, rmseu, rmset,
c #WR.                    .001*yrmse2,immeu4,rmmeu4,rmmet4,rmseu4,rmset4
        close(unit=42)

      END IF


C +--RESET
C +  =====

c #OL DO k=1,mz
c #OL DO j=1,my
c #OL DO i=1,mx
c #OL  uairDY(i,j,k) = urefOL(i,j,k)
c #OL  tairDY(i,j,k) = trefOL(i,j,k)
c #OL  gplvDY(i,j,k) = gplvOL(i,j,k)
c #OL ENDDO
c #OL ENDDO
c #OL ENDDO

      return
      end


      subroutine ANAlmw

C +------------------------------------------------------------------------+
C | MAR OUTPUT                                             08-03-2004  MAR |
C |   SubRoutine ANAlmw computes the Analytical Solution of                |
C |                              Linear Mountain Waves                     |
C +------------------------------------------------------------------------+


      IMPLICIT NONE


C +--Global Variables
C +  ================

      include 'MARphy.inc'

      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'

      include 'MAR_DY.inc'
c #OL include 'MAR_OL.inc'

      include 'MAR_SL.inc'


      integer           jplan
      common/LiMtWa_int/jplan
      real              ua_ANA(mx,mz),Ta_ANA(mx,mz)
      common/LiMtWa_rea/ua_ANA       ,Ta_ANA


C +--Local  Variables
C +  ================

      logical  sinuso
      real     uum   ,ttm   ,rat   ,rho0  ,ssm   ,ssn   ,ss2
      real     xx    ,zz    ,ppm   ,rhom  ,c2m   ,beta
      real     vl2   ,akk   ,ak2   ,vlm   ,vlz   ,coe   
      real     eta   ,uup   ,vlx   ,expla ,rhop  ,ppp   ,ttp

      real     gam   ,ga1   ,hhm   ,aam   ,aas   


C +--DATA
C +  ====

c #OL include "OUTlmw.inc"

      data     gam   /    1.40/
      data     ga1   /    0.40/


C +--Initialization
C +  ==============

      sinuso = .false. 
c #OS sinuso = .true. 


C +--Main Parameters of the Flow
C +  ---------------------------

      uum     = ugeoDY(1,1,1)
C +...uum     : Large Scale Wind 
      ttm     = tsrfSL(1,1,1)
C +...ttm     : Temperature, assumed to be constant
      rat     = 1.   / RDryAi / ttm
      rho0    = 1.e5 * rat
C +...rho0    : rho(0)
      ssm     = gravit    * rat
      ssn     =-ssm
C +...ssn     : Heterogeneity Parameter 

      ss2     = ssn  / 2.


C +--ANALYTICAL SOLUTION
C +  ===================

      DO i=1,mx
      DO k=1,mz
          xx      = 1000.*xxkm(i)
          zz      =       gplvDY(i,jplan,k)        * grvinv

          ppm     = 1.0e3*(pstDY(i,jplan)*sigma(k) + ptopDY)
C +...    ppm     : pression (en Pa)

          rhom    = ppm * rat
C +...    rhom    : masse volumique
          c2m     = gam * ppm / rhom
C +...    c2m     : carre de la vitesse du son
          beta    = ga1 * gravit   / c2m
C +v Compressibility Effect #C2
          rhom    = ppm * rat /(1. - uum*uum/c2m)
C +^ Compressibility Effect #C2

          vl2     = beta* gravit   / uum / uum - 0.25 * ssm * ssm
C +...    vl2     : carre du nombre d'onde vertical

C +--Sinusoidal    shaped Mountain
C +  -----------------------------

        IF (sinuso)                                                 THEN
          akk     = 2.  *pi/aas
          ak2     = akk *   akk
          vlm     = sqrt(vl2 - ak2)
          vlz     = vlm *   zz
          coe     = sqrt(rho0/rhom)*hhm
          eta     =       coe *     cos(vlz + xx*akk )
          uup     = uum *(eta * gravit /c2m 
     .                   +eta * ss2
     .                   +coe * vlm*sin(vlz + xx*akk))
        ELSE


C +--(Lorenz-)bell shaped Mountain
C +  -----------------------------

         vlm     = sqrt(vl2)
         vlz     = vlm * zz
         vlx     = vlm * xx
         coe     = sqrt(rho0/rhom)*hhm*aam/(aam*aam + xx*xx)
         expla   = exp  (-vlm*aam)
         eta     = coe *( aam*cos(vlz)    -xx*sin(vlz)
     .                  -(aam*cos(vlz+vlx)-xx*sin(vlz+vlx))*expla)
         uup     = uum

C +v Compressibility Effect #C2
     .  * ( 1.   / (1.   + uum*uum/c2m) )
C +^ Compressibility Effect #C2

     .  * ( eta *gravit/c2m
     .    + eta *ss2 
     .    + vlm *coe *( aam*sin(vlz)    +xx*cos(vlz)
     .                -(aam*sin(vlz+vlx)+xx*cos(vlz+vlx))*expla))
        END IF


C +--Thermodynamical Variables
C +  -------------------------

          rhop    =            beta*rhom*eta
          ppp     =                -rhom*uum*uup
          ttp     = ttm*(1.+ppp/ppm-rhop/rhom)


C +--Linear Mountain Wave: Analytical Solution for Wind and Temperature
C +  ==================================================================

          ua_ANA(i,k) = uup
          Ta_ANA(i,k) = ttp
      ENDDO
      ENDDO

      return
      end


      subroutine dynbil(tdt,afdt,jdyn,ibd)
C +
C +------------------------------------------------------------------------+
C | MAR OUTPUT                                             19-09-2001  MAR |
C |   SubRoutine Dynbil computes the Dynamical Balance of the Circulation  |
C |                     in the vertical plane j (parallel to the y axis)   |
C |   This balance is done over the last 10 time steps of the run          |
C |                                                                        |
C +------------------------------------------------------------------------+
C |                                                                        |
C |   REMARK : In order to get accurate values of the contributions,       |
C |   ^^^^^^^^ the model has to be run at least over 10 time steps         |
C |                                                                        |
C |   REMARK : Because of extra computing time and Memory Requirements,    |
C |   ^^^^^^^^ it is not recommended to use this routine over long runs.   |
C |            It is preferable to recompile the code with this routine    |
C |            and restart from the variables state saved in commun.dat    |
C |                                                                        |
C |   REMARK : Standard OUTPUT on files 61-->66, with other possibilies    |
C |   ^^^^^^^^                                                             |
C +------------------------------------------------------------------------+
C +
C +
      IMPLICIT NONE
C +
C +
C +--Global Variables
C +  ================
C +
      include 'MARCTR.inc'
      include 'MARphy.inc'
C +
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
C +
      include 'MAR_DY.inc'
C +
      include 'MAR_RA.inc'
C +
      real          tdt   ,afdt
      integer       jdyn  ,ibd 
C +
C +
C +--Local  Variables
C +  ================
C +
      integer   nto
      parameter(nto=10)
C +... nto = 10 : contibution is computed over the last 10 time steps
C +           
      logical outdyn,outlev,outthe
C +...        .true.================> Output for Dynamics       (2D)
C +                  .true.=========> Output for Dynamics       (1D)
C +                         .true.==> Output for Thermodynamics (2D)
C +
      real                  u0(mx,mz)  ,  du(mx,mz,6,nto),
     .                      v0(mx,mz)  ,  dv(mx,mz,6,nto),
     .                    pkt0(mx,mz)  ,dpkt(mx,mz,6,nto)
      common /dynbil_bi0/   u0         ,  du,
     .                      v0         ,  dv,
     .                    pkt0         ,dpkt
      real                 dub(mx,mz,6),
     .                     dvb(mx,mz,6),
     .                   dpktb(mx,mz,6)
      common /dynbil_bi1/  dub,
     .                     dvb,
     .                   dpktb
C +
      integer   ib0   ,n     ,ibl   ,imx1  ,imx2  ,kw    ,ifac
      real      rto   ,extrem,fac
C +
      character*126 iwofig,iwork,iworkb,iworkc,iworkd,iworke
      character* 40 cmmt0, cmmt1,cmmt2, cmmt3, cmmt(12)
      character* 24 variab(6)
      character* 15 fout
      character*  9 ddate
      character*  8 ttime
      character*  3 mois(12)
      character*  1 ch1(6)
C +
C +
C +--DATA
C +  ====
C +
      data ch1  /'1','2','3','4','5','6'/
C +
      data mois/'JAN','FEB','MAR','APR','MAY','JUN',
     .          'JUL','AUG','SEP','OCT','NOV','DEC'/
C +
      data (cmmt(i),i=1,12)
     ./'    Variable :                          ',
     . '    SIMULATION      /  after  d   h     ',
     . '    (mx,my,mz) = (   ,   ,   )          ',
     . '    Simulated Date  :  dd mmm /   h     ',
     . '     Variable       Extrem. Value       ',
     . '    Hydrological Cycle :                ',
     . '                                        ',
     . '                                        ',
     . '                                        ',
     . '    Last Input :                        ',
     . '                                        ',
     . '                                        '/
C +
      data variab/'PGF         (1.d-3 m/s2)',
     .            'DIFFUSION   (1.d-3 m/s2)',
     .            'ADVECTION   (1.d-3 m/s2)',
     .            'CORIOLIS    (1.d-3 m/s2)',
     .            'PGF+FILTER  (1.d-3 m/s2)',
     .            'FILTER      (1.d-3 m/s2)'/
C +
C +
C +--INITIALISATION
C +  ==============
C +
      outdyn = .false.
      outlev = .true.
      outthe = .false.
C +
      fout= fnam
      rto = dble(nto)
C +
      if (outdyn) then
       call date(ddate)
       call time(ttime)
C +
       iwork (  1: 30) = '                              '
       iwork ( 31: 60) = '                              '
       iwork ( 61: 90) = '                              '
       iwork ( 91:120) = '                              '
       iwork (121:126) = '     $'
       iworkb          = iwork
       iworkc          = iwork
       iworkd          = iwork
       iworke          = iwork
       iwofig          = iwork
       iwofig(121:126) = '      '
      end if
C +
      if (ibd.eq.0) then
       do 413 ib0=1,6
       do 413 n=1,nto
       do 413 k=1,mz
       do 413 i=1,mx
       du  (i,k,ib0,n ) = 0.  
       dv  (i,k,ib0,n ) = 0.  
       dpkt(i,k,ib0,n ) = 0.  
 413   continue
       do 414 k=1,mz
       do 414 i=1,mx
       u0  (i,k       ) = uairDY(i,jdyn,k)
       v0  (i,k       ) = vairDY(i,jdyn,k)
       pkt0(i,k       ) = pktaDY(i,jdyn,k)
 414   continue
      else
C +
C +
C +--TREATMENT
C +  =========
C +
C +
C +--Loading the Contributions
C +  -------------------------
C +
       if (ibd.le.6) then
        do 415 n=1,nto-1
        do 415 k=1,mz
        do 415 i=1,mx
        du  (i,k,ibd,n ) = du  (i,k,ibd,n+1)
        dv  (i,k,ibd,n ) = dv  (i,k,ibd,n+1)
        dpkt(i,k,ibd,n ) = dpkt(i,k,ibd,n+1)
C +...  Update                                 
C
 415    continue
        do 416 k=1,mz
        do 416 i=1,mx
        du  (i,k,ibd,nto) =   afdt *(uairDY(i,jdyn,k)-  u0(i,k)) 
        dv  (i,k,ibd,nto) =   afdt *(vairDY(i,jdyn,k)-  v0(i,k)) 
        dpkt(i,k,ibd,nto) =   afdt *(pktaDY(i,jdyn,k)-pkt0(i,k)) 
     .                       + tdt * pktRAd(i,jdyn,k)
C +...  Details of Each Contribution           
C +
C +
C +--Update old Values of the Variables
C +  ----------------------------------
C +
        u0   (i,k        ) = uairDY(i,jdyn,k)
        v0   (i,k        ) = vairDY(i,jdyn,k)
        pkt0 (i,k        ) = pktaDY(i,jdyn,k)
        dub  (i,k,ibd    ) =     du(i,k,ibd,1)
        dvb  (i,k,ibd    ) =     dv(i,k,ibd,1)
        dpktb(i,k,ibd    ) =   dpkt(i,k,ibd,1)
 416    continue
C +
C +
C +--Temporal Average (is done at each time step)
C +  --------------------------------------------
C +
        do 417 n=2,nto
        do 417 k=1,mz
        do 417 i=1,mx
        dub  (i,k,ibd   ) =  du  (i,k,ibd,n) + dub  (i,k,ibd)
        dvb  (i,k,ibd   ) =  dv  (i,k,ibd,n) + dvb  (i,k,ibd)
        dpktb(i,k,ibd   ) =  dpkt(i,k,ibd,n) + dpktb(i,k,ibd)
 417    continue
        do 418 k=1,mz
        do 418 i=1,mx
        dub  (i,k,ibd   ) =             1000. *dub  (i,k,ibd) /rto /dt
        dvb  (i,k,ibd   ) =             1000. *dvb  (i,k,ibd) /rto /dt
        dpktb(i,k,ibd   ) =      pcap *86400. *dpktb(i,k,ibd) /rto /dt
 418    continue
C +
       else
C +
C +
C +--Sum of Contributions from the PGF and the Filter
C +  ------------------------------------------------
C +
        do 4180 k=1,mz
        do 4180 i=1,mx
        dub  (i,k,5     ) = dub  (i,k,1) + dub  (i,k,6)
        dvb  (i,k,5     ) = dvb  (i,k,1) + dvb  (i,k,6)
        dpktb(i,k,5     ) = dpktb(i,k,1) + dpktb(i,k,6)
 4180   continue
C +
C +
C +--OUTPUT
C +  ======
C +
C +--Output FIRST Sigma Level
C +  ------------------------
C +
      if (mod(minuGE,10).eq.0.and.jsecGE.eq.0) then
         write(61,61)itexpe,(dub(i,mz,1), i=imez-10,imez+30)
 61      format(i10,20f5.1,/,10x,21f5.1)
         write(62,62)itexpe,(dub(i,mz,2), i=imez-10,imez+30)
 62      format(i10,20f5.1,/,10x,21f5.1)
         write(63,63)itexpe,(dub(i,mz,3), i=imez-10,imez+30)
 63      format(i10,20f5.1,/,10x,21f5.1)
         write(64,64)itexpe,(dub(i,mz,4), i=imez-10,imez+30)
 64      format(i10,20f5.1,/,10x,21f5.1)
         write(65,65)itexpe,(dub(i,mz,5), i=imez-10,imez+30)
 65      format(i10,20f5.1,/,10x,21f5.1)
         write(66,66)itexpe,(dub(i,mz,6), i=imez-10,imez+30)
 66      format(i10,20f5.1,/,10x,21f5.1)
      end if
C +
C +
C +--Output fct(x,z)
C +  ---------------
C +
        if (outdyn) then
         fout( 1: 4) = 'dy_u'
         fout( 8: 8) = '_'
         do 419 ibl=1,6
         fout( 9: 9) =  ch1(ibl)
         open (unit=26,status='unknown',file=fout)
         rewind     26
         write(26,4190) 
 4190    format(' (10e12.4)')
         write(26,4191)((dub  (i,k, ibl)       ,i=1,mx),k=mz,1,-1)
     .                ,((gplvDY(i,jdyn,k)*grvinv,i=1,mx),k=mz,1,-1)
     .                , (xxkm (i)              ,i=1,mx)
 4191    format(10e12.4)
C +
C +--Control Parameters fct(x,z)
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
         extrem = -1.d20
         do 153 i=1,mx
         do 153 k=1,mz
         extrem = max(extrem,dub(i,k,ibl))
 153     continue
          imx1          =     extrem
          imx2          = 10*(extrem  -imx1)
C +
         cmmt0        = cmmt  (1)
         cmmt0(16:39) = variab(ibl)
C +      if (abs(fac(ibl)-10.).lt.0.001) cmmt0(30:32) = '(.1'
C +      12345678901234567890123456789012345678901234567890
         cmmt (1)     = cmmt0
C +
         cmmt0        = cmmt  (2)
C +      si_ddhhmm.lab
C +      1234567890123
         cmmt0(16:18) = fnam  (11:13)
         cmmt0(30:30) = fnam  ( 5: 5)
         cmmt0(33:34) = fnam  ( 6: 7)
         cmmt (2)     = cmmt0
C +      write(6,251)   cmmt0
 251     format(a40)
C +
         cmmt0        = cmmt  (3)
C +
         if  (mmx.gt.99) then
           write(cmmt0(19:21),'(i3)') mx
         else
          if (mmx.gt. 9) then
           write(cmmt0(20:21),'(i2)') mx
          else
           write(cmmt0(21:21),'(i1)') mx
          end if
         end if
C +
         if  (mmy.gt.99) then
           write(cmmt0(23:25),'(i3)') my
         else
          if (mmy.gt. 9) then
           write(cmmt0(24:25),'(i2)') my
          else
           write(cmmt0(25:25),'(i1)') my
          end if
         end if
C +
         if  (mmz.gt.99) then
           write(cmmt0(27:29),'(i3)') mz
         else
          if (mmz.gt. 9) then
           write(cmmt0(28:29),'(i2)') mz
          else
           write(cmmt0(29:29),'(i1)') mz
          end if
         end if
         cmmt (3)     = cmmt0
C +
         cmmt0        = cmmt  (4)
C +
         if  (jdarGE.gt.99) then
           write(cmmt0(23:25),'(i3)') jdarGE
         else
          if (jdarGE.gt. 9) then
           write(cmmt0(24:25),'(i2)') jdarGE
          else
           write(cmmt0(25:25),'(i1)') jdarGE
          end if
         end if
         cmmt0(27:29) = mois  (mmarGE)
C +
         if  (jhurGE.gt.99) then
           write(cmmt0(32:34),'(i3)') jhurGE
         else
          if (jhurGE.gt. 9) then
           write(cmmt0(33:34),'(i2)') jhurGE
          else
           write(cmmt0(34:34),'(i1)') jhurGE
          end if
         end if
C +
         if  (minuGE.gt.99) then
           write(cmmt0(35:37),'(i3)') minuGE
         else
          if (minuGE.gt. 9) then
           write(cmmt0(36:37),'(i2)') minuGE
          else
           write(cmmt0(37:37),'(i1)') minuGE
          end if
         end if
C +
         cmmt (4)     = cmmt0
C +
         cmmt0        = cmmt  (5)
C +
         if  (ibl.ne. 0) then
         if  (ibl.gt.99) then
           write(cmmt0(17:19),'(i3)') ibl
         else
          if (ibl.gt. 9) then
           write(cmmt0(18:19),'(i2)') ibl
          else
           write(cmmt0(19:19),'(i1)') ibl
          end if
         end if
         else
                        cmmt0(17:19) ='INT'
         end if
C +
         if  (imx1.gt.99) then
           write(cmmt0(35:37),'(i3)') imx1
         else
          if (imx1.gt. 9) then
                        cmmt0(35:35)=' '
           write(cmmt0(36:37),'(i2)') imx1
          else
                        cmmt0(35:36)='  '
           write(cmmt0(37:37),'(i1)') imx1
          end if
         end if
                        cmmt0(38:38)='.'
           write(cmmt0(39:39),'(i1)') imx2
         cmmt (5)     = cmmt0
C +
         cmmt0        = cmmt  (6)
         if (micphy)                                   then
         cmmt0(26:28) = 'ON '
         else
         cmmt0(26:28) = 'OFF'
         end if
         cmmt (6)     = cmmt0
C +
         cmmt0        = cmmt(10)
         cmmt0(18:19) ='XX'
         cmmt0(20:30) = fnam( 3:13)
         cmmt (10)    = cmmt0
C +
C +      12345678901234567890123456789012345678901234567890
C +  . /'    Variable :                          ',
C +  .  '    SIMULATION XXX  /  after xd xxh     ',
C +  .  '    (mx,my,mz) = (XXX,XXX,XXX)          ',
C +  .  '    Simulated Date  :  dd mmm / xxhxx   ',
C +  .  '     grid point XXX to grid point XXX   ',
C +  .  '    Hydrological Cycle :                ',
C +
         iworkb(  1:  1)= ' '
         iworkb(  2: 41)= cmmt(1)
         iworkb( 42: 43)= '  '
         iworkb( 44: 83)= cmmt(2)
         iworkb( 84:102)= '                   '
         iworkb(103:126)= '                        '
C +
         iworkc(  1:  6)= '      '
         iworkc(  2: 41)= cmmt(3)
         iworkc( 42: 43)= '  '
         iworkc( 44: 83)= cmmt(4)
         iworkc( 84:102)= '                   '
         iworkc(103:126)= '                        '
C +
         iworkd(  1:  6)= '      '
         iworkd(  2: 41)= cmmt(5)
         iworkd( 42: 43)= '  '
         iworkd( 44: 83)= cmmt(6)
         iworkd( 84:102)= '                   '
         iworkd(103:126)= '                        '
C +
         iworke(  1:  6)= '      '
         iworke(  2: 41)= cmmt(10)
         iworke( 42: 43)= '  '
         iworke( 44: 64) = '    Creation/dynbil: '
         iworke( 65: 74) =  ddate
         iworke( 75: 75) = '/'
         iworke( 76: 83) =  ttime
C +      iworke( 44: 83)= cmmt(10)
         iworke( 84:102)= '                   '
         iworke(103:126)= '                        '
C +
         write(26,154)iworkb,iworkc,iworkd,iworke,iwofig
 154     format(a126)
C +
 152     continue
         close(unit=26)
 419     continue
        end if
C +
C +
C +--Output fct(x)
C +  -------------
C +
        if (outlev.and.(minuGE.eq.0).and.(jsecGE.eq.0)) then
         fnam( 1: 2) ='DY' 
         open (unit=27,status='unknown',file=fnam)
         rewind     27
         kw = mz 
         write(27,4194)kw,mx
 4194    format(' U DYNAMICS / LEVEL',i3,18x,'  0 H',
     .        /,'    1 --- read x|y, y|x, x,y (1,2,3)',
     .        /,i5,  ' --- number of data',
     .        /,'    6 --- number of curves',
     .        /,' (7d12.4)',
     .        /,' (7i12  )')
         write(27,4195)
     .   (xxkm(i),(dub(i,kw,ibl),ibl=1,6),i=1,mx)
 4195    format((7e12.4))
         fac = 1.
         write(27,4196)fac,fac,fac,fac,fac,fac,fac
 4196    format(7e12.4,' --- facteur')
         fac = 0.
         write(27,4197)fac,fac,fac,fac,fac,fac,fac
 4197    format(7e12.4,' --- constante')
         ifac = 1
         write(27,4198)ifac,ifac,ifac,ifac,ifac,ifac,ifac
 4198    format(7i12  ,' --- (courbe,points) = (1,-1)')
         ifac =-3
         write(27,4199)ifac,ifac,ifac,ifac,ifac,ifac,ifac
 4199    format(7i12,' --- marker : -1, -2, -3,...')
         write(27,4193)fnam
 4193    format(
     .   '   0 --- axe x logarithmique :        (oui,non) = (1,0)',/,
     .   '   0 --- axe y logarithmique :        (oui,non) = (1,0)',/,
     .   '   0 --- label axe inferieur : mois : (oui,non) = (1,0)',/,
     .   '   DISTANCE TO THE ICE MARGIN (KM)    $',/,
     .   '  CONTRIBUTION TO U WIND COMPONENT    $',/,
     .   '           (1.d-3 M.S-2)              $',/,
     .   '                                      $',/,
     .   '    n H 0 --- Fichier Suivant / Type Graphe',/,
     .   '           ',/,
     .           '         INPUT FILE     : ',a15,/,
     .           '         1 = PRESSURE GRADIENT FORCE',/,
     .           '         2 = TURBULENT DIFFUSION    ',/,
     .           '         3 = ADVECTION              ',/,
     .           '         4 = CORIOLIS          FORCE',/,
     .           '         6 = FILTERING              ')
         close(unit=27)
        end if
C +
C +
C +--Output fct(x,z)
C +  ---------------
C +
        if (outthe) then
         fnam( 1: 4) = 'thp_'
         do 4192 ibl=1,6
         fnam( 9: 9) =  ch1(ibl)
         open (unit=28,status='unknown',file=fnam)
         rewind     28
         write(28,4190) 
         write(28,4191)((dpktb(i,k, ibl)        ,i= 1, mx),k=mz,1,-1)
     .                ,((gplvDY(i,jdyn,k)*grvinv,i= 1, mx),k=mz,1,-1)
     .                , (xxkm (i)               ,i= 1, mx)
         close(unit=28)
 4192    continue
        end if
       end if
      end if
C +
      return
      end


      subroutine OUTice
 
C +------------------------------------------------------------------------+
C | MAR OUTPUT                                           14-09-2014-XF MAR |
C |   SubRoutine OUTice is used to initialize                              |
C |                            and perform Ouput of Surface Mass Balance   |
C |                            (Netcdf files)                              |
C |                                                                        |
C |   CAUTION: the Estimation of the Optical Depth codIB is obsolescent    |
C |   ^^^^^^^                                                              |
C +------------------------------------------------------------------------+
 
 
      IMPLICIT NONE
 
 
C +--Global Variables
C +  ================
 
 
      include 'MARCTR.inc'
      include 'MARphy.inc'
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
      include 'MAR_DY.inc'
      include 'MAR_RA.inc'
      include 'MAR_SL.inc'
      include 'MAR_SV.inc'
      include 'MAR_TV.inc'
      include 'MAR_HY.inc'
      include 'MAR_CA.inc'
      include 'MARsSN.inc'
      include 'MAR_IB.inc'
      include 'MARsIB.inc'
      include 'MAR_WK.inc'
      include 'MAR_IO.inc'
      include 'MARdSV.inc'
      include 'NetCDF.inc'
      include 'MAR_TE.inc'
 
C +--Local  Variables
C +  ================
 
      integer    Lfnam,     Ltit,     Luni,     Lnam,     Llnam
      PARAMETER (Lfnam= 40, Ltit= 90, Luni= 31, Lnam= 13, Llnam=50)
C +...Length of char strings
 
      integer    NdimNC_ice
      PARAMETER (NdimNC_ice = 12)
C +...Number of defined spatial dimensions (exact)
 
      integer    MXdim
      PARAMETER (MXdim = 20000)
C +...Maximum Number of all dims: recorded Time Steps
C +   and also maximum of spatial grid points for each direction.
 
      integer    MX_var
      PARAMETER (MX_var = 200)
C +...Maximum Number of Variables
C +
      integer    NattNC_ice
      PARAMETER (NattNC_ice = 1)
C +...Number of real attributes given to all variables
 
      real              yearNC_ice(MXdim)
      real              dateNC_ice(MXdim)
      real              timeNC_ice(MXdim)
      real              VALdim(MXdim,0:NdimNC_ice)
      real              tmp(3),tmp1z(mz),tmp2z(mz),tmp3,tmp4
      real              znsn1(nsno+1),znsn2(nsno+1),snwae(nsno+1)
      real              tmp1_OK,tmp2_OK,tmp3_OK,avlwc,factim
 
      real              xyllx1(mx,my,llx)   ,xyllx2(mx,my,llx)
      real              xyllx3(mx,my,llx)   ,xyllx4(mx,my,llx)
      real              xymi1  (mx,my,mi)   ,xymi2  (mx,my,mi)
      real              xymi3  (mx,my,mi)   ,xymi4  (mx,my,mi)
      real              xymi5  (mx,my,mi)   ,xymi6  (mx,my,mi)
      real              xymi7  (mx,my,mi)
      real              xynsno1(mx,my,nsno) ,xynsno2(mx,my,nsno)
      real              xynsno3(mx,my,nsno) ,xynsno4(mx,my,nsno)
      real              xynsno5(mx,my,nsno) ,xynsno6(mx,my,nsno)
      real              xynsno7(mx,my,nsno) ,xynsno8(mx,my,nsno)
      real              xynsx0 (mx,my,nsx)
      real              xynsx1 (mx,my,nsx)  ,xynsx2 (mx,my,nsx)
      real              xynsx3 (mx,my,nsx)  ,xynsx4 (mx,my,nsx)
      real              xynsx5 (mx,my,nsx)  ,xynsx6 (mx,my,nsx)
      real              xynsx7 (mx,my,nsx)  ,xymlhh (mx,my,mlhh)
      real              xynsx8 (mx,my,nsx)  ,xynsx9 (mx,my,nsx)
      real              depthsnow(nsno),depthSNo,dater
      real              pLev,pUp,pDown,pMiddle,distUp
      real              zLev,zUp,zDown,zMiddle
      real              q,qst,r,rst,rh,qsat0D

      integer           nDFdim  (0:NdimNC_ice)
      integer            NvatNC_ice(NattNC_ice)
      integer             dayNC_ice(MXdim)
      integer           monthNC_ice(MXdim),RCODE
      integer           n1000 ,n100a ,n100  ,n10_a ,n10   ,n1    ,m10
      integer           n     ,jd10  ,jd1   ,nk    ,kk    ,nx
      integer           it    ,month  ,mill  ,iu
      integer           iSBLmx(mz),jSBLmx(mz)
      integer           ID__nc_ice,itotNC_ice,NtotNC_ice
      integer           dt_ICE,nbr_dt_ICE,dt_ICE2,index,njmo
      integer           kp,kz,kUp,kDown,kMiddle
 
      character*(Lfnam) fnamNC_ice
      character*(Lnam)  NAMdim(0:NdimNC_ice)
      character*(Luni)  UNIdim(0:NdimNC_ice)
      character*(Lnam)  SdimNC_ice(4,MX_var)
      character*(Luni)  unitNC_ice(MX_var)
      character*(Lnam)  nameNC_ice(MX_var)
      character*(Llnam) lnamNC_ice(MX_var)
      character*(Ltit ) tit_NC_ice
      character*(Lnam)  NAMrat(NattNC_ice)
      character*120     tmpINP
      character*1       sector
      integer*8         date 

      common/OUTice_r/ yearNC_ice,dateNC_ice
      common/OUTice_i/ dt_ICE,dt_ICE2,nDFdim,date
      common/OUTice_c/ fnamNC_ice
 
 
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++ 1. Initialisation  ++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 
      ID__nc_ice = -1 ! NetCDF File is not open
 
      IF   (itexpe.le.1)                                          THEN
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
          wei0IB (i,j,k)    = 0.   ! Bottom Ice added
          wes_IB (i,j,k)    = 0.   ! Sublimation
          wee_IB (i,j,k)    = 0.   ! Evapotranspiration
          wem_IB (i,j,k)    = 0.   ! Melting
          wer_IB (i,j,k)    = 0.   ! Refreezing
          weu_IB (i,j,k)    = 0.   ! Run-off
        ENDDO
        ENDDO
        ENDDO
      END IF
 
 
      IF   (iterun.le.1)                                          THEN
 
 
C +--1.1 Initialization of all variables
C +  ===================================
 
        itrdIB              = 0
        dt_ICE2             = 0
        timehIB             = 0.
 
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
 
          wet_IB (i,j,k)    = 0.   ! Total Mass Balance
          wes_IB (i,j,k)    = 0.   ! Sublimation
          wes0IB (i,j,k)    = 0.
          wee_IB (i,j,k)    = 0.   ! Evapotranspiration
          wee0IB (i,j,k)    = 0.
          wem_IB (i,j,k)    = 0.   ! onlyMelting
          wem0IB (i,j,k)    = 0.
          weu_IB (i,j,k)    = 0.   ! run-off
          weu0IB (i,j,k)    = 0.
          wer_IB (i,j,k)    = 0.   ! Refreezing
          wer0IB (i,j,k)    = 0.
          wesw0IB(i,j,k)    = max(0.,SWaSNo(i,j,k))
          werr0IB(i,j)      = 0. ! max(0.,rainHY(i,j))
          wesf0IB(i,j)      = 0. ! max(0.,snowHY(i,j)+crysHY(i,j))
          wecp0IB(i,j)      = 0. ! max(0.,rainCA(i,j)+snowCA(i,j))
          wero0IB(i,j)      = max(0.,runoTV(i,j))

          if (mw .eq. 5) then
          tt_intIB(i,j,k)   = 0.   !*CL* Interpolated temperature
          qq_intIB(i,j,k)   = 0.   !*CL* Interpolated spec. hum.
          endif

          WKxy2(i,j)        = 0.
          DO n=1,nsx
           WKxy2(i,j)       =   WKxy2(i,j)
     .                      +  SLsrfl(i,j,n) * snohSN(i,j,n) / 1000.
          END DO
          wesf0IB(i,j)      = wesf0IB(i,j) - WKxy2(i,j)
          prh0IB (i,j)      = 0. 
          meh0IB (i,j)      = 0.

          swdIB  (i,j)      = 0.   ! Shortwave incoming Radiation
          swuIB  (i,j)      = 0.   ! Shortwave outgoing Radiation
          lwdIB  (i,j)      = 0.   ! Longwave  incoming Radiation
          lwuIB  (i,j)      = 0.   ! Longwave  outgoing Radiation
          swdtIB (i,j)      = 0.   ! TOA Shortwave incoming Radiation
          swutIB (i,j)      = 0.   ! TOA Shortwave outgoing Radiation
          lwutIB (i,j)      = 0.   ! TOA Longwave  outgoing Radiation
          sunIB  (i,j)      = 0.   ! Sunshine
          shfIB  (i,j)      = 0.   ! Sensible  Heat
          lhfIB  (i,j)      = 0.   ! Latent    Heat
          alIB   (i,j)      = 0.   ! Albedo
          as1_IB (i,j)      = 0.   ! Albedo
          as2_IB (i,j)      = 0.   ! Albedo
          as3_IB (i,j)      = 0.   ! Albedo
          al1IB  (i,j,k)    = 0.   ! Albedo
          al2IB  (i,j,k)    = 0.   ! Albedo
          sicIB  (i,j)      = 0.   ! Sea ice fraction
          frvIB  (i,j,k)    = 0.   ! ifratv
          stIB   (i,j)      = 0.   ! Surface Temperature
          st2IB  (i,j,k)    = 0.   ! Surface Temperature
          spIB   (i,j)      = 0.   ! Surface Pressure
          if (mw .eq. 5) then
          gradTIB(i,j)      = 0.   ! *CL* Local temp. gradient
          gradQIB(i,j)      = 0.   ! *CL* Local hum. gradient
          endif
          z0IB   (i,j,k)    = 0.   ! Roughness length for Moment.
          r0IB   (i,j,k)    = 0.   ! Roughness length for Heat
          uusIB  (i,j,k)    = 0.   ! Friction Velocity
          utsIB  (i,j,k)    = 0.   ! Sfc Pot. Tp. Turb. Flux
          uqsIB  (i,j,k)    = 0.   ! Water Vapor Flux
          ussIB  (i,j,k)    = 0.   ! Blowing Snow Flux	  	
          ccIB   (i,j)      = 0.   ! Cloud Cover
          cuIB   (i,j)      = 0.   ! Cloud Cover
          cmIB   (i,j)      = 0.   ! Cloud Cover
          cdIB   (i,j)      = 0.   ! Cloud Cover
          codIB  (i,j)      = 0.   ! Cloud Optical Depth
          qwIB   (i,j)      = 0.   ! Cloud Dropplets Concent
          qiIB   (i,j)      = 0.   ! Cloud Ice Crystals Concent.
          qsIB   (i,j)      = 0.   ! Cloud Snow Flakes Concent.
          qrIB   (i,j)      = 0.   ! Cloud Rain Concentration
         wvpIB   (i,j)      = 0.   ! Water Vapour Path
         cwpIB   (i,j)      = 0.   ! Condensed Water Path
         iwpIB   (i,j)      = 0.   ! Ice Water Path 
         pblIB   (i,j,k)    = 0.   ! Height of Boundary Layer (2)
        ENDDO
        ENDDO
        ENDDO
 
        DO kk=1,ml
        DO j=1,my
        DO i=1,mx
          mintIB (i,j,kk)   =  99. ! Minimum Temp of the Day
          maxtIB (i,j,kk)   = -99. ! Maximum Temp of the Day
          maxwIB (i,j,kk)   = 0.   ! Maximum wind of the Day
          if (mw .eq. 5) then
          mingrTIB (i,j)    = 5.   ! *CL* Maximum temp gradient the Day
          maxgrTIB (i,j)    = -5.  ! *CL* Maximum temp gradient of the Day
          mingrQIB (i,j)    = 100. ! *CL* Maximum spec hum gradient the Day
          maxgrQIB (i,j)    = -100.! *CL* Maximum spec hum gradient of the Day
          endif
          ttIB   (i,j,kk)   = 0.   ! Temperature
          uuIB   (i,j,kk)   = 0.   ! x-Wind Speed component
          vvIB   (i,j,kk)   = 0.   ! y-Wind Speed component
          wwIB   (i,j,kk)   = 0.   ! z-Wind Speed component
          uvIB   (i,j,kk)   = 0.   ! Horizontal Wind Speed
          qqIB   (i,j,kk)   = 0.   ! Specific Humidity  	
          rhIB   (i,j,kk)   = 0.   ! Relative Humidity  
          zzIB   (i,j,kk)   = 0.   ! Model Levels Height
         pddIB   (i,j)      = 0.   ! Positive degree day quantity
        END DO
        END DO
        END DO

        DO j=1,my
        DO i=1,mx
           txhIB0 (i,j)     = -99. ! Maximum Temp of the hour
           tnhIB0 (i,j)     =  99. ! Minimum Temp of the hour
        END DO
        END DO

        DO kp=1,mp
        DO j=1,my
        DO i=1,mx
          nbpIB   (i,j,kp)   = 0   ! Count valid data on pressure levels
          ttpIB   (i,j,kp)   = 0.  ! Temperature
          uupIB   (i,j,kp)   = 0.  ! x-Wind Speed component
          vvpIB   (i,j,kp)   = 0.  ! y-Wind Speed component
          uvpIB   (i,j,kp)   = 0.  ! Horizontal Wind Speed
          qqpIB   (i,j,kp)   = 0.  ! Specific Humidity  	
          zzpIB   (i,j,kp)   = 0.  ! Model Levels Height
        END DO
        END DO
        END DO

        DO kz=1,mztq
        DO j=1,my
        DO i=1,mx
          ttzIB   (i,j,kz)   = 0.  ! Temperature
          qqzIB   (i,j,kz)   = 0.  ! Specific Humidity  	
        END DO
        END DO
        END DO

        DO kz=1,mzuv
        DO j=1,my
        DO i=1,mx
          uuzIB   (i,j,kz)   = 0.  ! x-Wind Speed component
          vvzIB   (i,j,kz)   = 0.  ! y-Wind Speed component	
          uvzIB   (i,j,kz)   = 0.  ! Horizontal Wind Speed
        END DO
        END DO
        END DO

        DO kk=1,llx
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
          sltIB (i,j,k,kk)  = 0    ! Soil Temperature
          slqIB (i,j,k,kk)  = 0    ! Soil Humidity Content
          slqcIB(i,j,k)     = 0    ! Soil Humidity Content
        END DO
        END DO
        END DO
        END DO
 
        DO kk=1,mi
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
          g1IB   (i,j,k,kk) = 0.   ! Average g1
          g2IB   (i,j,k,kk) = 0.   ! Average g2
          roIB   (i,j,k,kk) = 0.   ! Average ro
          tiIB   (i,j,k,kk) = 0.   ! Average ti
          waIB   (i,j,k,kk) = 0.   ! Avegage wa
        END DO
        END DO
        END DO
        END DO
 
 
C +--1.2 Output Netcdf Initialisation
C +  ================================
 
        n1000 = 1 +     iyrrGE/1000
        n100a =     mod(iyrrGE,1000)
        n100  = 1 +     n100a /100
        n10_a =     mod(n100a ,100)
        n10   = 1 +     n10_a /10
        n1    = 1 + mod(n10_a ,10)
        m10   = 1 +     mmarGE/10
        m1    = 1 + mod(mmarGE,10)
        jd10  = 1 +     jdarGE/10
        jd1   = 1 + mod(jdarGE,10)
 
 
C +--1.2.1 Output File Label
C +  -----------------------
 
        fnamNC_ice = 'ICE.'
     .            // labnum(n1000) // labnum(n100)
     .            // labnum(  n10) // labnum(  n1)
     .            // labnum(  m10) // labnum(  m1)
     .            // labnum( jd10) // labnum( jd1)
     .            // '.' // explIO
     .            // '.nc    '
 
 
C +--1.2.3 Output Title
C +  ------------------
 
        tit_NC_ice = 'ICE'
     .            // ' - Exp: ' // explIO
     .            // ' - '
     .            // labnum(n1000) // labnum(n100)
     .            // labnum(  n10) // labnum(  n1)
     .            // labnum(  m10) // labnum(  m1)
     .            // labnum( jd10) // labnum( jd1)
 
 
C +--1.2.4 Time Variable (hour)
C +  --------------------------
 
            dt_ICE = 0
        nbr_dt_ICE = nterun*dt*OutdyIB/86400           ! Nbr of Outputs
 
        nDFdim(0)  = nbr_dt_ICE
c #UL   nDFdim(0)  = 0
        NAMdim(0)  = 'time'
        UNIdim(0)  = 'HOURS since 1901-01-15 00:00:00'
 
        IF (nbr_dt_ICE.gt.MXdim)
     &  STOP '*** OUTice - ERROR : MXdim to low ***'
 
        date   = (351      +(iyrrGE  -1902) *365       ! Nb Days before iyrrGE
     .                     +(iyrrGE  -1901) /  4       ! Nb Leap Years
     .                     + njyrGE(mmarGE)            ! Nb Days before mmarGE
     .                     + njybGE(mmarGE)            ! (including Leap Day)
     .                     * max(0,1-mod(iyrrGE,4))    !
     .                     + jdarGE     -1      )*  24 !
     .                     + jhurGE                    !
     .                     + (minuGE *60+jsecGE )/3600.!
 
        DO it = 1,nbr_dt_ICE
              timeNC_ice(it)   = jhurGE    + minuGE/  60.0 ! Starting Time
     .                         + jsecGE/3600.0
     .                         + (it-1) * 24.0 !
     .                         / real(max(OutdyIB,1))      !
              VALdim(it,0)     = date   + (it-1) * 24.0    !
     .                         / real(max(OutdyIB,1))      ! values of dim.time
              dateNC_ice(it)   =          timeNC_ice(it)   ! Time Variabl
              dayNC_ice(it)    = jdarGE + timeNC_ice(it)   !
     .                         / 24.0
        END DO
 
              month            =  mmarGE
              mill             =  iyrrGE
        DO it = 1,nbr_dt_ICE
          IF     (month        .eq.2           .AND.
     .        mod(mill,4)      .eq.0           )                  THEN
                  njmo         =  njmoGE(month) + 1
          ELSE
                  njmo         =  njmoGE(month)
          END IF
          IF   (dayNC_ice(it)  .gt.njmo        )                  THEN
            DO iu=it,nbr_dt_ICE
                dayNC_ice(iu)  =  dayNC_ice(iu) - njmo
            END DO
              month            =  month + 1
            IF (month.gt.12)                                      THEN
              month            =          1
              mill             =  mill  + 1
            END IF
          END IF
              monthNC_ice(it)  =  month
              yearNC_ice(it)   =  mill
 
          IF (dateNC_ice(it)   .gt.24.0-epsi)                     THEN
            DO iu=it,nbr_dt_ICE
              dateNC_ice(iu)   = mod(dateNC_ice(iu),24.0)
            END DO
          END IF
        END DO
 
        DO it = 1,nbr_dt_ICE
              dateNC_ice(it)   =        dateNC_ice(it)
     .                         + 1.d+2 *dayNC_ice(it)
     .                         + 1.d+4 *monthNC_ice(it)
     .                         + 1.d+6 *yearNC_ice(it)
        END DO
 
 
C +--1.2.5 Define horizontal spatial dimensions
C +  ------------------------------------------
 
        DO i = 1, mx
          VALdim(i,1) = xxkm(i)
        END DO
          nDFdim(1)= mx
          NAMdim(1)= 'x'
          UNIdim(1)= 'km'
 
        DO j = 1, my
          VALdim(j,2) = yykm(j)
        END DO
          nDFdim(2)= my
          NAMdim(2)= 'y'
          UNIdim(2)= 'km'
 
        DO k = 1, nsx
          VALdim(k,3) = k
        END DO
          nDFdim(3)= nsx
          NAMdim(3)= 'sector'
          UNIdim(3)= 'level'
 
        DO k = 1, ml
          VALdim(k,4) = sigma(mz-k+1)
        END DO
          nDFdim(4)= ml
          NAMdim(4)= 'atmlay'
          UNIdim(4)= 'sigma_level'
 
        DO k = 1, mlhh
          VALdim(k,5) = k*(24./real(mlhh))
        END DO
          nDFdim(5)= mlhh
          NAMdim(5)= 'atmxh'
          UNIdim(5)= 'hours'
 
        DO k = 1, mi
          VALdim(k,6) = OutshIB(k)
        END DO
          nDFdim(6)= mi
          NAMdim(6)= 'outlay'
          UNIdim(6)= 'm'
 
        DO k = 1, llx
          VALdim(k,7) = k
        END DO
          nDFdim(7)= llx
          NAMdim(7)= 'sollay'
          UNIdim(7)= 'layer'
 
        DO k = 1, nsno
          VALdim(k,8) = k
        END DO
          nDFdim(8)= nsno
          NAMdim(8)= 'snolay'
          UNIdim(8)= 'layer'
 
         DO k = 1, mp
           VALdim(k,9) = OutPLevIB(k)
         END DO
           nDFdim(9)= mp
           NAMdim(9)= 'plev'
           UNIdim(9)= 'hPa'
 
         DO k = 1, mztq
           VALdim(k,10) = OutZTQLevIB(k)
         END DO
           nDFdim(10)= mztq
           NAMdim(10)= 'ztqlev'
           UNIdim(10)= 'm'
 
         DO k = 1, mzuv
           VALdim(k,11) = OutZUVLevIB(k)
         END DO
           nDFdim(11)= mzuv
           NAMdim(11)= 'zuvlev'
           UNIdim(11)= 'm'

         if( mlb>ml) then
          print *,"ERROR mlb > ml"
          stop
         endif 

         DO k = 1, mlb
           VALdim(k,12) = sigma(mz-k+1)
         END DO
           nDFdim(12)= mlb
           NAMdim(12)= 'blev'
           UNIdim(12)= 'sigma_level'

C +--1.2.6 Variable's Choice (Table ICEvou.dat)
C +  ------------------------------------------
 
        OPEN(unit=10,status='unknown',file='ICEvou.dat')
 
        itotNC_ice = 0
 980    CONTINUE
        READ (10,'(A120)',end=990) tmpINP
        IF (tmpINP(1:4).eq.'    ')                                THEN
          itotNC_ice = itotNC_ice + 1
          READ (tmpINP,'(4x,5A9,A12,A50)')
     .          nameNC_ice(itotNC_ice)  , ! Name
     .          SdimNC_ice(1,itotNC_ice), ! Names of Selected Dimensions
     .          SdimNC_ice(2,itotNC_ice), ! (max.4/variable)
     .          SdimNC_ice(3,itotNC_ice),
     .          SdimNC_ice(4,itotNC_ice),
     .          unitNC_ice(itotNC_ice)  , ! Units
     .          lnamNC_ice(itotNC_ice)    ! Description of the variable
 
        ENDIF
        GOTO 980
 990    CONTINUE
 
        CLOSE(unit=10)
 
        NtotNC_ice = itotNC_ice                 ! Total number of variables
C +                                             ! writen     in NetCDF file.
 
 
C +--1.2.7 List of NetCDF attributes given to all variables
C +  ------------------------------------------------------
 
        NAMrat    (1)          = 'actual_range' ! "actual_range" is (min,max)
        NvatNC_ice(1)          = 2              ! of all data for each variable
 
        if (NattNC_ice .eq. 2) then
          NAMrat    (NattNC_ice) = '[var]_range'
          NvatNC_ice(NattNC_ice) = 2
        endif
 
 
C +--1.2.8 Automatic Generation of the NetCDF File Structure
C +  -------------------------------------------------------
 
C +     **************
        CALL UNscreate (fnamNC_ice,tit_NC_ice,
     .                  NdimNC_ice,nDFdim    , MXdim     ,
     .                  NAMdim    ,UNIdim    , VALdim    ,
     .                  MX_var    ,NtotNC_ice, nameNC_ice,
     .                  SdimNC_ice,unitNC_ice, lnamNC_ice,
     .                  NattNC_ice,NAMrat    , NvatNC_ice,
     .                  ID__nc_ice)
C +     **************
 
 
C +--1.2.9 Computation of inital mass balance variables (at itexpe=0)
C +  ----------------------------------------------------------------
 
           tmp2_OK               = 1.0
        DO j=jp11,my1
        DO i=ip11,mx1
        DO k=1   ,nsx
           tmp2_OK               = min(tmp2_OK,
     .                             max(zero,sign(unun,-mb0IB(i,j,k))))
        END DO
        END DO
        END DO
 
        DO j=jp11,my1
        DO i=ip11,mx1
        DO k=1   ,nsx
          IF (    nssSNo(i,j,k).ge.1)                               THEN
            znsn1(nssSNo(i,j,k)) = dzsSNo(i,j,k,nssSNo(i,j,k))
            snwae(nssSNo(i,j,k)) = rosSNo(i,j,k,nssSNo(i,j,k))
     .                           * dzsSNo(i,j,k,nssSNo(i,j,k))
     .                           * 1.e3 / ro_Wat
     .                           * (1. + 0.*wasSNo(i,j,k,nssSNo(i,j,k)))
     .                           + SWaSNo(i,j,k)
            DO nk=nssSNo(i,j,k)-1,1,-1
            znsn1(nk)            = dzsSNo(i,j,k,nk) + znsn1 (      nk+1)
            snwae(nk)            = rosSNo(i,j,k,nk) * dzsSNo(i,j,k,nk  )
     .                           * 1.e3 / ro_Wat
     .                           * (1 + 0.*wasSNo(i,j,k,nk))
     .                           + snwae (nk+1)
            END DO
            tmp1_OK              = max(0  ,sign(1  ,nisSNo(i,j,k)-1))
            mb0IB(i,j,k)         =        tmp2_OK
     .              * (snwae (1) - snwae (nisSNo(i,j,k)+1) * tmp1_OK)
     .                           +    (1.-tmp2_OK) * mb0IB(i,j,k)
            zn0IB(i,j,k)         =        tmp2_OK
     .              * (znsn1 (1) - znsn1 (nisSNo(i,j,k)+1) * tmp1_OK)
     .                           +    (1.-tmp2_OK) * zn0IB(i,j,k)
C +...      tmp1_OK              = 1 if ice
C +         tmp2_OK              = 0 if mb0IB is initialised
            wet_IB(i,j,k)        = snwae(1)
            wet0IB(i,j,k)        = snwae(1)
            S_m_IB(i,j,k)        =
     .                (snwae (1) - snwae (nisSNo(i,j,k)+1) * tmp1_OK)
            S_h_IB(i,j,k)        =
     .                (znsn1 (1) - znsn1 (nisSNo(i,j,k)+1) * tmp1_OK)
            SIm_IB(i,j,k)        = snwae(1)
            SIh_IB(i,j,k)        = znsn1(1)
          ELSE
            mb0IB (i,j,k)        = 0.
            zn0IB (i,j,k)        = 0.
            wet_IB(i,j,k)        = 0.
            wet0IB(i,j,k)        = 0.
            S_m_IB(i,j,k)        = 0.
            S_h_IB(i,j,k)        = 0.
            SIm_IB(i,j,k)        = 0.
            SIh_IB(i,j,k)        = 0.
          END IF
            xynsx1(i,j,k)        = 1.  !  1.  above 1st superimposed Ice Layer
            SSh_IB(i,j,k)        = 0.  !  H (*  without superimposed Ice)
        END DO
        END DO
        END DO
 
        DO kk=nsno,1,-1
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
            xynsx1(i,j,k) =                          xynsx1(i,j,k)
     .                    * max(zero,sign(unun,850. -rosSNo(i,j,k,kk)))
            SSh_IB(i,j,k) = dzsSNo(i,j,k,kk)        *xynsx1(i,j,k)
     .                    +                          SSh_IB(i,j,k)
        END DO
        END DO
        END DO
        END DO
 
 
C +--1.2.10 Write Time - Constants
C +  -----------------------------

        DO j=1,my
        DO i=1,mx
          Wkxy1(i,j)   =  GElonh(i,j) * 15.d0  ! Hour->degrees
          WKxy2(i,j)   =  GElatr(i,j) / degrad ! rad ->degree
          WKxy3(i,j)   =  real(mskSNo(i,j,1))  ! REAL type
          DO k=1,nsx    
          xynsx2(i,j,k)=  real(mskSNo(i,j,k))
          END DO
          WKxy4(i,j)   =  real(isolTV(i,j))    ! REAL type	
          WKxy5(i,j)   =  real(isolSL(i,j))    ! REAL type
        END DO
        END DO
 
C +     ************
        CALL UNwrite (ID__nc_ice,'LON', 1, mx, my,   1, Wkxy1)
        CALL UNwrite (ID__nc_ice,'LAT', 1, mx, my,   1, Wkxy2)
        CALL UNwrite (ID__nc_ice,'SH',  1, mx, my,   1, sh)
        CALL UNwrite (ID__nc_ice,'SLO', 1, mx, my,   1, slopGE)

        if(mw.ne.5) then
        CALL UNwrite (ID__nc_ice,'MSK', 1, mx, my,   1, WKxy3)
        else
        CALL UNwrite (ID__nc_ice,'MSK', 1, mx, my, nsx, xynsx2)
        endif

        CALL UNwrite (ID__nc_ice,'SOL', 1, mx, my,   1, Wkxy4)
        CALL UNwrite (ID__nc_ice,'SRF', 1, mx, my,   1, Wkxy5)
C +     ************

        DO k=1,min(nvx,nsx)
        DO j=1,my
        DO i=1,mx
          Wkxy1(i,j)    = real(czenGE(i,j))
          WKxy2(i,j)    = real(AlbSTV(i,j))
          xynsx1(i,j,k) = real(ivegTV(i,j,k))
          xynsx2(i,j,k) = real(ifraTV(i,j,k))
        END DO
        END DO
        END DO

        DO j=jp11,my1
        DO i=ip11,mx1
        DO k=1,nsx
           slqmIB(i,j,k) =0 
          DO kk=1,llx
           slqmIB(i,j,k) = EtadSV(isolTV(i,j))*1000. * dz_dSV(-llx+kk)
     .                                               + slqmIB(i,j,k) 
          ENDDO
        ENDDO
        ENDDO
        ENDDO
 
C +     ************
        CALL UNwrite (ID__nc_ice,'CZ' , 1, mx, my, 1  , Wkxy1)
        CALL UNwrite (ID__nc_ice,'SAL', 1, mx, my, 1  , WKxy2)
        CALL UNwrite (ID__nc_ice,'VEG', 1, mx, my, nsx, xynsx1)
        CALL UNwrite (ID__nc_ice,'FRV', 1, mx, my, nsx, xynsx2)
        CALL UNwrite (ID__nc_ice,'SLQM',1, mx, my, nsx, slqmIB)
C +     ************
 
        date      = (351+(iyrrGE  -1902) *365  ! Nb Days before iyrrGE
     .            +(iyrrGE  -1901) /  4        ! Nb Leap Years
     .            + njyrGE(mmarGE)             ! Nb Days before mmarGE
     .            + njybGE(mmarGE)             ! (including Leap Day)
     .            * max(0,1-mod(iyrrGE,4))     !
     .            + jdarGE -1 )*  24           !
     .            + jhurGE                     !
     .            + (0 *60 +0)/3600            !

       print *,"OUTice Initialization BEGIN"

       write(6,399) OutdyIB
 399   format(" OUTice: nbr of outputs by day:",i3) 

       write(6,400) mz,mz-ml
 400   format(" OUTice:     sigma levels kept:",i3,' => ',i3)

       write(6,401) int(24./real(mlhh)*60.)
 401   format(" OUTice:  x-hourly outputs every:",i5," minutes") 

       write(6,402) (int(OutPLevIB(i)),i=mp,1,-1)
 402   format(" OUTice:       Pressure levels:",20i4)

       write(6,403) (int(OutZTQLevIB(i)),i=1,mztq)
 403   format(" OUTice:         Height levels:",20i4)

       write(6,404) (OutshIB(i),i=1,mi)
 404   format(" OUTice:    Snow height levels:",30f5.1)

       print *,"OUTice Initialization END"

 
      END IF ! Initialization
 
 
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++ 2. Every Time  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
C +--2.1 Re-initialization
C +  =====================
 
      IF (dt_ICE2.eq.-1)                                           THEN
 
        dt_ICE2             = 0
        timehIB             = 0.
 
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
 
          swdIB  (i,j)      = 0.   ! Shortwave incoming Radiation
          swuIB  (i,j)      = 0.   ! Shortwave outgoing Radiation
          lwdIB  (i,j)      = 0.   ! Longwave  incoming Radiation
          lwuIB  (i,j)      = 0.   ! Longwave  outgoing Radiation
          swdtIB (i,j)      = 0.   ! TOA Shortwave incoming Radiation
          swutIB (i,j)      = 0.   ! TOA Shortwave outgoing Radiation
          lwutIB (i,j)      = 0.   ! TOA Longwave  outgoing Radiation
          sunIB  (i,j)      = 0.   ! Sunshine
          shfIB  (i,j)      = 0.   ! Sensible  Heat
          lhfIB  (i,j)      = 0.   ! Latent    Heat
          alIB   (i,j)      = 0.   ! Albedo
          as1_IB (i,j)      = 0.   ! Albedo
          as2_IB (i,j)      = 0.   ! Albedo
          as3_IB (i,j)      = 0.   ! Albedo
          al1IB  (i,j,k)    = 0.   ! Albedo
          al2IB  (i,j,k)    = 0.   ! Albedo
          sicIB  (i,j)      = 0.   ! Sea ice fraction
          frvIB  (i,j,k)    = 0.   ! ifratv
          stIB   (i,j)      = 0.   ! Surface Temperature
          st2IB  (i,j,k)    = 0.   ! Surface Temperature
          spIB   (i,j)      = 0.   ! Surface Pressure

          if (mw .eq. 5) then
          gradTIB(i,j)      = 0.   ! *CL* local temp. gradient
          gradQIB(i,j)      = 0.   ! *CL* local hum. gradient
         tt_intIB(i,j,k)    = 0.   ! *CL* Interpolated temperature
         qq_intIB(i,j,k)    = 0.   ! *CL* Interpolated spec. hum.

          endif
          z0IB   (i,j,k)    = 0.   ! Roughness length for Moment.
          r0IB   (i,j,k)    = 0.   ! Roughness length for Heat
          uusIB  (i,j,k)    = 0.   ! Friction Velocity
          utsIB  (i,j,k)    = 0.   ! Sfc Pot. Tp. Turb. Flux
          uqsIB  (i,j,k)    = 0.   ! Water Vapor Flux
          ussIB  (i,j,k)    = 0.   ! Blowing Snow Flux	  	
          ccIB   (i,j)      = 0.   ! Cloud Cover
          cuIB   (i,j)      = 0.   ! Cloud Cover
          cmIB   (i,j)      = 0.   ! Cloud Cover
          cdIB   (i,j)      = 0.   ! Cloud Cover
          codIB  (i,j)      = 0.   ! Cloud Optical Depth
          qwIB   (i,j)      = 0.   ! Cloud Dropplets Concent
          qiIB   (i,j)      = 0.   ! Cloud Ice Crystals Concent.
          qsIB   (i,j)      = 0.   ! Cloud Snow Flakes Concent.
          qrIB   (i,j)      = 0.   ! Cloud Rain Concentration
         wvpIB   (i,j)      = 0.   ! Water Vapour Path
         cwpIB   (i,j)      = 0.   ! Condensed Water Path
         iwpIB   (i,j)      = 0.   ! Ice Water Path
         pblIB   (i,j,k)    = 0.   !  Height of Boundary Layer (2)
        ENDDO
        ENDDO
        ENDDO
 
        DO kk=1,ml
        DO j=1,my
        DO i=1,mx
          mintIB (i,j,kk)   =  60. ! Minimum Temp of the Day
          maxtIB (i,j,kk)   = -60. ! Maximum Temp of the Day
          maxwIB (i,j,kk)   = 0.   ! Maximum Wind of the Day
          if (mw .eq. 5) then
          mingrTIB (i,j)    = 5.   ! *CL* Maximum temp gradient the Day
          maxgrTIB (i,j)    = -5.  ! *CL* Maximum temp gradient of the Day
          mingrQIB (i,j)    = 100. ! *CL* Maximum spec hum gradient the Day
          maxgrQIB (i,j)    = -100.! *CL* Maximum spec hum gradient of the Day
          endif
          ttIB   (i,j,kk)   = 0.   ! Temperature
          uuIB   (i,j,kk)   = 0.   ! x-Wind Speed component
          vvIB   (i,j,kk)   = 0.   ! y-Wind Speed component
          wwIB   (i,j,kk)   = 0.   ! w-Wind Speed component
          uvIB   (i,j,kk)   = 0.   ! Horizontal Wind Speed
          qqIB   (i,j,kk)   = 0.   ! Specific Humidity  	
          rhIB   (i,j,kk)   = 0.   ! Relative Humidity  
          zzIB   (i,j,kk)   = 0.   ! Model Levels Height
         pddIB   (i,j)      = 0.   ! Positive degree day quantity
        END DO
        END DO
        END DO

        DO j=1,my
        DO i=1,mx
           tnhIB0 (i,j)     =  99. ! Minimum Temp of the hour
           txhIB0 (i,j)     = -99. ! Maximum Temp of the hour
        END DO
        END DO
 
        DO kp=1,mp
        DO j=1,my
        DO i=1,mx
          nbpIB   (i,j,kp)   = 0   ! Count valid data on pressure levels
          ttpIB   (i,j,kp)   = 0.  ! Temperature
          uupIB   (i,j,kp)   = 0.  ! x-Wind Speed component
          vvpIB   (i,j,kp)   = 0.  ! y-Wind Speed component
          uvpIB   (i,j,kp)   = 0.  ! Horizontal Wind Speed
          qqpIB   (i,j,kp)   = 0.  ! Specific Humidity  	
          zzpIB   (i,j,kp)   = 0.  ! Model Levels Height
        END DO
        END DO
        END DO

        DO kz=1,mztq
        DO j=1,my
        DO i=1,mx
          ttzIB   (i,j,kz)   = 0.  ! Temperature
          qqzIB   (i,j,kz)   = 0.  ! Specific Humidity  	
        END DO
        END DO
        END DO

        DO kz=1,mzuv
        DO j=1,my
        DO i=1,mx
          uuzIB   (i,j,kz)   = 0.  ! x-Wind Speed component
          vvzIB   (i,j,kz)   = 0.  ! y-Wind Speed component	
          uvzIB   (i,j,kz)   = 0.  ! Horizontal Wind Speed
        END DO
        END DO
        END DO
 
        DO kk=1,llx
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
          sltIB (i,j,k,kk)  = 0    ! Soil Temperature
          slqIB (i,j,k,kk)  = 0    ! Soil Humidity Content
          slqcIB(i,j,k)     = 0    ! Soil Humidity Content
        END DO
        END DO
        END DO
        END DO
 
        DO kk=1,mi
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
          g1IB   (i,j,k,kk) = 0.   ! Average g1
          g2IB   (i,j,k,kk) = 0.   ! Average g2
          roIB   (i,j,k,kk) = 0.   ! Average ro
          tiIB   (i,j,k,kk) = 0.   ! Average ti
          waIB   (i,j,k,kk) = 0.   ! Avegage wa
        END DO
        END DO
        END DO
        END DO
      END IF
 
 
C +--2.2 Putting Values in Matrices
C +  ==============================
 
      dt_ICE2=dt_ICE2+1
 
C +--2.2.0 X-hourly variables
C +  ------------------------

      DO j=1,my
      DO i=1,mx

          tnhIB0(i,j)  = min(tairDY(i,j,mz)-TfSnow,tnhIB0(i,j))
          txhIB0(i,j)  = max(tairDY(i,j,mz)-TfSnow,txhIB0(i,j))

      ENDDO
      ENDDO
 
      do kk=1,mlhh
      if(iterun>10.and.timehIB(kk)==0.and.(
     .   jhurGE*3600+minuGE*60+jsecGE>=(kk)*86400./real(mlhh) .or.
     .  (jhurGE*3600+minuGE*60+jsecGE<=dt.and.kk==mlhh))) then 
        timehIB(kk)     = jhurGE+real(minuGE)/100.+real(jsecGE)/10000.
        print *,"OUTice x-hourly outputs",kk,timehIB(kk)
        do j=1,my
        do i=1,mx
            sphIB(i,j,kk)  = pstDY(i,j) * 10.
            sthIB(i,j,kk)  = tairsl(i,j)    - TfSnow
            tthIB(i,j,kk)  = tairDY(i,j,mz) - TfSnow
            txhIB(i,j,kk)  = txhIB0(i,j) ; txhIB0(i,j)=-99.
            tnhIB(i,j,kk)  = tnhIB0(i,j) ; tnhIB0(i,j)= 99.
            qqhIB(i,j,kk)  = qvDY(i,j,mz) * 1000.
            uuhIB(i,j,kk)  = uairDY(i,j,mz) 
            vvhIB(i,j,kk)  = vairDY(i,j,mz) 
            swdhIB(i,j,kk) = RAdsol(i,j)
            lwdhIB(i,j,kk) = RAd_ir(i,j)
            lwuhIB(i,j,kk) = firmSL(i,j)
            shfhIB(i,j,kk) = hsenSL(i,j)
            lhfhIB(i,j,kk) = hlatSL(i,j)
            alhIB(i,j,kk)  = albeSL(i,j) 
            clhIB(i,j,kk)  = cld_SL(i,j)
            snfhIB(i,j,kk) = (snowHY(i,j)+crysHY(i,j))*1000.
     .                     - snfh0IB(i,j)
            snfh0IB(i,j)   = (snowHY(i,j)+crysHY(i,j))*1000.
            prhIB(i,j,kk)  = (rainHY(i,j)+snowHY(i,j)+crysHY(i,j))
     .                     * 1000. - prh0IB(i,j)
            prh0IB(i,j)    = (rainHY(i,j)+snowHY(i,j)+crysHY(i,j))
     .                     * 1000.
            mehIB(i,j,kk)  = (-1.)*wem_IB(i,j,1) - meh0IB(i,j)
            meh0IB(i,j)    = (-1.)*wem_IB(i,j,1)
            lwc1mhIB(i,j,kk) = 0.
            lwc2mhIB(i,j,kk) = 0.
            nx = 1 ! Sector 1
            nk = max(1,nssSNo(i,j,nx))
            depthSNo = dzsSNo(i,j,nx,nk)/2.
            do while(depthSNo.le.1. .and. nk.gt.1)
                lwc1mhIB(i,j,kk) = lwc1mhIB(i,j,kk) + 
     .                          wasSNo(i,j,nx,nk) * 
     .                          rosSNo(i,j,nx,nk) * dzsSNo(i,j,nx,nk)
                depthSNo = depthSNo + 
     .                   (dzsSNo(i,j,nx,nk) + dzsSNo(i,j,nx,nk-1))/2.
                nk = nk - 1
            enddo
            nk = max(1,nssSNo(i,j,nx))
            depthSNo = dzsSNo(i,j,nx,nk)/2.
            do while(depthSNo.le.2. .and. nk.gt.1)
                lwc2mhIB(i,j,kk) = lwc2mhIB(i,j,kk) + 
     .                          wasSNo(i,j,nx,nk) * 
     .                          rosSNo(i,j,nx,nk) * dzsSNo(i,j,nx,nk)
                depthSNo = depthSNo + 
     .                   (dzsSNo(i,j,nx,nk) + dzsSNo(i,j,nx,nk-1))/2.
                nk = nk - 1
            enddo
        enddo
        enddo
      endif
      enddo 

 
C +--2.2.1 Atmospheric variables
C +  ---------------------------
 
      if(nsx<2) then
       print *,"mw <2!!!!"  
       stop
      endif

      DO j=1,my
      DO i=1,mx


        DO kk=1,ml

          q         = qvDY(i,j,mz-kk+1)
          qst       = qsat0D(tairDY(i,j,mz-kk+1),
     .                  sigma(mz-kk+1),pstDY(i,j),ptopDY,1)

          r         = q   / max(epsi,1.-q)
          rst       = qst / max(epsi,1.-qst)

          rh        =  (r/(0.622+r))
     .              / max(epsi,(rst/(0.622+rst))) * 100.
          rh        = max(0.,min(100.,rh))
     

          mintIB(i,j,kk)  = min(tairDY(i,j,mz-kk+1)-TfSnow,
     .                          mintIB(i,j,kk))
          maxtIB(i,j,kk)  = max(tairDY(i,j,mz-kk+1)-TfSnow,
     .                          maxtIB(i,j,kk))

          maxwIB(i,j,kk)  = max(
     .          (uairDY(i,j,mz-kk+1)**2+vairDY(i,j,mz-kk+1)**2)**0.5,
     .                          maxwIB(i,j,kk))
          if (mw .eq. 5) then
          maxgrTIB(i,j)   = max(gradTM(i,j),maxgrTIB(i,j))       ! *CL*
          mingrTIB(i,j)   = min(gradTM(i,j),mingrTIB(i,j))       ! *CL*
          maxgrQIB(i,j)   = max(gradQM(i,j),maxgrQIB(i,j))       ! *CL*
          mingrQIB(i,j)   = min(gradQM(i,j),mingrQIB(i,j))       ! *CL*
          endif
          ttIB  (i,j,kk)  = ttIB (i,j,kk)+ tairDY(i,j,mz-kk+1)-TfSnow
          uuIB  (i,j,kk)  = uuIB (i,j,kk)+ uairDY(i,j,mz-kk+1)
          vvIB  (i,j,kk)  = vvIB (i,j,kk)+ vairDY(i,j,mz-kk+1)
          uvIB  (i,j,kk)  = uvIB (i,j,kk)+                          
     .          (uairDY(i,j,mz-kk+1)**2+vairDY(i,j,mz-kk+1)**2)**0.5
          wwIB  (i,j,kk)  = wwIB (i,j,kk)+ wairDY(i,j,mz-kk+1)
          qqIB  (i,j,kk)  = qqIB (i,j,kk)+   qvDY(i,j,mz-kk+1)*1000.
          rhIB  (i,j,kk)  = rhIB (i,j,kk)+   rh
          zzIB  (i,j,kk)  = zzIB (i,j,kk)+ gplvDY(i,j,mz-kk+1)*grvinv

       ENDDO

        DO kk=1,mz
          tmp1z(kk)       = ect_TE(i,j,kk)
          tmp2z(kk)       = gplvDY(i,j,kk)*grvinv - sh(i,j)
       ENDDO

C +    ************     
       call PBLtop (tmp1z,tmp2z,tmp3,tmp4)
C +    ************

         pblIB (i,j,1)    = pblIB (i,j,1) + tmp3
         pblIB (i,j,2)    = pblIB (i,j,2) + tmp4

          spIB (i,j)      = spIB (i,j) + pstDY(i,j)*10.
 
          if (mw .eq. 5) then
          gradTIB (i,j)   = gradTIB (i,j) + gradTM(i,j) !*CL*
          gradQIB (i,j)   = gradQIB (i,j) + gradQM(i,j) !*CL*
          DO k=1,nsx
          tt_intIB(i,j,k) = tt_intIB(i,j,k)-TfSnow  + tairDY_int(i,j,k) !*CL*
          qq_intIB(i,j,k) = qq_intIB(i,j,k)+ qvDY_int(i,j,k)*1000.      !*CL*
          ENDDO
          endif

      END DO
      END DO
 
C +--2.2.3 Atmospheric variables on pressure levels
C +  ----------------------------------------------
      
      DO j=1,my
      DO i=1,mx
          pDown = (pstDY(i,j) * sigma(mz) + ptopDY) * 10
          DO kp=1,mp
              pLev=OutPLevIB(kp)
              IF (pLev.le.pDown) THEN
                  nbpIB(i,j,kp) = nbpIB(i,j,kp) + 1
                  kUp = 1
                  kDown = mz
                  DO WHILE (kDown-kUp.gt.1)
                      kMiddle = (kDown + kUp) / 2
                      pMiddle = (pstDY(i,j) * sigma(kMiddle)  +
     .                           ptopDY) * 10
                      IF (pMiddle.ge.pLev) THEN
                          kDown = kMiddle
                      ELSE
                          kUp = kMiddle
                      ENDIF
                  ENDDO
                  pUp    = (pstDY(i,j) * sigma(kUp)   + ptopDY) * 10
                  pDown  = (pstDY(i,j) * sigma(kDown) + ptopDY) * 10
                  distUp = (pLev - pUp) / (pDown - pUp)
                  tairDYp(i,j,kp) = distUp * tairDY(i,j,kDown) +
     .                              (1-distUp) * tairDY(i,j,kUp)
                  qvDYp(i,j,kp) = distUp * qvDY(i,j,kDown) +
     .                            (1-distUp) * qvDY(i,j,kUp)
                  gplvDYp(i,j,kp) = distUp * gplvDY(i,j,kDown) +
     .                            (1-distUp) * gplvDY(i,j,kUp)
                  uairDYp(i,j,kp) = distUp * uairDY(i,j,kDown) +
     .                              (1-distUp) * uairDY(i,j,kUp)
                  vairDYp(i,j,kp) = distUp * vairDY(i,j,kDown) +
     .                              (1-distUp) * vairDY(i,j,kUp)
                  ! sum for the output
                  ttpIB(i,j,kp) = ttpIB(i,j,kp) +
     .                            tairDYp(i,j,kp) - TfSnow
                  qqpIB(i,j,kp) = qqpIB(i,j,kp) +
     .                            qvDYp(i,j,kp) * 1000.
                  zzpIB(i,j,kp) = zzpIB(i,j,kp) +
     .                            gplvDYp(i,j,kp) * grvinv
                  uupIB(i,j,kp) = uupIB(i,j,kp) + uairDYp(i,j,kp)
                  vvpIB(i,j,kp) = vvpIB(i,j,kp) + vairDYp(i,j,kp)
                  uvpIB(i,j,kp) = uvpIB(i,j,kp) +
     .              (uairDYp(i,j,kp)**2 + vairDY(i,j,kp)**2)**0.5
              ENDIF
          ENDDO
      END DO
      END DO


C +--2.2.4 Atmospheric variables on heigth levels (z)
C +  ------------------------------------------------
      
C +--2.2.4.1 Temperature
      DO j=1,my
      DO i=1,mx
          zDown = gplvDY(i,j,mz) * grvinv - sh(i,j)
          DO kz=1,mztq
              zLev= OutZTQLevIB(kz)
              IF (zLev.lt.zDown) THEN
                  distUp = (zDown - zLev) / zDown
                  ttzIB_0(i,j,kz) = distUp * tairSL(i,j) +
     .                              (1-distUp) * tairDY(i,j,mz)
                  qqzIB_0(i,j,kz) = distUp * qvapSL(i,j) +
     .                              (1-distUp) * qvDY(i,j,mz)
              ELSE
                  kUp = 1
                  kDown = mz
                  DO WHILE (kDown-kUp.gt.1)
                      kMiddle = (kDown + kUp) / 2
                      zMiddle = gplvDY(i,j,kMiddle) * grvinv - sh(i,j)
                      IF (zMiddle.le.zLev) THEN
                          kDown = kMiddle
                      ELSE
                          kUp = kMiddle
                      ENDIF
                  ENDDO
                  zUp = gplvDY(i,j,kUp) * grvinv - sh(i,j)
                  zDown = gplvDY(i,j,kDown) * grvinv - sh(i,j)
                  distUp = (zUp - zLev) / (zUp - zDown)
                  ttzIB_0(i,j,kz) = distUp * tairDY(i,j,kDown) +
     .                              (1-distUp) * tairDY(i,j,kUp)
                  qqzIB_0(i,j,kz) = distUp * qvDY(i,j,kDown) +
     .                              (1-distUp) * qvDY(i,j,kUp)
              ENDIF
              ! sum for the output
              ttzIB(i,j,kz) = ttzIB(i,j,kz) +
     .                        ttzIB_0(i,j,kz) - TfSnow
              qqzIB(i,j,kz) = qqzIB(i,j,kz) +
     .                        qqzIB_0(i,j,kz) * 1000.
          END DO
      END DO
      END DO
      
C +--2.2.4.2 Wind
      DO j=1,my
      DO i=1,mx
          zDown = gplvDY(i,j,mz) * grvinv - sh(i,j)
          DO kz=1,mzuv
              zLev= OutZUVLevIB(kz)
              IF (zLev.lt.zDown) THEN
                  distUp = (zDown - zLev) / zDown
                  uuzIB_0(i,j,kz) = distUp * 0. +
     .                              (1-distUp) * uairDY(i,j,mz)
                  vvzIB_0(i,j,kz) = distUp * 0. +
     .                              (1-distUp) * vairDY(i,j,mz)
              ELSE
                  kUp = 1
                  kDown = mz
                  DO WHILE (kDown-kUp.gt.1)
                      kMiddle = (kDown + kUp) / 2
                      zMiddle = gplvDY(i,j,kMiddle) * grvinv - sh(i,j)
                      IF (zMiddle.le.zLev) THEN
                          kDown = kMiddle
                      ELSE
                          kUp = kMiddle
                      ENDIF
                  ENDDO
                  zUp = gplvDY(i,j,kUp) * grvinv - sh(i,j)
                  zDown = gplvDY(i,j,kDown) * grvinv - sh(i,j)
                  distUp = (zUp - zLev) / (zUp - zDown)
                  uuzIB_0(i,j,kz) = distUp * uairDY(i,j,kDown) +
     .                              (1-distUp) * uairDY(i,j,kUp)
                  vvzIB_0(i,j,kz) = distUp * vairDY(i,j,kDown) +
     .                              (1-distUp) * vairDY(i,j,kUp)
              ENDIF
              ! sum for the output
              uuzIB(i,j,kz) = uuzIB(i,j,kz) + uuzIB_0(i,j,kz)
              vvzIB(i,j,kz) = vvzIB(i,j,kz) + vvzIB_0(i,j,kz)
              uvzIB(i,j,kz) = uvzIB(i,j,kz) +
     .             (uuzIB_0(i,j,kz)**2. + vvzIB_0(i,j,kz)**2.)**0.5
          END DO
      END DO
      END DO

C +--2.2.4 Surface variables
C +  -----------------------

      DO j=jp11,my1
      DO i=ip11,mx1
 
          if(RAdsol(i,j)>120) 
     .    sunIB(i,j)      = sunIB(i,j)+dt*4. ! outice is called every 4 time steps

          swdIB(i,j)      = RAdsol(i,j)             + swdIB(i,j)
          swuIB(i,j)      = albeSL(i,j)*RAdsol(i,j) + swuIB(i,j)
          lwdIB(i,j)      = RAd_ir(i,j)             + lwdIB(i,j)
          lwuIB(i,j)      = firmSL(i,j)             + lwuIB(i,j)

         lwutIB(i,j)      = RAdOLR(i,j)             + lwutIB(i,j)
         swutIB(i,j)      = RAdOSR(i,j)             + swutIB(i,j)
         swdtIB(i,j)      = rsunGE * czenGE(i,j)    + swdtIB(i,j)
          shfIB(i,j)      = hsenSL(i,j)             + shfIB(i,j)
          lhfIB(i,j)      = hlatSL(i,j)             + lhfIB(i,j)
           alIB(i,j)      = albeSL(i,j)             +  alIB(i,j)
         as1_IB(i,j)      = alb1IB(i,j)             + as1_IB(i,j) 
         as2_IB(i,j)      = alb2IB(i,j)             + as2_IB(i,j) 
         as3_IB(i,j)      = alb3IB(i,j)             + as3_IB(i,j) 
           stIB(i,j)      = tairsl(i,j)-TfSnow      +  stIB(i,j)
          sicIB(i,j)      = sicsIB(i,j)             +  alIB(i,j)
          pddIB(i,j)      = pddIB(i,j)+
     .                                (tairDY(i,j,mz)-TfSnow)
     .                    * max(zero,sign(unun,
     .                                 tairDY(i,j,mz)-TfSnow))
        DO k=1,nsx
          al1IB(i,j,k)    = RAdsol(i,j)*albxSL(i,j,k)+al1IB(i,j,k)
          al2IB(i,j,k)    = albxSL(i,j,k)           + al2IB(i,j,k)
          frvIB(i,j,k)    = ifratv(i,j,k)           + frvIB(i,j,k)
          st2IB(i,j,k)    = tsrfSL(i,j,k)-TfSnow    + st2IB(i,j,k)
          z0IB (i,j,k)    = SL_Z0 (i,j,k)           + z0IB (i,j,k)
          r0IB (i,j,k)    = SL_R0 (i,j,k)           + r0IB (i,j,k)
          uusIB(i,j,k)    = SLuusl(i,j,k)           + uusIB(i,j,k)
          utsIB(i,j,k)    = SLutsl(i,j,k)           + utsIB(i,j,k)
          uqsIB(i,j,k)    = SLuqsl(i,j,k)           + uqsIB(i,j,k)
          ussIB(i,j,k)    = SLussl(i,j,k)           + ussIB(i,j,k)
        ENDDO
 
      END DO
      END DO
 
C +--2.2.5 Cloud Variables
C +  ---------------------
 
      DO j=1,my
      DO i=1,mx
 
        DO k=1,3
          tmp(k)          = 0.0
        ENDDO
 
        DO k = mzabso+1,mz
          tmp(3)          = (pstDY(i,j)  * sigma(k)+ptopDY)
     .                    / (ra*tairDY(i,j,k)*(1.+.608   *qvDY(i,j,k)))
     .                    * (   gpmiDY(i,j,k)-          gpmiDY(i,j,k+1))
          tmp(1)          = tmp(1)       + tmp(3)       * qwHY(i,j,k)
          tmp(2)          = tmp(2)       + tmp(3)       * qiHY(i,j,k)
        END DO
 
          codIB(i,j)      = 1.5 * ( tmp(1) / 20.d-6
     .                            + tmp(2) / 40.d-6 ) *grvinv
     .                            + codIB (i,j)
CC#EE     codIB(i,j)      = RAcdtO(i,j)+codIB (i,j)
 
        DO k = mzabso,mz
          qwIB(i,j)       = qwIB(i,j)   + qwHY(i,j,k)
          qiIB(i,j)       = qiIB(i,j)   + qiHY(i,j,k)
          qsIB(i,j)       = qsIB(i,j)   + qsHY(i,j,k)
          qrIB(i,j)       = qrIB(i,j)   + qrHY(i,j,k)
        ENDDO

        DO k = 2,mz
         tmp(1)           = rolvDY(i,j,k)  
     .                    *((gplvDY(i,j,k-1)-gplvDY(i,j,k  ))/2.
     .                    - (gplvDY(i,j,k)  -gplvDY(i,j,k+1))/2.)
     .                    * grvinv  

         wvpIB(i,j)       = wvpIB(i,j)  +  qvDY(i,j,k) * 1000. * tmp(1)
         cwpIB(i,j)       = cwpIB(i,j)  + (qwHY(i,j,k)+qrHY(i,j,k)) 
     .                    * 1000. * tmp(1)
         iwpIB(i,j)       = iwpIB(i,j)  + (qiHY(i,j,k)+qsHY(i,j,k)) 
     .                    * 1000. * tmp(1)
        ENDDO   
        
          ccIB (i,j)      = cld_SL(i,j) + ccIB (i,j)
          cuIB (i,j)      = clduSL(i,j) + cuIB (i,j)
          cmIB (i,j)      = cldmSL(i,j) + cmIB (i,j)
          cdIB (i,j)      = clddSL(i,j) + cdIB (i,j)
      ENDDO
      ENDDO
 
C +--2.2.6 Soil Variables
C +  --------------------
 
      DO j=jp11,my1
      DO i=ip11,mx1
        DO k=1,nsx
          DO kk=1,llx
            sltIB(i,j,k,kk) = TsolTV(i,j,k,kk)-TfSnow + sltIB (i,j,k,kk)
            slqIB(i,j,k,kk) = Eta_TV(i,j,k,kk)*1000.  + slqIB (i,j,k,kk)
           slqcIB(i,j,k)    = Eta_TV(i,j,k,kk)*1000.  * dz_dSV (-llx+kk)
     .                                                + slqcIB(i,j,k) 
          ENDDO
        ENDDO
      ENDDO
      ENDDO
 
 
C +--2.2.7 Snow Pack Variables
C +  -------------------------
 
      DO k=1,nsx
       DO j=jp11,my1
       DO i=ip11,mx1
        IF(nssSNo(i,j,k).gt.1) THEN
      
         depthsnow(nssSNo(i,j,k))=dzsSNo(i,j,k,nssSNo(i,j,k))/2.   

         DO nk=nssSNo(i,j,k)-1,1,-1
          depthsnow(nk)=depthsnow(nk+1)+dzsSNo(i,j,k,nk  )/2.
     .                                 +dzsSNo(i,j,k,nk+1)/2.
         enddo

         DO kk=1,mi
         
          IF(OutshIB(kk)<=depthsnow(nssSNo(i,j,k))) then
           g1IB(i,j,k,kk) = g1sSNo(i,j,k,nssSNo(i,j,k))
     .    +g1IB(i,j,k,kk)
           g2IB(i,j,k,kk) = g2sSNo(i,j,k,nssSNo(i,j,k))
     .    +g2IB(i,j,k,kk)
           roIB(i,j,k,kk) = rosSNo(i,j,k,nssSNo(i,j,k))
     .    +roIB(i,j,k,kk)
           tiIB(i,j,k,kk) = tisSNo(i,j,k,nssSNo(i,j,k))
     .    +tiIB(i,j,k,kk)
           waIB(i,j,k,kk) = wasSNo(i,j,k,nssSNo(i,j,k))
     .    +waIB(i,j,k,kk)
          ENDIF

          IF(OutshIB(kk)>=depthsnow(1)) then
           g1IB(i,j,k,kk) = g1sSNo(i,j,k,1)
     .    +g1IB(i,j,k,kk)
           g2IB(i,j,k,kk) = g2sSNo(i,j,k,1)
     .    +g2IB(i,j,k,kk)
           roIB(i,j,k,kk) = rosSNo(i,j,k,1)
     .    +roIB(i,j,k,kk)
           tiIB(i,j,k,kk) = tisSNo(i,j,k,1)
     .    +tiIB(i,j,k,kk)
           waIB(i,j,k,kk) = wasSNo(i,j,k,1)
     .    +waIB(i,j,k,kk)
          ENDIF
   
          IF(OutshIB(kk)>depthsnow(nssSNo(i,j,k)).and.
     .       OutshIB(kk)<depthsnow(1)) then

           nk=nssSNo(i,j,k)
           DO WHILE(OutshIB(kk)>depthsnow(nk))
            nk=nk-1 
           ENDDO 
      
           g1IB(i,j,k,kk) = g1sSNo(i,j,k,nk+1)+
     .    (g1sSNo(i,j,k,nk)-g1sSNo(i,j,k,nk+1))/
     .    (depthsnow(nk)-depthsnow(nk+1))*(OutshIB(kk)-depthsnow(nk+1))
     .    +g1IB(i,j,k,kk)           

           g2IB(i,j,k,kk) = g2sSNo(i,j,k,nk+1)+
     .    (g2sSNo(i,j,k,nk)-g2sSNo(i,j,k,nk+1))/
     .    (depthsnow(nk)-depthsnow(nk+1))*(OutshIB(kk)-depthsnow(nk+1))
     .    +g2IB(i,j,k,kk)   

           tiIB(i,j,k,kk) = tisSNo(i,j,k,nk+1)+
     .    (tisSNo(i,j,k,nk)-tisSNo(i,j,k,nk+1))/
     .    (depthsnow(nk)-depthsnow(nk+1))*(OutshIB(kk)-depthsnow(nk+1))
     .    +tiIB(i,j,k,kk)   

           roIB(i,j,k,kk) = rosSNo(i,j,k,nk+1)+
     .    (rosSNo(i,j,k,nk)-rosSNo(i,j,k,nk+1))/
     .    (depthsnow(nk)-depthsnow(nk+1))*(OutshIB(kk)-depthsnow(nk+1))
     .    +roIB(i,j,k,kk)

           waIB(i,j,k,kk) = wasSNo(i,j,k,nk+1)+
     .    (wasSNo(i,j,k,nk)-wasSNo(i,j,k,nk+1))/
     .    (depthsnow(nk)-depthsnow(nk+1))*(OutshIB(kk)-depthsnow(nk+1))
     .    +waIB(i,j,k,kk)   
          ENDIF


         ENDDO

        ENDIF
       ENDDO
       ENDDO
      ENDDO 
 
C +--2.2.8 Slush and Superimposed Ice
C +  --------------------------------
 
c      DO k= 1,nsx
c 
c        DO j=jp11,my1
c        DO i=ip11,mx1
c
c            WKxy1(i,j) = 1.
c
c          DO kk=1,nssSNo(i,j,k)
c
c            WKxy3(i,j)     = max( 0., sign(1., rosSNo(i,j,k,kk)-roCdSV))
c     .                     * max( 0., sign(1.,-wasSNo(i,j,k,kk)+epsi  ))
c
c            WKxy1(i,j)     = min( WKxy1(i,j) ,  WKxy3(i,j)
c     .                     + max( 0., sign(1.,-nsiiIB(i,j,k)   +epsi)))
c 
c            nsiiIB (i,j,k) = max(nsiiIB(i,j,k),
c     .                     kk*int(WKxy1(i,j)  * WKxy3(i,j)))
c            siiceIB(i,j,k) =    siiceIB(i,j,k)+dzsSNo(i,j,k,kk)
c     .                           *WKxy1(i,j)  * WKxy3(i,j)
c          END DO
c
c            siIB   (i,j,k)   =   siiceIB(i,j,k)  +    siIB(i,j,k)
c            slushIB(i,j,k)   =         0.
c            nsluIB (i,j,k)   =    nsiiIB(i,j,k)
c        END DO
c        END DO
c      END DO
c 
c      DO k=    1,nsx
c 
c        DO j=jp11,my1
c        DO i=ip11,mx1
c
c            WKxy2(i,j) = 1.
c
c          DO kk=1,nssSNo(i,j,k)
c            WKxy3(i,j)= max(0., sign(1., rosSNo(i,j,k,kk)- roCdSV))
c     .                * max(0., sign(1., wasSNo(i,j,k,kk)- 0.1e0 ))
c     .                * max(0 , sign(1 , kk-max(1,nsiiIB(i,j,k) )))
c            WKxy2(i,j)= min(WKxy2(i,j) ,  WKxy3(i,j)
c     .                + max(0., sign(1., nsiiIB(i,j,k)
c     .                                  -nsluIB(i,j,k) + epsi)))
c            nsluIB (i,j,k) = max(nsluIB(i,j,k),
c     .                     kk*int(WKxy2(i,j)*WKxy3(i,j)))
c            slushIB(i,j,k) =    slushIB(i,j,k)
c     .                     +     dzsSNo(i,j,k,kk)
c     .                           *WKxy2(i,j)*WKxy3(i,j)
c          END DO
c   
c            suIB   (i,j,k)   =   slushIB(i,j,k)  +    suIB(i,j,k)
c            nsluIB (i,j,k)   =    nsluIB(i,j,k)  -  nsiiIB(i,j,k)
c        END DO
c        END DO
c      END DO
 
 
C +       snow      (with ice lenses perhaps ! )
C + - - - - - - - -
C +      slush      (ro > 830kg/m3 and wa > 0.1)
C + - - - - - - - -
C + surimposed ice  (ro > 830kg/m3 and wa = 0  )
C + - - - - - - - -
C +       ice       (ro = 900kg/m3 and wa = 0  )
C + - - - - - - - -
C +      ground
 
 
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C +++  3. Output  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 
      IF ((iterun-itrdIB)*dt+unun.gt.86400.0/real(OutdyIB))       THEN
 
        if(dt_ICE2.gt. iterun-itrdIB) then
         print *,"OUTice error: dt_ICE2 > iterun-itrdIB",
     .   dt_ICE2,iterun-itrdIB
        endif
 
C +--3.0 Snapshot of Snow Height
C +  ===========================
 
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
            zn1IB (i,j,k) = 1.
            zn2IB (i,j,k) = 0.
            zn3IB (i,j,k) = 0.
            wet_IB(i,j,k) = 0.
        END DO
        END DO
        END DO
 
        DO kk=nsno,1,-1
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
            zn3IB (i,j,k) = dzsSNo(i,j,k,kk)   + zn3IB(i,j,k)
            wet_IB(i,j,k) = rosSNo(i,j,k,kk)   * dzsSNo(i,j,k,kk)
     .                    * 1.d3/ ro_Wat       *(1.+0.*wasSNo(i,j,k,kk))
     .                    + wet_IB(i,j,k)
            zn1IB (i,j,k) = zn1IB(i,j,k)
     .                    * max(zero,sign(unun,
     .                      ro_ice-20.-rosSNo(i,j,k,kk)))
            zn2IB (i,j,k) = dzsSNo(i,j,k,kk)   * zn1IB(i,j,k)
     .                                         + zn2IB(i,j,k)
        END DO
        END DO
        END DO
        END DO
 
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
            wet_IB(i,j,k)  = wet_IB(i,j,k) +     SWaSNo(i,j,k)
            zn2IB (i,j,k)  = zn2IB (i,j,k) * (1.- zn1IB(i,j,k))
            zn1IB (i,j,k)  = zn3IB (i,j,k)      - zn0IB(i,j,k)
            mbIB  (i,j,k)  = wet_IB(i,j,k)      - mb0IB(i,j,k)
        END DO
        END DO
        END DO
 
 
        DO j=1,my
        DO i=1,mx
 
 
C +--3.1 Computation of Averaged Values
C +  ==================================

          pddIB(i,j)      = pddIB(i,j)      / real(dt_ICE2)
 
        DO kk =1,ml
          ttIB( i,j,kk)   = ttIB (i,j,kk)   / real(dt_ICE2)
          uuIB (i,j,kk)   = uuIB (i,j,kk)   / real(dt_ICE2)
          vvIB (i,j,kk)   = vvIB (i,j,kk)   / real(dt_ICE2)
          uvIB (i,j,kk)   = uvIB (i,j,kk)   / real(dt_ICE2)
          wwIB (i,j,kk)   = wwIB (i,j,kk)   / real(dt_ICE2)
          qqIB (i,j,kk)   = qqIB (i,j,kk)   / real(dt_ICE2)
          rhIB (i,j,kk)   = rhIB (i,j,kk)   / real(dt_ICE2)
          zzIB (i,j,kk)   = zzIB (i,j,kk)   / real(dt_ICE2)
        ENDDO
        DO kp =1,mp
          if(nbpIB(i,j,kp).gt.0) then
              ttpIB (i,j,kp)  = ttpIB (i,j,kp)  / nbpIB(i,j,kp)
              uupIB (i,j,kp)  = uupIB (i,j,kp)  / nbpIB(i,j,kp)
              vvpIB (i,j,kp)  = vvpIB (i,j,kp)  / nbpIB(i,j,kp)
              uvpIB (i,j,kp)  = uvpIB (i,j,kp)  / nbpIB(i,j,kp)
              qqpIB (i,j,kp)  = qqpIB (i,j,kp)  / nbpIB(i,j,kp)
              zzpIB (i,j,kp)  = zzpIB (i,j,kp)  / nbpIB(i,j,kp)
          else
              ttpIB (i,j,kp)  = NF_FILL_REAL
              uupIB (i,j,kp)  = NF_FILL_REAL
              vvpIB (i,j,kp)  = NF_FILL_REAL
              uvpIB (i,j,kp)  = NF_FILL_REAL
              qqpIB (i,j,kp)  = NF_FILL_REAL
              zzpIB (i,j,kp)  = NF_FILL_REAL
          endif
        ENDDO
        DO kz =1,mztq
          ttzIB( i,j,kz)  = ttzIB (i,j,kz)  / real(dt_ICE2)
          qqzIB (i,j,kz)  = qqzIB (i,j,kz)  / real(dt_ICE2)
        ENDDO
        DO kz =1,mzuv
          uuzIB( i,j,kz)  = uuzIB (i,j,kz)  / real(dt_ICE2)
          vvzIB (i,j,kz)  = vvzIB (i,j,kz)  / real(dt_ICE2)
          uvzIB (i,j,kz)  = uvzIB (i,j,kz)  / real(dt_ICE2)
        ENDDO
        DO k=1,nsx  
          pblIB(i,j,k)    = pblIB(i,j,k)    / real(dt_ICE2)
          al1IB(i,j,k)    = al1IB(i,j,k)    / max(swdIB(i,j),epsi)
          al2IB(i,j,k)    = al2IB(i,j,k)    / real(dt_ICE2)
        ENDDO
           alIB(i,j)      =  alIB(i,j)      / real(dt_ICE2)
         as1_IB(i,j)      =as1_IB(i,j)      / real(dt_ICE2)
         as2_IB(i,j)      =as2_IB(i,j)      / real(dt_ICE2)
         as3_IB(i,j)      =as3_IB(i,j)      / real(dt_ICE2)
          swdIB(i,j)      = swdIB(i,j)      / real(dt_ICE2)
          swuIB(i,j)      = swuIB(i,j)      / real(dt_ICE2)
          lwdIB(i,j)      = lwdIB(i,j)      / real(dt_ICE2)
          lwuIB(i,j)      = lwuIB(i,j)      / real(dt_ICE2)
         swdtIB(i,j)      =swdtIB(i,j)      / real(dt_ICE2)
         swutIB(i,j)      =swutIB(i,j)      / real(dt_ICE2)
         lwutIB(i,j)      =lwutIB(i,j)      / real(dt_ICE2)
          shfIB(i,j)      = shfIB(i,j)      / real(dt_ICE2)
          lhfIB(i,j)      = lhfIB(i,j)      / real(dt_ICE2)
          spIB (i,j)      = spIB (i,j)      / real(dt_ICE2)
         if (mw .eq. 5) then
       gradTIB (i,j)      = gradTIB (i,j)   / real(dt_ICE2) !*CL*
       gradQIB (i,j)      = gradQIB (i,j)   / real(dt_ICE2) !*CL*
          endif
          ccIB (i,j)      = ccIB (i,j)      / real(dt_ICE2)
          cuIB (i,j)      = cuIB (i,j)      / real(dt_ICE2)
          cmIB (i,j)      = cmIB (i,j)      / real(dt_ICE2)
          cdIB (i,j)      = cdIB (i,j)      / real(dt_ICE2)
          qwIB (i,j)      = qwIB (i,j)      / real(dt_ICE2)
          qiIB (i,j)      = qiIB (i,j)      / real(dt_ICE2)
          qsIB (i,j)      = qsIB (i,j)      / real(dt_ICE2)
          qrIB (i,j)      = qrIB (i,j)      / real(dt_ICE2)
          wvpIB(i,j)      = wvpIB(i,j)      / real(dt_ICE2)
          cwpIB(i,j)      = cwpIB(i,j)      / real(dt_ICE2)
          iwpIB(i,j)      = iwpIB(i,j)      / real(dt_ICE2)
          codIB(i,j)      = codIB(i,j)      / real(dt_ICE2)
          stIB (i,j)      = stIB (i,j)      / real(dt_ICE2)
          sicIB(i,j)      = sicIB(i,j)      / real(dt_ICE2)
        DO k=1,nsx
          frvIB(i,j,k)    = frvIB(i,j,k)    / real(dt_ICE2)
          st2IB(i,j,k)    = st2IB(i,j,k)    / real(dt_ICE2)
          z0IB (i,j,k)    = z0IB (i,j,k)    / real(dt_ICE2)
          r0IB (i,j,k)    = r0IB (i,j,k)    / real(dt_ICE2)
          uusIB(i,j,k)    = uusIB(i,j,k)    / real(dt_ICE2)
          utsIB(i,j,k)    = utsIB(i,j,k)    / real(dt_ICE2)
          uqsIB(i,j,k)    = uqsIB(i,j,k)    / real(dt_ICE2)
          ussIB(i,j,k)    = ussIB(i,j,k)    / real(dt_ICE2)
          if (mw .eq. 5) then
          tt_intIB(i,j,k) = tt_intIB(i,j,k) / real(dt_ICE2)     !*CL*
          qq_intIB(i,j,k) = qq_intIB(i,j,k) / real(dt_ICE2)     !*CL*
          endif
          DO kk=1,llx
          sltIB(i,j,k,kk) = sltIB (i,j,k,kk)/ real(dt_ICE2)
          slqIB(i,j,k,kk) = slqIB (i,j,k,kk)/ real(dt_ICE2)
          ENDDO
          slqcIB(i,j,k)   =slqcIB (i,j,k)   / real(dt_ICE2)
          DO kk =1,mi
          g1IB (i,j,k,kk) = g1IB (i,j,k,kk) / real(dt_ICE2)
          g2IB (i,j,k,kk) = g2IB (i,j,k,kk) / real(dt_ICE2)
          roIB (i,j,k,kk) = roIB (i,j,k,kk) / real(dt_ICE2)
          tiIB (i,j,k,kk) = tiIB (i,j,k,kk) / real(dt_ICE2)-TfSnow
          waIB (i,j,k,kk) = waIB (i,j,k,kk) / real(dt_ICE2)
          END DO
        END DO
 
        END DO
        END DO
 
        itrdIB = iterun
        dt_ICE2= -1
 
 
C +  3.2 Save in a netcdf file
C +  =========================
 
        dt_ICE = dt_ICE + 1
 
        IF (iterun.gt.1)                                          THEN !
 
C +       ************
          CALL UNwopen (fnamNC_ice,ID__nc_ice)
C +       ************
 
        END IF ! Re-Open file IF already created.
 
 
C +--3.2.1 Write Time-dependent variables
C +  ------------------------------------
 
 
        IF (nDFdim(0).eq.0)                  THEN  !
 
C +     ************
        dater=date
        CALL UNwrite(ID__nc_ice,'time', dt_ICE,  1,  1,  1, dater)
C +     ************
 
        date      = (351+(iyrrGE  -1902) *365  ! Nb Days before iyrrGE
     .            +(iyrrGE  -1901) /  4        ! Nb Leap Years
     .            + njyrGE(mmarGE)             ! Nb Days before mmarGE
     .            + njybGE(mmarGE)             ! (including Leap Day)
     .            * max(0,1-mod(iyrrGE,4))     !
     .            + jdarGE -1 )*  24           !
     .            + jhurGE                     !
     .            +(minuGE *60 +jsecGE)/3600   !
        END IF
 
C +     ************
        CALL UNwrite(ID__nc_ice,'DATE', dt_ICE,  1,  1,  1,
     .               dateNC_ice(dt_ICE))
        CALL UNwrite(ID__nc_ice,'year', dt_ICE,  1,  1,  1,
     .               yearNC_ice(dt_ICE))
C +     ************

C +     ************
        dater=iyrrGE
        CALL UNwrite (ID__nc_ice, 'YYYY',dt_ICE, 1, 1, 1,dater)
        dater=mmarGE
        CALL UNwrite (ID__nc_ice, 'MM'  ,dt_ICE, 1, 1, 1,dater)
        dater=jdarGE
        CALL UNwrite (ID__nc_ice, 'DD'  ,dt_ICE, 1, 1, 1,dater)
        dater=jhurGE
        CALL UNwrite (ID__nc_ice, 'HH'  ,dt_ICE, 1, 1, 1,dater)
        dater=minuGE
        CALL UNwrite (ID__nc_ice, 'MIN' ,dt_ICE, 1, 1, 1,dater)
        dater=jsecGE
        CALL UNwrite (ID__nc_ice, 'SS'  ,dt_ICE, 1, 1, 1,dater)
C +     ************

C +--3.2.0.a X-hourly Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~

C +     ************
        CALL UNwrite (ID__nc_ice,'TIMEh',dt_ICE,mlhh, 1, 1,timehIB)
        CALL UNwrite (ID__nc_ice, 'SPh', dt_ICE,mx, my, mlhh,sphIB)
        CALL UNwrite (ID__nc_ice, 'STh', dt_ICE,mx, my, mlhh,sthIB)
        CALL UNwrite (ID__nc_ice, 'TTh', dt_ICE,mx, my, mlhh,tthIB)
        CALL UNwrite (ID__nc_ice, 'TXh', dt_ICE,mx, my, mlhh,txhIB)
        CALL UNwrite (ID__nc_ice, 'TNh', dt_ICE,mx, my, mlhh,tnhIB)
        CALL UNwrite (ID__nc_ice, 'QQh', dt_ICE,mx, my, mlhh,qqhIB)
        CALL UNwrite (ID__nc_ice, 'UUh', dt_ICE,mx, my, mlhh,uuhIB)
        CALL UNwrite (ID__nc_ice, 'VVh', dt_ICE,mx, my, mlhh,vvhIB)
        CALL UNwrite (ID__nc_ice,'SWDh', dt_ICE,mx, my, mlhh,swdhIB)
        CALL UNwrite (ID__nc_ice,'LWDh', dt_ICE,mx, my, mlhh,lwdhIB)
        CALL UNwrite (ID__nc_ice,'LWUh', dt_ICE,mx, my, mlhh,lwuhIB)
        CALL UNwrite (ID__nc_ice,'SHFh', dt_ICE,mx, my, mlhh,shfhIB)
        CALL UNwrite (ID__nc_ice,'LHFh', dt_ICE,mx, my, mlhh,lhfhIB)
        CALL UNwrite (ID__nc_ice, 'ALh', dt_ICE,mx, my, mlhh,alhIB)
        CALL UNwrite (ID__nc_ice, 'CCh', dt_ICE,mx, my, mlhh,clhIB)
        CALL UNwrite (ID__nc_ice, 'MEh', dt_ICE,mx, my, mlhh,mehIB)
        CALL UNwrite (ID__nc_ice, 'PRh', dt_ICE,mx, my, mlhh,prhIB)
        CALL UNwrite (ID__nc_ice,'SNFh', dt_ICE,mx, my, mlhh,snfhIB)
        CALL UNwrite (ID__nc_ice,'LWC1mh',dt_ICE,mx,my,mlhh,lwc1mhIB)
        CALL UNwrite (ID__nc_ice,'LWC2mh',dt_ICE,mx,my,mlhh,lwc2mhIB)
c +     ************  

C +--3.2.1.a Atmospheric Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         
        ! daily mean
 
C +     ************
        CALL UNwrite (ID__nc_ice, 'TTmin', dt_ICE, mx, my, ml,mintIB)
        CALL UNwrite (ID__nc_ice, 'TTmax', dt_ICE, mx, my, ml,maxtIB)
        CALL UNwrite (ID__nc_ice, 'TTint', dt_ICE, mx, my, nsx,tt_intIB)
        CALL UNwrite (ID__nc_ice, 'TT'   , dt_ICE, mx, my, ml,  ttIB)
        CALL UNwrite (ID__nc_ice, 'UU'   , dt_ICE, mx, my, ml,  uuIB)
        CALL UNwrite (ID__nc_ice, 'VV'   , dt_ICE, mx, my, ml,  vvIB)
        CALL UNwrite (ID__nc_ice, 'UV'   , dt_ICE, mx, my, ml,  uvIB)
        CALL UNwrite (ID__nc_ice, 'UVmax', dt_ICE, mx, my, ml,maxwIB)
        CALL UNwrite (ID__nc_ice, 'WW'   , dt_ICE, mx, my, ml,  wwIB)
        CALL UNwrite (ID__nc_ice, 'QQ'   , dt_ICE, mx, my, ml,  qqIB)
        CALL UNwrite (ID__nc_ice, 'QQint', dt_ICE, mx, my, nsx,qq_intIB)  !*CL*
        CALL UNwrite (ID__nc_ice, 'RH'   , dt_ICE, mx, my, ml,  rhIB)
        CALL UNwrite (ID__nc_ice, 'ZZ'   , dt_ICE, mx, my, ml,  zzIB)
        CALL UNwrite (ID__nc_ice, 'PDD'  , dt_ICE, mx, my,  1, pddIB)
        CALL UNwrite (ID__nc_ice, 'SP'   , dt_ICE, mx, my,  1,  spIB)
        CALL UNwrite (ID__nc_ice, 'gradT'  , dt_ICE,mx, my,1,gradTIB) !*CL*
        CALL UNwrite (ID__nc_ice, 'gradTmin',dt_ICE,mx, my,1,mingrTIB) !*CL*
        CALL UNwrite (ID__nc_ice, 'gradTmax',dt_ICE,mx, my,1,maxgrTIB) !*CL*
        CALL UNwrite (ID__nc_ice, 'gradQ'   ,dt_ICE,mx, my,1,gradQIB) !*CL*
        CALL UNwrite (ID__nc_ice, 'gradQmin',dt_ICE,mx, my,1,mingrQIB) !*CL*
        CALL UNwrite (ID__nc_ice, 'gradQmax',dt_ICE,mx, my,1,maxgrQIB) !*CL*


        ttbIB = ttIB(:,:,1:mlb)
        txbIB = maxtIB(:,:,1:mlb)
        tnbIB = mintIB(:,:,1:mlb)
        qqbIB = qqIB(:,:,1:mlb)
        uubIB = uuIB(:,:,1:mlb)
        vvbIB = vvIB(:,:,1:mlb)
        uvbIB = uvIB(:,:,1:mlb)
        zzbIB = zzIB(:,:,1:mlb)

        CALL UNwrite (ID__nc_ice, 'TTb'   , dt_ICE, mx, my,mlb, ttbIB)
        CALL UNwrite (ID__nc_ice, 'TXb'   , dt_ICE, mx, my,mlb, txbIB)
        CALL UNwrite (ID__nc_ice, 'TNb'   , dt_ICE, mx, my,mlb, tnbIB)
        CALL UNwrite (ID__nc_ice, 'QQb'   , dt_ICE, mx, my,mlb, qqbIB)
        CALL UNwrite (ID__nc_ice, 'ZZb'   , dt_ICE, mx, my,mlb, zzbIB)
        CALL UNwrite (ID__nc_ice, 'UUb'   , dt_ICE, mx, my,mlb, uubIB)
        CALL UNwrite (ID__nc_ice, 'VVb'   , dt_ICE, mx, my,mlb, vvbIB)
        CALL UNwrite (ID__nc_ice, 'UVb'   , dt_ICE, mx, my,mlb, uvbIB)

        CALL UNwrite (ID__nc_ice, 'TTp'   , dt_ICE, mx, my, mp, ttpIB)
        CALL UNwrite (ID__nc_ice, 'QQp'   , dt_ICE, mx, my, mp, qqpIB)
        CALL UNwrite (ID__nc_ice, 'ZZp'   , dt_ICE, mx, my, mp, zzpIB)
        CALL UNwrite (ID__nc_ice, 'UUp'   , dt_ICE, mx, my, mp, uupIB)
        CALL UNwrite (ID__nc_ice, 'VVp'   , dt_ICE, mx, my, mp, vvpIB)
        CALL UNwrite (ID__nc_ice, 'UVp'   , dt_ICE, mx, my, mp, uvpIB)

        CALL UNwrite (ID__nc_ice, 'TTz'   , dt_ICE, mx, my, mztq, ttzIB)
        CALL UNwrite (ID__nc_ice, 'QQz'   , dt_ICE, mx, my, mztq, qqzIB)
        CALL UNwrite (ID__nc_ice, 'UUz'   , dt_ICE, mx, my, mzuv, uuzIB)
        CALL UNwrite (ID__nc_ice, 'VVz'   , dt_ICE, mx, my, mzuv, vvzIB)
        CALL UNwrite (ID__nc_ice, 'UVz'   , dt_ICE, mx, my, mzuv, uvzIB)
C +     ************
 
C +--3.2.1.b Surface Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~
 
        ! daily mean

C +     ************
        CALL UNwrite (ID__nc_ice, 'SWD'  , dt_ICE, mx, my,  1, swdIB)
        CALL UNwrite (ID__nc_ice, 'SWU'  , dt_ICE, mx, my,  1, swuIB)
        CALL UNwrite (ID__nc_ice, 'SUN'  , dt_ICE, mx, my,  1, sunIB)
        CALL UNwrite (ID__nc_ice, 'LWD'  , dt_ICE, mx, my,  1, lwdIB)
        CALL UNwrite (ID__nc_ice, 'LWU'  , dt_ICE, mx, my,  1, lwuIB)

        CALL UNwrite (ID__nc_ice, 'SWDT' , dt_ICE, mx, my,  1, swdtIB)
        CALL UNwrite (ID__nc_ice, 'SWUT' , dt_ICE, mx, my,  1, swutIB)
        CALL UNwrite (ID__nc_ice, 'LWUT' , dt_ICE, mx, my,  1, lwutIB)

        CALL UNwrite (ID__nc_ice, 'SHF'  , dt_ICE, mx, my,  1, shfIB)
        CALL UNwrite (ID__nc_ice, 'LHF'  , dt_ICE, mx, my,  1, lhfIB)
        CALL UNwrite (ID__nc_ice,  'AL'  , dt_ICE, mx, my,  1,  alIB)
        CALL UNwrite (ID__nc_ice, 'AS1'  , dt_ICE, mx, my,  1,aS1_IB)
        CALL UNwrite (ID__nc_ice, 'AS2'  , dt_ICE, mx, my,  1,aS2_IB)
        CALL UNwrite (ID__nc_ice, 'AS3'  , dt_ICE, mx, my,  1,aS3_IB)
        CALL UNwrite (ID__nc_ice, 'AL1'  , dt_ICE, mx, my,nsx, al1IB)
        CALL UNwrite (ID__nc_ice, 'AL2'  , dt_ICE, mx, my,nsx, al2IB)
        CALL UNwrite (ID__nc_ice,'FRV2'  , dt_ICE, mx, my,nsx, frvIB)
        CALL UNwrite (ID__nc_ice, 'SIC'  , dt_ICE, mx, my,nsx, sicIB)
        CALL UNwrite (ID__nc_ice, 'FRA'  , dt_ICE, mx, my,nsx, frvIB)
        CALL UNwrite (ID__nc_ice, 'ST'   , dt_ICE, mx, my,  1,  stIB)
        CALL UNwrite (ID__nc_ice, 'ST2'  , dt_ICE, mx, my,nsx, st2IB)
        CALL UNwrite (ID__nc_ice, 'Z0'   , dt_ICE, mx, my,nsx,  Z0IB)
        CALL UNwrite (ID__nc_ice, 'R0'   , dt_ICE, mx, my,nsx,  R0IB)
        CALL UNwrite (ID__nc_ice, 'UUS'  , dt_ICE, mx, my,nsx, UUSIB)
        CALL UNwrite (ID__nc_ice, 'UTS'  , dt_ICE, mx, my,nsx, UTSIB)
        CALL UNwrite (ID__nc_ice, 'UQS'  , dt_ICE, mx, my,nsx, UQSIB)
        CALL UNwrite (ID__nc_ice, 'USS'  , dt_ICE, mx, my,nsx, USSIB)
        CALL UNwrite (ID__nc_ice, 'PBL'  , dt_ICE, mx, my,nsx, pblIB)
C +     ++++++++++++
 
C +--3.2.1.c Cloud Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~~
 
        ! daily mean
 
C +     ++++++++++++
        CALL UNwrite (ID__nc_ice, 'CC'   , dt_ICE, mx, my,  1,  ccIB)
        CALL UNwrite (ID__nc_ice, 'CU'   , dt_ICE, mx, my,  1,  cuIB)
        CALL UNwrite (ID__nc_ice, 'CM'   , dt_ICE, mx, my,  1,  cmIB)
        CALL UNwrite (ID__nc_ice, 'CD'   , dt_ICE, mx, my,  1,  cdIB)
        CALL UNwrite (ID__nc_ice, 'QW'   , dt_ICE, mx, my,  1,  qwIB)
        CALL UNwrite (ID__nc_ice, 'QI'   , dt_ICE, mx, my,  1,  qiIB)
        CALL UNwrite (ID__nc_ice, 'QS'   , dt_ICE, mx, my,  1,  qsIB)
        CALL UNwrite (ID__nc_ice, 'QR'   , dt_ICE, mx, my,  1,  qrIB)
        CALL UNwrite (ID__nc_ice, 'COD'  , dt_ICE, mx, my,  1, codIB)
        CALL UNwrite (ID__nc_ice, 'WVP'  , dt_ICE, mx, my,  1, wvpIB)
        CALL UNwrite (ID__nc_ice, 'CWP'  , dt_ICE, mx, my,  1, cwpIB)
        CALL UNwrite (ID__nc_ice, 'IWP'  , dt_ICE, mx, my,  1, iwpIB)
C +     ++++++++++++
 
C +--3.2.1.d Snow Pack Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
        DO k =1,nsx
 
        write(sector,'(i1)') k
 
        DO kk=1,mi
        DO j =1,my
        DO i =1,mx
           xymi1(i,j,kk) = g1IB(i,j,k,kk)
           xymi2(i,j,kk) = g2IB(i,j,k,kk)
           xymi5(i,j,kk) = roIB(i,j,k,kk)
           xymi6(i,j,kk) = tiIB(i,j,k,kk)
           xymi7(i,j,kk) = waIB(i,j,k,kk)
        ENDDO
        ENDDO
        ENDDO
 
        ! daily mean
 
C +     ++++++++++++
        CALL UNwrite (ID__nc_ice, 'G1'//sector,
     .                dt_ICE, mx, my, mi, xymi1)
        CALL UNwrite (ID__nc_ice, 'G2'//sector,
     .                dt_ICE, mx, my, mi, xymi2)
        CALL UNwrite (ID__nc_ice, 'RO'//sector,
     .                dt_ICE, mx, my, mi, xymi5)
        CALL UNwrite (ID__nc_ice, 'TI'//sector,
     .                dt_ICE, mx, my, mi, xymi6)
        CALL UNwrite (ID__nc_ice, 'WA'//sector,
     .                dt_ICE, mx, my, mi, xymi7)
C +     ************
 
        END DO
 
        DO k=1,nsx
        DO j=1,my
        DO i=1,mx
            xynsx1(i,j,k)   = real(nssSNo(i,j,k))
            xynsx2(i,j,k)   = real(nisSNo(i,j,k))
        END DO
        END DO
        END DO
 
        ! Snapshot
 
C +     ************
        CALL UNwrite (ID__nc_ice, 'nSSN',
     .                dt_ICE, mx, my, nsx, xynsx1 )
        CALL UNwrite (ID__nc_ice, 'nISN',
     .                dt_ICE, mx, my, nsx, xynsx2 )
        CALL UNwrite (ID__nc_ice, 'SWSN' ,
     .                dt_ICE, mx, my, nsx, SWaSNo)
        CALL UNwrite (ID__nc_ice, 'ALSN',
     .                dt_ICE, mx, my,  1,  albeSL)
        CALL UNwrite (ID__nc_ice, 'MB',
     .                dt_ICE, mx, my, nsx, mbIB  )
        CALL UNwrite (ID__nc_ice, 'ZN',
     .                dt_ICE, mx, my, nsx, zn1IB )
        CALL UNwrite (ID__nc_ice, 'ZN1',
     .                dt_ICE, mx, my, nsx, zn1IB )
        CALL UNwrite (ID__nc_ice, 'ZN2',
     .                dt_ICE, mx, my, nsx, zn2IB )
        CALL UNwrite (ID__nc_ice, 'ZN3',
     .                dt_ICE, mx, my, nsx, zn3IB )
        CALL UNwrite (ID__nc_ice,'ZN0',dt_ICE, mx, my, nsx, zn0IB)
        CALL UNwrite (ID__nc_ice,'MB0',dt_ICE, mx, my, nsx, mb0IB)
C +     ************
 
        DO k =1,nsx
 
        write(sector,'(i1)') k
 
        DO kk=1,nsno
        DO j=1,my
        DO i=1,mx
          xynsno1(i,j,kk) =      agsSNo(i,j,k,kk)
          xynsno2(i,j,kk) =      dzsSNo(i,j,k,kk)
          xynsno3(i,j,kk) = real(nhsSNo(i,j,k,kk))
          xynsno4(i,j,kk) =      g1sSNo(i,j,k,kk)
          xynsno5(i,j,kk) =      g2sSNo(i,j,k,kk)
          xynsno6(i,j,kk) =      rosSNo(i,j,k,kk)
          xynsno7(i,j,kk) =      tisSNo(i,j,k,kk) - TfSnow
          xynsno8(i,j,kk) =      wasSNo(i,j,k,kk)
        END DO
        END DO
        END DO
 
        ! Snapshot
 
C +     ************
        CALL UNwrite (ID__nc_ice, 'agSN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno1)
        CALL UNwrite (ID__nc_ice, 'dzSN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno2)
        CALL UNwrite (ID__nc_ice, 'nhSN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno3)
        CALL UNwrite (ID__nc_ice, 'g1SN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno4)
        CALL UNwrite (ID__nc_ice, 'g2SN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno5)
        CALL UNwrite (ID__nc_ice, 'roSN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno6)
        CALL UNwrite (ID__nc_ice, 'tiSN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno7)
        CALL UNwrite (ID__nc_ice, 'waSN'//sector,
     .                dt_ICE, mx, my, nsno, xynsno8)
C +     ************
 
        END DO
 
C +--3.2.1.e Soil Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~


        CALL UNwrite (ID__nc_ice, 'SLQC',dt_ICE, mx, my, nvx, slqcIB)
 
        DO k =1,nvx
 
        write(sector,'(i1)') k
 
        DO kk=1,llx
        DO j=1,my
        DO i=1,mx
          xyllx1(i,j,kk)=TsolTV(i,j,k,kk) - TfSnow
          xyllx2(i,j,kk)=Eta_TV(i,j,k,kk)
          xyllx3(i,j,kk)=sltIB (i,j,k,kk)
          xyllx4(i,j,kk)=slqIB (i,j,k,kk)
        END DO
        END DO
        END DO
 
        ! Daily mean + snapshot
 
C +     ************
        CALL UNwrite (ID__nc_ice, 'SLTSN'//sector,
     .                dt_ICE, mx, my, llx, xyllx1)
        CALL UNwrite (ID__nc_ice, 'SLQSN'//sector,
     .                dt_ICE, mx, my, llx, xyllx2)
        CALL UNwrite (ID__nc_ice, 'SLT'//sector,
     .                dt_ICE, mx, my, llx, xyllx3)
        CALL UNwrite (ID__nc_ice, 'SLQ'//sector,
     .                dt_ICE, mx, my, llx, xyllx4)
C +     ************
 
        END DO
 
C +--3.2.1.f Mass Balance Variables
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
        DO j=1,my
        DO i=1,mx
 
          WKxy1(i,j)     =  snowHY(i,j)   * 1000.
          WKxy2(i,j)     =  rainHY(i,j)   * 1000.
 
        END DO
        END DO
 
        ! Snapshot
 
C +     ************
c        CALL UNwrite (ID__nc_ice, 'SImass', dt_ICE, mx, my, nsx,SIm_IB)
c        CALL UNwrite (ID__nc_ice, 'SImadd', dt_ICE, mx, my, nsx,wei0IB)
c        CALL UNwrite (ID__nc_ice, 'S_mass', dt_ICE, mx, my, nsx,S_m_IB)
c        CALL UNwrite (ID__nc_ice, 'SI_hhh', dt_ICE, mx, my, nsx,SIh_IB)
c        CALL UNwrite (ID__nc_ice, 'S__hhh', dt_ICE, mx, my, nsx,S_h_IB)
c        CALL UNwrite (ID__nc_ice, 'SS_hhh', dt_ICE, mx, my, nsx,SSh_IB)
c        CALL UNwrite (ID__nc_ice, 'MBsubl', dt_ICE, mx, my, nsx,wes_IB)
c        CALL UNwrite (ID__nc_ice, 'MBmelt', dt_ICE, mx, my, nsx,wem_IB)
c        CALL UNwrite (ID__nc_ice, 'MBrefr', dt_ICE, mx, my, nsx,wer_IB)
c        CALL UNwrite (ID__nc_ice, 'MBruno', dt_ICE, mx, my, nsx,weu_IB)
c        CALL UNwrite (ID__nc_ice, 'MBsrfW', dt_ICE, mx, my, nsx,SWaSNo)
c        CALL UNwrite (ID__nc_ice, 'MBevap', dt_ICE, mx, my, nsx,wee_IB)
c        CALL UNwrite (ID__nc_ice, 'MBsnow', dt_ICE, mx, my,   1, WKxy1)
c        CALL UNwrite (ID__nc_ice, 'MBrain', dt_ICE, mx, my,   1, WKxy2)
c        CALL UNwrite (ID__nc_ice, 'MBroff', dt_ICE, mx, my,   1,runoTV)
C +     ************
 
c +     factim = (86400.0/real(OutdyIB)) / abs((itrdIB-iterun) *dt )
        factim =      1.0
C +...  factim :  Conversion Factor (x /elapsed time --> x /Days)

        DO j=1,my
        DO i=1,mx
        DO k=1,nsx
          xynsx1(i,j,k)  = (wet_IB(i,j,k) - wet0IB(i,j,k)) * factim
          wet0IB(i,j,k)  =  wet_IB(i,j,k) ! Total

          xynsx2(i,j,k)  = (wes_IB(i,j,k) - wes0IB(i,j,k)) * factim
          wes0IB(i,j,k)  =  wes_IB(i,j,k) ! Sublimation

          xynsx3(i,j,k)  = (wem_IB(i,j,k) - wem0IB(i,j,k)) * factim
     .                   + (wer_IB(i,j,k) - wer0IB(i,j,k)) * factim
          xynsx3(i,j,k)  = (-1.)*xynsx3(i,j,k)
C +                                       ! Refreezing - Melting

          xynsx4(i,j,k)  = (wem_IB(i,j,k) - wem0IB(i,j,k)) * factim
          xynsx4(i,j,k)  = (-1.)*xynsx4(i,j,k)
          wem0IB(i,j,k)  =  wem_IB(i,j,k) ! Only Melting

          xynsx5(i,j,k)  = (wer_IB(i,j,k) - wer0IB(i,j,k)) * factim
          wer0IB(i,j,k)  =  wer_IB(i,j,k) ! Refreezing

          xynsx6(i,j,k)  = (SWaSNo(i,j,k) - wesw0IB(i,j,k))* factim
          wesw0IB(i,j,k) =  SWaSNo(i,j,k) ! Superficial Water

          xynsx7(i,j,k)  = (wee_IB(i,j,k) - wee0IB(i,j,k)) * factim
          wee0IB(i,j,k)  =  wee_IB(i,j,k) ! Evapotranspiration

          xynsx8(i,j,k)  = (weu_IB(i,j,k) - weu0IB(i,j,k)) * factim
          weu0IB(i,j,k)  =  weu_IB(i,j,k) ! Run-off

        END DO

        if (isolSL(i,j).le.2) then
        endif

          WKxy2(i,j)     = 0.
        DO k=1,nsx
          WKxy2(i,j)     =   WKxy2(i,j)
     .                   +  SLsrfl(i,j,k) * snohSN(i,j,k) /1000.
        END DO

          WKxy1(i,j)     =  (snowHY(i,j)  - wesf0IB(i,j) + crysHY(i,j)  
     .                                    - WKxy2(i,j)) * factim
          WKxy1(i,j)     =  max(0.,WKxy1(i,j) * 1000.)
          wesf0IB(i,j)   =  snowHY(i,j)   + crysHY(i,j) -   WKxy2(i,j)  ! Snowfall
 
          WKxy2(i,j)     = (rainHY(i,j)   - werr0IB(i,j) ) * factim
          WKxy2(i,j)     =  max(0.,WKxy2(i,j) * 1000.)
          werr0IB(i,j)   =  rainHY(i,j)   ! Rain

          WKxy3(i,j)     = (rainCA(i,j) + snowCA(i,j) 
     .                   - wecp0IB(i,j) ) * factim
          WKxy3(i,j)     =  max(0.,WKxy3(i,j) * 1000.)
          wecp0IB(i,j)   =  rainCA(i,j) + snowCA(i,j)   ! Convective precip.


          WKxy4(i,j)     = (runoTV(i,j)   - wero0IB(i,j) ) * factim
          wero0IB(i,j)   =  runoTV(i,j)   ! RunOFF

        END DO
        END DO

        DO j=1,my
        DO i=1,mx
        DO k=1,nsx
            xynsx0(i,j,k) = WKxy1(i,j) + WKxy2(i,j) -
     .                      xynsx2(i,j,k) - xynsx8(i,j,k) ! smb = snf + rnf - sbl - rof
            xynsx9(i,j,k) = WKxy2(i,j) + xynsx4(i,j,k) - xynsx8(i,j,k) ! rfz = rnf + mlt - rof
        END DO
            if (isolSL(i,j).le.2) then ! ocean and sea-ice
                xynsx0(i,j,1) = NF_FILL_REAL ! SMB
                xynsx2(i,j,1) = NF_FILL_REAL ! Sublimation
                xynsx4(i,j,1) = NF_FILL_REAL ! Melting
                xynsx8(i,j,1) = NF_FILL_REAL ! Run-off
                xynsx9(i,j,1) = NF_FILL_REAL ! Refreezing
            endif
        END DO
        END DO
        
        ! Sum
 
C +     ************
        CALL UNwrite (ID__nc_ice,  'smb', dt_ICE, mx, my, nsx,xynsx0)
        CALL UNwrite (ID__nc_ice,  'snf', dt_ICE, mx, my,   1, WKxy1)
        CALL UNwrite (ID__nc_ice,  'rnf', dt_ICE, mx, my,   1, WKxy2)
        CALL UNwrite (ID__nc_ice,  'sbl', dt_ICE, mx, my, nsx,xynsx2)
        CALL UNwrite (ID__nc_ice,  'mlt', dt_ICE, mx, my, nsx,xynsx4)
        CALL UNwrite (ID__nc_ice,  'rof', dt_ICE, mx, my, nsx,xynsx8)
        CALL UNwrite (ID__nc_ice,  'rfz', dt_ICE, mx, my, nsx,xynsx9)
        
        CALL UNwrite (ID__nc_ice, 'MBto', dt_ICE, mx, my, nsx,xynsx1)
        CALL UNwrite (ID__nc_ice, 'MBsf', dt_ICE, mx, my,   1, WKxy1)
        CALL UNwrite (ID__nc_ice, 'MBrr', dt_ICE, mx, my,   1, WKxy2)
        CALL UNwrite (ID__nc_ice, 'MBcp', dt_ICE, mx, my,   1, WKxy3)
        CALL UNwrite (ID__nc_ice,  'MBs', dt_ICE, mx, my, nsx,xynsx2)
        CALL UNwrite (ID__nc_ice, 'MBmt', dt_ICE, mx, my, nsx,xynsx3)
        CALL UNwrite (ID__nc_ice,  'MBm', dt_ICE, mx, my, nsx,xynsx4)
        CALL UNwrite (ID__nc_ice,  'MBr', dt_ICE, mx, my, nsx,xynsx5)
        CALL UNwrite (ID__nc_ice, 'MBsw', dt_ICE, mx, my, nsx,xynsx6)
        CALL UNwrite (ID__nc_ice,  'MBe', dt_ICE, mx, my, nsx,xynsx7)
        CALL UNwrite (ID__nc_ice,'MBru2', dt_ICE, mx, my, nsx,xynsx8)
        CALL UNwrite (ID__nc_ice, 'MBru', dt_ICE, mx, my,   1, WKxy4)
C +     Conservation on ice sheet: MBSF+MBRR-MBS-MBRU~MBTO
C +     ************



C +--3.2.2 Work Arrays Reset
C +  -----------------------
 
        DO j=1,my
        DO i=1,mx
          WKxy0(i,j) =0.0
          WKxy1(i,j) =0.0
          WKxy2(i,j) =0.0
          WKxy3(i,j) =0.0
          WKxy4(i,j) =0.0
          WKxy5(i,j) =0.0
          WKxy6(i,j) =0.0
          WKxy7(i,j) =0.0
          WKxy8(i,j) =0.0
          WKxy9(i,j) =0.0
        END DO
        END DO
 
      END IF  !Daily
 
 
C +--3.2.3 NetCDF File Closure
C +  -------------------------
 
      IF              (ID__nc_ice.ne.-1)                         THEN
 
C +       ************
          call UNclose(ID__nc_ice)
C +       ************
 
      END IF
 
      return
      end



      subroutine PBLtop(TKE_1D,HHH_1D,h__PSL,h__SSL)

C +---------------------------------------------------------------------------+
C |                                                               07-APR-2005 |
C |              PBLtop computes the height of the Primary   Seeing Layer PSL |
C |                                                Secondary Seeing Layer SSL |
C |                                                                           |
C |   INPUT:   TKE_1D: Turbulent Kinetic Energy                       [m2/s2] |
C |            HHH_1D: Height above the Surface                           [m] |
C |                                                                           |
C |   OUTPUT:  h__PSL: Height of the Primary   Seeing Layer               [m] |
C |            h__SSL: Height of the Secondary Seeing Layer               [m] |
C |                                                                           |
C +---------------------------------------------------------------------------+


      IMPLICIT NONE

      include "MARdim.inc"

      real     TKE_1D(mz)
      real     HHH_1D(mz)
      real     h__PSL
      real     h__SSL

      real     TKEmin
      real     TKEtop
      
      integer  k     ,kmx   ,kzi

      logical  RESET
      logical  INTERP


      DATA     TKEmin/1.e-6/


C +--Height of the Primary   Seeing Layer (PSL)
C +  ==========================================

C +--Search the lowest TKE maximum
C +  -----------------------------

            k           =              mz
            TKEtop      =  0.01*TKE_1D(k)
 1001 CONTINUE
            k           =              k-1
      IF   (k          .LE.     mzabso     )                  GO TO 1000
      IF   (TKE_1D(k)  .LT.     TKE_1D(k+1).AND.
     .      TKE_1D(k+1).GT.     TKEmin*3.00)                  GO TO 1000
C +                                    3.00     = 1/2 order of magnitude
C +        (in order to only detect a significant maximum)
                                                              GO TO 1001
 1000 CONTINUE
            kmx         =              k+1
            TKEtop      =  0.01*TKE_1D(kmx)
            TKEtop      =   max(TKEmin*1.50,TKEtop)
C +                                    1.50     = 1/4 order of magnitude


C +--Search (from above) the lowest TKE minimum above the lowest TKE maximum
C +  ------ (This mimimum may be                                ) ----------
C +         (either a  TRUE         minimum  => INTERP = .FALSE.)
C +         (    or an arbitrary small value => INTERP = .TRUE. )
C +         -----------------------------------------------------

C +--Index  of the layer containing the minimum
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            kzi         =       mzabso
      DO k= mzabso,kmx
        IF (TKE_1D(k) .LT.      TKEtop          .OR.
     .      TKE_1D(k) .LT.      TKE_1D(k-1)*0.3     )               THEN
            kzi         =              k
         IF(TKE_1D(k) .LT.      TKEtop              )               THEN
            INTERP      =      .TRUE.
         ELSE
            INTERP      =      .FALSE.
         END IF
        END IF
      ENDDO

C +--Height of the                      minimum
C +  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            k           =       kzi     
      IF   (kzi       .LE.      mzabso+1)                           THEN
            h__PSL      =       HHH_1D(mz)
      ELSE
        IF (INTERP)                                                 THEN
            h__PSL      =       HHH_1D(k+1)
     .                        +(HHH_1D(k)  -HHH_1D(k+1))
     .                        *(TKEtop     -TKE_1D(k+1))
     .                        /(TKE_1D(k)  -TKE_1D(k+1))
        ELSE
            h__PSL      =       HHH_1D(k)
        END IF
      END IF

            h__PSL      =   min(h__PSL     ,HHH_1D(1)  )
            h__PSL      =   max(HHH_1D(mz) ,h__PSL     )


C +--Height of the Secondary Seeing Layer (SSL)
C +  ==========================================

            RESET       =      .TRUE.


C +--Search the        TKE minimum above the Primary Seeing Layer (PSL)
C +  (necessary if the TKE has decreased below the minimum value)
C +  ------------------------------------------------------------------

      IF   (INTERP)                                                 THEN
            k           =       kzi + 1 
 1011   CONTINUE
            k           =       k-1
        IF (k         .LE.      mzabso     )                  GO TO 1010
        IF (TKE_1D(k) .LT.      TKE_1D(k+1))                  GO TO 1011
 1010   CONTINUE
      ELSE
            k           =       kzi
      END IF


C +--Search the first  TKE maximum above the Primary Seeing Layer (PSL)
C +  ------------------------------------------------------------------

            kmx         =       kzi
            k           =       k+1
 1021   CONTINUE
            k           =       k-1
      IF   (k            .LE.   mzabso)                       GO TO 1020
        IF (TKE_1D(k)    .GT.   TKE_1D(k-1)     .AND.
     .      TKE_1D(k)    .GT.   TKE_1D(k+1)     .AND.
     .      TKE_1D(k)    .GT.   TKEmin*3.0           )              THEN
C +                                    3.0      = 1/2 order of magnitude
C +        (in order to only detect a significant maximum)


C +--Define the TKE at the SSL top from the largest maximum in the SSL
C +  (thus examine the remaining upper part of the atmospheric column)
C +  -----------------------------------------------------------------

         IF(RESET)                                                  THEN
            RESET       =      .FALSE. ! indicates TKEtop is initialized
            TKEtop      =       0.00   !
         END IF
         IF(TKEtop       .LT.   TKE_1D(k)  *0.01)                   THEN
            TKEtop      =       TKE_1D(k)  *0.01
            kmx         =              k
         END IF
        END IF
                                                              GO TO 1021
 1020 CONTINUE
            TKEtop      =   max(TKEmin*3.0 ,TKEtop)
C +                                    3.0      = 1/2 order of magnitude


C +--Search (from above) the SSL top            above the SSL    TKE maximum
C +  ------ (This         may be                                ) ----------
C +         (either a  TRUE         minimum  => INTERP = .FALSE.)
C +         (    or an arbitrary small value => INTERP = .TRUE. )
C +         -----------------------------------------------------

            kzi         =       mzabso
      DO k= kmx,mzabso,-1     
        IF (TKE_1D(k) .GT.      TKEtop)
     .      kzi         =       k
      ENDDO

            k           =       kzi   -1
      IF   (kzi       .LE.      mzabso+1)                           THEN
            h__SSL      =       HHH_1D(mz)
      ELSE
        IF (INTERP)                                                 THEN
            h__SSL      =       HHH_1D(k+1)
     .                        +(HHH_1D(k)  -HHH_1D(k+1))
     .                        *(TKEtop     -TKE_1D(k+1))
     .                        /(TKE_1D(k)  -TKE_1D(k+1))
        ELSE
            h__SSL      =       HHH_1D(k)
        END IF
      END IF

            h__SSL      =   min(h__SSL     ,HHH_1D(1)  )
            h__SSL      =   max(h__PSL     ,h__SSL     )

      return
      end



      function ou2sGE (yr,mo,da,hh,mm,ss)

C +------------------------------------------------------------------------+
C | MAR INPUT                                            31-11-2012-XF MAR |
C +------------------------------------------------------------------------+

      IMPLICIT NONE

      include 'MARdim.inc'
      include 'MAR_GE.inc'

      integer   y,yr,mo,da,hh,mm,ss

      ou2sGE=0
      do y=iyr0GE,yr-1
       ou2sGE=ou2sGE+365+njmbGE(2)*max(0,1-mod(y,4))
      enddo 

      ou2sGE=ou2sGE+njyrGE(mo)+njybGE(mo)*max(0,1-mod(yr,4))+da-1

      ou2sGE=ou2sGE*24   + hh
      ou2sGE=ou2sGE*3600 + mm*60 + ss

      return
      end


      subroutine time_steps

C +------------------------------------------------------------------------+
C | MAR INPUT                                            21-10-2013-XF MAR |
C +------------------------------------------------------------------------+

      IMPLICIT NONE

      character(8)  :: date_mar
      character(10) :: time_mar


      include 'MARdim.inc'
      include 'MAR_GE.inc'
      include 'MARgrd.inc'
      include 'MARphy.inc'
      include 'MARCTR.inc'

      ! in summer or full year
     
      ! characteristic time of radCEP (3600s)
      jtRadi2 = max(     900/int(dt),jtRadi2) ! 15 min
      jtRadi2 = min(3  *3600/int(dt),jtRadi2) ! 3h
      jtRadi  = 1*jtRadi2
 
      ! characteristic time of sisvat (60-80s)
      ntPhys  = nint(dt/70.)
      if(dt>70) ntPhys=max(2,ntPhys)

      ! characteristic time of Hydmic (60-80s)
      ntHyd   = nint(dt/70.)
      if(dt>70) ntHyd=max(2,ntHyd)

!     -----------------------------------------------------------------

      ! Arctic 
      if(GElatr(1,1)/degrad>70.or.GElatr(mx,my)/degrad>70) then
       if(mmarGE>=9.and.mmarGE<=10) jtRadi = 2*jtRadi2
       if(mmarGE>=3.and.mmarGE<=4 ) jtRadi = 2*jtRadi2
       if(mmarGE>=11.or.mmarGE<=2 ) jtRadi = 3*jtRadi2
      endif 

!     ----------------------------------------------------------------- 


      ! Antarctic 
c #AC if(GElatr(1,1)/degrad<-40.and.GElatr(mx,my)/degrad<-40) then
c #AC  if(mmarGE>=9.and.mmarGE<=10) jtRadi  = 2*jtRadi2  ! spring
c #AC  if(mmarGE>=3.and.mmarGE<=4 ) jtRadi  = 2*jtRadi2  ! fall
c #AC  if(mmarGE>=5.and.mmarGE<=8 ) jtRadi  = 3*jtRadi2  ! winter (no sun)
c #AC endif 

!     -----------------------------------------------------------------

c#BS  ntPhys = max(2,ntPhys)

      ntPhys = min(4,max(1,ntPhys))
      ntHyd  = min(4,max(1,ntHyd))

      dtPhys = dt/real(ntPhys)
      dtHyd  = dt/real(ntHyd)

      dtRadi = dt*jtRadi

!     -----------------------------------------------------------------

       call date_and_time(DATE=date_mar)
       call date_and_time(TIME=time_mar)

       write(6,400) jdarGE,mmarGE,iyrrGE,jhurGE,minuGE,jsecGE

  400  format (' MAR  time : ',i2,'/',i2,'/',i4,' ',i2,':',i2,':',i2)

       write(6,*) "Real time : "//date_mar(5:6)//"/"
     .      //date_mar(7:8) //"/"//date_mar(1:4)//" "//time_mar(1:2)
     .      //":"//time_mar(3:4)//":"//time_mar(5:6)
     
       write(6,401) dt,dtHyd,dtRadi
  401  format (' Step time : dt=',f5.1,", dtHyd=",f5.1,
     .          ", dtRadi=",f6.0,' s')            
 
      end



      subroutine FILatmo

C +------------------------------------------------------------------------+
C | MAR Filtering                                        19-01-2014-XF MAR |
C +------------------------------------------------------------------------+

      IMPLICIT NONE

C +
C +--General Variables
C +  =================

      include 'MARphy.inc'
      include 'MARCTR.inc'
      include 'MAR_SV.inc'
      include 'MARdim.inc'
      include 'MARgrd.inc'
      include 'MAR_GE.inc'
      include 'MAR_DY.inc'
      include 'MAR_LB.inc'
      include 'MAR_SL.inc'
      include 'MAR_SN.inc'
      include 'MAR_BS.inc'
      include 'MAR_IO.inc'
      include 'MAR_TV.inc'
      include 'MARsSN.inc'
      include 'MAR_IB.inc'
      include 'MARdSV.inc'

      real min_tt_sea,min_tt_land,diff_max

c #AC data min_tt_sea /-80./ !degree C
c #AC data min_tt_land/-90./ !degree C

      data min_tt_sea /-70./ !degree C
      data min_tt_land/-75./ !degree C
      data diff_max   / 40./ !degree C

      real           :: min_tt,tt,diff,ww,w
      real           :: pk,ua,va,wa,gp,ps

      integer        :: n,ii,jj

      if(iterun<=1) then

       write(6,11) min_tt_sea,min_tt_land
11     format('XF WARNING: FILatmo min Temp. over  sea=',f5.0,
     .                           ' min Temp. over land=',f5.0)      

      else

       do i=2,mx-1 ; do j=2,my-1

        if(isolSL(i,j)<=2) then 
         min_tt=min_tt_sea
        else
         min_tt=min_tt_land
        endif

        do k=mz/2,mz

         diff=0

         if (tairdy(i,j,k)-273.15<min(-30.,min_tt+30.)) then
          diff=max(diff,abs(tairdy(i,j,k)-tairdy(i-1,j  ,k))) 
          diff=max(diff,abs(tairdy(i,j,k)-tairdy(i+1,j  ,k))) 
          diff=max(diff,abs(tairdy(i,j,k)-tairdy(i  ,j-1,k))) 
          diff=max(diff,abs(tairdy(i,j,k)-tairdy(i  ,j+1,k))) 
         endif  

         if (tairdy(i,j,k)-273.15<min_tt.or.diff>diff_max.or.
     .       isnan(pktaDY(i,j,k)))then

          pk=0;ua=0;va=0;wa=0;gp=0;ps=0;ww=0

          do ii=-1,1 ; do jj=-1,1

                                w=1   
            if(ii==0.or. jj==0) w=2              
            if(ii==0.and.jj==0) w=0              

            if (tairdy(i+ii,j+jj,k)-273.15>min_tt-20.and.
     .          .not.isnan(pktaDY(i+ii,j+jj,k))) then
             pk=pk+w*pktaDY(i+ii,j+jj,k)
c            ua=ua+w*uairDY(i+ii,j+jj,k)
c            va=va+w*vairDY(i+ii,j+jj,k)
c            wa=wa+w*wairDY(i+ii,j+jj,k)
c            gp=gp+w*gplvDY(i+ii,j+jj,k)
c            ps=ps+w* pstDY(i+ii,j+jj)
             ww=ww+w
            endif

          enddo ; enddo

          if (ww>2) then
           pktaDY(i,j,k)=pk/ww    
c          uairDY(i,j,k)=ua/ww
c          vairDY(i,j,k)=va/ww
c          wairDY(i,j,k)=wa/ww
c          gplvDY(i,j,k)=gp/ww
c           pstDY(i,j  )=ps/ww

           tt            = -273.15 + pktaDY(i,j,k)
     .                   * ((pstDY(i,j)*sigma(k)+ptopDY)**cap)

           write(6,12) iyrrGE,mmarGE,jdarGE,jhurGE,minuGE,
     .                 i,j,k,tairdy(i,j,k)-273.15,tt
   12      format('ERROR FILatmo',
     .             i5,4i3,' for (',i3,','i3,',',i2,')',f6.0,'=>',f6.0)
           write(6,*)
          endif
         endif

        enddo
       enddo     ; enddo

      endif

      end


      subroutine interp_subpix(var,var_int,opt,inf,sup,grad_MS)

C     + ---------------------------------------------------------- +
C     / Subroutine interp_subpix interpolates MAR variables        /
C     / (inputs of SISVAT) on the subgrid.                         /
C     / Calculates a local gradient for the variable and adjusts   / 
C     / the subgrid values using the elevation difference between  /
C     / the pixel and its subpixels.                               /
C     + ---------------------------------------------------------- +
C     /                                                            /
C     / INPUT :  var : MAR variable to be interpolated		   /
C     / ^^^^^^^			                                   /
C     /                                                            /
C     / OUTPUT : var_int : variable interpolated on the subgrid    /
C     / ^^^^^^^  grad_MS : mean local gradient of var              /
C     /			   (with spat. and temp. smoothing)        /
C     + ---------------------------------------------------------- +
C     / /!\ opt = options					   /                                                           /
C     / 1 = only interpolation (eg: for temperature)		   /
C     / 2 = interpolated value can not be negative                 /
C     /     (eg: humidity, precipitation ...)                      /
C     /                                                            /
C     / inf, sup = lower and upper limits of the gradient          /
C     /                                                            /
C     / dSH_min = min value of elevation difference between        /                                                            /
C     /           2 pixels to compute the local gradient = 100 m   /
C     /                                                            /
C     /                                                            /
C     / 				Charlotte Lang	13/03/2015 /
C     + ---------------------------------------------------------- +

      IMPLICIT NONE

      include  "MARCTR.inc"
      include  "MARphy.inc"
 
      include  "MARdim.inc"
      include  "MARgrd.inc"
      include  "MAR_GE.inc"
 
      include  "MAR_RA.inc"
 
      include  "MAR_LB.inc"
      include  "MAR_DY.inc"
      include  "MAR_HY.inc"
c #BW include  "MAR_TE.inc"
      include  "MAR_TU.inc"
 
c #TC include  "MAR_TC.inc"
 
      include  "MAR_SV.inc"
      include  "MARdSV.inc"
      include  "MAR0SV.inc"
 
      include  "MAR_SL.inc"
c #AO include  "MAR_AO.inc"
      include  "MAR_TV.inc"
      include  "MAR_BS.inc"
      include  "MARsSN.inc"
      include  "MAR_IB.inc"
 
      include  "MARsIB.inc"
c #PO include  "MAR_PO.inc"
 
      include  "MAR_WK.inc"


      integer  n
      real, parameter :: dSH_min= 100

      real var(mx,my), var_int(mx,my,mw)
      real delta_sh, delta_var, grad_old(mx,my)
      real grad_var,grad_M(mx,my),grad_MS(mx,my)

C + grad_var = gradient between the pixel and one of its 8 surrounding pixels
C + grad_M   = mean value of the local gradient. Average of the 8 surrounding grad_var
C + grad_MS  = mean gradient after spatial and temporal smoothing


      real w, q, qi(3,3)
      real inf, sup

      integer opt
      real sum_var_int(mx,my), fact(mx,my)



      do i=1,mx; do j=1,my
      do k=1,nsx
       var_int(i,j,k) = var(i,j)
       if(isnan(var(i,j))) then
           write(6,399) iyrrGE,mmarGE,jdarGE,
     .     jhurGE,i,j
399        format('/!\ CL WARNING: VAR is NaN ',i4,'/',i2,'/',
     .            i2,i3,'h, (i,j)=',i4,i4)
           stop
       endif
      enddo
      enddo; enddo



      DO i=2,mx-1; DO j=2,my-1


      if (itexpe .eq. 0) grad_MS(i,j) = 0.0
      grad_old(i,j)    = grad_MS(i,j)

C + grad_old = value of the mean local gradient at the previous time step. Used for temp. smoothing


C + *******************************************
C + ***   Computing of the local gradient   ***
C + *******************************************

                 w = 0.0
       grad_M(i,j) = 0.0

       IF (isolSL(i,j) >=3) then ! Gradient is computed only for land pixels. grad = 0 on the ocean

C + Computation of the gradient between each pixel and its 8 surroung pixels (grad_var)
        do m=-1,1; do n=-1,1

        grad_var   = 0.0

        if (isolSL(i+m,j+n) >=3) then
        delta_sh   = sh(i+m,j+n)-sh(i,j)
         if (abs(delta_sh).gt. dSH_min) then
C +  If no minimum elevation difference for the computation of the gradient, delta_sh still has to be non-zero 
C +  to go through the if loop --> If dSH_min = 0.0, decomment next line. 
C         if (delta_sh .neq. 0.0) then
         delta_var =  var(i+m,j+n)-var(i,j)
         grad_var  = delta_var/delta_sh
         w         =  w+1.0
         endif
        endif
C + Computation of the mean local gradient
        grad_M(i,j) = grad_M(i,j) + grad_var

        enddo; enddo


        if (w .ne. 0.0) then                 ! w = # of pixels among the 8 surrouding pixels with delta_sh > dSHmin. 
        grad_M(i,j) = grad_M(i,j)/w	     ! If w = 0, no pixel among the 8 surrouding pixels has delta_sh > dSHmin.   
        endif

       if(isnan(grad_M(i,j))) then
           write(6,400) iyrrGE,mmarGE,jdarGE,
     .     jhurGE,i,j
400        format('/!\ CL WARNING: grad is NaN ',i4,'/',i2,'/',
     .            i2,i3,'h, (i,j)=',i4,i4)
           stop
       endif

       ENDIF
      ENDDO; ENDDO

C+ ***   Smoothing of the mean local gradient   ***
      DO i=2,mx-1; DO j=2,my-1

                  q = 0.0
       grad_MS(i,j) = 0.0

       IF (isolSL(i,j) >=3) then

C + ***   Spatial smoothing of the gradient   ***
        do m=-1,1; do n=-1,1
        if (isolSL(i+m,j+n) >=3) then
                                       qi(m,n)=1.0
           if(m .eq. 0 .or.  n .eq. 0) qi(m,n)=2.0 
           if(m .eq. 0 .and. n .eq. 0) qi(m,n)=4.0
         q            = q+qi(m,n)
         grad_MS(i,j) = grad_MS(i,j)+qi(m,n)*grad_M(i+m,j+n)
        endif

        enddo; enddo
        

        grad_MS(i,j) = grad_MS(i,j)/q

C + ***   Temporal smoothing of the gradient   ***

        if (itexpe .ne. 0) then
        grad_MS(i,j) = 0.75*grad_MS(i,j)+0.25*grad_old(i,j)
        endif

C + ***   Lower and upper limits of the mean gradient value   *** 
        grad_MS(i,j) = max(inf,min(sup,grad_MS(i,j)))

C + ********************************************************
C + ***   Interpolation of the variable on the subgrid   ***
C + ********************************************************
        do k=1,nsx-1
        var_int(i,j,k)   = var(i,j)
     .  +grad_MS(i,j)*(sh_int(i,j,k)-sh(i,j))
        enddo

        var_int(i,j,nsx) = var(i,j)
 

       ENDIF
      ENDDO; ENDDO


C + *******************
C + ***   Options   ***
C + *******************

C + Opt = 1 --> Nothing more than the interpolation is done
C + Opt = 2 --> Interpolated value has to be positive

        IF (opt .eq. 2) then
         DO i=1,mx; DO j=1,my
          do k=1,nsx
           var_int(i,j,k) = max(0.0,var_int(i,j,k))
          enddo
         ENDDO; ENDDO
        ENDIF


      return
      end


      subroutine relrea

C +------------------------------------------------------------------------+
C |   SubRoutine relrea Computes Machine Precision                         |
C |      using a LAPACK auxiliary routine                                  |
C |   (Originating from CONVEX -- Ruud VAN DER PAS)                        |
C +------------------------------------------------------------------------+

      include 'MARCTR.inc'

      character *1 cc
cXF
c Pour ifort 9.1
c     eps   = SLAMCH(cc)
      eps   = 0.1E-06
      cc    ='S'
c     sfmin = SLAMCH(cc)
      sfmin = 0.1E-36
      cc    ='U'
c     rrmin = SLAMCH(cc)
      rrmin = 0.1E-36
      cc    ='O'
c     rrmax = SLAMCH(cc)
      rrmax = 0.1E+38
cXF
      write(6,16) eps,sfmin,rrmin,rrmax
 16   format(' Precision relative  : ',e12.4,
     .     /,' Plus petit nombre   : ',e12.4,
     .     /,' Underflow Threshold = ',e12.4,
     .     /,' Overflow  Threshold = ',e12.4)

      return
      end


      REAL             FUNCTION SLAMCH( CMACH )
C
C  -- LAPACK auxiliary routine (version 1.0) --
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C     February 29, 1992
C
C     .. Scalar Arguments ..
      CHARACTER          CMACH
C     ..
C
C  Purpose
C  =======
C
C  SLAMCH determines single precision machine parameters.
C
C  Arguments
C  =========
C
C  CMACH   (input) CHARACTER*1
C          Specifies the value to be returned by SLAMCH:
C          = 'E' or 'e',   SLAMCH := eps
C          = 'S' or 's ,   SLAMCH := sfmin
C          = 'B' or 'b',   SLAMCH := base
C          = 'P' or 'p',   SLAMCH := eps*base
C          = 'N' or 'n',   SLAMCH := t
C          = 'R' or 'r',   SLAMCH := rnd
C          = 'M' or 'm',   SLAMCH := emin
C          = 'U' or 'u',   SLAMCH := rmin
C          = 'L' or 'l',   SLAMCH := emax
C          = 'O' or 'o',   SLAMCH := rmax
C
C          where
C
C          eps   = relative machine precision
C          sfmin = safe minimum, such that 1/sfmin does not overflow
C          base  = base of the machine
C          prec  = eps*base
C          t     = number of (base) digits in the mantissa
C          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
C          emin  = minimum exponent before (gradual) underflow
C          rmin  = underflow threshold - base**(emin-1)
C          emax  = largest exponent before overflow
C          rmax  = overflow threshold  - (base**emax)*(1-eps)
C
C
C     .. Parameters ..
      REAL               ONE, ZERO
      PARAMETER          ( ONE = 1.0d+0, ZERO = 0.0d+0 )
C     ..
C     .. Local Scalars ..
      LOGICAL            FIRST, LRND
      INTEGER            BETA, IMAX, IMIN, IT
      REAL               BASE, EMAX, EMIN, EPS, PREC, RMACH, RMAX, RMIN,
     $                   RND, SFMIN, SMALL, T
C     ..
C     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
C     ..
C     .. External Subroutines ..
      EXTERNAL           SLAMC2
C     ..
C     .. Save statement ..
      SAVE               FIRST, EPS, SFMIN, BASE, T, RND, EMIN, RMIN,
     $                   EMAX, RMAX, PREC
C     ..
C     .. Data statements ..
      DATA               FIRST / .TRUE. /
C     ..
C     .. Executable Statements ..
C
      IF( FIRST ) THEN
         FIRST = .FALSE.
         CALL SLAMC2( BETA, IT, LRND, EPS, IMIN, RMIN, IMAX, RMAX )
         BASE = BETA
         T = IT
         IF( LRND ) THEN
            RND = ONE
            EPS = ( BASE**( 1-IT ) ) / 2
         ELSE
            RND = ZERO
            EPS = BASE**( 1-IT )
         END IF
         PREC = EPS*BASE
         EMIN = IMIN
         EMAX = IMAX
         SFMIN = RMIN
         SMALL = ONE / RMAX
         IF( SMALL.GE.SFMIN ) THEN
C
C           Use SMALL plus a bit, to avoid the possibility of rounding
C           causing overflow when computing  1/sfmin.
C
            SFMIN = SMALL*( ONE+EPS )
         END IF
      END IF
C
      IF( LSAME( CMACH, 'E' ) ) THEN
         RMACH = EPS
      ELSE IF( LSAME( CMACH, 'S' ) ) THEN
         RMACH = SFMIN
      ELSE IF( LSAME( CMACH, 'B' ) ) THEN
         RMACH = BASE
      ELSE IF( LSAME( CMACH, 'P' ) ) THEN
         RMACH = PREC
      ELSE IF( LSAME( CMACH, 'N' ) ) THEN
         RMACH = T
      ELSE IF( LSAME( CMACH, 'R' ) ) THEN
         RMACH = RND
      ELSE IF( LSAME( CMACH, 'M' ) ) THEN
         RMACH = EMIN
      ELSE IF( LSAME( CMACH, 'U' ) ) THEN
         RMACH = RMIN
      ELSE IF( LSAME( CMACH, 'L' ) ) THEN
         RMACH = EMAX
      ELSE IF( LSAME( CMACH, 'O' ) ) THEN
         RMACH = RMAX
      END IF
C
      SLAMCH = RMACH
      RETURN
C
C     End of SLAMCH
C
      END
C
C***********************************************************************
C
      SUBROUTINE SLAMC1( BETA, T, RND, IEEE1 )
C
C  -- LAPACK auxiliary routine (version 1.0) --
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C     February 29, 1992
C
C     .. Scalar Arguments ..
      LOGICAL            IEEE1, RND
      INTEGER            BETA, T
C     ..
C
C  Purpose
C  =======
C
C  SLAMC1 determines the machine parameters given by BETA, T, RND, and
C  IEEE1.
C
C  Arguments
C  =========
C
C  BETA    (output) INTEGER
C          The base of the machine.
C
C  T       (output) INTEGER
C          The number of ( BETA ) digits in the mantissa.
C
C  RND     (output) LOGICAL
C          Specifies whether proper rounding  ( RND = .TRUE. )  or
C          chopping  ( RND = .FALSE. )  occurs in addition. This may not
C          be a reliable guide to the way in which the machine performs
C          its arithmetic.
C
C  IEEE1   (output) LOGICAL
C          Specifies whether rounding appears to be done in the IEEE
C          'round to nearest' style.
C
C  Further Details
C  ===============
C
C  The routine is based on the routine  ENVRON  by Malcolm and
C  incorporates suggestions by Gentleman and Marovich. See
C
C     Malcolm M. A. (1972) Algorithms to reveal properties of
C        floating-point arithmetic. Comms. of the ACM, 15, 949-951.
C
C     Gentleman W. M. and Marovich S. B. (1974) More on algorithms
C        that reveal properties of floating point arithmetic units.
C        Comms. of the ACM, 17, 276-277.
C
C
C     .. Local Scalars ..
      LOGICAL            FIRST, LIEEE1, LRND
      INTEGER            LBETA, LT
      REAL               A, B, C, F, ONE, QTR, SAVEC, T1, T2
C     ..
C     .. External Functions ..
      REAL               SLAMC3
      EXTERNAL           SLAMC3
C     ..
C     .. Save statement ..
      SAVE               FIRST, LIEEE1, LBETA, LRND, LT
C     ..
C     .. Data statements ..
      DATA               FIRST / .TRUE. /
C     ..
C     .. Executable Statements ..
C
      IF( FIRST ) THEN
         FIRST = .FALSE.
         ONE = 1
C
C        LBETA,  LIEEE1,  LT and  LRND  are the  local values  of  BETA,
C        IEEE1, T and RND.
C
C        Throughout this routine  we use the Function  SLAMC3  to ensure
C        that relevant values are  stored and not held in registers,  or
C        are not affected by optimizers.
C
C        Compute  a = 2.0**m  with the  smallest positive integer m such
C        that
C
C           fl( a + 1.0 ) = a.
C
         A = 1
         C = 1
C
C+       WHILE( C.EQ.ONE )LOOP
   10    CONTINUE
         IF( C.EQ.ONE ) THEN
            A = 2*A
            C = SLAMC3( A, ONE )
            C = SLAMC3( C, -A )
            GO TO 10
         END IF
C+       END WHILE
C
C        Now compute  b = 2.0**m  with the smallest positive integer m
C        such that
C
C           fl( a + b ) .gt. a.
C
         B = 1
         C = SLAMC3( A, B )
C
C+       WHILE( C.EQ.A )LOOP
   20    CONTINUE
         IF( C.EQ.A ) THEN
            B = 2*B
            C = SLAMC3( A, B )
            GO TO 20
         END IF
C+       END WHILE
C
C        Now compute the base.  a and c  are neighbouring floating point
C        numbers  in the  interval  ( beta**t, beta**( t + 1 ) )  and so
C        their difference is beta. Adding 0.25 to c is to ensure that it
C        is truncated to beta and not ( beta - 1 ).
C
         QTR = ONE / 4
         SAVEC = C
         C = SLAMC3( C, -A )
         LBETA = C + QTR
C
C        Now determine whether rounding or chopping occurs,  by adding a
C        bit  less  than  beta/2  and a  bit  more  than  beta/2  to  a.
C
         B = LBETA
         F = SLAMC3( B / 2, -B / 100 )
         C = SLAMC3( F, A )
         IF( C.EQ.A ) THEN
            LRND = .TRUE.
         ELSE
            LRND = .FALSE.
         END IF
         F = SLAMC3( B / 2, B / 100 )
         C = SLAMC3( F, A )
         IF( ( LRND ) .AND. ( C.EQ.A ) )
     $      LRND = .FALSE.
C
C        Try and decide whether rounding is done in the  IEEE  'round to
C        nearest' style. B/2 is half a unit in the last place of the two
C        numbers A and SAVEC. Furthermore, A is even, i.e. has last  bit
C        zero, and SAVEC is odd. Thus adding B/2 to A should not  change
C        A, but adding B/2 to SAVEC should change SAVEC.
C
         T1 = SLAMC3( B / 2, A )
         T2 = SLAMC3( B / 2, SAVEC )
         LIEEE1 = ( T1.EQ.A ) .AND. ( T2.GT.SAVEC ) .AND. LRND
C
C        Now find  the  mantissa, t.  It should  be the  integer part of
C        log to the base beta of a,  however it is safer to determine  t
C        by powering.  So we find t as the smallest positive integer for
C        which
C
C           fl( beta**t + 1.0 ) = 1.0.
C
         LT = 0
         A = 1
         C = 1
C
C+       WHILE( C.EQ.ONE )LOOP
   30    CONTINUE
         IF( C.EQ.ONE ) THEN
            LT = LT + 1
            A = A*LBETA
            C = SLAMC3( A, ONE )
            C = SLAMC3( C, -A )
            GO TO 30
         END IF
C+       END WHILE
C
      END IF
C
      BETA = LBETA
      T = LT
      RND = LRND
      IEEE1 = LIEEE1
      RETURN
C
C     End of SLAMC1
C
      END
C
C***********************************************************************
C
      SUBROUTINE SLAMC2( BETA, T, RND, EPS, EMIN, RMIN, EMAX, RMAX )
C
C  -- LAPACK auxiliary routine (version 1.0) --
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C     February 29, 1992
C
C     .. Scalar Arguments ..
      LOGICAL            RND
      INTEGER            BETA, EMAX, EMIN, T
      REAL               EPS, RMAX, RMIN
C     ..
C
C  Purpose
C  =======
C
C  SLAMC2 determines the machine parameters specified in its argument
C  list.
C
C  Arguments
C  =========
C
C  BETA    (output) INTEGER
C          The base of the machine.
C
C  T       (output) INTEGER
C          The number of ( BETA ) digits in the mantissa.
C
C  RND     (output) LOGICAL
C          Specifies whether proper rounding  ( RND = .TRUE. )  or
C          chopping  ( RND = .FALSE. )  occurs in addition. This may not
C          be a reliable guide to the way in which the machine performs
C          its arithmetic.
C
C  EPS     (output) REAL
C          The smallest positive number such that
C
C             fl( 1.0 - EPS ) .LT. 1.0,
C
C          where fl denotes the computed value.
C
C  EMIN    (output) INTEGER
C          The minimum exponent before (gradual) underflow occurs.
C
C  RMIN    (output) REAL
C          The smallest normalized number for the machine, given by
C          BASE**( EMIN - 1 ), where  BASE  is the floating point value
C          of BETA.
C
C  EMAX    (output) INTEGER
C          The maximum exponent before overflow occurs.
C
C  RMAX    (output) REAL
C          The largest positive number for the machine, given by
C          BASE**EMAX * ( 1 - EPS ), where  BASE  is the floating point
C          value of BETA.
C
C  Further Details
C  ===============
C
C  The computation of  EPS  is based on a routine PARANOIA by
C  W. Kahan of the University of California at Berkeley.
C
C
C     .. Local Scalars ..
      LOGICAL            FIRST, IEEE, IWARN, LIEEE1, LRND
      INTEGER            GNMIN, GPMIN, I, LBETA, LEMAX, LEMIN, LT,
     $                   NGNMIN, NGPMIN
      REAL               A, B, C, HALF, LEPS, LRMAX, LRMIN, ONE, RBASE,
     $                   SIXTH, SMALL, THIRD, TWO, ZERO
C     ..
C     .. External Functions ..
      REAL               SLAMC3
      EXTERNAL           SLAMC3
C     ..
C     .. External Subroutines ..
      EXTERNAL           SLAMC1, SLAMC4, SLAMC5
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, MIN
C     ..
C     .. Save statement ..
      SAVE               FIRST, IWARN, LBETA, LEMAX, LEMIN, LEPS, LRMAX,
     $                   LRMIN, LT
C     ..
C     .. Data statements ..
      DATA               FIRST / .TRUE. / , IWARN / .FALSE. /
C     ..
C     .. Executable Statements ..
C
      IF( FIRST ) THEN
         FIRST = .FALSE.
         ZERO = 0
         ONE = 1
         TWO = 2
C
C        LBETA, LT, LRND, LEPS, LEMIN and LRMIN  are the local values of
C        BETA, T, RND, EPS, EMIN and RMIN.
C
C        Throughout this routine  we use the Function  SLAMC3  to ensure
C        that relevant values are stored  and not held in registers,  or
C        are not affected by optimizers.
C
C        SLAMC1 returns the parameters  LBETA, LT, LRND and LIEEE1.
C
         CALL SLAMC1( LBETA, LT, LRND, LIEEE1 )
C
C        Start to find EPS.
C
         B = LBETA
         A = B**( -LT )
         LEPS = A
C
C        Try some tricks to see whether or not this is the correct  EPS.
C
         B = TWO / 3
         HALF = ONE / 2
         SIXTH = SLAMC3( B, -HALF )
         THIRD = SLAMC3( SIXTH, SIXTH )
         B = SLAMC3( THIRD, -HALF )
         B = SLAMC3( B, SIXTH )
         B = ABS( B )
         IF( B.LT.LEPS )
     $      B = LEPS
C
         LEPS = 1
C
C+       WHILE( ( LEPS.GT.B ).AND.( B.GT.ZERO ) )LOOP
   10    CONTINUE
         IF( ( LEPS.GT.B ) .AND. ( B.GT.ZERO ) ) THEN
            LEPS = B
            C = SLAMC3( HALF*LEPS, ( TWO**5 )*( LEPS**2 ) )
            C = SLAMC3( HALF, -C )
            B = SLAMC3( HALF, C )
            C = SLAMC3( HALF, -B )
            B = SLAMC3( HALF, C )
            GO TO 10
         END IF
C+       END WHILE
C
         IF( A.LT.LEPS )
     $      LEPS = A
C
C        Computation of EPS complete.
C
C        Now find  EMIN.  Let A = + or - 1, and + or - (1 + BASE**(-3)).
C        Keep dividing  A by BETA until (gradual) underflow occurs. This
C        is detected when we cannot recover the previous A.
C
         RBASE = ONE / LBETA
         SMALL = ONE
         DO 20 I = 1, 3
            SMALL = SLAMC3( SMALL*RBASE, ZERO )
   20    CONTINUE
         A = SLAMC3( ONE, SMALL )
         CALL SLAMC4( NGPMIN, ONE, LBETA )
         CALL SLAMC4( NGNMIN, -ONE, LBETA )
         CALL SLAMC4( GPMIN, A, LBETA )
         CALL SLAMC4( GNMIN, -A, LBETA )
         IEEE = .FALSE.
C
         IF( ( NGPMIN.EQ.NGNMIN ) .AND. ( GPMIN.EQ.GNMIN ) ) THEN
            IF( NGPMIN.EQ.GPMIN ) THEN
               LEMIN = NGPMIN
C            ( Non twos-complement machines, no gradual underflow;
C              e.g.,  VAX )
            ELSE IF( ( GPMIN-NGPMIN ).EQ.3 ) THEN
               LEMIN = NGPMIN - 1 + LT
               IEEE = .TRUE.
C            ( Non twos-complement machines, with gradual underflow;
C              e.g., IEEE standard followers )
            ELSE
               LEMIN = MIN( NGPMIN, GPMIN )
C            ( A guess; no known machine )
               IWARN = .TRUE.
            END IF
C
         ELSE IF( ( NGPMIN.EQ.GPMIN ) .AND. ( NGNMIN.EQ.GNMIN ) ) THEN
            IF( ABS( NGPMIN-NGNMIN ).EQ.1 ) THEN
               LEMIN = MAX( NGPMIN, NGNMIN )
C            ( Twos-complement machines, no gradual underflow;
C              e.g., CYBER 205 )
            ELSE
               LEMIN = MIN( NGPMIN, NGNMIN )
C            ( A guess; no known machine )
               IWARN = .TRUE.
            END IF
C
         ELSE IF( ( ABS( NGPMIN-NGNMIN ).EQ.1 ) .AND.
     $            ( GPMIN.EQ.GNMIN ) ) THEN
            IF( ( GPMIN-MIN( NGPMIN, NGNMIN ) ).EQ.3 ) THEN
               LEMIN = MAX( NGPMIN, NGNMIN ) - 1 + LT
C            ( Twos-complement machines with gradual underflow;
C              no known machine )
            ELSE
               LEMIN = MIN( NGPMIN, NGNMIN )
C            ( A guess; no known machine )
               IWARN = .TRUE.
            END IF
C
         ELSE
            LEMIN = MIN( NGPMIN, NGNMIN, GPMIN, GNMIN )
C         ( A guess; no known machine )
            IWARN = .TRUE.
         END IF
C**
C Comment out this if block if EMIN is ok
         IF( IWARN ) THEN
            FIRST = .TRUE.
            WRITE( 6, FMT = 9999 )LEMIN
         END IF
C**
C
C        Assume IEEE arithmetic if we found denormalised  numbers above,
C        or if arithmetic seems to round in the  IEEE style,  determined
C        in routine SLAMC1. A true IEEE machine should have both  things
C        true; however, faulty machines may have one or the other.
C
         IEEE = IEEE .OR. LIEEE1
C
C        Compute  RMIN by successive division by  BETA. We could compute
C        RMIN as BASE**( EMIN - 1 ),  but some machines underflow during
C        this computation.
C
         LRMIN = 1
         DO 30 I = 1, 1 - LEMIN
            LRMIN = SLAMC3( LRMIN*RBASE, ZERO )
   30    CONTINUE
C
C        Finally, call SLAMC5 to compute EMAX and RMAX.
C
         CALL SLAMC5( LBETA, LT, LEMIN, IEEE, LEMAX, LRMAX )
      END IF
C
      BETA = LBETA
      T = LT
      RND = LRND
      EPS = LEPS
      EMIN = LEMIN
      RMIN = LRMIN
      EMAX = LEMAX
      RMAX = LRMAX
C
      RETURN
C
 9999 FORMAT( / / ' WARNING. The value EMIN may be incorrect:-',
     $      '  EMIN = ', I8, /
     $      ' If, after inspection, the value EMIN looks',
     $      ' acceptable please comment out ',
     $      / ' the IF block as marked within the code of routine',
     $      ' SLAMC2,', / ' otherwise supply EMIN explicitly.', / )
C
C     End of SLAMC2
C
      END
C
C***********************************************************************
C
      REAL             FUNCTION SLAMC3( A, B )
C
C  -- LAPACK auxiliary routine (version 1.0) --
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C     February 29, 1992
C
C     .. Scalar Arguments ..
      REAL               A, B
C     ..
C
C  Purpose
C  =======
C
C  SLAMC3  is intended to force  A  and  B  to be stored prior to doing
C  the addition of  A  and  B ,  for use in situations where optimizers
C  might hold one of these in a register.
C
C  Arguments
C  =========
C
C  A, B    (input) REAL
C          The values A and B.
C
C
C     .. Executable Statements ..
C
      SLAMC3 = A + B
C
      RETURN
C
C     End of SLAMC3
C
      END
C
C***********************************************************************
C
      SUBROUTINE SLAMC4( EMIN, START, BASE )
C
C  -- LAPACK auxiliary routine (version 1.0) --
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C     February 29, 1992
C
C     .. Scalar Arguments ..
      INTEGER            BASE, EMIN
      REAL               START
C     ..
C
C  Purpose
C  =======
C
C  SLAMC4 is a service routine for SLAMC2.
C
C  Arguments
C  =========
C
C  EMIN    (output) EMIN
C          The minimum exponent before (gradual) underflow, computed by
C          setting A = START and dividing by BASE until the previous A
C          can not be recovered.
C
C  START   (input) REAL
C          The starting point for determining EMIN.
C
C  BASE    (input) INTEGER
C          The base of the machine.
C
C
C     .. Local Scalars ..
      INTEGER            I
      REAL               A, B1, B2, C1, C2, D1, D2, ONE, RBASE, ZERO
C     ..
C     .. External Functions ..
      REAL               SLAMC3
      EXTERNAL           SLAMC3
C     ..
C     .. Executable Statements ..
C
      A = START
      ONE = 1
      RBASE = ONE / BASE
      ZERO = 0
      EMIN = 1
      B1 = SLAMC3( A*RBASE, ZERO )
      C1 = A
      C2 = A
      D1 = A
      D2 = A
C+    WHILE( ( C1.EQ.A ).AND.( C2.EQ.A ).AND.
C    $       ( D1.EQ.A ).AND.( D2.EQ.A )      )LOOP
   10 CONTINUE
      IF( ( C1.EQ.A ) .AND. ( C2.EQ.A ) .AND. ( D1.EQ.A ) .AND.
     $    ( D2.EQ.A ) ) THEN
         EMIN = EMIN - 1
         A = B1
         B1 = SLAMC3( A / BASE, ZERO )
         C1 = SLAMC3( B1*BASE, ZERO )
         D1 = ZERO
         DO 20 I = 1, BASE
            D1 = D1 + B1
   20    CONTINUE
         B2 = SLAMC3( A*RBASE, ZERO )
         C2 = SLAMC3( B2 / RBASE, ZERO )
         D2 = ZERO
         DO 30 I = 1, BASE
            D2 = D2 + B2
   30    CONTINUE
         GO TO 10
      END IF
C+    END WHILE
C
      RETURN
C
C     End of SLAMC4
C
      END
C
C***********************************************************************
C
      SUBROUTINE SLAMC5( BETA, P, EMIN, IEEE, EMAX, RMAX )
C
C  -- LAPACK auxiliary routine (version 1.0) --
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C     February 29, 1992
C
C     .. Scalar Arguments ..
      LOGICAL            IEEE
      INTEGER            BETA, EMAX, EMIN, P
      REAL               RMAX
C     ..
C
C  Purpose
C  =======
C
C  SLAMC5 attempts to compute RMAX, the largest machine floating-point
C  number, without overflow.  It assumes that EMAX + abs(EMIN) sum
C  approximately to a power of 2.  It will fail on machines where this
C  assumption does not hold, for example, the Cyber 205 (EMIN = -28625,
C  EMAX = 28718).  It will also fail if the value supplied for EMIN is
C  too large (i.e. too close to zero), probably with overflow.
C
C  Arguments
C  =========
C
C  BETA    (input) INTEGER
C          The base of floating-point arithmetic.
C
C  P       (input) INTEGER
C          The number of base BETA digits in the mantissa of a
C          floating-point value.
C
C  EMIN    (input) INTEGER
C          The minimum exponent before (gradual) underflow.
C
C  IEEE    (input) LOGICAL
C          A logical flag specifying whether or not the arithmetic
C          system is thought to comply with the IEEE standard.
C
C  EMAX    (output) INTEGER
C          The largest exponent before overflow
C
C  RMAX    (output) REAL
C          The largest machine floating-point number.
C
C
C     .. Parameters ..
      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
C     ..
C     .. Local Scalars ..
      INTEGER            EXBITS, EXPSUM, I, LEXP, NBITS, TRY, UEXP
      REAL               OLDY, RECBAS, Y, Z
C     ..
C     .. External Functions ..
      REAL               SLAMC3
      EXTERNAL           SLAMC3
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC          MOD
C     ..
C     .. Executable Statements ..
C
C     First compute LEXP and UEXP, two powers of 2 that bound
C     abs(EMIN). We then assume that EMAX + abs(EMIN) will sum
C     approximately to the bound that is closest to abs(EMIN).
C     (EMAX is the exponent of the required number RMAX).
C
      LEXP = 1
      EXBITS = 1
   10 CONTINUE
      TRY = LEXP*2
      IF( TRY.LE.( -EMIN ) ) THEN
         LEXP = TRY
         EXBITS = EXBITS + 1
         GO TO 10
      END IF
      IF( LEXP.EQ.-EMIN ) THEN
         UEXP = LEXP
      ELSE
         UEXP = TRY
         EXBITS = EXBITS + 1
      END IF
C
C     Now -LEXP is less than or equal to EMIN, and -UEXP is greater
C     than or equal to EMIN. EXBITS is the number of bits needed to
C     store the exponent.
C
      IF( ( UEXP+EMIN ).GT.( -LEXP-EMIN ) ) THEN
         EXPSUM = 2*LEXP
      ELSE
         EXPSUM = 2*UEXP
      END IF
C
C     EXPSUM is the exponent range, approximately equal to
C     EMAX - EMIN + 1 .
C
      EMAX = EXPSUM + EMIN - 1
      NBITS = 1 + EXBITS + P
C
C     NBITS is the total number of bits needed to store a
C     floating-point number.
C
      IF( ( MOD( NBITS, 2 ).EQ.1 ) .AND. ( BETA.EQ.2 ) ) THEN
C
C        Either there are an odd number of bits used to store a
C        floating-point number, which is unlikely, or some bits are
C        not used in the representation of numbers, which is possible,
C        (e.g. Cray machines) or the mantissa has an implicit bit,
C        (e.g. IEEE machines, Dec Vax machines), which is perhaps the
C        most likely. We have to assume the last alternative.
C        If this is true, then we need to reduce EMAX by one because
C        there must be some way of representing zero in an implicit-bit
C        system. On machines like Cray, we are reducing EMAX by one
C        unnecessarily.
C
         EMAX = EMAX - 1
      END IF
C
      IF( IEEE ) THEN
C
C        Assume we are on an IEEE machine which reserves one exponent
C        for infinity and NaN.
C
         EMAX = EMAX - 1
      END IF
C
C     Now create RMAX, the largest machine number, which should
C     be equal to (1.0 - BETA**(-P)) * BETA**EMAX .
C
C     First compute 1.0 - BETA**(-P), being careful that the
C     result is less than 1.0 .
C
      RECBAS = ONE / BETA
      Z = BETA - ONE
      Y = ZERO
      DO 20 I = 1, P
         Z = Z*RECBAS
         IF( Y.LT.ONE )
     $      OLDY = Y
         Y = SLAMC3( Y, Z )
   20 CONTINUE
      IF( Y.GE.ONE )
     $   Y = OLDY
C
C     Now multiply by BETA**EMAX to get RMAX.
C
      DO 30 I = 1, EMAX
         Y = SLAMC3( Y*BETA, ZERO )
   30 CONTINUE
C
      RMAX = Y
      RETURN
C
C     End of SLAMC5
C
      END
      LOGICAL FUNCTION LSAME(CH1,CH2)
C +
C +----------------------------------------+
C |   cfr. Hubert Gallee, 30 octobre 92    |
C +----------------------------------------+
C +
      CHARACTER CH1,CH2
      IF (CH1.EQ.CH2)  THEN
       LSAME = .TRUE.
      ELSE
       LSAME = .FALSE.
      END IF
      RETURN
      END
